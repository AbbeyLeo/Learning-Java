/**
 * @author Liu Awen
 * @create 2020-05-15 18:52
 */
/*
数组的算法：
1、找最值
2、找最值及其下标
3、统计：累加和、平均值等
4、反转
5、复制
6、查找：在数组中，查找某个值是否存在，或者查找某个值的下标
（1）数组中的元素是无序的
	顺序查找
（2）数组中的元素是有序的
	①顺序查找
	②二分查找
7、数组的排序
（1）冒泡排序
（2）直接选择排序
*/
class Test04_SelectSort{
    public static void main(String[] args){
        int[] arr = {4,2,1,8,3};

		/*
		直接选择排序：
			经过很多轮
			每一轮，把当前“未排序”的元素中最大/最小的元素及其位置找出来，
			然后与这“最大/最小”值本来/正确的位置的元素进行交换
		也可以理解为直接插入排序

		以从小到大为例
		第一轮：
			找出本轮最小的值：1，它的下标[2]
			这个最小值，应该在[0]位置，就交换[2]和[0]位置的元素
			{1,2,4,8,3}
		第二轮：
			找出本轮未排序元素中最小的值：2，它的下标[1]
			这个最小值，应该在[1]位置，就可以不动
		第三轮：
			找出本轮未排序元素中最小的值：3，它的下标[4]
			这个最小值，应该在[2]位置，就交换[4]和[2]位置的元素
			{1,2,3,8,4}
		第四轮：
			找出本轮未排序元素中最小的值：4，它的下标[4]
			这个最小值，应该在[3]位置，就交换[4]和[3]位置的元素
			{1,2,3,4,8}

		轮数：长度-1
		选最大/最小
		*/
        for(int i=0; i<arr.length-1; i++){//总轮数 = 长度-1
            //(1)找出本轮未排序元素中的最小值及其下标
			/*
			第1轮：[0]~[4]范围内最小值及其下标
			第2轮：[1]~[4]范围内最小值及其下标
			第3轮：[2]~[4]范围内最小值及其下标
			第4轮：[3]~[4]范围内最小值及其下标

			思路：假设本轮未排序的第一个元素最小，然后用min与本轮后面的元素一一比较
			*/
            int min = arr[i];
            int index = i;
            for(int j = i+1; j<arr.length; j++){
                if(arr[j] < min){
                    min = arr[j];
                    index = j;
                }
            }

            //(2)看这个最小值是否在它应该在的位置
			/*
			第1轮：最小值应该在[0]
			第2轮：最小值应该在[1]
			第3轮：最小值应该在[2]
			第4轮：最小值应该在[3]
			*/
            if(index != i){//交换arr[i]和arr[index]
                int temp = arr[i];
                arr[i] = arr[index];
                arr[index] = temp;
            }
        }

        //显示结果
        for(int i=0; i<arr.length; i++){
            System.out.print(arr[i] + " ");
        }
    }
}