**第八章  枚举与注解**

# 第八章  枚举与注解

## 8.1 枚举

1、枚举（JDK1.5引入的）
类似：列举，穷举，一一罗列。

Java枚举：把某个类型的对象，全部列出来

当什么情况下会用到枚举类型？

 * 当某个类型的对象是固定的，有限的几个，那么就可以选择使用枚举。
 * 在整个系统的运行期间，有且只有这几个对象。

枚举类型的对象是有限、固定的几个常量对象。
例如：
 星期  Week，它的对象只有7个：Monday,Tuesday,Wednesday,Thursday,Friday,Saturday,Sunday
 季节 Season，它的对象只有4个：Spring,Summer,Fall,Winter

讨论：JDK1.5之前，如果想要实现枚举的这种效果

（1）构造器私有化：目的：在这个类的外面，无法随意的创建对象

（2）在这个类中，提前创建好几个对象，供别人使用

```java
public class TestEnum {
    public static void main(String[] args) {
//		Gender g1 = new Gender();

        Gender nan1 = Gender.NAN;////com.awen.test07.Gender@1b6d3586
        Gender nan2 = Gender.NAN;////com.awen.test07.Gender@1b6d3586
        System.out.println(nan1 == nan2);//true
    }
}
class Gender{
    //public：使得外面可以直接访问
    //static：使得可以使用“类名.”访问
    //final：前调这个对象是不可变
    public static final Gender NAN = new Gender("男");
    public static final Gender NV = new Gender("女");
    public static final Gender YAO = new Gender("妖");

    private String description;

    private Gender(String description){
        this.description = description;
    }
}
```

枚举是一种类，是一种特殊的类，特殊在它的对象是有限的几个常量对象。

JDK1.5之后，就优化了枚举的语法： 可以枚举了

2、语法格式

```java
//形式一：枚举类型中只有常量对象列表
【修饰符】 enum 枚举类型名{
    常量对象列表
}

//形式二：枚举类型中只有常量对象列表
【修饰符】 enum 枚举类型名{
    常量对象列表;
    
    其他成员列表；
}
```

说明：常量对象列表必须在枚举类型的首行

> 说明：如果常量对象列表后面还有其他的成员，那么需要在常量对象列表后面加;进行分割

回忆：首行

（1）super()或super(实参列表)：必须在子类构造器的首行

（2）this()或this(实参列表)：必须在本类构造器的首行

（3）package 包; 声明包的语句必须在源文件.java的代码首行

（4）枚举常量对象列表必须在枚举类型的首行



3、在其他类中如何获取枚举的常量对象

```
 * 3、API中没有的方法，是编译器帮我们生成的方法
 * （1）枚举类型[] values()
 * （2）枚举类型   valueOf(String name)

```



```java
//获取一个常量对象
枚举类型名.常量对象名

//获取一个常量对象
枚举类型名.valueOf("常量对象名")
    
//获取所有常量对象
枚举类型名[] all = 枚举类型名.values();
```



4、枚举类型的特点

（1）枚举类型有一个公共的基本的父类，是java.lang.Enum类型，所以不能再继承别的类型

（2）枚举类型的构造器必须是私有的

（3）枚举类型可以实现接口

```java
interface MyRunnable{
    void run();
}
enum Gender implements MyRunnable{
    NAN,NV;
    public void run(){
        //...
    }
}
//或
enum Gender implements MyRunnable{
    NAN{
        public void run(){
       	 //...
    	}
    },NV{
        public void run(){
        //...
   		}
    };
    
}
```



```java
/*
 * 补充：枚举类型实现接口
 * 枚举类型实现接口
 */
public class TestEnum3 {
    public static void main(String[] args) {
        MyEnum a = MyEnum.A;
        a.test();//aaa

        MyEnum b = MyEnum.B;
        b.test();//bbb
    }
}
interface MyInter{
    void test();
}
enum MyEnum implements MyInter{
    //想A,B对象实现的不一样
    A{
        @Override
        public void test() {
            System.out.println("aaa");
        }
    },B{
        @Override
        public void test() {
            System.out.println("bbb");
        }
    }
}
/*enum MyEnum implements MyInter{
	A,B;

	@Override
	public void test() {
		System.out.println("test");
	}
}*/
```



5、父类java.lang.Enum类型

枚举类型不能继承其他类型，因为枚举类型有一个隐含的父类

java.lang.Enum

即Enum是所有 Java 语言枚举类型的公共基本类。

```
* （1）Enum类中有一个唯一的构造器
 * protected  Enum(String name, int ordinal)
 * 这个构造器不是程序员手动调用的，是编译器自动调用，在所有枚举类型的构造器的首行，
 * 帮我们自动调用，并且自动传入name和ordinal的值。
 *
 * name：就是常量对象名称
 * ordinal：就是常量对象的序号，其中初始常量序数为零
 *
 * （2）String name()
 * 		int ordinal()
 * （3）String toString()
 * 	在Enum类中重写了Object类的toString方法，返回常量对象名
 *
 * 自定义的枚举类型，在eclipse工具类中，不能自动生成toString方法。手动重写。
 * 因为eclipse认为，父类重写的toString方法的实现已经很完美了，就是返回常量对象名，已经能代表一切。
 *
```



（1）构造器

protected Enum(String name, int ordinal)：由编译器自动调用

（2）String name()：常量对象名

（3）int ordinal()：返回常量对象的序号，第一个的序号是0

（4）String toString()：返回常量对象名，如果子类想重写，需要手动

（5）int compareTo(Object obj)：按照常量对象的顺序比较



```java
public class TestEnum2 {
    public static void main(String[] args) {
        Season s = Season.SPRING;
        //重写了toString
        System.out.println(s);//自动调用toString
        //SPRING:春暖花开

        System.out.println(s.name());//SPRING
        System.out.println(s.ordinal());//0
        System.out.println("-----------------");

        Season[] all = Season.values();
        for (int i = 0; i < all.length; i++) {
            System.out.println(all[i]);
        }
        //SPRING:春暖花开
        //SUMMER:null
        //FALL:null
        //WINTER:null

        System.out.println("-----------------");
        Season spring = Season.valueOf("SPRING");
        System.out.println(spring);
        //SPRING:春暖花开
    }
}
enum Season{
    //常量对象后面没有(值)就是调用无参构造
    //常量对象后面有(值)就是调用有参构造
    SPRING("春暖花开"),SUMMER,FALL,WINTER;

    private String description;

    //私有的
    private Season() {

    }

    private Season(String description) {
        this.description = description;
    }

    public String toString(){
        return name() + ":" + description;
    }

}
```



## 8.2 注解

1、注解

它是代码级别的注释



2、标记符号：@



3、系统预定义的三个最基本的注解：

（1）@Override：表示某个方法是重写的方法

它只能用在方法上面，会让编译器对这个方法进行格式检查，是否满足重写的要求

（2）@SuppressWarnings(xx)：抑制警告

（3）@Deprecated：表示xx已过时



4、和文档注释相关的注解

（1）文档注释

```java
/**
文档注释
*/
```

（2）常见的文档注释

@author：作者

@since：从xx版本加入的

@see：另请参考

@param：形参

@return：返回值

@throws或@exception：异常



5、JUnit相关的几个注解

（1）@Test：表示它是一个单元测试方法

这个方法需要是：public void xxx(){}

（2）@Before：表示在每一个单元测试方法之前执行

这个方法需要是：public void xxx(){}

（3）@After：表示在每一个单元测试方法之后执行

这个方法需要是：public void xxx(){}

（4）@BeforeClass：表示在类初始化阶段执行，而且只执行一次

这个方法需要是：public static void xxx(){}

（3）@AfterClass：表示在类的“卸载”阶段执行，而且只执行一次

这个方法需要是：public static void xxx(){}



6、元注解

（1）@Target(xx)：用它标记的注解能够用在xx位置

(xx)：由ElementType枚举类型的10个常量对象指定，例如：TYPE，METHOD，FIELD等

例如：

```java
@Target(ElementType.TYPE)

@Target({ElementType.TYPE,ElementType.METHOD,ElementType.FIELD})
```

```java
import static java.lang.annotation.ElementType.*;


@Target({TYPE,METHOD,FIELD})
```



（2）@Retention（xx）：用它标记的注解可以滞留到xx阶段

(xx)：由RetentionPolicy枚举类型的3个常量对象指定，分别是：SOURCE，CLASS，RUNTIME

唯有RUNTIME阶段的注解才能被反射读取到

例如：

```java
@Retention(RetentionPolicy.RUNTIME)
```



（3）@Documentd：用它标记的注解可以读取到API中

（4）@Inherited：用它标记的注解可以被子类继承



7、自定义注解

```java
@元注解
【修饰符】 @interface 注解名{
    
}

@元注解
【修饰符】 @interface 注解名{
    配置参数列表
}
```

配置参数的语法格式：

```java
数据类型  配置参数名();

或

数据类型  配置参数名() default 默认值;
```

关于配置参数：

（1）配置参数的类型有要求：

八种基本数据类型、String、枚举、Class类型、注解、它们的数组。

（2）如果自定义注解声明了配置参数，那么在使用这个注解时必须为配置参数赋值，除非它有默认值

```java
@自定义注解名(配置参数名1=值，配置参数名2=值。。。)

//如果配置参数类型是数组，那么赋值时，可以用{}表示数组
@自定义注解名(配置参数名1={值}，配置参数名2=值。。。)
```

（3）如果配置参数只有一个，并且名称是value，那么赋值时可以省略value=

（4）如果读取这个注解时，要获取配置参数的值的话，可以当成方法一样来访问

```
自定义注解对象.配置参数();
```



静态导入