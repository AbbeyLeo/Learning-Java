<?xml version="1.0" encoding="UTF-8" standalone="no"?><xmap-content xmlns="urn:xmind:xmap:xmlns:content:2.0" xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:svg="http://www.w3.org/2000/svg" xmlns:xhtml="http://www.w3.org/1999/xhtml" xmlns:xlink="http://www.w3.org/1999/xlink" modified-by="x1c" timestamp="1596894513298" version="2.0"><sheet id="37rbrs6jvhndu9ufun0ner5add" modified-by="x1c" style-id="20en42qf90t41dgukhalvpn6v1" theme="0a0n2t4scjd2g85273148n60m8" timestamp="1596894513298"><topic id="2nqftu42nm3sjket3nmjcc816d" modified-by="" structure-class="org.xmind.ui.logic.right" timestamp="1510278618763"><title>Java基础</title><children><topics type="attached"><topic id="3ic91tuq0rdjektstjorucpn2f" modified-by="" timestamp="1510275566736"><title>Java历史</title><children><topics type="attached"><topic id="63bfdujtj3e8qq44bsjfnojq2b" modified-by="" timestamp="1510275494448"><title svg:width="500">1、诞生于SUN（Stanford University Network）</title></topic><topic id="2omek215i6h8k3sdme79283uik" modified-by="" timestamp="1510275510794"><title>2、Java之父：詹姆斯.高斯林</title></topic><topic id="3rssds610aflpg57k0pfrpj8dq" modified-by="" timestamp="1510275538587"><title>3、2009年SUN被Oracle甲骨文公司收购</title></topic><topic id="3o6ei2obe14pog20vv7dtkgt3k" modified-by="" timestamp="1510275564109"><title>4、于1996年发布JDK1.0正式版</title></topic><topic id="2b31evvjhn3d6l1diebo1gct36" modified-by="" timestamp="1510275739583"><title svg:width="500">比较有有代表性的几个版本：JDK1.2（引入了集合框架等）、JDK1.4（引入了NIO）、JDK1.5（枚举、泛型、可变参数、foreach循环、自动装箱拆箱。。。）、JDK1.7（switch对字符串的支持，try...with...resource）、JDK1.8（接口、日期时间API、Optional类、Lambda表达式和StreamAPI）</title></topic></topics></children></topic><topic id="77qtl9u8bag720ubp6rbf0n4vv" modified-by="" timestamp="1510275934424"><title>Java的特点</title><children><topics type="attached"><topic id="5kavihms2tkb5pcjd5l6c6mdh7" modified-by="" timestamp="1510275843258"><title>1、面向对象</title><children><topics type="attached"><topic id="6im5aid6ous6eg1748bnadvepk" modified-by="" timestamp="1510275821547"><title>类与对象，类的成员</title></topic><topic id="2eqdb62k6u65q953ie982eppjc" modified-by="" timestamp="1510275834840"><title>三个基本特征：封装、继承、多态</title></topic><topic id="024d7mvv1906183f4gi8suu9h2" modified-by="" timestamp="1510275842638"><title>高级特性</title></topic><topic id="2igum4l2fo5vmbi2dlijh0pl37" modified-by="" timestamp="1510275848855"><title>相关关键字</title></topic></topics></children></topic><topic id="2l3pnqfkmuaodjelibfs91fqad" modified-by="" timestamp="1510275857393"><title>2、健壮性</title><children><topics type="attached"><topic id="533eo10pd3jfan8im938bosmt7" modified-by="x1c" timestamp="1596892739355"><title svg:width="500">内存自动分配，有垃圾回收机制自动进行回收</title></topic></topics></children></topic><topic id="3rpq6spkrs4hilqh897qnfj1g5" modified-by="" timestamp="1510275903571"><title>3、跨平台</title><children><topics type="attached"><topic id="70e1gsq9rm7fpurp3bqroeaadl" modified-by="x1c" timestamp="1596894236714"><title>Write Once ,Run Anywhere.</title></topic><topic id="7c5ff0uvfvgvbatq096k9gnb7i" modified-by="" timestamp="1510275931307"><title svg:width="500">原理：使用JVM，不同的操作系统使用不同的JVM，而Java程序编译成字节码，运行JVM上</title></topic></topics></children></topic><topic id="5395bbj5ufscbbels0tbvrflrd" modified-by="" timestamp="1510275937467"><title>。。。。</title></topic></topics></children></topic><topic id="6062ucerdustr6q39al14r04lp" modified-by="" timestamp="1510276103869"><title>环境搭建</title><children><topics type="attached"><topic id="09tfm00529qr26646a8eemgqr3" modified-by="" timestamp="1510276073393"><title>1、JDK、JRE、JVM</title><children><topics type="attached"><topic id="4ot69sa1iurar65aufq89igu7g" modified-by="" timestamp="1510276032816"><title svg:width="500">JDK：Java Development Kit，Java的开发工具集，包含JRE + 开发工具（javac.exe，java.exe，javadoc.exe，jar.exe）</title></topic><topic id="2r5ilv34me2p17r3e5k01a1434" modified-by="" timestamp="1510276072502"><title svg:width="500">JRE：Java Runtime Enviroment，Java运行环境，包括JVM + 核心类库</title></topic><topic id="5h920r2f1ev57su97d72nbbjt4" modified-by="" timestamp="1510276098663"><title svg:width="500">JVM：Java Virtual Machine，Java的虚拟机</title></topic></topics></children></topic><topic id="2man2c7a5u5us5r6c4jqf3jr12" modified-by="" timestamp="1510276183340"><title>2、环境变量的配置</title><children><topics type="attached"><topic id="2j2nc0pq8f6q3733qg993rk5f8" modified-by="" timestamp="1510276160717"><title svg:width="500">path：windows操作系统寻找命令工具的路径，在path中进行登记</title><children><topics type="attached"><topic id="6ohdfi0h033skmvkkp3lvb3164" modified-by="" timestamp="1510276180838"><title>D:\ProgramFiles\Java\jdk1.8.0_141\bin;</title></topic></topics></children></topic><topic id="1ajnjuktv14v4g3mka6sujpipg" modified-by="" timestamp="1510276246424"><title>JAVA_HOME + path</title><children><topics type="attached"><topic id="1j1bo1cv12ee2t2l4ue99dq89h" modified-by="" timestamp="1510276224259"><title>JAVA_HOME</title><children><topics type="attached"><topic id="5jkbnopfuicsv03nsuja45mu4o" modified-by="x1c" timestamp="1596894513298"><title svg:width="500">D:\ProgramFiles\Java\jdk1.8.0_141</title></topic></topics></children></topic><topic id="22oe7cmdhhnnstgphhalep2m5q" modified-by="" timestamp="1510276231617"><title>path</title><children><topics type="attached"><topic id="1kgqk18o4el2h558n5t7coku64" modified-by="" timestamp="1510276243955"><title>%JAVA_HOME%\bin;</title></topic></topics></children></topic><topic id="5ne9qr0vbdntno3udbke1o7qrg" modified-by="" timestamp="1510276266583"><title svg:width="500">这两个变量要么同时在用户级环境变量，要么都在系统级环境变量</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="32dtvbhhoq0aravgce0p3anguj" modified-by="" timestamp="1510276668798"><title>第一个Java应用程序</title><children><topics type="attached"><topic id="19mht6ev5pbcta3o1et835fu37" modified-by="" timestamp="1510276481439"><title>1、Java程序编写的步骤</title><children><topics type="attached"><topic id="57m5cr6gj9u3tdialbperoj55n" modified-by="" timestamp="1510276367414"><title svg:width="500">（1）编辑，编写源代码，保存成“.java”结尾的源文件</title><children><topics type="attached"><topic id="4gogs28ig5e94p4ua1vq1i0495" modified-by="" timestamp="1510276377103"><title>源文件的构成</title><children><topics type="attached"><topic id="725ki95cm58nrjpqm61l9fv6ie" modified-by="" timestamp="1510276401105"><title>类{&#13;
	方法{&#13;
		语句;&#13;
	}&#13;
}</title></topic></topics></children></topic></topics></children></topic><topic id="71oojv6vj3fqaeppfpkn2n24io" modified-by="" timestamp="1510276434845"><title svg:width="500">（2）编译：把源文件编译成1个或多个的字节码文件</title><children><topics type="attached"><topic id="2fh3tsahk7rmro10h2nppfqc0u" modified-by="" timestamp="1510276434068"><title>编译的工具：javac.exe</title></topic><topic id="0gm59e88b24joctukdgne3nb7m" modified-by="" timestamp="1510276454633"><title>编译的格式：</title><children><topics type="attached"><topic id="117lja53kbqvcre03vsvrs9dm9" modified-by="" timestamp="1510276542987"><title>javac  源文件名.java</title><children><topics type="attached"><topic id="7ip5s328ruv45m0u0k34krtp89" modified-by="" timestamp="1510276542696"><title>源文件名.java后缀名必须写</title></topic><topic id="4jf2h2cbhtqgek5rcg4sov2obm" modified-by="" timestamp="1510276549218"><title>源文件名不区分大小写</title></topic></topics></children></topic><topic id="69astif5qpp1fnd708sjlrqhi5" modified-by="" timestamp="1510276471869"><title>javac  -encoding  字符编码  源文件名.java</title></topic></topics></children></topic></topics></children></topic><topic id="0d7mh3kcon37f3ibf73kc10s0p" modified-by="" timestamp="1510276499490"><title>（3）运行：运行字节码文件</title><children><topics type="attached"><topic id="387quj9r5ssfdf4nkgm9d8ov65" modified-by="" timestamp="1510276497887"><title>运行工具：java.exer</title></topic><topic id="42774rij2at2gaab5m2t9nable" modified-by="" timestamp="1510276505210"><title>格式：</title><children><topics type="attached"><topic id="2ss416136b52jsif42pp37avq7" modified-by="" timestamp="1510276525267"><title>java  类名</title><children><topics type="attached"><topic id="3iqiko1836t6iuemdpihirnagp" modified-by="" timestamp="1510276523636"><title>类名，不带后缀名</title></topic><topic id="5lmp2v4d7u4ju0sou9p5fu84o8" modified-by="" timestamp="1510276532347"><title>类名是严格区分大小写</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="1uehiadkh1f7leh734ev5lvg7k" modified-by="" timestamp="1510276585109"><title>2、Java程序的入口</title><children><topics type="attached"><topic id="2a4oilfadrgj3ub4a9boong2d8" modified-by="" timestamp="1510276583182"><title>主方法</title></topic><topic id="5r0ojlu2vnnbalka8icuot0kt8" modified-by="" timestamp="1510276602662"><title>public static void main(String[] args){&#13;
}</title></topic></topics></children></topic><topic id="6ciun2op21vj4p9svt4dmmtmrf" modified-by="" timestamp="1510276619679"><title>3、输出语句</title><children><topics type="attached"><topic id="1rs03bk6f9oh79cmm5ds2jv2jq" modified-by="" timestamp="1510276652138"><title>System.out.print(xxx);</title><children><topics type="attached"><topic id="25f03tsqvlg42bdlh47b98odsl" modified-by="" timestamp="1510276651231"><title>如果原样输出的字符串，那么就加""</title></topic><topic id="5rvplkksf9251ghsfnbv76pvjo" modified-by="" timestamp="1510276660533"><title>其他的变量或数值就不用加""</title></topic></topics></children></topic><topic id="7sodckql69n4ehptig2a9cl896" modified-by="" timestamp="1510276640119"><title>System.out.println(xxx);</title></topic></topics></children></topic><topic id="6v74euah5g1so7b9m1v7a1ni6o" modified-by="" timestamp="1510276968958"><title>4、相关的问题</title><children><topics type="attached"><topic id="5bjrbi096ji75aadu3nmcud327" modified-by="" timestamp="1510276816387"><title>（1）主方法一定要在public的类中？</title><children><topics type="attached"><topic id="08neqb1brcp39u0touvrumfhts" modified-by="" timestamp="1510276816076"><title>不是</title></topic><topic id="43hke5l1poffsubjdvkl5lmh8s" modified-by="" timestamp="1510276831772"><title>绝大部分都在public的类中</title></topic></topics></children></topic><topic id="204h438cbpcpeflrd6havstf3o" modified-by="" timestamp="1510276902618"><title>（2）一个源文件只能写一个class</title><children><topics type="attached"><topic id="1emvd1cg6oslq4989o5547k8v8" modified-by="" timestamp="1510276905275"><title>不是</title></topic></topics></children></topic><topic id="2abpvr368j5k012dsk4sqh1evn" modified-by="" timestamp="1510276926390"><title>（3）类名与源文件名是否必须一致</title><children><topics type="attached"><topic id="535idvvvb6brrq67u081ht61t3" modified-by="" timestamp="1510276925908"><title>不是</title></topic><topic id="5bnr6t800v3iiv0kloq9vumf2n" modified-by="" timestamp="1510276968641"><title>但是当这个类是public时，那么就必须一致</title></topic></topics></children></topic><topic id="6mfvkjp2627vb5jreb6jat10q7" modified-by="" timestamp="1510276981235"><title>（4）一个源文件只能有一个public修饰的类</title></topic></topics></children></topic></topics></children></topic><topic id="0ud49qd6duthigq74o02ctkkt3" modified-by="" timestamp="1510277188844"><title>DOS命令</title><children><topics type="attached"><topic id="4768b4itesqhf66j015s0sis0v" modified-by="" timestamp="1510277022578"><title>（1）列出当前目录的内容</title><children><topics type="attached"><topic id="1b7hajiti7c7hsivmjriqccsqu" modified-by="" timestamp="1510277024147"><title>dir</title></topic></topics></children></topic><topic id="360t721d1viqgm8uctp5oahc8i" modified-by="" timestamp="1510277031577"><title>（2）切换盘符</title><children><topics type="attached"><topic id="69rfslv656kafb3qopksal6t28" modified-by="" timestamp="1510277036169"><title>盘符:</title></topic></topics></children></topic><topic id="7gibv1ggj6u50thbeto1gsrjdp" modified-by="" timestamp="1510277071433"><title>（3）进入到某个目录</title><children><topics type="attached"><topic id="1f8svk2qjmalcsbe5ntqt961fn" modified-by="" timestamp="1510277052022"><title>cd  目录的路径</title></topic><topic id="0f2o77qff6btuc1bvbcjpq8ot5" modified-by="" timestamp="1510277058448"><title>cd  ..</title><children><topics type="attached"><topic id="46mnkd84evle79ejeo0q9sr5j6" modified-by="" timestamp="1510277062340"><title>回到上一级</title></topic></topics></children></topic><topic id="5gb2ajgsonqarr4ahju7ie6a60" modified-by="" timestamp="1510277066416"><title>cd /</title><children><topics type="attached"><topic id="6fn803udag9mjoqmp331914eb1" modified-by="" timestamp="1510277070446"><title>回到根目录</title></topic></topics></children></topic><topic id="6mvrp08g19hnjktufrebircgqo" modified-by="" timestamp="1510277075274"><title>cd .</title><children><topics type="attached"><topic id="2g3bnjgk51pngbh4d92v0ndkup" modified-by="" timestamp="1510277084034"><title>还是在当前目录</title></topic></topics></children></topic></topics></children></topic><topic id="5ttamb94bfupn5aqu8tsm4vvt9" modified-by="" timestamp="1510277092496"><title>（4）创建目录</title><children><topics type="attached"><topic id="43jc922seo4sbu7v5r04dac8l9" modified-by="" timestamp="1510277163972"><title>md  新目录</title><children><topics type="attached"><topic id="292laaufuq09qm5e0gklj59ekn" modified-by="" timestamp="1510277170859"><title>只能创建一级</title></topic></topics></children></topic></topics></children></topic><topic id="5hltbnngrfur966p8gmi78et4n" modified-by="" timestamp="1510277177055"><title>（5）删除目录</title><children><topics type="attached"><topic id="6ebntgn8llie09dp2t2utfva9i" modified-by="" timestamp="1510277182376"><title>rd 目录</title><children><topics type="attached"><topic id="6ilkdh61k26ioq262h8buai7iu" modified-by="" timestamp="1510277187080"><title>只能删除空目录</title></topic></topics></children></topic></topics></children></topic><topic id="0bi3f6aviig5hj427843bhlepf" modified-by="" timestamp="1510277208131"><title>（6）删除文件</title><children><topics type="attached"><topic id="0g35nte8lkpl9lf3evgs2qq120" modified-by="" timestamp="1510277204849"><title>del 文件名.扩展名</title><children><topics type="attached"><topic id="1nmdrfjuk9200go9mnvlq4gcgs" modified-by="" timestamp="1510277207926"><title>删除一个文件</title></topic></topics></children></topic><topic id="29edpkj7ullus1bek80q91a650" modified-by="" timestamp="1510277212939"><title>del 目录</title><children><topics type="attached"><topic id="3ogj97e8v6lmr0sqimc35a016i" modified-by="" timestamp="1510277217749"><title>删除目录中的所有文件</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="087ehcchkp2v5q89b8jtk9snt6" modified-by="" timestamp="1510278779444"><title>进制（了解）</title><children><topics type="attached"><topic id="16rufd5e824rfqelguadss78f5" modified-by="" timestamp="1510278663038"><title>二进制</title><children><topics type="attached"><topic id="1c9e511imsmh69nlo4fnn0c951" modified-by="" timestamp="1510278639236"><title>只有0和1</title></topic><topic id="2h2flqfp88gic6dpj2pciss4f6" modified-by="" timestamp="1510278721911"><title>二进制转十进制</title><children><topics type="attached"><topic id="35nnnj2t17bs16df529t4bhjhn" modified-by="" timestamp="1510278733245"><title>从最右边开始依次是2的0次</title></topic></topics></children></topic></topics></children></topic><topic id="0sn6200ge8uv9qfg8dgq8dtpia" modified-by="" timestamp="1510278665242"><title>十进制</title><children><topics type="attached"><topic id="5d9itpbjsnd74htik4mut134s6" modified-by="" timestamp="1510278643328"><title>0-9</title></topic><topic id="3hv5m10646lehd7bb84l1b8v29" modified-by="" timestamp="1510278692241"><title>转二进制</title><children><topics type="attached"><topic id="62rm1n46eic9q5nnlfugskdimp" modified-by="" timestamp="1510278676494"><title>整数部分</title><children><topics type="attached"><topic id="0ottfgd55dmfoaou8bj07t3lm2" modified-by="" timestamp="1510278691919"><title>除2取余，倒取</title></topic></topics></children></topic><topic id="4t202r6ajc1l6hbe36i2j5rfb3" modified-by="" timestamp="1510278695727"><title>小数部分</title><children><topics type="attached"><topic id="5u0e0fojo9h63a3hdmid12k59m" modified-by="" timestamp="1510278709261"><title>乘2取整，顺</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="3llhoo3n6c47ms5agv7nkmomvr" modified-by="" timestamp="1510278741531"><title>八进制</title><children><topics type="attached"><topic id="7urpnjekj1sttr8uosjh9d3til" modified-by="" timestamp="1510278646768"><title>0-7</title></topic><topic id="2ics49nujl0atfdngpu0u2t9tg" modified-by="" timestamp="1510278758727"><title>通过二进制</title><children><topics type="attached"><topic id="18dts85os5pf9qcmsosg8h0gp9" modified-by="" timestamp="1510278757782"><title>三个二进制值代表一个八进制值</title></topic><topic id="6e0lk09onrtnrs3h1f7hjp19fd" modified-by="" timestamp="1510278764211"><title>从右边开始</title></topic></topics></children></topic></topics></children></topic><topic id="5rdnljpda306hko1tk6gsprjhb" modified-by="" timestamp="1510278766270"><title>十六进制</title><children><topics type="attached"><topic id="1efp06o7uucvljlqcaktp5ime9" modified-by="" timestamp="1510278660294"><title>0-9，A~F大小写都可以</title></topic><topic id="2h18avk0aen76s29rsp04dmovs" modified-by="" timestamp="1510278766233"><title>通过二进制</title><children><topics type="attached"><topic id="7a2c46q9o4pvighg93fb2havu4" modified-by="" timestamp="1510278770658"><title>四个二进制值代表一个八进制值</title></topic><topic id="6220ab2fu7giu5nilmcetu6ars" modified-by="" timestamp="1510278764211"><title>从右边开始</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><title>Java基础</title></sheet><sheet id="3do69mqq2qmlqbbdr0gcalttsu" modified-by="x1c" style-id="16sqmmpvtaekisq6ntdaa1aood" theme="xminddefaultthemeid" timestamp="1596874686163"><topic id="5dii6lc7ld2nf0tj2am8j11fkg" modified-by="" structure-class="org.xmind.ui.logic.right" timestamp="1510363498737"><title>Java基础语法</title><extensions><extension provider="org.xmind.ui.map.unbalanced"><content><right-number>-1</right-number></content></extension></extensions><children><topics type="attached"><topic id="01epeql8osg019d1hjn10ibr28" modified-by="x1c" timestamp="1596874686163"><title>1、标识符</title><children><topics type="attached"><topic id="7796ea396p60fprrteerb1t7u2" modified-by="" timestamp="1510277280875"><title svg:width="500">凡是在程序中需要自己命名的地方都是标识符，例如：变量名、包名、类名等</title></topic><topic id="6cr23rd45b0j2u8fge2oqqcpos" modified-by="" timestamp="1510277442158"><title>标识符的命名规则</title><children><topics type="attached"><topic id="4dgqtsl3s2l80fqfi1m2md92r9" modified-by="" timestamp="1510277333975"><title svg:width="500">1、Java的标识符只能使用26英文字母大小写，0-9的数字，下划线(_)和美元符号($)</title></topic><topic id="6ij0dmc8oihbvkln68flh4akcm" modified-by="" timestamp="1510277344348"><title>2、标识符中不能包含空格</title></topic><topic id="0g7p83la39of03lclp4tkfgvqn" modified-by="" timestamp="1510277351724"><title>3、数字不能开头</title></topic><topic id="1hdqemmadcnrj7s60vgt93vgg1" modified-by="" timestamp="1510277412749"><title>4、不能使用关键字和保留字和特殊值</title><children><topics type="attached"><topic id="1svlfvqj9n0fife353a19qh9sl" modified-by="" timestamp="1510277419068"><title>50个</title><children><topics type="attached"><topic id="4a0meb7sb10hjji2faa6893raa" modified-by="" timestamp="1510277380042"><title>class</title></topic><topic id="1e05gri7j47i0t5ovicv1oofqs" modified-by="" timestamp="1510277387731"><title>基本数据类型</title><children><topics type="attached"><topic id="4r184iiojuk6udcs2ev3b2dsfu" modified-by="" timestamp="1510277398554"><title>byte,short,int,long,float,double,char,boolean</title></topic></topics></children></topic><topic id="50n3t2qreie7c4v45sesbukjvn" modified-by="" timestamp="1510277403060"><title>public</title></topic><topic id="02lbha006bqsvgj0jr25rl576h" modified-by="" timestamp="1510277407140"><title>static</title></topic><topic id="78cg572iukjr3i6tr9m1k9ttbc" modified-by="" timestamp="1510277409339"><title>void</title></topic></topics></children></topic><topic id="1059skr935f1q0b6hjn059ml29" modified-by="" timestamp="1510277427807"><title>3个</title><children><topics type="attached"><topic id="7l0eqtimrr6kmif2cuvuimdadj" modified-by="" timestamp="1510277425853"><title>true</title></topic><topic id="5039hqs7m4r9uq30gli6jvcpv8" modified-by="" timestamp="1510277427542"><title>false</title></topic><topic id="7vbcq577u0vt8g4de8rrmnii39" modified-by="" timestamp="1510277430374"><title>null</title></topic></topics></children></topic></topics></children></topic><topic id="44db42gstp1l75uickn50hmdcj" modified-by="" timestamp="1510277441940"><title>5、Java严格区分大小写</title></topic><topic id="3f0teaafdfrlcavuhkd0huhsko" modified-by="" timestamp="1510277458718"><title>6、Java标识符没有长度限制，但是不宜太长</title></topic></topics></children></topic><topic id="1vdiro42t9g9elcjg4t76dvasr" modified-by="" timestamp="1510277607521"><title>标识符的命名规范</title><children><topics type="attached"><topic id="358si8lvo400pfvg9uh5nmsn7o" modified-by="" timestamp="1510277476201"><title>总原则</title><children><topics type="attached"><topic id="1ra1t86cdfg6kqt0jjfb0th1mo" modified-by="" timestamp="1510277484381"><title>见名知意，有意义</title></topic></topics></children></topic><topic id="1jkr69jl32ko8h90eo4qtlncpp" modified-by="" timestamp="1510277496282"><title>1、类名，接口名</title><children><topics type="attached"><topic id="2jdsoul5ipp802btuqh2f08r4a" modified-by="" timestamp="1510277516619"><title>所有单词的首字母大写</title><children><topics type="attached"><topic id="70d703kj8d8dgueclqborobjs8" modified-by="" timestamp="1510277515862"><title>XxxYyyZzz</title></topic><topic id="2pclu51jvfcbgorek3e5i8hhku" modified-by="" timestamp="1510277528279"><title>例如：String，System，HelloWorld</title></topic></topics></children></topic></topics></children></topic><topic id="57qqj7q81t4pec87d5bjb4l6te" modified-by="" timestamp="1510277535067"><title>2、变量名</title><children><topics type="attached"><topic id="4hvctrtkibr344m25pu4c7oqq8" modified-by="" timestamp="1510277558205"><title>第一个单词首字母小写，其余单词首字母大写</title><children><topics type="attached"><topic id="3l854r3afv2b5siqbqu37qnq01" modified-by="" timestamp="1510277552935"><title>xxxYyyZzz</title></topic><topic id="3eu8s8ap57bue6k1ou5se6m921" modified-by="" timestamp="1510277572668"><title>例如：age，maxValue</title></topic></topics></children></topic></topics></children></topic><topic id="7f7ulqc3ss226kclir4do0qdd9" modified-by="" timestamp="1510277578995"><title>3、包名</title><children><topics type="attached"><topic id="38qtfcat6cgdkf1pavtnv476dc" modified-by="" timestamp="1510277599399"><title>所有字母都小写，单词之间使用.分割</title><children><topics type="attached"><topic id="3108bp5bcsrhcb5blfb2qak8v8" modified-by="" timestamp="1510277598655"><title>xxx.yyy.zzz</title></topic><topic id="3e0rfh67ut6l6vaub5q5risd9t" modified-by="" timestamp="1510277606100"><title>例如：java.lang</title></topic></topics></children></topic></topics></children></topic><topic id="502b0gvnospftd5jg0lshc0pou" modified-by="" timestamp="1510277614750"><title>4、常量名</title><children><topics type="attached"><topic id="1u23t8ik1ufbluj4qd1j7b60l0" modified-by="" timestamp="1510277632847"><title>所有字母都大写，单词之间使用下划线_</title><children><topics type="attached"><topic id="5l9b6hu41imt972ui3dta51ftq" modified-by="" timestamp="1510277632260"><title>XXX_YYY_ZZZ	</title></topic><topic id="6c4bbd657s8mvp31g8hc7l7i5i" modified-by="" timestamp="1510277645013"><title>例如：MAX_VALUE</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic branch="folded" id="5tvdcis78aitso57cuia4vavsq" modified-by="" structure-class="org.xmind.ui.logic.right" timestamp="1531100351786"><title>2、变量</title><children><topics type="attached"><topic id="7dla1qiggk4i0aloqu9577761g" modified-by="" timestamp="1510277690607"><title>变量是代表内存的一块存储区域</title></topic><topic id="34s8o3asbklmq5phdtjuve3v8v" modified-by="" timestamp="1510277709028"><title>变量三要素</title><children><topics type="attached"><topic id="3mkko4fqpnvh5evf3uh3e9bju0" modified-by="" timestamp="1510277718355"><title>变量名</title><children><topics type="attached"><topic id="59jmcao4agqk9o3aohanu42cn5" modified-by="" timestamp="1510277734250"><title>给这块存储区域命名，就不用内存地址访问</title></topic></topics></children></topic><topic id="40jfpj28vqjjtg230ekn37t527" modified-by="" timestamp="1510277736647"><title>变量值</title><children><topics type="attached"><topic id="2b1gsmd4cbiuhkp0u4k2hrrelg" modified-by="" timestamp="1510277742617"><title>这块内存中存的数据</title></topic></topics></children></topic><topic id="08sbv68k3m62kgevbvoofhq5ro" modified-by="" timestamp="1510277743621"><title>数据类型</title><children><topics type="attached"><topic id="4ukj81pdt3akesqa2r9r7ep550" modified-by="" timestamp="1510277754588"><title>决定这块内存的大小</title></topic></topics></children></topic></topics></children></topic><topic id="4j3inulsqloluetf7eon5nj0fc" modified-by="" timestamp="1510277835881"><title>使用要求</title><children><topics type="attached"><topic id="66tepsrjnor6emks0v9fcqgj4e" modified-by="" timestamp="1510277772878"><title>1、先声明后使用</title><children><topics type="attached"><topic id="3h943ug5350irucut9ic58578k" modified-by="" timestamp="1510277776344"><title>声明格式</title><children><topics type="attached"><topic id="1qnf34t9sbfonfpatcnm1hkhl5" modified-by="" timestamp="1510277784452"><title>数据类型  变量名;</title></topic></topics></children></topic></topics></children></topic><topic id="5ikpp7c4gg525k5led8iv7bofn" modified-by="" timestamp="1510277797011"><title>2、在使用之前必须赋值</title><children><topics type="attached"><topic id="6ajhhn3rt066atujm5226as3n3" modified-by="" timestamp="1510277800296"><title>赋值格式</title><children><topics type="attached"><topic id="45d22811vifb2600m255eiohsq" modified-by="" timestamp="1510277809629"><title>变量名 = 值;</title><children><topics type="attached"><topic id="7fqg8utfpv0f2so92dnavmh30a" modified-by="" timestamp="1510277826382"><title>这个值可以是常量值，表达式</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="4l8abm56babu313mqt4jjl1cce" modified-by="" timestamp="1510277857550"><title>3、变量的作用域</title><children><topics type="attached"><topic id="10kk1pssmet5n8gperfq8ivroj" modified-by="" timestamp="1510277855361"><title>从声明处开始，到它所属的}结束</title></topic><topic id="4tn5ujlo574iqgs7s265bmu3gr" modified-by="" timestamp="1510277864328"><title>同一个作用域不能同名</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic branch="folded" id="2s5nsgun8qqdtbm366t1hti6bo" modified-by="" timestamp="1539745500813"><title>3、数据类型</title><children><topics type="attached"><topic id="66vmpjitelj80ekeodieml7nuc" modified-by="" timestamp="1510362992880"><title>基本数据类型</title><children><topics type="attached"><topic id="6aejoupbuo13kmq1rl9snh580m" modified-by="" timestamp="1510277934537"><title>整型</title><children><topics type="attached"><topic id="7jmobrde5da1pb27dtungu6p07" modified-by="" timestamp="1510277964552"><title>byte</title><children><topics type="attached"><topic id="7kahlmtidjhgro1i2m86mm44j7" modified-by="" timestamp="1510277964316"><title>占1个字节</title></topic><topic id="46tea2g2d7e9goo1lo3di51ft5" modified-by="" timestamp="1510277972952"><title>存储范围是 -128~127</title></topic></topics></children></topic><topic id="48knk4127qhuqt47gkco2h9moq" modified-by="" timestamp="1510277975647"><title>short</title><children><topics type="attached"><topic id="2vfmdnat9m79pgk0bsqielgkb0" modified-by="" timestamp="1510277980432"><title>占2个字节</title></topic></topics></children></topic><topic id="0ll09hr9p8oedmjd2mui21l88a" modified-by="" timestamp="1510277985263"><title>int</title><children><topics type="attached"><topic id="285pv9va81oa3u2lkqm1ps20uq" modified-by="" timestamp="1510277984752"><title>占4个字节</title></topic><topic id="5r346lbfkmq3g8ai7lge393r0n" modified-by="" timestamp="1510277989748"><title>默认类型</title></topic></topics></children></topic><topic id="1jjovqmtf73ccbo6gmi0q2ejr4" modified-by="" timestamp="1510277997362"><title>long</title><children><topics type="attached"><topic id="1imknfgfvnnghlqano9rmngae3" modified-by="" timestamp="1510277997055"><title>占8个字节</title></topic><topic id="0mh6vj2qnjvgln70v2c16van87" modified-by="" timestamp="1510278011622"><title>需要在数字后面加L或小写l</title></topic></topics></children></topic></topics></children></topic><topic id="1s3j2iksaevh159mb5mfu78trq" modified-by="" timestamp="1510277941509"><title>浮点型</title><children><topics type="attached"><topic id="3dh8k1pcdp7mhbcel4ksaslhg2" modified-by="" timestamp="1510278041811"><title>float</title><children><topics type="attached"><topic id="394qgoru2mvidoa2ared6p53ng" modified-by="" timestamp="1510278025040"><title>占4个字节</title></topic><topic id="46l387df6lg6g609q4el5gant4" modified-by="" timestamp="1510278050236"><title>需要在数字后面加F或f</title></topic></topics></children></topic><topic id="3s2fb8cmdogl6pia6q9g3g2fid" modified-by="" timestamp="1510278031563"><title>double</title><children><topics type="attached"><topic id="2812ojpavjce631ol3j27n0o0b" modified-by="" timestamp="1510278029928"><title>占8个字节</title></topic><topic id="5l7580928a4puca5uclpiujho4" modified-by="" timestamp="1510278039278"><title>默认类型</title></topic></topics></children></topic></topics></children></topic><topic id="3r184k2gvpsc1q0cnk750jotrs" modified-by="" timestamp="1510277946271"><title>字符型</title><children><topics type="attached"><topic id="55m78l078bk6f2tgbdbq1rvr3u" modified-by="" timestamp="1510278375222"><title>char</title><children><topics type="attached"><topic id="506dof5eacjcq3jn74qes5djhs" modified-by="" timestamp="1510278059679"><title>占2个字节</title></topic><topic id="35t0slf946h233i31orgajr8m1" modified-by="" timestamp="1510278074671"><title>存储的是字符的Unicode编码值</title></topic><topic id="450n58jh1pv7mct9ejtfoe1brv" modified-by="" timestamp="1510278402563"><title>三种方式</title><children><topics type="attached"><topic id="4ral4f44e2k8ka348p60ui1e4k" modified-by="" timestamp="1510278397920"><title>'一个字符'</title></topic><topic id="0omrei0nmd0ev4kvnht4off8gp" modified-by="" timestamp="1510278526790"><title>'转义字符'</title><children><topics type="attached"><topic id="3umctks6ei95er3s6fpdfgvk2v" modified-by="" timestamp="1510278431379"><title>退格</title><children><topics type="attached"><topic id="4vb12ga0np34iq85kkm00dd8ek" modified-by="" timestamp="1510278434434"><title>\b</title></topic></topics></children></topic><topic id="64m07enr182hvk207dnhajacap" modified-by="" timestamp="1510278441596"><title>回车</title><children><topics type="attached"><topic id="1ev2573u6bh618vf0tj6miol4c" modified-by="" timestamp="1510278443907"><title>\r</title></topic></topics></children></topic><topic id="37i7ogbi34gidbvi68dub0l6it" modified-by="" timestamp="1510278457288"><title>换行</title><children><topics type="attached"><topic id="5ijm73jvie8iug5u1rvh3iai7s" modified-by="" timestamp="1510278459806"><title>\n</title></topic></topics></children></topic><topic id="3rg4ipbovfoe3lajj41j27vnfs" modified-by="" timestamp="1510278513819"><title>\\</title></topic><topic id="16gtsrdt1k5n9b0bh3otsulcnp" modified-by="" timestamp="1510278516316"><title>\'</title></topic><topic id="374adlecpn4n8hiurug86q4q8g" modified-by="" timestamp="1510278519627"><title>\"</title></topic><topic id="2jv0uu2lsv7rm77u515thb5dl2" modified-by="" timestamp="1510278534494"><title>Tab键</title><children><topics type="attached"><topic id="599tlbmrg3d7n56739mrp5km57" modified-by="" timestamp="1510278536644"><title>\t</title></topic></topics></children></topic></topics></children></topic><topic id="6vofe8c68p45ufu5ta09cthr9v" modified-by="" timestamp="1510278415828"><title>'\u字符的Unicode编码值的十六进制形式'</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="1nfd4dtk9807dsm98rhpja835c" modified-by="" timestamp="1510277951977"><title>布尔型</title><children><topics type="attached"><topic id="1nlh21320sbuiqg671n377t8ne" modified-by="" timestamp="1510278360304"><title>boolean</title><children><topics type="attached"><topic id="3dh3oucka05hpgbntjuc3h6pea" modified-by="" timestamp="1510278370373"><title>只能赋值为true或false</title></topic></topics></children></topic></topics></children></topic><topic id="0156018p72165g9tvjnlo87abu" modified-by="" timestamp="1510363146936"><title>基本数据类型的转换</title><children><topics type="attached"><topic id="2dpk7edtcknneofrppmc4b89ka" modified-by="" timestamp="1510363018047"><title>1、自动类型转换</title><children><topics type="attached"><topic id="5h5jdak0kn37lkmsrcgsoljcc2" modified-by="" timestamp="1510363126771"><title>byte,short,char --&gt;int -&gt;long --&gt;float --&gt;double</title><children><topics type="attached"><topic id="4b62irdkol9568ivguuf6uhd2v" modified-by="" timestamp="1510363101527"><title svg:width="500">（1）byte,short,char只要算术运算都要升级为int或以上</title><children><topics type="attached"><topic id="67n3h0hr8i0redvbhsi7sb2947" modified-by="" timestamp="1510363080584"><title>例如：byte + byte升级为int</title></topic><topic id="7qs71b6ulfh1j5em6l4ev2f8gt" modified-by="" timestamp="1510363095934"><title>例如：byte + double 升级为double</title></topic><topic id="31vjsggs2ksurdi2bbdf634ld8" modified-by="" timestamp="1510363108197"><title>例如：byte + short升级int</title></topic></topics></children></topic><topic id="3l7eug9ve75butj010abcmtfaf" modified-by="" timestamp="1510363125304"><title>（2）boolean不参与</title></topic><topic id="7i5097ltl5m69h03o4kvba5k21" modified-by="" timestamp="1510363142103"><title>（3）和字符串拼接的结果都是String字符串</title></topic></topics></children></topic></topics></children></topic><topic id="1oupu383b37m3nofcr4q3i4873" modified-by="" timestamp="1510363233935"><title>2、强制类型转换</title><children><topics type="attached"><topic id="32954e2lcm6j9pjceotqn1qq3u" modified-by="" timestamp="1510363183507"><title>double--&gt;float--&gt;long--&gt;int--&gt;byte,short,char</title><children><topics type="attached"><topic id="5n3toql13uiadkvqlfivv23id1" modified-by="" timestamp="1510363206515"><title>（1）例如： char  c = (char)97;</title><children><topics type="attached"><topic id="59olj8vmgbockas0929rpve9n8" modified-by="" timestamp="1510363225397"><title>相当于把'a'字符赋值给c</title></topic></topics></children></topic></topics></children></topic><topic id="4m8vabq1en07tctcbe0djjr8jh" modified-by="" timestamp="1510363180483"><title>需要强制类型转换符(类型)</title></topic><topic id="0n60199rbsfn0v91mg74q37rof" modified-by="" timestamp="1510363250531"><title>有可能溢出或损失精度，需谨慎</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic branch="folded" id="0qldsc5f19aoci3rfma3isque8" modified-by="" timestamp="1510363007554"><title>引用数据类型</title><children><topics type="attached"><topic id="60n41048kjube8q494n4o31gjn" modified-by="" timestamp="1510278583496"><title>类</title><children><topics type="attached"><topic id="5bd733gvbvahccun57tvm5t0ct" modified-by="" timestamp="1510278590059"><title>例如：String，System</title></topic></topics></children></topic><topic id="52598de0nghsl4bjvjvl4juj1t" modified-by="" timestamp="1510278579112"><title>接口</title></topic><topic id="3tu4dktk0fg99rteuuf5v67tcl" modified-by="" timestamp="1510278582461"><title>数组</title></topic></topics></children></topic></topics></children></topic><topic branch="folded" id="058a33jq4i8dkqadcalrafp5bu" modified-by="" timestamp="1539745503958"><title>4、运算符</title><children><topics type="attached"><topic branch="folded" id="4ks1bsn65dcm83qic085fb4buv" modified-by="" timestamp="1539745501918"><title>算术运算符</title><children><topics type="attached"><topic id="57idqi13b6sr3sg76q5q1lut9k" modified-by="" timestamp="1510363316261"><title>正号</title><children><topics type="attached"><topic id="6tttcsbgrgjtg5gc02m5s1av6g" modified-by="" timestamp="1510363341495"><title>+</title></topic></topics></children></topic><topic id="41o6e6bmovd4j6obs6m2gfdk87" modified-by="" timestamp="1510363318249"><title>负号</title><children><topics type="attached"><topic id="3m5fii7v4b1ou7simdjetc58a8" modified-by="" timestamp="1510363341522"><title>-</title><children><topics type="attached"><topic id="0931dlbf4va81sf9t7morkkigi" modified-by="" timestamp="1510363341495"><title>例如：int a = -5;  int b = -a;</title></topic></topics></children></topic></topics></children></topic><topic id="4eklt65p6t45bfe13p2n2lnh19" modified-by="" timestamp="1510363347625"><title>加法</title><children><topics type="attached"><topic id="471iiknco390dkf48qv1ojqebp" modified-by="" timestamp="1510363349479"><title>+</title></topic></topics></children></topic><topic id="0jvbhokbi7h56nlsimstp049a2" modified-by="" timestamp="1510363352714"><title>减法</title><children><topics type="attached"><topic branch="folded" id="5b3n88r09r20ae0sj3od6tm6e6" modified-by="" timestamp="1510363354557"><title>-</title></topic></topics></children></topic><topic id="1598d07ulu2emk2o8il8knboc4" modified-by="" timestamp="1510363358455"><title>乘法</title><children><topics type="attached"><topic id="6n35qaar610hjujr6abq5g1nia" modified-by="" timestamp="1510363363859"><title>*</title></topic></topics></children></topic><topic id="3dbme68uncrd4phojm7h0drtkj" modified-by="" timestamp="1510363368695"><title>除法</title><children><topics type="attached"><topic id="7s4f1l858ccenbph2qclvq0ibo" modified-by="" timestamp="1510363373655"><title>/</title><children><topics type="attached"><topic id="2nm2em4gnrhnde3ciqep7tiomv" modified-by="" timestamp="1510363422516"><title svg:width="500">注意：</title><children><topics type="attached"><topic id="2vnt1s3e696c02urfmcmebjqrp" modified-by="" timestamp="1510363391921"><title>当整数与整数相除，结果只保留整数部分</title></topic><topic id="3519rcviifj4qi861p12l2luul" modified-by="" timestamp="1510363421282"><title svg:width="500">当整数与整数相除，被除数/除数 ，除数不能为0，报异常</title></topic><topic id="34mc4qs22foar0j2jiqeihddc3" modified-by="" timestamp="1510363442696"><title svg:width="500">当浮点数相除，如果除数为0，结果是无穷大，非数字</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="1q2m6heuorugd3uk6deb671l2d" modified-by="" timestamp="1510363466372"><title>取模，求余数</title><children><topics type="attached"><topic id="6ssd90f717ctil4qp996keshdr" modified-by="" timestamp="1510363467475"><title>%</title><children><topics type="attached"><topic id="0qq3f6055et7c0ldpo4p58tea3" modified-by="" timestamp="1510363471164"><title>特殊</title><children><topics type="attached"><topic id="0fqtmj1jot2m5b773pj7dont5t" modified-by="" timestamp="1510363478041"><title>会忽略模数的负号</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="5k1d1n78neb85qjn54o38ambt6" modified-by="" timestamp="1510363489166"><title>自增</title><children><topics type="attached"><topic id="2lqt3g1dc1r0m4o29f42vvotvi" modified-by="" timestamp="1510363521582"><title>++</title><children><topics type="attached"><topic id="522i55t3sd12694dq7jk8l299l" modified-by="" timestamp="1510363519852"><title>对于自增变量来说，一定会自增1</title></topic><topic id="3er8hfomcmt5mn8vip4kvgi3kq" modified-by="" timestamp="1510363581903"><title>但是对于表达式的结果，看++在前或在后</title><children><topics type="attached"><topic id="37us92979mu6sjioufv9ka8kev" modified-by="" timestamp="1510363543015"><title>i++</title><children><topics type="attached"><topic id="0htjgj7dfkr5rmguj0ih9p5uuf" modified-by="" timestamp="1510363557340"><title>这个表达式的结果是与i自增前的结果一样</title><children><topics type="attached"><topic id="2mfscovoi648r2ab820sq57dja" modified-by="" timestamp="1510363570789"><title>例如：int i=0;int j = i++;</title><children><topics type="attached"><topic id="2qftnrpmo1h069bk44o2e0839j" modified-by="" timestamp="1510363578772"><title>j=0,i=1</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="007gp01gfid3dv99on3l3iogpp" modified-by="" timestamp="1510363588661"><title>++i</title><children><topics type="attached"><topic id="35b13d0f3djhj5rpl6h57ngp6r" modified-by="" timestamp="1510363592945"><title>这个表达式的结果是与i自增后的结果一样</title><children><topics type="attached"><topic id="3j48mbmhgg6nedr45t0a3sp3uh" modified-by="" timestamp="1510363599590"><title>例如：int i=0;int j = ++i;</title><children><topics type="attached"><topic id="0i4ns8eatb5610731bs2269i9b" modified-by="" timestamp="1510363602823"><title>j=1,i=1</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="1idc7usef1jgbh56mdk7iih6f3" modified-by="" timestamp="1510363495990"><title>自减</title><children><topics type="attached"><topic id="114hc3ls5j6d52v3oslnvqjrq8" modified-by="" timestamp="1510363607817"><title>--</title><children><topics type="attached"><topic id="3v8vcr9hbagqusdh7rcu6ostdb" modified-by="" timestamp="1510363614282"><title>同自增</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="15rmvgbno25nervv6e887up93i" modified-by="" timestamp="1510363654439"><title>赋值运算符</title><children><topics type="attached"><topic id="52jfis8qb2f20ths2dqsmoghu7" modified-by="" timestamp="1510363628179"><title>基本赋值运算符</title><children><topics type="attached"><topic id="1mkr0n9h5nv4ovs3u7hhbkn32r" modified-by="" timestamp="1510363631398"><title>=</title><children><topics type="attached"><topic id="0j0fecpglstc3lpj5v1mk0itp1" modified-by="" timestamp="1510363652022"><title>把右边的结果赋值给左边的变量</title></topic></topics></children></topic></topics></children></topic><topic id="5vnfvgf5sod0kubdblan8m9iuv" modified-by="" timestamp="1510363660109"><title>扩展赋值运算符</title><children><topics type="attached"><topic id="3asknsleoi3gihtqsft416bog7" modified-by="" timestamp="1510363673807"><title>+=, -=,.....</title><children><topics type="attached"><topic id="47ko2cnsfaa65smanuge7rkv6t" modified-by="" timestamp="1510363686029"><title>隐含强制类型转换</title><children><topics type="attached"><topic id="4ug5d6p11d8djurj2ar78fah56" modified-by="" timestamp="1510363702409"><title>例如： short s = 1;  s += 1;  </title><children><topics type="attached"><topic id="30v4l33ko75obunliucl4diolr" modified-by="" timestamp="1510363721304"><title>等价于 s = (short)(s+1);</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="2s9dmgjrjf060a2doh3olsqp0b" modified-by="" timestamp="1510363775965"><title>比较运算符</title><children><topics type="attached"><topic id="5fufts8h5rq7535cvoc9aq4a82" modified-by="" timestamp="1510363733666"><title>大于</title><children><topics type="attached"><topic id="51e9i3p590aerbltm76m4eki4v" modified-by="" timestamp="1510363735683"><title>&gt;</title></topic></topics></children></topic><topic id="7fvucehip000qs8au5fgqrplks" modified-by="" timestamp="1510363739255"><title>小于</title><children><topics type="attached"><topic id="04t30iu413eci9qmu3a27p6219" modified-by="" timestamp="1510363741247"><title>&lt;</title></topic></topics></children></topic><topic id="1cg9jf3tsflc87fkjlno5p79tv" modified-by="" timestamp="1510363744921"><title>大于等于</title><children><topics type="attached"><topic id="3aenfb9fsnho4lj8gl3t17q87d" modified-by="" timestamp="1510363747246"><title>&gt;=</title></topic></topics></children></topic><topic id="49ur8iflsomt4ldof7agduivgv" modified-by="" timestamp="1510363751586"><title>小于等于</title><children><topics type="attached"><topic id="3gacrh79fa16dg25pdfok199bh" modified-by="" timestamp="1510363753782"><title>&lt;=</title></topic></topics></children></topic><topic id="5qbt6rb0gg9oa1v3cldh8fegs6" modified-by="" timestamp="1510363758984"><title>等于</title><children><topics type="attached"><topic id="4a0ndf749d348cc9vflishrl9q" modified-by="" timestamp="1510363761380"><title>==</title></topic></topics></children></topic><topic id="3eang3ntslujharfgo1aiu8s04" modified-by="" timestamp="1510363769130"><title>不等于</title><children><topics type="attached"><topic id="2ngeue785kui4f04m6us428s15" modified-by="" timestamp="1510363771839"><title>!=</title></topic></topics></children></topic><topic id="4h4oqcbk1kt337j0hj1s90lcgj" modified-by="" timestamp="1510363799699"><title svg:width="500">结果一定是boolean值，所以比较表达式常常用于条件表达式</title></topic></topics></children></topic><topic id="7f7k3sj0k54qq94lc8krspf5jm" modified-by="" timestamp="1510364086355"><title>逻辑运算符</title><children><topics type="attached"><topic id="3aog62erqvad25h1s5gkah8j3k" modified-by="" timestamp="1510363809602"><title>逻辑与</title><children><topics type="attached"><topic id="1ujl7vai2kfg3us3l5st8mh401" modified-by="" timestamp="1510363813130"><title>&amp;</title><children><topics type="attached"><topic id="18d07bupe755eb3ais6eicbc6e" modified-by="" timestamp="1510363857834"><title>只有左右两边的值都为true，结果才为true</title><children><topics type="attached"><topic id="3pugs3dbpcnkl1867pmpim1rmm" modified-by="" timestamp="1510363843869"><title>true  &amp; true = true</title></topic><topic id="0gtg94ve7dbkjvef5dg75pfr7v" modified-by="" timestamp="1510363849683"><title>true &amp; false = false</title></topic><topic id="7fsq97pd5nfdb5vtuk8i71rbsr" modified-by="" timestamp="1510363857578"><title>false &amp; true = false</title></topic><topic id="09khj29i1535smjd38ef776o37" modified-by="" timestamp="1510363862930"><title>false &amp; false = false</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="2j7gopl29egm9t4kgqh624lh0g" modified-by="" timestamp="1510363879148"><title>逻辑或</title><children><topics type="attached"><topic id="293rkp1t0uicsg8mnehkda4gnp" modified-by="" timestamp="1510363872385"><title>|</title><children><topics type="attached"><topic id="7hi6iv862djavj74lfbl9pj4q4" modified-by="" timestamp="1510363892849"><title>只要左右两边的值有一个为true，结果就为true</title><children><topics type="attached"><topic id="4u68pf1q18g9ht6sa1q1khdncd" modified-by="" timestamp="1510363900833"><title>true  | true = true</title></topic><topic id="06lkb78fn814jrun6g2lc3t65l" modified-by="" timestamp="1510363920165"><title>true | false = true</title></topic><topic id="0ith0ks88lc7ciajq7vf2nccng" modified-by="" timestamp="1510363913237"><title>false | true = true</title></topic><topic id="7lnpt84ihsohjc1gs0todi58md" modified-by="" timestamp="1510363916027"><title>false | false = false</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="409jmctp3vaugkqif34vrnii7u" modified-by="" timestamp="1510363928943"><title>逻辑异或</title><children><topics type="attached"><topic id="5jsuqnd4oiq44jeupd4n2imb1r" modified-by="" timestamp="1510363950194"><title>^</title><children><topics type="attached"><topic id="29ujkm1smtdb559v6ha6iv35r4" modified-by="" timestamp="1510363985703"><title svg:width="500">只有左右两边一个为true,另一个为false，结果才为true</title><children><topics type="attached"><topic id="4mkvmngha0344626okk0vuuqto" modified-by="" timestamp="1510363993218"><title>true  ^ true = false</title></topic><topic id="7e7o29fo1m2v776jqqfaktmpr8" modified-by="" timestamp="1510363997702"><title>true ^ false = true</title></topic><topic id="5j9f9rbl37f7ttcqsan6kkb6bl" modified-by="" timestamp="1510364001543"><title>false ^ true = true</title></topic><topic id="64v2ktg2ugpsfsobo9blj9lu95" modified-by="" timestamp="1510364005207"><title>false ^ false = false</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="21ui0msq9hk2puunr7555cpajl" modified-by="" timestamp="1510364026933"><title>逻辑非</title><children><topics type="attached"><topic id="570jqhsph8ca9aq7iqdj0j9u3i" modified-by="" timestamp="1510364027822"><title>!</title><children><topics type="attached"><topic id="5lnslnn87sfbvsgmmhl0g4cv2j" modified-by="" timestamp="1510364025331"><title>!true 即为false</title></topic><topic id="5t6s6trmbljs7o4of288k1rb1r" modified-by="" timestamp="1510364033414"><title>!false即为true</title></topic></topics></children></topic></topics></children></topic><topic id="628tv986rl2kab34s8fsdds529" modified-by="" timestamp="1510364039344"><title>短路与</title><children><topics type="attached"><topic id="06d4ujndusk06mlht7ktbgc5u8" modified-by="" timestamp="1510364059328"><title>&amp;&amp;</title><children><topics type="attached"><topic id="1mf89kndls7lce9jegkavs6kga" modified-by="" timestamp="1510364056142"><title>结果与&amp;一样</title><children><topics type="attached"><topic id="2vmmallh80sf4pskp5c7oj5pq1" modified-by="" timestamp="1510364056095"><title>只有左右两边的值都为true，结果才为true</title><children><topics type="attached"><topic id="2n7sg9a3ihhnpqhaug3lavvn0u" modified-by="" timestamp="1510363843869"><title>true  &amp; true = true</title></topic><topic id="6kcv4gn1da44heaeq6na7esemu" modified-by="" timestamp="1510363849683"><title>true &amp; false = false</title></topic><topic id="21a5eae5nvmgg6ngem8i9v4n68" modified-by="" timestamp="1510363857578"><title>false &amp; true = false</title></topic><topic id="4cs861jq54rojnfi3gf687970r" modified-by="" timestamp="1510363862930"><title>false &amp; false = false</title></topic></topics></children></topic></topics></children></topic><topic id="1ugacbjp7l5capubusog4uktvg" modified-by="" timestamp="1510364064446"><title>不同的是</title><children><topics type="attached"><topic id="6btp7f6u73lv44qaie992hhf3e" modified-by="" timestamp="1510364085010"><title svg:width="500">如果左边的表达式为false，右边的表达式就不计算了，出现短路现象</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="1bp1fsv5s224immtgmgvkqistm" modified-by="" timestamp="1510364091046"><title>短路或</title><children><topics type="attached"><topic id="58jpv8u16k51hlneftbrhfl1pk" modified-by="" timestamp="1510364115285"><title>||</title><children><topics type="attached"><topic id="7pjasdnk2cd7aike7ob243si7k" modified-by="" timestamp="1510364105528"><title>结果与|一样</title><children><topics type="attached"><topic id="53f81153uhirgcmd0lf8jp191p" modified-by="" timestamp="1510364105486"><title>只要左右两边的值有一个为true，结果就为true</title><children><topics type="attached"><topic id="3ov9cd6umtl0r6v0j87c2rqvim" modified-by="" timestamp="1510363900833"><title>true  | true = true</title></topic><topic id="602j6drobc9c6b0739j9ucbuc9" modified-by="" timestamp="1510363920165"><title>true | false = true</title></topic><topic id="2tvn1ijk6hdlou39vqvkt4nn4q" modified-by="" timestamp="1510363913237"><title>false | true = true</title></topic><topic id="0cofqtgl5s3pveo1sbi24o13ib" modified-by="" timestamp="1510363916027"><title>false | false = false</title></topic></topics></children></topic></topics></children></topic><topic id="6p41qrnp90adgekb31ilmb5kqs" modified-by="" timestamp="1510364115252"><title>不同的是</title><children><topics type="attached"><topic id="67bkclpd1hia6e0cf2s9s3ckj1" modified-by="" timestamp="1510364123236"><title svg:width="500">如果左边的表达式为true，右边的表达式就不计算了，出现短路现象</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="60jauagqecub1anqn2nrnevsbn" modified-by="" timestamp="1510364152887"><title>条件运算符</title><children><topics type="attached"><topic id="73sobc5un73is6fse4cir8rj8g" modified-by="" timestamp="1510364174795"><title>格式</title><children><topics type="attached"><topic id="5qkfbr2npvkipecrohaovqa106" modified-by="" timestamp="1510364173909"><title>条件表达式 ?  表达式1 ： 表达式2</title></topic><topic id="2i5c351alcqbuc96b48j3570n8" modified-by="" timestamp="1510364200314"><title svg:width="500">整个表达式的结果看条件表达式，如果条件表达式为true，那么就取表达式1的结果，否则取表达式2的结果</title></topic></topics></children></topic></topics></children></topic><topic id="1ejjq3agqej3fu65hf4k5pllmt" modified-by="" timestamp="1510364236294"><title>位运算符</title><children><topics type="attached"><topic id="5de4d2c9294jj0q8thdj3k5ire" modified-by="" timestamp="1510364253769"><title>左移</title><children><topics type="attached"><topic id="6t22isj2ffho3vtq6hsfcujv32" modified-by="" timestamp="1510364365848"><title>&lt;&lt;</title><children><topics type="attached"><topic id="19vdlfslds9ukphtihfa8c9m85" modified-by="" timestamp="1510364312617"><title>相当于乘以2的几次</title><children><topics type="attached"><topic id="5l8e742346gh9qthrv59r2vclh" modified-by="" timestamp="1510364318888"><title>例如：1 &lt;&lt; 3</title><children><topics type="attached"><topic id="7k14i07r3ph72jm95u2650va6q" modified-by="" timestamp="1510364330471"><title>相当于 1 * 2的3次方</title></topic></topics></children></topic></topics></children></topic><topic id="0r02nbet1gou1kdav962j91s9b" modified-by="" timestamp="1510364376371"><title>右边补0</title></topic></topics></children></topic></topics></children></topic><topic id="3e7tm971vsrq2sm67uprnl7kib" modified-by="" timestamp="1510364257503"><title>右移</title><children><topics type="attached"><topic id="2bq92udirtq8s0qle3m3h2hvbt" modified-by="" timestamp="1510364377218"><title>&gt;&gt;</title><children><topics type="attached"><topic id="3dbki53jd6dfct08cer67mmv36" modified-by="" timestamp="1510364342479"><title>相当于除以2的几次</title><children><topics type="attached"><topic id="7a8u6cb0f2gu2uec1qaouc41nh" modified-by="" timestamp="1510364349971"><title>例如：16 &gt;&gt; 3</title><children><topics type="attached"><topic id="5nublsp57aq1irtseasdke6111" modified-by="" timestamp="1510364355541"><title>相当于 16 / 2的3次方</title></topic></topics></children></topic></topics></children></topic><topic id="6ia9vv2d49hulvs34fflnkq1v1" modified-by="" timestamp="1510364396344"><title svg:width="500">左边补什么，看最高位，最高位是1，就补1，是0就补0</title></topic></topics></children></topic></topics></children></topic><topic id="34qreps2c80tgrqaaijut4qq64" modified-by="" timestamp="1510364260626"><title>无符号右移</title><children><topics type="attached"><topic id="28r0f8g4rf4acl5t5jttn6br2j" modified-by="" timestamp="1510364411454"><title>&gt;&gt;&gt;</title><children><topics type="attached"><topic id="5s60427v831c663ur1e4j7dfnv" modified-by="" timestamp="1510364410696"><title>不管最高位是什么，左边都补0</title></topic><topic id="4tkmebq5nas0an4uhg3t2lfel7" modified-by="" timestamp="1510364415967"><title>结果一定是正数</title></topic></topics></children></topic></topics></children></topic><topic id="37pepkn6dtdkfkchhu81f2tpvk" modified-by="" timestamp="1510364267060"><title>按位与</title><children><topics type="attached"><topic id="555u5fdha6mlurnc3ihhpdjsel" modified-by="" timestamp="1510364421469"><title>&amp;</title><children><topics type="attached"><topic id="1lui7pgpes1k3etlgj8q0708t6" modified-by="" timestamp="1510364456617"><title>运算规则，对应位</title><children><topics type="attached"><topic id="4dggihcde512ic9bgha4lkdg2t" modified-by="" timestamp="1510364443536"><title>1 &amp; 1 = 1</title></topic><topic id="4jsdog4ed2jp0s9370ebc68vuv" modified-by="" timestamp="1510364449119"><title>1&amp;0 = 0</title></topic><topic id="79ku9phk3a6bepe2tes927masv" modified-by="" timestamp="1510364456325"><title>0&amp;1 = 0</title></topic><topic id="7p9vath2km3p7evcpfr9pqsb5o" modified-by="" timestamp="1510364461825"><title>0&amp;0=0</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="3754o54pr7loqqhiqt87jkh1a0" modified-by="" timestamp="1510364269837"><title>按位或</title><children><topics type="attached"><topic id="7ek2q3n8v5d9sb7boa7nesqq95" modified-by="" timestamp="1510364466314"><title>|</title><children><topics type="attached"><topic id="1ma7k4k574d44sud8de7h4r8lq" modified-by="" timestamp="1510364466260"><title>运算规则，对应位</title><children><topics type="attached"><topic id="6bdkcb6lgml9vu728hbs7dj50c" modified-by="" timestamp="1510364471721"><title>1 | 1 = 1</title></topic><topic id="3lq78k9p4lmtd5gmuoqba28rdi" modified-by="" timestamp="1510364475913"><title>1|0 = 1</title></topic><topic id="7ej8613pvl1hv47v5odkpr9mha" modified-by="" timestamp="1510364481439"><title>0|1 = 1</title></topic><topic id="19rfshiqqr9bfbgl2k26ha3g6l" modified-by="" timestamp="1510364484571"><title>0|0=0</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="6165a4fal3tk573bmhdqh91mib" modified-by="" timestamp="1510364272535"><title>按位异或</title><children><topics type="attached"><topic id="5n585ad4onai399hk8ofvmf27e" modified-by="" timestamp="1510364487448"><title>^</title><children><topics type="attached"><topic id="28qoofjv5ip26ve9ujdar9voj4" modified-by="" timestamp="1510364487382"><title>运算规则，对应位</title><children><topics type="attached"><topic id="1c1ee2soouoalqub38gk02fr96" modified-by="" timestamp="1510364494469"><title>1^ 1 = 0</title></topic><topic id="42slqso42ha1fh3vvc93vkn55v" modified-by="" timestamp="1510364499818"><title>1^0 = 1</title></topic><topic id="2qus1v0ep4ngie79cuqkqrlvj8" modified-by="" timestamp="1510364503203"><title>0^1 = 1</title></topic><topic id="3e8demt9ro7b4tdubv3v6dj189" modified-by="" timestamp="1510364506518"><title>0^|0=0</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="6k9m6k37doui1jam0vomvrdp47" modified-by="" timestamp="1510364274820"><title>按位取反</title><children><topics type="attached"><topic id="1s9kvr99lpvrmlighvg8k6j4d0" modified-by="" timestamp="1510364511047"><title>~</title><children><topics type="attached"><topic id="3k2ojt8s1n0olvm46cobvsfpor" modified-by="" timestamp="1510364535178"><title svg:width="500">运算规则，对应位，原来是1，变成0，原来是0，变成1</title></topic></topics></children></topic></topics></children></topic><topic id="6k0l3kfid4haf7ob1j3oovsv28" modified-by="" timestamp="1510364249872"><title>所有都是直接用二进制计算（补码）</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><title>Java基础语法</title></sheet><sheet id="6p581keuc46npn1ovok5tj9g0j" modified-by="" style-id="15gk97kdsd93jhf4sutdl4nrmt" theme="xminddefaultthemeid" timestamp="1510623652710"><topic id="0bsn4ihtn0jff52qmeoa1ajllm" modified-by="" structure-class="org.xmind.ui.logic.right" timestamp="1510622958050"><title>流程控制语句结构</title><extensions><extension provider="org.xmind.ui.map.unbalanced"><content><right-number>-1</right-number></content></extension></extensions><children><topics type="attached"><topic id="1qqj89agdbime4rq4dg9bg9p8s" modified-by="" timestamp="1510364598282"><title>顺序结构</title><children><topics type="attached"><topic id="6ccgo84v9e6bvarvjlbeqsohqu" modified-by="" timestamp="1510364610440"><title>同一个方法中，从上往下，顺序执行</title></topic></topics></children></topic><topic id="3ghcehbbius727seaheg5nier4" modified-by="" timestamp="1510536364008"><title>分支结构</title><children><topics type="attached"><topic id="1s4qro3sdg7105v98f6hsihm8n" modified-by="" timestamp="1510535782297"><title>条件判断</title><children><topics type="attached"><topic id="4qsm9kp5jcbsh4d3oful5l83nd" modified-by="" timestamp="1510364728922"><title>1、单分支条件判断</title><children><topics type="attached"><topic id="04aq3virssmhfpra3o3qiio9bk" modified-by="" timestamp="1510364636952"><title>语法</title><children><topics type="attached"><topic id="0fg03bhghugil8c9p7661lce32" modified-by="" timestamp="1510364698397"><title>if(条件表达式){&#13;
  当条件表达式为true时，要执行的语句块&#13;
}</title><children><topics type="attached"><topic id="5np13ej9e9h22vliiqcg9pqs71" modified-by="" timestamp="1510364697200"><title svg:width="500">（1）如果条件成立，就执行语句块，如果条件不成立，就不执行语句块</title></topic><topic id="4tm1bfm2ngj823g7bc7peloljv" modified-by="" timestamp="1510364712541"><title svg:width="500">（2）{}可以省略，默认只带一句，建议不要省略</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="4leot8viuobkfugrap8tt35tla" modified-by="" timestamp="1510364734422"><title>2、双分支条件判断</title><children><topics type="attached"><topic id="1ma9kdgai7ktiphdf2221du135" modified-by="" timestamp="1510364734376"><title>语法</title><children><topics type="attached"><topic id="5eb9suoprhp4176ktm0aq10pbr" modified-by="" timestamp="1510364774164"><title>if(条件表达式){&#13;
  当条件表达式为true时，要执行的语句块1&#13;
}else{&#13;
	当条件表达式为false时，要执行的语句块2&#13;
}</title><children><topics type="attached"><topic id="00ch56l434o2104feqlkafiomv" modified-by="" timestamp="1510364764758"><title svg:width="500">（1）如果条件成立，就执行语句块1，如果条件不成立，就执行语句块2</title></topic><topic id="12o0vp18gv6sr3aft728lp7o47" modified-by="" timestamp="1510364712541"><title svg:width="500">（2）{}可以省略，默认只带一句，建议不要省略</title></topic><topic id="1n929a7apt9jjm4cr1vim7smtj" modified-by="" timestamp="1510364787125"><title>（3）else不可以单独存在的，必须有if配对</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="58skv4skmp4ucr0qjtm5aqsfoa" modified-by="" timestamp="1510535370199"><title>3、多分支条件判断</title><children><topics type="attached"><topic id="5qp1eu3r4v8e14ee799hujb4vk" modified-by="" timestamp="1510535375743"><title>语法</title><children><topics type="attached"><topic id="0qqlma8l0ul4t5e4i9jk1lhrvp" modified-by="" timestamp="1510535599458"><title svg:width="500">if(条件表达式1){&#13;
  当条件表达式1为true时，要执行的语句块1&#13;
}else if(条件表达式2){&#13;
	当条件表达式2为true时，要执行的语句块2&#13;
}else if(条件表达式3){&#13;
	当条件表达式3为true时，要执行的语句块3&#13;
}&#13;
.....&#13;
else{&#13;
	当以上所有条件表达式都不成立时，要执行的语句块n+1&#13;
}</title><children><topics type="attached"><topic id="0se9pete9ao2562hlu5qrj5hbl" modified-by="" timestamp="1510535560746"><title svg:width="500">（1）如果条件表达式1成立，执行语句块1，如果条件表达式1不成立才会去判断条件表达2，如果条件表达式2成立，那么执行语句块2，如果条件表达式2不成立，才会去看条件表达式3，依次类推。只有一个分支会被执行</title></topic><topic id="3n24t7oljtjn5r88uep6huigtc" modified-by="" timestamp="1510364712541"><title svg:width="500">（2）{}可以省略，默认只带一句，建议不要省略</title></topic><topic id="71un287nf61olnj8j32ku7t8kj" modified-by="" timestamp="1510364787125"><title>（3）else不可以单独存在的，必须有if配对</title></topic><topic id="6630o4c8u8fubocp0ebnraudou" modified-by="" timestamp="1510535671729"><title>（4）多个条件表达式的范围</title><children><topics type="attached"><topic id="2l68g7gps3b37a4j7243r31ca3" modified-by="" timestamp="1510535666560"><title>互斥，没有交集</title><children><topics type="attached"><topic id="647crce9nol03s225uv4mf5hp0" modified-by="" timestamp="1510535642265"><title>例如</title><children><topics type="attached"><topic id="38qe3brjfj158keq19qldes2uj" modified-by="" timestamp="1510535655005"><title>if(age&gt;=0 &amp;&amp; age&lt;18){&#13;
		System.out.println("未成年");&#13;
}else if(age &gt;=18 &amp;&amp; age&lt;60){&#13;
		System.out.println("成年");&#13;
}</title><children><topics type="attached"><topic id="27d8nj5pjb5rivgv1tpgmc7c2d" modified-by="" timestamp="1510535662528"><title>两个条件没有交集</title></topic></topics></children></topic></topics></children></topic><topic id="6aevospfppbhjstluh45sgvpp2" modified-by="" timestamp="1510535670915"><title>顺序可以互换</title></topic></topics></children></topic><topic id="5hmigeki3c88g0ofs0tn3v2tms" modified-by="" timestamp="1510535745403"><title>包含</title><children><topics type="attached"><topic id="26i52jsgakp2fp4cf5doa6n9ad" modified-by="" timestamp="1510535684877"><title>例如</title><children><topics type="attached"><topic id="6lb8qcn55efohn7iok4j9qjhho" modified-by="" timestamp="1510535695847"><title>if(age&lt;18){&#13;
		System.out.println("未成年");&#13;
}else if(age&lt;60){&#13;
	  System.out.println("成年");&#13;
}</title><children><topics type="attached"><topic id="2rohm77vsg1okc9nt0nkq82uqo" modified-by="" timestamp="1510535704776"><title>两个条件有包含关系</title></topic></topics></children></topic></topics></children></topic><topic id="5q19ep9hhslgsuehh596idv6bo" modified-by="" timestamp="1510535754325"><title>顺序不可以调整</title><children><topics type="attached"><topic id="1ruolpu7hi7hmlthg2rqjvklfp" modified-by="" timestamp="1510535764886"><title>范围小的在上面，范围大的在下面</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="18hotc4cn2sggbjlr1jmbghbh5" modified-by="" timestamp="1510535834681"><title>4、嵌套</title><children><topics type="attached"><topic id="11knj1rv07rm4oaknmoutg7fd2" modified-by="" timestamp="1510535806366"><title svg:width="500">在任意一个语句块中，都还可以嵌套任意一种分支结构</title></topic><topic id="2370vl3srhktdtu1tlsrf063qb" modified-by="" timestamp="1510535856024"><title svg:width="500">当外部的条件成立的情况下，才会进行内部的条件判断</title><children><topics type="attached"><topic id="1or4jmchg010jpvn08n0jls6kh" modified-by="" timestamp="1510536078634"><title>示例</title><notes><html><xhtml:p>if(条件表达式1){</xhtml:p><xhtml:p>	if(条件表达式2){</xhtml:p><xhtml:p>		当条件表达式1成立，并且条件表达式2也成立时执行</xhtml:p><xhtml:p>	}else if(条件表达式3){</xhtml:p><xhtml:p>		当条件表达式1成立，并且条件表达式2不成立，条件表达式3成立时执行</xhtml:p><xhtml:p>	}else{</xhtml:p><xhtml:p>		当条件表达式1成立，并且条件表达式2不成立，条件表达式3不成立时执行</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}else{</xhtml:p><xhtml:p>	if(条件表达式4){</xhtml:p><xhtml:p>		当条件表达式1不成立，条件表达式4成立，执行</xhtml:p><xhtml:p>	}else if(条件表达式5){</xhtml:p><xhtml:p>		当条件表达式1不成立，条件表达式4不成立，条件表达式5成立，执行</xhtml:p><xhtml:p>	}else{</xhtml:p><xhtml:p>		当条件表达式1不成立，条件表达式4不成立，条件表达式5也不成立，执行</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p></html><plain>if(条件表达式1){&#13;
	if(条件表达式2){&#13;
		当条件表达式1成立，并且条件表达式2也成立时执行&#13;
	}else if(条件表达式3){&#13;
		当条件表达式1成立，并且条件表达式2不成立，条件表达式3成立时执行&#13;
	}else{&#13;
		当条件表达式1成立，并且条件表达式2不成立，条件表达式3不成立时执行&#13;
	}&#13;
}else{&#13;
	if(条件表达式4){&#13;
		当条件表达式1不成立，条件表达式4成立，执行&#13;
	}else if(条件表达式5){&#13;
		当条件表达式1不成立，条件表达式4不成立，条件表达式5成立，执行&#13;
	}else{&#13;
		当条件表达式1不成立，条件表达式4不成立，条件表达式5也不成立，执行&#13;
	}&#13;
}</plain></notes></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="56o5h2helspv0dtr8qh4resibr" modified-by="" timestamp="1510536262150"><title>选择结构</title><children><topics type="attached"><topic id="398nktn164858k0g02ro5hr30l" modified-by="" timestamp="1510536178159"><title>语法结构</title><notes><html><xhtml:p>switch(表达式){</xhtml:p><xhtml:p>	case 常量值:</xhtml:p><xhtml:p>		语句块;</xhtml:p><xhtml:p>		【break;】</xhtml:p><xhtml:p>	case 常量值:</xhtml:p><xhtml:p>		语句块;</xhtml:p><xhtml:p>		【break;]</xhtml:p><xhtml:p>	....</xhtml:p><xhtml:p>	【</xhtml:p><xhtml:p>	default:</xhtml:p><xhtml:p>		语句块;</xhtml:p><xhtml:p>		【break;】</xhtml:p><xhtml:p>	】</xhtml:p><xhtml:p>}</xhtml:p></html><plain>switch(表达式){&#13;
	case 常量值:&#13;
		语句块;&#13;
		【break;】&#13;
	case 常量值:&#13;
		语句块;&#13;
		【break;]&#13;
	....&#13;
	【&#13;
	default:&#13;
		语句块;&#13;
		【break;】&#13;
	】&#13;
}</plain></notes></topic><topic id="09q6oislj9hmtdhasv80mm0fbo" modified-by="" timestamp="1510536230338"><title>表达式类型要求</title><children><topics type="attached"><topic id="0erqhps0uthdibrs5tqmumfa1u" modified-by="" timestamp="1510536224632"><title>基本数据类型：byte，short，char，int</title></topic><topic id="3nv79dso966g8jke2novothn40" modified-by="" timestamp="1510536231703"><title svg:width="500">引用数据类型：枚举（JDK1.5之后），String（JDK1.7之后）</title></topic></topics></children></topic><topic id="111irgiae502lu0c3uga3cvesp" modified-by="" timestamp="1510536251907"><title>执行过程</title><children><topics type="attached"><topic id="2mr918ufg17llrre3j047iesh4" modified-by="" timestamp="1510536249200"><title svg:width="500">入口：&#13;
（1）当与某个case匹配&#13;
（2）当与所有case都不匹配，如果有default，从default进入</title></topic><topic id="1ugsmna4grbg6f2jrgsjr3n7rv" modified-by="" timestamp="1510536257995"><title>出口：&#13;
（1）switch结束的}&#13;
（2）break;</title></topic></topics></children></topic><topic id="4lbe66ei4ut14o387pan03ge7d" modified-by="" timestamp="1510536320911"><title>其他要求</title><children><topics type="attached"><topic id="4uoeqrd6tq8efmkbr8qqa77v7d" modified-by="" timestamp="1510536305186"><title>(1)case后面必须是常量或常量表达式</title></topic><topic id="2mn20o3ve6gorvj2ne2vupv4vh" modified-by="" timestamp="1510536320066"><title>(2)所有case后面的值必须不相同</title></topic><topic id="7d0u5qm0qjav8lj2lk8vndhdn6" modified-by="" timestamp="1510536337559"><title>(3)case后面常量值的类型与表达式的类型要一致</title></topic></topics></children></topic></topics></children></topic><topic id="6cou4hernf54de04o1esamf6e7" modified-by="" timestamp="1510536429641"><title>条件判断与选择结构的取舍</title><children><topics type="attached"><topic id="7ghubp251e65enidi1erfj9qnq" modified-by="" timestamp="1510536428669"><title svg:width="500">（1）凡是可以使用switch...case一定可以用if..else代替，凡是反过来不一定</title></topic><topic id="4heu3kn9sda9foosjap77e3sok" modified-by="" timestamp="1510536468352"><title svg:width="500">（2）当所有的条件判断是“常量的等值判断”，那么建议使用switch...case，可读性更好，效率更高</title></topic></topics></children></topic></topics></children></topic><topic id="393f5k4ghn8cibf226089sj2i9" modified-by="" timestamp="1510622366690"><title>循环结构</title><children><topics type="attached"><topic id="2fp48m8r052a33nhn74diqqggq" modified-by="" timestamp="1510622498871"><title>1、for循环</title><children><topics type="attached"><topic id="4mf2rgdpqnuaets2m6p17vnnd5" modified-by="" timestamp="1510622293467"><title>语法结构</title><children><topics type="attached"><topic id="1hkdm084gdt4hb2b2r7nmtm7ij" modified-by="" timestamp="1510622396642"><title>for(初始化表达式①;  循环条件②;  迭代表达式④){&#13;
	循环体语句（要重复的代码）③&#13;
}</title></topic></topics></children></topic><topic id="683sri9oe7t4bl0fv4ncvo7p5c" modified-by="" timestamp="1510622492112"><title>执行的过程</title><children><topics type="attached"><topic id="45kjuq216aj4nrove3gvgthmlt" modified-by="" timestamp="1510622413612"><title>（1）初始化表达式①</title></topic><topic id="4bs2n1lh34s4epnf5fv8v7kt1i" modified-by="" timestamp="1510622423302"><title>（2）循环条件的判断②</title></topic><topic id="20iieoi8m3bmj2qm0l3kg9kdor" modified-by="" timestamp="1510622444208"><title>（3）如果条件成立，执行循环体语句③一次</title></topic><topic id="65f1crsd002dfcq5ginodatmtl" modified-by="" timestamp="1510622454292"><title>（4）迭代表达式④</title></topic><topic id="4f0oabk9tc5lhaoooc74q2amt3" modified-by="" timestamp="1510622490855"><title svg:width="500">（5）回到（2），直到循环条件不成立，结束for循环</title></topic></topics></children></topic><topic id="4aph2udeoimcvfkou9j6uiuh8o" modified-by="" timestamp="1510622561415"><title>注意</title><children><topics type="attached"><topic id="71sii5t3f42pg8v5ks8vtvgsu3" modified-by="" timestamp="1510622519109"><title svg:width="500">（1）for(;;)中两个分号不可以省略，但是表达式可以省略</title></topic><topic id="6op7oj30r6c1agiih00ch50s37" modified-by="" timestamp="1510622554683"><title svg:width="500">（2）适用于起始条件和终止条件明确，循环次数比较明显的情况</title></topic></topics></children></topic></topics></children></topic><topic id="3novnp6ehovd5ieovr1088dbn5" modified-by="" timestamp="1510622634183"><title>2、while循环</title><children><topics type="attached"><topic id="1fideunc21bvalcqcadqnpfba9" modified-by="" timestamp="1510622590719"><title>语法结构</title><children><topics type="attached"><topic id="1oua6rnbqrhioujhpt8nbme7r3" modified-by="" timestamp="1510622592108"><title>while(循环条件){&#13;
	循环体语句;&#13;
}</title></topic></topics></children></topic><topic id="02hiqsvhcmvmokrfecfnmkg3vb" modified-by="" timestamp="1510622632687"><title>执行过程</title><children><topics type="attached"><topic id="7pt97kdrrcki4a1i72qama1j8n" modified-by="" timestamp="1510622603838"><title>（1）循环条件判断</title></topic><topic id="5lpf763rasi4jgpggjvv676ar9" modified-by="" timestamp="1510622612855"><title>（2）如果条件成立，执行循环体语句一次</title></topic><topic id="4i18hoqi0a4g8o056d36kavtpu" modified-by="" timestamp="1510622630384"><title svg:width="500">（3）回到（1），直到循环条件不成立，结束while循环</title></topic></topics></children></topic><topic id="0mnme2dv4co6o07bsqjr0bnk7i" modified-by="" timestamp="1510622648372"><title>注意</title><children><topics type="attached"><topic id="7dcc113st409897jva0sghg54h" modified-by="" timestamp="1510622647402"><title>（1）循环条件明显，次数不明显</title></topic><topic id="1b0c5tmjs9msf5gl7c8u7kh5mo" modified-by="" timestamp="1510622673778"><title>（2）经常这样使用while(true)  和 break 结合</title></topic></topics></children></topic></topics></children></topic><topic id="566k8gsjmlu04o08tdec4kd5g9" modified-by="" timestamp="1510622795909"><title>3、do..while循环</title><children><topics type="attached"><topic id="2tun6nsvduqt8lkocsanlmocmv" modified-by="" timestamp="1510622723098"><title>语法结构</title><children><topics type="attached"><topic id="4au0pea35bguse2mropn9qc69h" modified-by="" timestamp="1510622724350"><title>do{&#13;
	循环体语句;&#13;
}while(循环条件);</title></topic></topics></children></topic><topic id="44ni0fkrlh3ehe5ul5cbvl56m0" modified-by="" timestamp="1510622794274"><title>执行过程</title><children><topics type="attached"><topic id="79a5qkuhe96aagqu41m30bh3bf" modified-by="" timestamp="1510622743830"><title>（1）先执行一次循环体语句</title></topic><topic id="3giq8piu0u5mri3th4p1iqveuc" modified-by="" timestamp="1510622757846"><title>（2）再判断循环条件，是否继续下一次</title></topic><topic id="37nc7k2ham5oqitl2btbriht85" modified-by="" timestamp="1510622772434"><title>（3）如果循环条件成立，执行下一次循环体语句</title></topic><topic id="2fl039fjmto7bi15gdldid3vke" modified-by="" timestamp="1510622791376"><title svg:width="500">（4）回到（2），直到循环条件不成立，结束do..while</title></topic></topics></children></topic><topic id="17851dlmm6g3pee9t5ucsobb79" modified-by="" timestamp="1510622800392"><title>注意</title><children><topics type="attached"><topic id="64jcf5989j7nvekolbg3du9mes" modified-by="" timestamp="1510622811101"><title>（1）和while的最大区别，至少执行一次</title></topic></topics></children></topic></topics></children></topic><topic id="3o34tkfrtmuggu40asnhirb15q" modified-by="" timestamp="1510622283699"><title>4、foreach</title></topic><topic id="6ptc7uphhmk4uhoi5kb7bcc8m2" modified-by="" timestamp="1510622920972"><title>5、嵌套</title><children><topics type="attached"><topic id="4k5lh3gu0mvvu5ng5uojam9hto" modified-by="" timestamp="1510622885545"><title svg:width="500">（1）无论哪种循环，循环中都可以嵌套任一种循环结构</title></topic><topic id="3tbfkq7ls447pv61tln25h1sd6" modified-by="" timestamp="1510622928612"><title>（2）执行过程</title><children><topics type="attached"><topic id="2aqhtia2cs3hpperi0v174k8co" modified-by="" timestamp="1510622943195"><title>外循环循环一次，内循环循环一轮</title></topic></topics></children></topic></topics></children></topic><topic id="26cnot7relsak7ijie3mfhk7id" modified-by="" timestamp="1510622364775"><title>作用：重复执行某些代码</title></topic></topics></children></topic><topic id="4dsgigrt05dad6njjc81fr0j9n" modified-by="" timestamp="1510622975475"><title>跳转、中断</title><children><topics type="attached"><topic id="2vnkbvut8iod7p0cn7kuhu4237" modified-by="" timestamp="1510623570779"><title>1、break</title><children><topics type="attached"><topic id="5mm21iov6mrpvpbs2gotj3vpee" modified-by="" timestamp="1510623000410"><title>可以适用于switch和循环</title></topic><topic id="53sqsb75kvm4ovossukc4ik0nq" modified-by="" timestamp="1510623578727"><title>默认表示结束当层循环或switch</title></topic><topic id="12msqpda8i47rdr5gjori8lt56" modified-by="" timestamp="1510623595880"><title>break 标签;</title><children><topics type="attached"><topic id="6c4jot3l2k2ok8r2lga6k6hlb9" modified-by="" timestamp="1510623595831"><title>表示结束指定的循环</title></topic><topic id="6379c9lifgdhusu5dp4n0i3cra" modified-by="" timestamp="1510623640522"><title>标签:循环</title><notes><html><xhtml:p>		out_label:for(int i = 1; i&lt;=5; i++){</xhtml:p><xhtml:p>			inner_label:while(true){</xhtml:p><xhtml:p>				System.out.println("请输入数字：");</xhtml:p><xhtml:p>				int num = input.nextInt();</xhtml:p><xhtml:p>				</xhtml:p><xhtml:p>				if(num&gt;0){</xhtml:p><xhtml:p>					positive ++;</xhtml:p><xhtml:p>				}else if(num&lt;0){</xhtml:p><xhtml:p>					negative++;</xhtml:p><xhtml:p>				}else{</xhtml:p><xhtml:p>					//break;//结束的是while内层循环</xhtml:p><xhtml:p>					break out_label;</xhtml:p><xhtml:p>					//break inner_label;</xhtml:p><xhtml:p>				}</xhtml:p><xhtml:p>			}</xhtml:p><xhtml:p>	}</xhtml:p></html><plain>		out_label:for(int i = 1; i&lt;=5; i++){&#13;
			inner_label:while(true){&#13;
				System.out.println("请输入数字：");&#13;
				int num = input.nextInt();&#13;
				&#13;
				if(num&gt;0){&#13;
					positive ++;&#13;
				}else if(num&lt;0){&#13;
					negative++;&#13;
				}else{&#13;
					//break;//结束的是while内层循环&#13;
					break out_label;&#13;
					//break inner_label;&#13;
				}&#13;
			}&#13;
	}</plain></notes></topic></topics></children></topic></topics></children></topic><topic id="5nagcvg89ubh5dgqmsq3jq4jp8" modified-by="" timestamp="1510623031391"><title>2、continue</title><children><topics type="attached"><topic id="4bn3icuu452u1oqc6cku1sb4hg" modified-by="" timestamp="1510623016603"><title>只能用于循环</title></topic><topic id="1hsibf0c98j3n1g9v8svpdaccs" modified-by="" timestamp="1510623040494"><title>表示提前结束当层本次循环，进入下一次循环</title></topic></topics></children></topic><topic id="6setd91jjlis2slslrkrjvhp9r" modified-by="" timestamp="1510623645448"><title>3、return</title><children><topics type="attached"><topic id="7k257g2lcoqpo2batqibj5pick" modified-by="" timestamp="1510623652710"><title>结束当前方法</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><title>流程控制语句结构</title></sheet><sheet id="78fe7jm876cepvkj2edulh9vd8" modified-by="" style-id="0uerjbajt0v4fkcicm3ffhcnu3" theme="xminddefaultthemeid" timestamp="1510709431650"><topic id="2u4klge7kk87a9scj0q0du0fpa" modified-by="" structure-class="org.xmind.ui.logic.right" timestamp="1510709289350"><title>方法</title><extensions><extension provider="org.xmind.ui.map.unbalanced"><content><right-number>-1</right-number></content></extension></extensions><children><topics type="attached"><topic id="209b148tg6tk745kfipkde2mn2" modified-by="" timestamp="1510708072735"><title svg:width="500">方法(Method)：又称为函数（Function），代表一个独立功能，目的为了代码重用</title></topic><topic id="18iho51qbcpilljbtg0c4k4b46" modified-by="" timestamp="1510708179699"><title>声明的格式</title><children><topics type="attached"><topic id="539rsqid78g2neemevveooqadf" modified-by="" timestamp="1510708169266"><title svg:width="500">【修饰符列表】 返回值类型  方法名（【形参列表】）【抛出异常列表】{&#13;
		方法体，方法功能的实现代码;&#13;
		【return  【返回值】;】&#13;
}</title></topic><topic id="6f5t6plccquque8a5cflkuvqra" modified-by="" timestamp="1510708269301"><title>四种形式</title><children><topics type="attached"><topic id="5tcu30uoho4n925rv2nj8s6svb" modified-by="" timestamp="1510708216709"><title>1、无参无返回值</title><children><topics type="attached"><topic id="2i4kiaa03kvhpd4oo86c1htp3f" modified-by="" timestamp="1510708211171"><title>[修饰符列表] void 方法名()[抛出的异常列表]{&#13;
	方法体;&#13;
}</title></topic><topic id="3d0lvhikt907t4o87jak4uol30" modified-by="" timestamp="1510708218256"><title>public static void 方法名(){&#13;
	方法体;&#13;
}</title></topic></topics></children></topic><topic id="2eq3p2bh2odlogsdmg6u76sfii" modified-by="" timestamp="1510708242828"><title>2、有参无返回值</title><children><topics type="attached"><topic id="1l54e60c28dg4gb8ecfvbvftrj" modified-by="" timestamp="1510708241909"><title svg:width="500">[修饰符列表] void 方法名(形参列表)[抛出的异常列表]{&#13;
	方法体;&#13;
}</title></topic><topic id="292h7nvvis2570m6jd1rpibrvm" modified-by="" timestamp="1510708244172"><title>public static void 方法名(形参列表){&#13;
	方法体;&#13;
}</title></topic></topics></children></topic><topic id="5repav8ss3o91r239i14ogpn68" modified-by="" timestamp="1510708265955"><title>3、无参有返回值</title><children><topics type="attached"><topic id="1bun970h1nni13rettvr9fv2a7" modified-by="" timestamp="1510708265049"><title svg:width="500">[修饰符列表] 返回值类型 方法名()[抛出的异常列表]{&#13;
	方法体;&#13;
}</title></topic><topic id="2aqieqir41tgfvdfsekfvvm4sg" modified-by="" timestamp="1510708267483"><title>public static 返回值类型 方法名(){&#13;
	方法体;&#13;
	return 返回值;&#13;
}</title></topic></topics></children></topic><topic id="5vnsp14g3v3ua9t4m13vud1rm4" modified-by="" timestamp="1510708287059"><title>4、有参有返回值</title><children><topics type="attached"><topic id="2ejdhn3g66ggfjvcrfjif942m5" modified-by="" timestamp="1510708280890"><title svg:width="500">[修饰符列表] 返回值类型 方法名(形参列表)[抛出的异常列表]{&#13;
	方法体;&#13;
}</title></topic><topic id="1noavksbhs6oo2l4rb9ftfjtt4" modified-by="" timestamp="1510708288450"><title>public static 返回值类型 方法名(形参列表){&#13;
	方法体;&#13;
	return 返回值;&#13;
}</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="6sb0r4fp1crqtjouc4c9fat58g" modified-by="" timestamp="1510708597373"><title>调用格式</title><children><topics type="attached"><topic id="55ihcioom34c067pjdqi2qj50b" modified-by="" timestamp="1510708595098"><title>本类中</title><children><topics type="attached"><topic id="0cc6gcd9b005fm5ni2555po0gn" modified-by="" timestamp="1510708514464"><title>不需要在方法名前面加前缀</title></topic></topics></children></topic><topic id="43u47sfg76jv5cre0g7o6evu6i" modified-by="" timestamp="1510708497777"><title>其他类中</title><children><topics type="attached"><topic id="1efhaj9e5e1kqi2hua9p0c9p6a" modified-by="" timestamp="1510708537833"><title>需要在方法名前面加前缀</title><children><topics type="attached"><topic id="0q2fo4r2j60hg93ior7t6ig8cr" modified-by="" timestamp="1510708562620"><title>如果被调用的方法是static</title><children><topics type="attached"><topic id="2hst712geb8nri4fbatjfiep55" modified-by="" timestamp="1510708536178"><title>前缀是 类名.</title></topic><topic id="67geh3pf5v1gkph005c8qhq7u9" modified-by="" timestamp="1510708571442"><title>类名.方法名</title></topic></topics></children></topic><topic id="11qk4tocnp78v5hi1dsvn1r6q7" modified-by="" timestamp="1510708571755"><title>如果被调用的方法是非static</title><children><topics type="attached"><topic id="5hpr1nm2hsiroq5r4kb081gugd" modified-by="" timestamp="1510708560959"><title>前缀是  对象名.</title></topic><topic id="7401lvqtato68gch0rtlsfsi9r" modified-by="" timestamp="1510708575870"><title>对象名.方法名</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="1c3rrh0gjj996n65j6cooprjb1" modified-by="" timestamp="1510708375603"><title svg:width="500">不管是本类中还是其他类中，对于方法签名的关注点是一样：</title><children><topics type="attached"><topic id="30sfo16tnvfvi63lrchd6fp2a1" modified-by="" timestamp="1510708372883"><title svg:width="500">【修饰符列表】 返回值类型  方法名（【形参列表】）【抛出异常列表】</title></topic><topic id="1sc64h1uuf5dciuteq0lcl5ogr" modified-by="" timestamp="1510708385685"><title>目前</title><children><topics type="attached"><topic id="642lmajv89hap2f77kafj4ooc2" modified-by="" timestamp="1510708421695"><title>有无形参列表</title><children><topics type="attached"><topic id="0vefn5vs03iat1jua8jv55o19h" modified-by="" timestamp="1510708420413"><title svg:width="500">如果有形参，调用是必须传实参，而且实参的个数与形参的个数一致，类型兼容</title></topic><topic id="109gc2bu8qh22gpvrm67lh2n9g" modified-by="" timestamp="1510708432864"><title>如果没有形参，调用是也不用传实参</title></topic></topics></children></topic><topic id="7fol1m8dnof4h3qa5llnbk9du2" modified-by="" timestamp="1510708453244"><title>有无返回值</title><children><topics type="attached"><topic id="2i5uq8n0vb78gnkvc3pum6omq6" modified-by="" timestamp="1510708452327"><title>如果有返回值，调用时就可以接受</title></topic><topic id="2tdrdbhn1070n2dt35tln2aj73" modified-by="" timestamp="1510708478069"><title svg:width="500">如果无返回值，调用时不能用变量接收，只能单独成一个语句</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="05ffb1p7ddqkd42j2rs64i6b2c" modified-by="" timestamp="1510708735230"><title>四种形式</title><children><topics type="attached"><topic id="00vspfmarefomt8fsoaht07gos" modified-by="" timestamp="1510708635007"><title>1、无参无返回值</title><children><topics type="attached"><topic id="6dfab6itkj2paq499kav7h6u4g" modified-by="" timestamp="1510708634125"><title>本类中</title><children><topics type="attached"><topic id="5ssl58u7kl335bi4u76r4ckukt" modified-by="" timestamp="1510708634090"><title>方法名();</title><children><topics type="attached"><topic id="31kfmsdrnn6m1t92itap336ohv" modified-by="" timestamp="1510708618664"><title>单独一个语句</title></topic></topics></children></topic></topics></children></topic><topic id="3njfocjmb0otvrdkfhuo691j4i" modified-by="" timestamp="1510708647925"><title>其他类中</title><children><topics type="attached"><topic id="0jfvfa7bs20c03urtv2i6jverk" modified-by="" timestamp="1510708646117"><title>类名.方法名();</title><children><topics type="attached"><topic id="6dgp9guuhfk51no1otpgp09e0t" modified-by="" timestamp="1510708618664"><title>单独一个语句</title></topic></topics></children></topic><topic id="2bhpqbl977iik1mqfrsqr9eqkb" modified-by="" timestamp="1510708653485"><title>对象名.方法名();</title><children><topics type="attached"><topic id="0cpiofh3ebgmq75ubp8df6ls5g" modified-by="" timestamp="1510708618664"><title>单独一个语句</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="2pprugk60m9ssf0ojd8cb6jemk" modified-by="" timestamp="1510708670195"><title>2、有参无返回值</title><children><topics type="attached"><topic id="68fbkq2uvur1bgdvamg3gmj712" modified-by="" timestamp="1510708670091"><title>本类中</title><children><topics type="attached"><topic id="44ssq4cql67dqhbslbf5mv9gp9" modified-by="" timestamp="1510708679301"><title>方法名(实参列表);</title><children><topics type="attached"><topic id="098lnrmn6huj8v8nek99bl84r8" modified-by="" timestamp="1510708618664"><title>单独一个语句</title></topic></topics></children></topic></topics></children></topic><topic id="481t6a2c7g8jqsp7gt8geh2if3" modified-by="" timestamp="1510708670091"><title>其他类中</title><children><topics type="attached"><topic id="361b34fbf9hvqe8f5hqf0g2gln" modified-by="" timestamp="1510708681553"><title>类名.方法名(实参列表);</title><children><topics type="attached"><topic id="0tb5h7v3sbfc92424j6k07co01" modified-by="" timestamp="1510708618664"><title>单独一个语句</title></topic></topics></children></topic><topic id="2vo88pforobdbt2295rv4jt80b" modified-by="" timestamp="1510708683782"><title>对象名.方法名(实参列表);</title><children><topics type="attached"><topic id="40g501d5197n0a8jii8fmkjvnn" modified-by="" timestamp="1510708618664"><title>单独一个语句</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="6nc5r30o1jtmdm7qv2ujmvm7q8" modified-by="" timestamp="1510708711034"><title>3、无参有返回值</title><children><topics type="attached"><topic id="058stembnes912bo3flp19t0pt" modified-by="" timestamp="1510708710956"><title>本类中</title><children><topics type="attached"><topic id="7q6a6k9d24rhlpg9fu4pt0i4sn" modified-by="" timestamp="1510708790647"><title>变量 = 方法名();</title><children><topics type="attached"><topic id="3g9vv1calhsojikb9s2jmsucsh" modified-by="" timestamp="1510708789530"><title>方法的调用作为表达式</title></topic><topic id="1mpcj4botuuhp615bcj79ltcop" modified-by="" timestamp="1510708801931"><title>把方法调用的返回值赋值给变量</title></topic></topics></children></topic></topics></children></topic><topic id="5ura5qec4ck2cj6q4m9svh35hi" modified-by="" timestamp="1510708710956"><title>其他类中</title><children><topics type="attached"><topic id="5q6u7ounlvqq6falp044mfd944" modified-by="" timestamp="1510708811396"><title>变量 = 类名.方法名();</title><children><topics type="attached"><topic id="0pvhl5c3dl1ouhpgkaq2hvqp1v" modified-by="" timestamp="1510708811370"><title>方法的调用作为表达式</title></topic><topic id="619po05b3oko82904favt0vlmh" modified-by="" timestamp="1510708811370"><title>把方法调用的返回值赋值给变量</title></topic></topics></children></topic><topic id="28qp7ms1t39nhqgjei9ur1ev3s" modified-by="" timestamp="1510708812702"><title>变量 = 对象名.方法名();</title><children><topics type="attached"><topic id="7914qusrc5njobpst9p1u5u021" modified-by="" timestamp="1510708812659"><title>方法的调用作为表达式</title></topic><topic id="2hg9njh90k7v74tm87mo64hvmo" modified-by="" timestamp="1510708812659"><title>把方法调用的返回值赋值给变量</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="14rj4scd2m237qk402gsom390o" modified-by="" timestamp="1510708746964"><title>4、有参有返回值</title><children><topics type="attached"><topic id="2tg2uk08lqomb8vb13a84p74uq" modified-by="" timestamp="1510708746879"><title>本类中</title><children><topics type="attached"><topic id="56lmejhoeidclk31mbg7pciqi4" modified-by="" timestamp="1510708813755"><title>变量 = 方法名(实参列表);</title><children><topics type="attached"><topic id="6aho7ujr16p273rvap6lp9a7r1" modified-by="" timestamp="1510708813720"><title>方法的调用作为表达式</title></topic><topic id="0sdvv74edbud36vloefi954hgu" modified-by="" timestamp="1510708813720"><title>把方法调用的返回值赋值给变量</title></topic></topics></children></topic></topics></children></topic><topic id="4h58i8rscib2rgclfgma7lsd2d" modified-by="" timestamp="1510708746879"><title>其他类中</title><children><topics type="attached"><topic id="3suart6lfrj49iitap12lpuo90" modified-by="" timestamp="1510708814976"><title>变量 = 类名.方法名(实参列表);</title><children><topics type="attached"><topic id="19nmtj6b4310b0nmss2ngdfp1k" modified-by="" timestamp="1510708814942"><title>方法的调用作为表达式</title></topic><topic id="2hphqlhafo7gvo6vlrsc9sqaeq" modified-by="" timestamp="1510708814942"><title>把方法调用的返回值赋值给变量</title></topic></topics></children></topic><topic id="7432r8savqtiqfce4kv8tfbpfe" modified-by="" timestamp="1510708816765"><title>变量 = 对象名.方法名(实参列表);</title><children><topics type="attached"><topic id="0o3cv039joah0d8fumh0c14vn3" modified-by="" timestamp="1510708816717"><title>方法的调用作为表达式</title></topic><topic id="06nfgd2hd7rm10oaflft4s6grt" modified-by="" timestamp="1510708816717"><title>把方法调用的返回值赋值给变量</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="5ijo11ntbtsa6oul2e76hs2cjj" modified-by="" timestamp="1510709267412"><title>方法的参数传递机制</title><children><topics type="attached"><topic id="15icsvsib85bdmk8qaffluh01k" modified-by="" timestamp="1510709212530"><title>形参的类型是基本数据类型</title><children><topics type="attached"><topic id="5hgk7jvc6u16lhavlsr71rfv0l" modified-by="" timestamp="1510709219991"><title>值传递机制</title><children><topics type="attached"><topic id="0q02db21fifdo6i3tq7dlij60o" modified-by="" timestamp="1510709233336"><title>形参的修改是不会影响实参</title></topic></topics></children></topic></topics></children></topic><topic id="6447cku1cl5jnqm3lvjs0qm72k" modified-by="" timestamp="1510709278190"><title>形参的类型是引用数据类型</title><children><topics type="attached"><topic id="2hmfcqo8ihq0oshdfdapvotd2d" modified-by="" timestamp="1510709279961"><title>？</title></topic></topics></children></topic></topics></children></topic><topic id="4fpi725ekd0h20nn41kau7vaob" modified-by="" timestamp="1510709339947"><title>方法的重载Overload</title><children><topics type="attached"><topic id="0o6i5u55q7r6kkv87jqaqei6jo" modified-by="" timestamp="1510709425685"><title>概念</title><children><topics type="attached"><topic id="1u2997nffrvk1ve21c0elccbqo" modified-by="" timestamp="1510709387819"><title svg:width="500">在同一个类中，方法名相同，形参列表不同的两个或多个方法构成方法的重载</title></topic><topic id="7ck53qqrr1e381lqdfr93lj67m" modified-by="" timestamp="1510709431650"><title>和返回值类型无关</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><title>方法</title></sheet><sheet id="6lgaqelsl7vahaqga4b8v9t2n0" modified-by="" style-id="4cvokp6eo22cm3100r95ohtobs" theme="xminddefaultthemeid" timestamp="1539745484340"><topic id="38p178imlngv6oeg71qrap62ko" modified-by="" structure-class="org.xmind.ui.logic.right" timestamp="1511316240491"><title>面向对象</title><extensions><extension provider="org.xmind.ui.map.unbalanced"><content><right-number>-1</right-number></content></extension></extensions><children><topics type="attached"><topic id="7vqmkooiolif9nkr53r35g9vgv" modified-by="" timestamp="1510969245046"><title>面向对象和面向过程的区别</title><children><topics type="attached"><topic id="5jp6s924bksm0io5aoi9ucl552" modified-by="" timestamp="1510969231995"><title>都是编程思想</title></topic><topic id="7qf6he5midsicdvqn2n0rlkvpi" modified-by="" timestamp="1510969269336"><title>面向过程注重过程，步骤，怎么做</title><children><topics type="attached"><topic id="7obu1vh5vk4sl11uu6r29prv67" modified-by="" timestamp="1510969272655"><title>执行者</title></topic></topics></children></topic><topic id="1qfh4n64it1d8fhb828bvuc00h" modified-by="" timestamp="1510969264718"><title>面向对象注重对象，谁来做</title><children><topics type="attached"><topic id="7g5v275uhha0okvtdg8vupfpud" modified-by="" timestamp="1510969285674"><title>指挥者</title></topic></topics></children></topic></topics></children></topic><topic branch="folded" id="0b6hlirrehqa8udkp75uo07e1n" modified-by="" timestamp="1539745484340"><title>面向对象学习</title><children><topics type="attached"><topic id="486r5icrc8qi15at1k55itbbmi" modified-by="" timestamp="1510969400584"><title>1、类与对象</title><children><topics type="attached"><topic id="08naed3otb3nem8rb99a537e31" modified-by="" timestamp="1510969378876"><title>（1）类与对象的概念</title></topic><topic id="1e7r4366h51gg4nqfp1h4thavm" modified-by="" timestamp="1510969385448"><title>（2）类与对象的关系</title></topic><topic id="0tnjk3ojt5tua1fhj9aj3ogpl0" modified-by="" timestamp="1510969399778"><title>（3）如何设计类，类的成员</title></topic><topic id="75p12ljfr4jhnl4jo1grnie0af" modified-by="" timestamp="1510969407156"><title>（4）如何创建对象</title></topic></topics></children></topic><topic id="3meal99au70ic6ea5gq6s6b1re" modified-by="" timestamp="1510969443984"><title>2、面向对象的三个基本特征和高级特性</title><children><topics type="attached"><topic id="3iu3e90066h9p47gfqi3hj7erv" modified-by="" timestamp="1510969453306"><title>基本特性</title><children><topics type="attached"><topic id="478c4qhobph4lt9heinp64a5hs" modified-by="" timestamp="1510969450839"><title>封装</title></topic><topic id="3mlcn5efguqumctbgscnj2ft0p" modified-by="" timestamp="1510969453022"><title>继承</title></topic><topic id="0s10erkmuh1maq7dhff9hkg5g1" modified-by="" timestamp="1510969455798"><title>多态</title></topic></topics></children></topic><topic branch="folded" id="4h0tlsaa6ad0egbdqlhg05t9eo" modified-by="" timestamp="1510969523287"><title>高级特性</title><children><topics type="attached"><topic id="2ov40f939vd7gs386p24jj95f0" modified-by="" timestamp="1510969465642"><title>枚举</title></topic><topic id="443u4opatfo2bbt3apcr58nkgh" modified-by="" timestamp="1510969469737"><title>接口</title></topic><topic id="7nfhdarg2tsrstsh65arj2lge4" modified-by="" timestamp="1510969472189"><title>抽象</title></topic><topic id="6cjgdp8ouga2qcp914iol3aja2" modified-by="" timestamp="1510969476162"><title>泛型</title></topic><topic id="7vslliho62empnag0ogeku934u" modified-by="" timestamp="1510969479908"><title>注解</title></topic><topic id="039lt9kcpmbuqpcou0ehs0km3h" modified-by="" timestamp="1510969485113"><title>可变参数</title></topic><topic id="0bpfk2e0qhbhiq799ht34724of" modified-by="" timestamp="1510969494107"><title>自动装箱与拆箱</title></topic><topic id="45gncr7juapf8eihn508ru0pgr" modified-by="" timestamp="1510969502595"><title>foreach</title></topic><topic id="5c86uap75vpbhjg2savmvfnitj" modified-by="" timestamp="1510969516664"><title>Lambda表达式</title></topic><topic id="50g837eelg011e7o10nqk096vb" modified-by="" timestamp="1510969519088"><title>.....</title></topic></topics></children></topic></topics></children></topic><topic id="730c45en9p6s5bhvhcpr8gv61t" modified-by="" timestamp="1510969596816"><title>3、相关的关键字和API</title><children><topics type="attached"><topic id="07ok66sa7dcttraphc48am9tml" modified-by="" timestamp="1510969596033"><title>关键字</title><children><topics type="attached"><topic id="2sbtsmedigvauhgvf63mtdifd3" modified-by="" timestamp="1510969592250"><title>class</title></topic><topic id="3otdtujqikfo8c9mefnekk9nqt" modified-by="" timestamp="1510969592260"><title>new</title></topic><topic id="21r357benf6fnd3n44khguokho" modified-by="" timestamp="1510969592275"><title>this</title></topic><topic id="3afq88sfd51c6plfoghpfrngo0" modified-by="" timestamp="1510969592291"><title>权限修饰符</title><children><topics type="attached"><topic id="0q37n8i2p90nnari5t10edkcas" modified-by="" timestamp="1510969552166"><title>public</title></topic><topic id="4vl38p0oqa1mqpnbkuaq2ieahc" modified-by="" timestamp="1510969556375"><title>protected</title></topic><topic id="5m6ibi2623s2rtore9uk8i6bhc" modified-by="" timestamp="1510969559408"><title>缺省</title></topic><topic id="09ds2p9i419nqeu66fc8au9prs" modified-by="" timestamp="1510969562249"><title>private</title></topic></topics></children></topic><topic id="7of49ugl33m7vsa1guvdbb5ldp" modified-by="" timestamp="1510969592334"><title>super</title></topic><topic id="4rqtuin2sfpjilu0vet7fh7fgs" modified-by="" timestamp="1510969592355"><title>...</title></topic></topics></children></topic><topic id="3v1a34204gosd4ta1pvk5fovig" modified-by="" timestamp="1510969618063"><title>API</title><children><topics type="attached"><topic id="4rdtq02guhn6r5ktarguik0e7t" modified-by="" timestamp="1510969603720"><title>集合</title></topic><topic id="0ar0uae6akhhj88uec0lru5pif" modified-by="" timestamp="1510969606627"><title>异常</title></topic><topic id="1mcpl58flfjco70tk7ji2oims3" modified-by="" timestamp="1510969609266"><title>IO</title></topic><topic id="56d8ac7t3sth0tgcbbkb69gat9" modified-by="" timestamp="1510969614566"><title>网络编程</title></topic><topic id="40o5ca4eu4v7lr3u4h72clptmm" modified-by="" timestamp="1510969617504"><title>线程</title></topic><topic id="2f0jg92g21chcopc7r2obkl7mm" modified-by="" timestamp="1510969620263"><title>....</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic branch="folded" id="306fnpuq0v5iliclk2bl048t8n" modified-by="" timestamp="1539745478129"><title>1、类与对象</title><children><topics type="attached"><topic id="06ij68q4i1d7sju6rtn4ki87mi" modified-by="" timestamp="1510969673025"><title>(1)类与对象的概念</title><children><topics type="attached"><topic id="25ns0m76o47sms8c7d05shjitl" modified-by="" timestamp="1510969672116"><title>类：对一类具有相同特征的事物的抽象描述</title></topic><topic id="6qh30ftjeuru0m1ctj838iukln" modified-by="" timestamp="1510969683039"><title>对象：类的实例，是具体的个体</title></topic></topics></children></topic><topic id="49q9lm06s2lh1geojas6kp1k6l" modified-by="" timestamp="1510969708344"><title>(2)类与对象的关系</title><children><topics type="attached"><topic id="0gu0euiahhs71fsr3kr008miql" modified-by="" timestamp="1510969706627"><title>类是对象的设计图，创建的模板</title></topic><topic id="35srakdi66c1js4446cpnlthim" modified-by="" timestamp="1510969724601"><title>对象是类的实例，是一个具体的个体</title></topic></topics></children></topic><topic id="21reh5g7692chiguqg09t2709r" modified-by="" timestamp="1511829561557"><title>(3)类的设计，成员</title><children><topics type="attached"><topic id="71f2cfk7vs935sanh4okkmbjce" modified-by="" timestamp="1510969916821"><title>（1）属性</title><children><topics type="attached"><topic id="4ecotof3ru7e20k60drs0kcia1" modified-by="" timestamp="1510969874025"><title>属性的特点</title><children><topics type="attached"><topic id="5v14m920essmntejbv7fa2vkj0" modified-by="" timestamp="1510969795984"><title>（1）声明的位置</title><children><topics type="attached"><topic id="7gq6s18u26402h5hcqvitd2i0v" modified-by="" timestamp="1510969800751"><title>在类中方法外</title></topic></topics></children></topic><topic id="6q01gstict6qckcl64tca1mt8d" modified-by="" timestamp="1510969819291"><title>（2）保存的位置</title><children><topics type="attached"><topic id="6d0clcldv5isb8tf1sq8ke5qgg" modified-by="" timestamp="1510969836522"><title>static</title><children><topics type="attached"><topic id="3v72g7hcdopn7lu30c5uf6nmpm" modified-by="" timestamp="1510969839685"><title>在方法区</title></topic></topics></children></topic><topic id="7qkt945u3s7qluj8ssknraoev9" modified-by="" timestamp="1510969829943"><title>非static</title><children><topics type="attached"><topic id="740q8m52evj4udc8ctplfqq11i" modified-by="" timestamp="1510969834017"><title>在堆中</title></topic></topics></children></topic></topics></children></topic><topic id="7js439gte460v7mbigefgsd9gb" modified-by="" timestamp="1510969858532"><title>（3）默认值</title><children><topics type="attached"><topic id="50djossk6kafpr804glkdembgn" modified-by="" timestamp="1510969859747"><title svg:width="500">byte,short,int,long是0，float,double是0.0，boolean是false，char是\u0000，引用数据类型都是null</title></topic></topics></children></topic><topic id="32575f68vb4uggji7ol0b50ljv" modified-by="" timestamp="1510969868471"><title>（4）作用域</title><children><topics type="attached"><topic id="0lsgcmqql4qma18foupf6hbut2" modified-by="" timestamp="1510969873140"><title>在整个类中</title></topic></topics></children></topic><topic id="2rlffo9c2q8somuba9dbu538dt" modified-by="" timestamp="1510969881924"><title>（5）生命周期</title><children><topics type="attached"><topic id="4sq0rfch61hbf5948d6joi5v0p" modified-by="" timestamp="1510969913149"><title>随着对象的创建而创建，到垃圾回收为止</title></topic></topics></children></topic></topics></children></topic><topic id="2ecg7cobf58kv86fv73aipmt0j" modified-by="" timestamp="1510969923308"><title>属性声明格式</title><children><topics type="attached"><topic id="3mm8ijkmm9oqk6g796mg7tqah1" modified-by="" timestamp="1510969950430"><title>[修饰符]  数据类型  属性名 【=显式值】; </title><children><topics type="attached"><topic id="3dgeqnk78iuh57omb1r2rf1niv" modified-by="" timestamp="1510969956857"><title>修饰符</title><children><topics type="attached"><topic id="774hj97mjjr3bemh9r7a43ht40" modified-by="" timestamp="1510969960254"><title>private</title><children><topics type="attached"><topic id="1hfun1vuuot6mndedlsvl8f6tk" modified-by="" timestamp="1510969966379"><title>私有化</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="0b9avo6ih7d3r8vm4vovbjv6l3" modified-by="" timestamp="1510970103252"><title>（2）构造器</title><children><topics type="attached"><topic id="5pnas4q9jjp049k6nhqc83knbh" modified-by="" timestamp="1510970002277"><title>构造器的作用</title><children><topics type="attached"><topic id="6j76ml3chb86hv2u1eh26tjvek" modified-by="" timestamp="1510970001017"><title>（1）和new一起创建对象</title></topic><topic id="5pt86eklh7498dim4fgkmiqjc7" modified-by="" timestamp="1510970008282"><title>（2）为属性赋值</title></topic></topics></children></topic><topic id="6k6n8a48qh4vr565ck5c1bs630" modified-by="" timestamp="1510970034013"><title>如何声明</title><children><topics type="attached"><topic id="1p1i859d1061oipv03niu2ku63" modified-by="" timestamp="1510970031700"><title>无参</title><children><topics type="attached"><topic id="3lr99ar8of9us6327oa4vdoejk" modified-by="" timestamp="1510970032884"><title>[修饰符] 类名(){&#13;
}</title></topic></topics></children></topic><topic id="4dcfniifjiaourunjnv5muv8oo" modified-by="" timestamp="1510970040578"><title>有参</title><children><topics type="attached"><topic id="1vp29taud7hlqcls4s1l56g6k3" modified-by="" timestamp="1510970041635"><title>[修饰符] 类名(形参列表){&#13;
}</title></topic></topics></children></topic></topics></children></topic><topic id="4e7ofvi9ukeivdvq8j8t104gfs" modified-by="" timestamp="1510970071611"><title>特点</title><children><topics type="attached"><topic id="3t7ngv2p4t5jkppiljg7232imv" modified-by="" timestamp="1510970091694"><title svg:width="500">构造器的特点：&#13;
（1）构造器名与类名必须相同&#13;
（2）构造器没有返回值&#13;
（3）构造器可以重载&#13;
（4）如果一个类没有声明过构造器，编译器将默认添加一个无参构造&#13;
如果这个类声明了构造器，编译器将不再自动添加无参构造</title></topic></topics></children></topic><topic id="0q44sgelkmf8v7uln3t0a2n4hp" modified-by="" timestamp="1510970155768"><title>如何调用</title><children><topics type="attached"><topic id="5thauu852lnaesrdo1glf05ki4" modified-by="" timestamp="1510970161287"><title>（1）和new一起  </title><children><topics type="attached"><topic id="2jiu6llbbrcebr7m4uttf4o120" modified-by="" timestamp="1510970135268"><title>  new 构造器()&#13;
  new 构造器(实参列表)</title></topic></topics></children></topic><topic id="4h051nnpb2iqor8vf3p873jn2c" modified-by="" timestamp="1510970162730"><title svg:width="500">（2）在本类的其他构造器中或子类的构造器中</title><children><topics type="attached"><topic id="2qinovv8uglem3jedk40o1im01" modified-by="" timestamp="1510970148622"><title>在本类的其他构造器中：this()或this(实参列表)&#13;
在子类的构造器中：super()或super(实参列表)</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="2eabg034823ups92t2gl4hj8v2" modified-by="" timestamp="1510970209829"><title>（3）方法</title><children><topics type="attached"><topic id="2slmrtj4u5v3eepks3nf6jpof9" modified-by="" timestamp="1510970196642"><title>无参无返回值</title></topic><topic id="5113bnis38702ffcc4ni4afpka" modified-by="" timestamp="1510970205025"><title>有参无返回值</title></topic><topic id="45kaq2eqt92jkkv2ghlg6l16kh" modified-by="" timestamp="1510970209570"><title>无参有返回值</title></topic><topic id="2jmof8da0mvlk7i7or0uh6kli1" modified-by="" timestamp="1510970218585"><title>有参有返回值</title></topic></topics></children></topic><topic branch="folded" id="751kar81iolb25bmjnga13ki97" modified-by="" timestamp="1512100351347"><title>（4）代码块</title><children><topics type="attached"><topic id="5vti4fago5hul0ch3ff70h9mo6" modified-by="" timestamp="1511573507975"><title>按位置分</title><children><topics type="attached"><topic id="45lhd9965r887u6u8bsvqhoenh" modified-by="" timestamp="1511573523866"><title>在类中方法外</title><children><topics type="attached"><topic id="3q6ddbvq0rdiqq6a1oaokgspk7" modified-by="" timestamp="1511573552584"><title>是否有static修饰</title><children><topics type="attached"><topic id="4qb94cppg7n0d790hig717ridt" modified-by="" timestamp="1511573672131"><title>有static修饰的：静态代码块</title><children><topics type="attached"><topic id="2padql194iu1j4ra5taoa3oqjl" modified-by="" timestamp="1511573576169"><title>语法结构</title><children><topics type="attached"><topic id="0vn34r3vemmoa76k7q44m6auve" modified-by="" timestamp="1511573604494"><title>class 类{&#13;
	static{&#13;
		静态代码块&#13;
    }&#13;
}</title></topic></topics></children></topic><topic id="07b5kd34pmkkgcm927su1c5at8" modified-by="" timestamp="1511573626225"><title>特点</title><children><topics type="attached"><topic id="2r8if2nonkcj4ejdjfb556878f" modified-by="" timestamp="1511573657096"><title svg:width="500">随着类的加载并初始时而执行，而且一个类的静态代码块只执行一次</title><children><topics type="attached"><topic id="37k19sacbakrms4694shcp24ej" modified-by="" timestamp="1511573655747"><title>而且父类的静态代码块优先于子类的静态代码块</title></topic><topic id="6j1ia5r5g45l7ebh82gusca31j" modified-by="" timestamp="1511573667833"><title>静态代码块肯定优先于构造块和构造器</title></topic></topics></children></topic></topics></children></topic><topic id="02vemqn9rdgftmdacr3nof25e4" modified-by="" timestamp="1511573675124"><title>作用</title><children><topics type="attached"><topic id="0emell9ppdv0j5ej0ifqh86agr" modified-by="" timestamp="1511573688470"><title>为静态变量（类变量）初始化（赋值）</title></topic></topics></children></topic></topics></children></topic><topic id="53rn9et1ihgnbm60hpifu2gsb0" modified-by="" timestamp="1511573711956"><title>没有static修饰的：非静态代码块，构造块</title><children><topics type="attached"><topic id="4kp16ilro7gm9m9j792h1qgvha" modified-by="" timestamp="1511573615272"><title>语法结构</title><children><topics type="attached"><topic id="12lldha76jncf65d4tlb4stghr" modified-by="" timestamp="1511573619135"><title>class 类{&#13;
	{&#13;
		静态代码块&#13;
    }&#13;
}</title></topic></topics></children></topic><topic id="3e1qpmovbpjvn3toqokqaj3ldv" modified-by="" timestamp="1511573694674"><title>特点</title><children><topics type="attached"><topic id="12b64iktr8mjmjmgkh4lu3kpq9" modified-by="" timestamp="1511573710684"><title>每次创建对象时调用，而且先于构造器调用</title></topic></topics></children></topic><topic id="71j9jlin3hu5sgcg4q2j018n2i" modified-by="" timestamp="1511573714939"><title>作用</title><children><topics type="attached"><topic id="5qlj0dtrt9ok63lrkemn1c3t0u" modified-by="" timestamp="1511573739540"><title svg:width="500">为实例变量初始化（赋值），一般是多个构造器中重复的代码提取到构造块</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="74rt7cf5r2npf2dsg085esf5ob" modified-by="" timestamp="1511573511370"><title>在方法中</title><children><topics type="attached"><topic id="5pamve804mj4qnotp9hghk9vrc" modified-by="" timestamp="1511573522041"><title>局部代码块（了解）</title></topic></topics></children></topic></topics></children></topic><topic id="1ka0gab07p9d01evteflabk4nm" modified-by="" timestamp="1511573933800"><title>相关的面试题</title><children><topics type="attached"><topic id="5m2j1b8vksq84o6gtmcllqss6l" modified-by="" timestamp="1511573850855"><title>赋值和执行的顺序</title><children><topics type="attached"><topic id="6rksq40pl6069ccgbvnig83dbe" modified-by="" timestamp="1511573816929"><title svg:width="500">父类的静态代码块 -- 》子类的静态代码块  --》父类的构造块--》父类的构造器 --》子类的构造块 --》子类的构造器</title></topic><topic id="56gbduf2khi1eli2186smuveef" modified-by="" timestamp="1511573916347"><title/><xhtml:img svg:height="306" svg:width="400" xhtml:src="xap:attachments/2gonv6kv6okhdbj0dahp0nnc02.png"/></topic></topics></children></topic><topic id="44f2iqvij3phnioujne299c1bh" modified-by="" timestamp="1511573948825"><title>关于static的重写问题</title><children><topics type="attached"><topic id="6211nv4qoksurp9obvbv1jjjs7" modified-by="" timestamp="1511574019387"><title svg:width="500">静态的方法和属性，没有编译时类型和运行时类型的区别，只有编译时类型，换句话说没有重写（覆盖）一说</title><notes><html><xhtml:p>package com.atguigu.static_.buchong;</xhtml:p><xhtml:p>/*</xhtml:p><xhtml:p> * 静态的方法：不存在编译时和运行时类型，只有编译时类型</xhtml:p><xhtml:p> * 静态的属性：不存在编译时和运行时类型，只有编译时类型</xhtml:p><xhtml:p> */</xhtml:p><xhtml:p>public class Test {</xhtml:p><xhtml:p>	public static void main(String[] args) {</xhtml:p><xhtml:p>		SuperClass s = new SubClass();</xhtml:p><xhtml:p>		s.test();//父类的方法</xhtml:p><xhtml:p>		System.out.println(s.info);//尚硅谷</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		SubClass sub = new SubClass();</xhtml:p><xhtml:p>		sub.test();//子类的方法</xhtml:p><xhtml:p>		System.out.println(sub.info);//atguigu</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p>class SuperClass{</xhtml:p><xhtml:p>	static String info = "尚硅谷";</xhtml:p><xhtml:p>	public static void test(){</xhtml:p><xhtml:p>		System.out.println("父类的方法");</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p>class SubClass extends SuperClass{</xhtml:p><xhtml:p>	static String info = "atguigu";</xhtml:p><xhtml:p>	public static void test(){</xhtml:p><xhtml:p>		System.out.println("子类的方法");</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p></html><plain>package com.atguigu.static_.buchong;&#13;
/*&#13;
 * 静态的方法：不存在编译时和运行时类型，只有编译时类型&#13;
 * 静态的属性：不存在编译时和运行时类型，只有编译时类型&#13;
 */&#13;
public class Test {&#13;
	public static void main(String[] args) {&#13;
		SuperClass s = new SubClass();&#13;
		s.test();//父类的方法&#13;
		System.out.println(s.info);//尚硅谷&#13;
		&#13;
		SubClass sub = new SubClass();&#13;
		sub.test();//子类的方法&#13;
		System.out.println(sub.info);//atguigu&#13;
	}&#13;
}&#13;
class SuperClass{&#13;
	static String info = "尚硅谷";&#13;
	public static void test(){&#13;
		System.out.println("父类的方法");&#13;
	}&#13;
}&#13;
class SubClass extends SuperClass{&#13;
	static String info = "atguigu";&#13;
	public static void test(){&#13;
		System.out.println("子类的方法");&#13;
	}&#13;
}</plain></notes></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic branch="folded" id="5voiclv6c2oblqkk2gcjs6pk7v" modified-by="" timestamp="1512100347902"><title>（5）内部类</title><children><topics type="attached"><topic id="2gsjjk5kjvtkd12acj8k8vkou7" modified-by="" timestamp="1511829751969"><title>什么情况下使用内部类</title><children><topics type="attached"><topic id="6j8dsmrp03a2vjbgg4hlr8vbkp" modified-by="" timestamp="1511829753919"><title svg:width="500">（1）当一个事物的内部，还有一个部分需要一个完整的结构进行描述，而这个内部的完整的结构又只为外部事物提供服务，那么整个内部的完整结构最好使用内部类&#13;
（2）内部类可以访问外部类的所有的成员，包括私有的</title></topic></topics></children></topic><topic id="7ut1h6fs6kt8pei707br42uilc" modified-by="" timestamp="1511829812112"><title>形式</title><children><topics type="attached"><topic id="1qst29v8f67aesjed5t14vpfij" modified-by="" timestamp="1511829823013"><title>成员</title><children><topics type="attached"><topic id="41jtpk3bbcgnl6jbmkoe0an85r" modified-by="" timestamp="1511830328244"><title>静态内部类</title><children><topics type="attached"><topic id="37n82fhfc1ppu4bg68lmal6od7" modified-by="" timestamp="1511829939740"><title>格式</title><children><topics type="attached"><topic id="1f1d41qjthrtph2qvi2qja6tbk" modified-by="" timestamp="1511829976954"><title>[修饰符] class 外部类{&#13;
	[修饰符] static class 内部类{&#13;
	}&#13;
}</title></topic></topics></children></topic><topic id="2lhocad35elqifka69j0l28ktf" modified-by="" timestamp="1511830223583"><title>修饰符的问题</title><children><topics type="attached"><topic id="0pndnjhuto34ae0httulmpj3bf" modified-by="" timestamp="1511830177182"><title>（1）权限修饰符</title><children><topics type="attached"><topic id="7vqrsidqrshsfqhqkkm2vn73vb" modified-by="" timestamp="1511830180692"><title>4种</title></topic></topics></children></topic><topic id="7smveveu1ov4miln82pvhq8mua" modified-by="" timestamp="1511830201240"><title>（2）static</title><children><topics type="attached"><topic id="44t2mblkptini5htl2nd56tmq9" modified-by="" timestamp="1511830209368"><title>必须得有</title></topic></topics></children></topic><topic id="2ggvapngah5lva51vctejqcmov" modified-by="" timestamp="1511830267354"><title>（3）final（极少）</title><children><topics type="attached"><topic id="31rvlo4iftlvl9pnmhfn1k884u" modified-by="" timestamp="1511830217818"><title>可以</title><children><topics type="attached"><topic id="23vije3ae6k22dtf53ci6k69bg" modified-by="" timestamp="1511830223344"><title>表示不能被继承</title></topic></topics></children></topic></topics></children></topic><topic id="4mnpdkb2c5jrs2pqmpchq360ff" modified-by="" timestamp="1511830265033"><title>（4）abstract（极少）</title><children><topics type="attached"><topic id="6a6hr8usq6fohtah6g2jsgojp5" modified-by="" timestamp="1511830232998"><title>可以</title><children><topics type="attached"><topic id="197gkhn0bhdj85vt4pbtvhgih9" modified-by="" timestamp="1511830247529"><title>表示可以包含抽象方法，需要子类继承</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="53jn18akofm12bdnffa1b5kahh" modified-by="" timestamp="1511830317288"><title>静态内部类的成员</title><children><topics type="attached"><topic id="1fd5oa60vmn8nsi2ujmbfl10gr" modified-by="" timestamp="1511830323816"><title>所有都可以，包括静态的</title></topic></topics></children></topic><topic id="4hkh0ejloimagl537u1l0hstk0" modified-by="" timestamp="1511830421627"><title>使用问题</title><children><topics type="attached"><topic id="283v3r45u67dfinstmge48v4dq" modified-by="" timestamp="1511830354572"><title>（1）在静态内部类中使用外部类的成员</title><children><topics type="attached"><topic id="04hd82q5got4nniv036bdsspre" modified-by="" timestamp="1511830372292"><title>只能使用外部类的静态成员</title></topic></topics></children></topic><topic id="38gplhra36tfuh07ufdgb10ni0" modified-by="" timestamp="1511830402017"><title>（2）在外部类中使用静态内部类</title><children><topics type="attached"><topic id="0i22osrk7le8c1bo8teiav56si" modified-by="" timestamp="1511830406056"><title>都可以</title></topic></topics></children></topic><topic id="6nklperfinj4ve8khg419apfti" modified-by="" timestamp="1511830453230"><title>（3）在外部类的外面，其他类中</title><children><topics type="attached"><topic id="2iiiaf7tuvemfj8l59ikp54gbi" modified-by="" timestamp="1511830467015"><title>（1）用静态内部类的静态成员</title><children><topics type="attached"><topic id="1t22fi4ge81m41c90b6emdao79" modified-by="" timestamp="1511830492614"><title>外部类名.内部类名.静态成员</title></topic></topics></children></topic><topic id="37bt81mmvqqo6ejp186f3kk5b2" modified-by="" timestamp="1511830513861"><title>（2）用静态内部类的非静态成员</title><children><topics type="attached"><topic id="41dvovo0frp9cd0jlc5tl7mkgv" modified-by="" timestamp="1511830513071"><title>需要静态内部类的对象</title></topic><topic id="3to05hukt2g9736pemle9l6jdb" modified-by="" timestamp="1511830545485"><title svg:width="500">外部类名.内部类   变量 = new   外部类名.内部类();&#13;
变量.成员....</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="6q3sbs77n3hugdkb5ah41m9rd4" modified-by="" timestamp="1511831057383"><title>非静态内部类，通常称为成员内部类</title><children><topics type="attached"><topic id="3p29iqrthi1ictolurdu9q07r2" modified-by="" timestamp="1511829989460"><title>格式</title><children><topics type="attached"><topic id="5rao5nkqbkt8fnp7sh3k6qkcs2" modified-by="" timestamp="1511829990906"><title>[修饰符] class 外部类{&#13;
	[修饰符] class 内部类{&#13;
	}&#13;
}</title></topic></topics></children></topic><topic id="59462sugqe0kkqlm0k1ri5evh0" modified-by="" timestamp="1511830590134"><title>修饰符的问题</title><children><topics type="attached"><topic id="0mb2u3faeg5v4ncmc7u3na58d6" modified-by="" timestamp="1511830177182"><title>（1）权限修饰符</title><children><topics type="attached"><topic id="506schralrohrlrvbkhanp9ed5" modified-by="" timestamp="1511830180692"><title>4种</title></topic></topics></children></topic><topic id="4orsso4iku27krmb1jhqsp83so" modified-by="" timestamp="1511830201240"><title>（2）static</title><children><topics type="attached"><topic id="1f6sbksg9lhk8gmdtqak0q0k9v" modified-by="" timestamp="1511830609742"><title>没有</title></topic></topics></children></topic><topic id="403vd7d9qe7m0ohvkab6orbg8f" modified-by="" timestamp="1511830267354"><title>（3）final（极少）</title><children><topics type="attached"><topic id="6j851mpqtkt89hcemh1gubqbh8" modified-by="" timestamp="1511830217818"><title>可以</title><children><topics type="attached"><topic id="0vvr5bq2almir62sadg6pjijfu" modified-by="" timestamp="1511830223344"><title>表示不能被继承</title></topic></topics></children></topic></topics></children></topic><topic id="6g7nplduojubf4c5t061blt5sp" modified-by="" timestamp="1511830265033"><title>（4）abstract（极少）</title><children><topics type="attached"><topic id="6b5qej6s07dcs74pi17pn5ggfp" modified-by="" timestamp="1511830232998"><title>可以</title><children><topics type="attached"><topic id="5e5b8ileo5tb04hp07vhde4htt" modified-by="" timestamp="1511830247529"><title>表示可以包含抽象方法，需要子类继承</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="2s9q3v03m1erk0hbmp3jj76r2s" modified-by="" timestamp="1511830635924"><title>非静态内部类的成员</title><children><topics type="attached"><topic id="5ognhglpv152vipt22rjhq6kta" modified-by="" timestamp="1511830648852"><title>除了静态成员，其他都可以</title></topic></topics></children></topic><topic id="5f1t08biektn71ai3e53posbsn" modified-by="" timestamp="1511830775850"><title>使用的问题</title><children><topics type="attached"><topic id="3snq6kebpvu7vuf7t14ii5faau" modified-by="" timestamp="1511830678195"><title>（1）在非静态成员内部类中使用外部类的成员</title><children><topics type="attached"><topic id="17f10k7fafsc6b0d1drv016mkr" modified-by="" timestamp="1511830681072"><title>都可以</title></topic></topics></children></topic><topic id="2dndt09e2tat4cv7n7ujhbkl28" modified-by="" timestamp="1511830705585"><title>（2）在外部类中使用非静态成员内部类</title><children><topics type="attached"><topic id="175i3ote4b50kp7l14r16ekhuo" modified-by="" timestamp="1511830729539"><title>在外部类的静态成员中不能使用非静态成员内部类</title><children><topics type="attached"><topic id="64dmhul731f6c25rub5vs93lrq" modified-by="" timestamp="1511830742918"><title>静态  （不能用） 非静态</title><children><topics type="attached"><topic id="4ppcciffchnrdpnm891vmdseoa" modified-by="" timestamp="1511830763634"><title svg:width="500">原因，静态的成员先加载，非静态只有创建对象才有</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="1revhiepatignnujitpn9fccou" modified-by="" timestamp="1511830902439"><title>（3）在外部类的外面使用非静态成员内部类</title><children><topics type="attached"><topic id="3abrsh10ic45o4phsqrf3lgc3b" modified-by="" timestamp="1511830797481"><title>依赖于外部类的对象</title></topic><topic id="2hrn6vj5hco0k6kgidpdpff0fu" modified-by="" timestamp="1511830871874"><title>形式一</title><children><topics type="attached"><topic id="0bq4s43scaqrokm0u3mhcm163v" modified-by="" timestamp="1511830814514"><title>（1）先创建外部类的对象</title><children><topics type="attached"><topic id="39pqpka8gubhocrc33fdno8aj4" modified-by="" timestamp="1511830824259"><title>外部类  out = new  外部类();</title></topic></topics></children></topic><topic id="7ig1e7vamitacu4tev07ofbime" modified-by="" timestamp="1511830840846"><title>（2）通过外部类的对象创建内部类的对象</title><children><topics type="attached"><topic id="1aeo7kpsreeo4n424tupoqu8c6" modified-by="" timestamp="1511830868734"><title>外部类.内部类  in = out.new 内部类();</title></topic></topics></children></topic><topic id="0nr56vl0028pfnvem6copbg4ik" modified-by="" timestamp="1511830883904"><title>（3）通过内部类对象调用它的成员</title><children><topics type="attached"><topic id="00sb25ip4kn1soludk16r3jeno" modified-by="" timestamp="1511830889884"><title>in.成员</title></topic></topics></children></topic></topics></children></topic><topic id="3nvpquhu6404fjbo3m56atl6qq" modified-by="" timestamp="1511831026240"><title>形式二</title><children><topics type="attached"><topic id="4qunl7bi2mkasijfgv0q875r3k" modified-by="" timestamp="1511830972852"><title svg:width="500">（1）在外部类中提供一个方法，用来返回内部类的对象</title><children><topics type="attached"><topic id="4lhj8iljei5e6jjekahbj6nem3" modified-by="" timestamp="1511830978201"><title>class 外部类{&#13;
	class  内部类{&#13;
	}&#13;
&#13;
	public 内部类  getInnerInstance(){&#13;
		return new 内部类();&#13;
	}&#13;
&#13;
}</title></topic></topics></children></topic><topic id="3ads76vodr3krcfsljg3imaahl" modified-by="" timestamp="1511830990988"><title>（2）创建外部类的对象</title><children><topics type="attached"><topic id="2fc23733f7v41da35umpsa3m0q" modified-by="" timestamp="1511830990952"><title>外部类  out = new  外部类();</title></topic></topics></children></topic><topic id="50sov68l01v25tf6mjsr3au297" modified-by="" timestamp="1511831008554"><title>（3）通过外部类的对象，获取内部类的对象</title><children><topics type="attached"><topic id="4vkbot4r4br1maj4qlkbjb51fd" modified-by="" timestamp="1511831023421"><title>外部类.内部类  in = out.getInnerInstance();</title></topic></topics></children></topic><topic id="7m7tehbocgpp458v67l8fu6sl9" modified-by="" timestamp="1511831029047"><title>（4）通过内部类对象调用它的成员</title><children><topics type="attached"><topic id="3ha0kkh19b0b3ei0tnrrvvd1el" modified-by="" timestamp="1511830889884"><title>in.成员</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="58oc2joasckcgna9qu2ddbcra0" modified-by="" timestamp="1511831063667"><title>面试题</title><children><topics type="attached"><topic id="5npo3e075tgeqj0289sdupab55" modified-by="" timestamp="1511831137499"><title>如何继承非静态成员的内部类</title><children><topics type="attached"><topic id="1v215j5vbdr7kt3410akmg07rd" modified-by="" timestamp="1511831145390"><title>示例</title><notes><html><xhtml:p>class Outer{</xhtml:p><xhtml:p>	class Inner{</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p>class Other extends Outer.Inner{</xhtml:p><xhtml:p>	Other(Outer out){</xhtml:p><xhtml:p>		out.super();</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p></html><plain>class Outer{&#13;
	class Inner{&#13;
	}&#13;
}&#13;
class Other extends Outer.Inner{&#13;
	Other(Outer out){&#13;
		out.super();&#13;
	}&#13;
}</plain></notes></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="32k8d7b8evi4na58osqll7j23b" modified-by="" timestamp="1511829908071"><title>局部</title><children><topics type="attached"><topic id="19bkgtokcta4kssmqp7gksd57o" modified-by="" timestamp="1511831219463"><title>有名字的局部内部类，通常称为局部内部类</title><children><topics type="attached"><topic id="6dovj47q6qk7uebibg2nmls9dr" modified-by="" timestamp="1511831152639"><title>格式</title><children><topics type="attached"><topic id="0c3hk6eoi257a610mng1jh6mvk" modified-by="" timestamp="1511830046224"><title>[修饰符] class 外部类{&#13;
	[修饰符] 返回值类型  方法名([形参列表]){&#13;
		[修饰符] class 内部类{&#13;
		}&#13;
	}&#13;
}</title></topic></topics></children></topic><topic id="6dlhbr9qrvcmvtbmc99b386l8j" modified-by="" timestamp="1511831161352"><title>修饰符的问题</title><children><topics type="attached"><topic id="0cm3rloj5pmbdiqtca43tn0qu3" modified-by="" timestamp="1511830177182"><title>（1）权限修饰符</title><children><topics type="attached"><topic id="631e7p7keptaaiuaonqfusujuh" modified-by="" timestamp="1511831175556"><title>都不行</title></topic></topics></children></topic><topic id="5hq3ihp5d3kos8pi0ff1hcnqga" modified-by="" timestamp="1511830201240"><title>（2）static</title><children><topics type="attached"><topic id="5lcr5gds7a414b266mne6lh35l" modified-by="" timestamp="1511830609742"><title>没有</title></topic></topics></children></topic><topic id="4huolqjpdm1an2hrtnk920vckc" modified-by="" timestamp="1511830267354"><title>（3）final（极少）</title><children><topics type="attached"><topic id="7h5dmf9njkjjd3tot5qe06d6nh" modified-by="" timestamp="1511830217818"><title>可以</title><children><topics type="attached"><topic id="5bicoef6hjrbjud897ra26k3lo" modified-by="" timestamp="1511830223344"><title>表示不能被继承</title></topic></topics></children></topic></topics></children></topic><topic id="283932opgptj8dru9884ok1i1h" modified-by="" timestamp="1511830265033"><title>（4）abstract（极少）</title><children><topics type="attached"><topic id="63dqqvh2k9pdngs1i98ibgirkp" modified-by="" timestamp="1511830232998"><title>可以</title><children><topics type="attached"><topic id="4g9lhh41ldj3p3e6g7nj7vuvat" modified-by="" timestamp="1511830247529"><title>表示可以包含抽象方法，需要子类继承</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="0oqnpcuu6c7rd6g901cs06k7q3" modified-by="" timestamp="1511831209027"><title>有名字的局部内部类的成员</title><children><topics type="attached"><topic id="0hk7bpu3h3n4ehnn24ri6tv89j" modified-by="" timestamp="1511830648852"><title>除了静态成员，其他都可以</title></topic></topics></children></topic><topic id="24lg1ejv96ji0q9qicsgvieftm" modified-by="" timestamp="1511831386554"><title>使用</title><children><topics type="attached"><topic id="2lh7ni2te0q6r3iipcg3gd290j" modified-by="" timestamp="1511831248207"><title>（1）在内部类中使用外部类的成员</title><children><topics type="attached"><topic id="27riu127tnh40gln4tad3ek6pc" modified-by="" timestamp="1511831279513"><title svg:width="500">受所在方法的约束，如果所在方法是静态的，那么只能使用外部类的静态成员，如果所在方法是非静态的，那么都可以使用</title></topic></topics></children></topic><topic id="1u50dth5j6en7qaqs06fl814lb" modified-by="" timestamp="1511831299237"><title>（2）在内部类中使用外部类的局部变量</title><children><topics type="attached"><topic id="4c6kq8o5e6kn4ppe1rdqttoubo" modified-by="" timestamp="1511831317048"><title>必须是final修饰</title><children><topics type="attached"><topic id="7aaea0qsln2lk68hs384o6b5mc" modified-by="" timestamp="1511831316381"><title>JDK1.8之前，必须显式声明</title></topic><topic id="05vnn74iuh2k7o0cmmn2dpi6uv" modified-by="" timestamp="1511831331898"><title>JDK1.8之后，默认就是final修饰</title></topic></topics></children></topic></topics></children></topic><topic id="1sjcmagvgodrodqm39cj2qift8" modified-by="" timestamp="1511831347535"><title>（3）在外部类中使用内部类</title><children><topics type="attached"><topic id="58f33kvnisbl7813grrer865t9" modified-by="" timestamp="1511831361827"><title svg:width="500">只能在声明它的方法中使用，而且在声明之后使用</title><children><topics type="attached"><topic id="2s39d2e8hdsl65tcv9i79mlhe6" modified-by="" timestamp="1511831366790"><title>和局部变量的作用域一样</title></topic></topics></children></topic></topics></children></topic><topic id="7dhegt884m9hgoll2i58n6o4b6" modified-by="" timestamp="1511831381332"><title>（4）在外部类的外面</title><children><topics type="attached"><topic id="1kbtdb6f11md3pberq7kck896u" modified-by="" timestamp="1511831383619"><title>不可以</title></topic></topics></children></topic><topic id="2ici3pa6m66233346rpnu8h4lj" modified-by="" timestamp="1511831392801"><title>（5）在外部类的其他方法中</title><children><topics type="attached"><topic id="7kbkek76m3iophes1todk2ursh" modified-by="" timestamp="1511831400822"><title>不可以</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="6agfu5nu5u2be9d3urjn2osdbe" modified-by="" timestamp="1511832251002"><title>匿名内部类</title><children><topics type="attached"><topic id="1nsrgv2tt0pm3qss4a87i0g07g" modified-by="" timestamp="1511830125428"><title>格式</title><children><topics type="attached"><topic id="5r0cnmsrgk1aohbj7oda4prjmu" modified-by="" timestamp="1511830147663"><title>new 父类/父接口(){&#13;
	方法&#13;
}</title></topic></topics></children></topic><topic id="420um57k0nvpft16rf4mdidfg3" modified-by="" timestamp="1511831426471"><title>修饰符</title><children><topics type="attached"><topic id="1qgjotibucu5vc2v6akv5m0odt" modified-by="" timestamp="1511831429948"><title>一个都没有</title></topic></topics></children></topic><topic id="6thu5i17ls910q2e98cjvhbvig" modified-by="" timestamp="1511831450284"><title>匿名内部类的成员</title><children><topics type="attached"><topic id="7k1ctcaiid7l60ag7569ja636i" modified-by="" timestamp="1511831499007"><title svg:width="500">除了非静态的都可以，但是一般很少自定义方法等成员，它的成员都是重写父类的，父接口的方法</title></topic></topics></children></topic><topic id="3j45hqehfjj0cbumbjdjg3756e" modified-by="" timestamp="1511831794241"><title>匿名内部类的特点</title><children><topics type="attached"><topic id="7pcqh34tcnn26co1gf7scdsl2i" modified-by="" timestamp="1511831789041"><title>（1）声明类和创建对象同时进行， 只有一个对象</title><notes><html><xhtml:p>	public static void main(String[] args) {</xhtml:p><xhtml:p>		//Object的一个子类对象</xhtml:p><xhtml:p>		new Object(){</xhtml:p><xhtml:p>			public void test(){</xhtml:p><xhtml:p>				System.out.println(this.getClass());</xhtml:p><xhtml:p>			}</xhtml:p><xhtml:p>		}.test();</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//Object的另一个子类对象</xhtml:p><xhtml:p>		new Object(){</xhtml:p><xhtml:p>			public void test(){</xhtml:p><xhtml:p>				System.out.println(this.getClass());</xhtml:p><xhtml:p>			}</xhtml:p><xhtml:p>		}.test();</xhtml:p><xhtml:p>	}</xhtml:p></html><plain>	public static void main(String[] args) {&#13;
		//Object的一个子类对象&#13;
		new Object(){&#13;
			public void test(){&#13;
				System.out.println(this.getClass());&#13;
			}&#13;
		}.test();&#13;
		&#13;
		//Object的另一个子类对象&#13;
		new Object(){&#13;
			public void test(){&#13;
				System.out.println(this.getClass());&#13;
			}&#13;
		}.test();&#13;
	}</plain></notes></topic><topic id="2mksmq3jtkft2n04am3fbgub9l" modified-by="" timestamp="1511831995821"><title>（2）子类一定会调用父类的构造器</title><notes><html><xhtml:p>class MyClass{</xhtml:p><xhtml:p>	private String info;</xhtml:p><xhtml:p>	MyClass(String info){</xhtml:p><xhtml:p>		this.info = info;</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p/><xhtml:p>		//创建一个MyClass的子类对象，使用匿名内部类</xhtml:p><xhtml:p>		MyClass m = new MyClass("参数"){</xhtml:p><xhtml:p>			</xhtml:p><xhtml:p>		};</xhtml:p></html><plain>class MyClass{&#13;
	private String info;&#13;
	MyClass(String info){&#13;
		this.info = info;&#13;
	}&#13;
}&#13;
&#13;
		//创建一个MyClass的子类对象，使用匿名内部类&#13;
		MyClass m = new MyClass("参数"){&#13;
			&#13;
		};</plain></notes></topic></topics></children></topic><topic id="2e1jgk9hd5k81pvg3gvmbtk6bh" modified-by="" timestamp="1511832158390"><title>匿名内部类的使用形式</title><children><topics type="attached"><topic id="4sm6e5lv6k8eu9uj5hmtbva5na" modified-by="" timestamp="1511832026863"><title>形式一</title><children><topics type="attached"><topic id="1psisuqgm5co9ukud3bemoe75h" modified-by="" timestamp="1511832053954"><title>匿名内部类的匿名对象直接调用方法</title><notes><html><xhtml:p>		new Object(){</xhtml:p><xhtml:p>			public void test(){</xhtml:p><xhtml:p>				System.out.println(this.getClass());</xhtml:p><xhtml:p>			}</xhtml:p><xhtml:p>		}.test();</xhtml:p></html><plain>		new Object(){&#13;
			public void test(){&#13;
				System.out.println(this.getClass());&#13;
			}&#13;
		}.test();</plain></notes></topic></topics></children></topic><topic id="6ti7vf1fp4evrlgvm0j4gh5hmo" modified-by="" timestamp="1511832058297"><title>形式二</title><children><topics type="attached"><topic id="66ljcs6qava677r54pvirge3rv" modified-by="" timestamp="1511832157370"><title>与父类或父接口构成多态引用</title><notes><html><xhtml:p>class MyClass{</xhtml:p><xhtml:p>	public void test(){</xhtml:p><xhtml:p>		System.out.println("父类的测试方法");</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p/><xhtml:p>		MyClass m = new MyClass(){</xhtml:p><xhtml:p>			public void test(){</xhtml:p><xhtml:p>				System.out.println("重写");</xhtml:p><xhtml:p>			}</xhtml:p><xhtml:p>		};</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		m.test();</xhtml:p></html><plain>class MyClass{&#13;
	public void test(){&#13;
		System.out.println("父类的测试方法");&#13;
	}&#13;
}&#13;
&#13;
		MyClass m = new MyClass(){&#13;
			public void test(){&#13;
				System.out.println("重写");&#13;
			}&#13;
		};&#13;
		&#13;
		m.test();</plain></notes></topic></topics></children></topic><topic id="5ngsdrdfb43kskvocdej6uohl1" modified-by="" timestamp="1511832162533"><title>形式三</title><children><topics type="attached"><topic id="23do4ttask4em0p426qcjgua4v" modified-by="" timestamp="1511832243547"><title>匿名内部类的匿名对象作为实参</title><notes><html><xhtml:p>		MyClass[] arr = new MyClass[5];</xhtml:p><xhtml:p>		Arrays.sort(arr, new Comparator(){</xhtml:p><xhtml:p/><xhtml:p>			@Override</xhtml:p><xhtml:p>			public int compare(Object o1, Object o2) {</xhtml:p><xhtml:p>				return 0;</xhtml:p><xhtml:p>			}</xhtml:p><xhtml:p>			</xhtml:p><xhtml:p>		});</xhtml:p></html><plain>		MyClass[] arr = new MyClass[5];&#13;
		Arrays.sort(arr, new Comparator(){&#13;
&#13;
			@Override&#13;
			public int compare(Object o1, Object o2) {&#13;
				return 0;&#13;
			}&#13;
			&#13;
		});</plain></notes></topic></topics></children></topic></topics></children></topic><topic id="64vulm1r56hspquoi7o81p6kvt" modified-by="" timestamp="1511832271311"><title>使用其他要求</title><children><topics type="attached"><topic id="5dprsld8ueg8gt9d44bfocualv" modified-by="" timestamp="1511832271202"><title>（1）在内部类中使用外部类的成员</title><children><topics type="attached"><topic id="5m9tgk47h8r40b3j96ira1mmlb" modified-by="" timestamp="1511831279513"><title svg:width="500">受所在方法的约束，如果所在方法是静态的，那么只能使用外部类的静态成员，如果所在方法是非静态的，那么都可以使用</title></topic></topics></children></topic><topic id="1ipdh1l356p4gsa9lsdfq4s58a" modified-by="" timestamp="1511832271202"><title>（2）在内部类中使用外部类的局部变量</title><children><topics type="attached"><topic id="5vivg8ouqcmg0qg3sm1c56fck9" modified-by="" timestamp="1511831317048"><title>必须是final修饰</title><children><topics type="attached"><topic id="69pr2qsdvlpp9p93ih2tjulr6p" modified-by="" timestamp="1511831316381"><title>JDK1.8之前，必须显式声明</title></topic><topic id="62p02vrhql89v4m07sds1t8l0a" modified-by="" timestamp="1511831331898"><title>JDK1.8之后，默认就是final修饰</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic branch="folded" id="3ck76cdrnlvbq11labp67pduhs" modified-by="" timestamp="1511829574014"><title>（4）类的声明格式</title><children><topics type="attached"><topic id="6qv2psnfimoktgg1vnedr1fc9t" modified-by="" timestamp="1510970452398"><title>格式</title><children><topics type="attached"><topic id="7dflctrh4h82nfu1i7jvkrio6m" modified-by="" timestamp="1510970462836"><title>[修饰符] class 类名{&#13;
	//属性列表&#13;
	//构造器列表&#13;
	//get/set方法&#13;
	//其他方法&#13;
}</title></topic></topics></children></topic></topics></children></topic><topic branch="folded" id="36k9n7ge475mthgs0q07g4p1fa" modified-by="" timestamp="1511829576654"><title>（5）如何创建对象</title><children><topics type="attached"><topic id="692pk4899u3gatiohcivur1cpt" modified-by="" timestamp="1510970499105"><title>new 类名()</title><children><topics type="attached"><topic id="127vcctcbdgfk8frjo0s50ns1p" modified-by="" timestamp="1510970502715"><title>用无参构造</title></topic></topics></children></topic><topic id="5ksug1sqtt9a33je34205va54e" modified-by="" timestamp="1510970507795"><title>new 类名(实参列表)</title><children><topics type="attached"><topic id="7eenpo36965dhon05kaa5jkse3" modified-by="" timestamp="1510970511102"><title>用有参构造</title></topic></topics></children></topic><topic id="4m748l8dir0opek2mdbove9ha6" modified-by="" timestamp="1510970552710"><title>匿名对象和有名对象</title><children><topics type="attached"><topic id="22pa131egpo29stoo8rb4mlu08" modified-by="" timestamp="1510970542104"><title>Student stu = new Student();</title><children><topics type="attached"><topic id="04ik6b8suimhccc225m3d58o90" modified-by="" timestamp="1510970551612"><title>stu对象名，也可以称为对象的引用</title></topic></topics></children></topic><topic id="2vlofkpu0p5ouel1mhr5vvofu7" modified-by="" timestamp="1510970556613"><title>匿名对象</title><children><topics type="attached"><topic id="0du78gh7uqbe5k5gf9giq5unlf" modified-by="" timestamp="1510970571368"><title>System.out.println(new Student());</title></topic></topics></children></topic></topics></children></topic><topic id="5da9ffl2bq3hfhj9gs5pa6onvh" modified-by="" timestamp="1510987560940"><title>对象的内存图</title><children><topics type="attached"><topic id="2nvfop4gts768kbs44j87b8o7o" modified-by="" timestamp="1510987571831"><title/><xhtml:img svg:height="167" svg:width="400" xhtml:src="xap:attachments/5j9g7a2pbspd7q4cq3occthomb.png"/></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic branch="folded" id="27q99oc5j8mev0h6vps1m400nf" modified-by="" timestamp="1539745480567"><title>2、面向对象的基本特征</title><children><topics type="attached"><topic id="2g5rdapos8jsvflit2s809gq53" modified-by="" timestamp="1510970312821"><title>封装</title><children><topics type="attached"><topic id="0m5enp4ci4qq9m2psricsp6ctp" modified-by="" timestamp="1510970279465"><title>封装的作用</title><children><topics type="attached"><topic id="1t7l0sk2s9i6h4abp9255hcq3u" modified-by="" timestamp="1510970274660"><title>安全</title></topic><topic id="7bp03dt4rpah6sg8q6g0c0oi5s" modified-by="" timestamp="1510970292937"><title>使用方便</title><children><topics type="attached"><topic id="47m6k4kv5psir8m8hj1j11m93v" modified-by="" timestamp="1510970301382"><title>对于使用者屏蔽实现细节</title></topic></topics></children></topic></topics></children></topic><topic id="64k7frhflfsm7l164a320q66hf" modified-by="" timestamp="1510970331111"><title>概念</title><children><topics type="attached"><topic id="118adtqrps31u2usek30vcroap" modified-by="" timestamp="1510970326674"><title>狭义</title><children><topics type="attached"><topic id="5iqui9hrut0t6rqhsqc05qlkl4" modified-by="" timestamp="1510970361030"><title>属性的封装</title><children><topics type="attached"><topic id="62hu1qetslg4d8b5f4tpk02hb3" modified-by="" timestamp="1510970360342"><title>（1）属性私有化：private</title></topic><topic id="3rb6k2erm3ndhtien7vqvh3t1g" modified-by="" timestamp="1510970372795"><title>（2）提供公共get/set方法</title></topic></topics></children></topic></topics></children></topic><topic id="49j6d6k4pmrns3s7td5jogsn4i" modified-by="" timestamp="1510970344862"><title>广义</title><children><topics type="attached"><topic id="5s2vuuurif90dnqrsiseuovht8" modified-by="" timestamp="1510970338292"><title>方法</title></topic><topic id="3o2bgsoc9hpnne0spp75cg67l4" modified-by="" timestamp="1510970340325"><title>类</title></topic><topic id="4tal9iuttco5noni2953b00a4s" modified-by="" timestamp="1510970342267"><title>包</title></topic><topic id="536bodom1da2q8l5297i014nlc" modified-by="" timestamp="1510970344586"><title>组件</title></topic><topic id="79j33t85p0qutj4gdt3rmruu4s" modified-by="" timestamp="1510970348642"><title>系统</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="3hnfd1dtjbtfebq9i3s2e78f79" modified-by="" timestamp="1511314173555"><title>继承</title><children><topics type="attached"><topic id="5a5hd0c0c3f89hhipgs43cbaq9" modified-by="" timestamp="1511313441660"><title>什么情况下需要继承？继承的好处是什么？</title><children><topics type="attached"><topic id="3lsrng6sp0nfqfmqliqtfk6po7" modified-by="" timestamp="1511313370128"><title>为了代码重用</title><children><topics type="attached"><topic id="4umdb9gp8asp2dh9m9fl6mogsg" modified-by="" timestamp="1511313368996"><title svg:width="500">（1）当有一个父类，如果再声明类时，发现这些类与已经存在的父类有很多相同特征，那么就可以通过继承的方式来简化代码</title></topic><topic id="77onu46n6tj7cbq1547q5ffgu1" modified-by="" timestamp="1511313414669"><title svg:width="500">（2）已经很多类，发现这些类有很多共同的特点，那么我们可以把这些共同的特点抽取到一个父类中，以便简化代码</title></topic></topics></children></topic><topic id="69ejjthppq7f2c0s9br4r15ahs" modified-by="" timestamp="1511313446729"><title>逻辑的角度</title><children><topics type="attached"><topic id="3l56jntpbs15ggr0ccr36d8mrt" modified-by="" timestamp="1511313452847"><title>表示is-a的关系</title></topic></topics></children></topic></topics></children></topic><topic id="6jqmif2hl4no2jqks5va0rl4g8" modified-by="" timestamp="1511313516225"><title>如何继承</title><children><topics type="attached"><topic id="5jk7fj6sks9iol3qfsst5n00d2" modified-by="" timestamp="1511313517516"><title>语法格式：&#13;
[修饰符] class  子类名  extends  父类名{&#13;
}</title></topic></topics></children></topic><topic id="2163i2r34c1svdj0umei09f75d" modified-by="" timestamp="1511313539440"><title>继承后对几个成员的影响</title><children><topics type="attached"><topic id="0i699lidivaurj9nnd0n33s59k" modified-by="" timestamp="1511313632013"><title>属性</title><children><topics type="attached"><topic id="1u5387jpcamq3prqbaborqtgb6" modified-by="" timestamp="1511313625272"><title svg:width="500">（1）子类继承父类时，一定会继承父类的所有的属性，包括私有的，但是由于私有的关键字private的原因，在子类中无法直接操作它，但是可以通过get/set方式操作它</title></topic><topic id="45pt594h6jle9ru3vmqm194np6" modified-by="" timestamp="1511314020431"><title svg:width="500">（2）当子类的属性与父类的属性重名时，而且父类的属性没有私有化，如果要访问父类的属性那么通过super.属性进行访问，如果子类中没有通过super.属性访问，那这个属性就表示是子类自己的</title><children><topics type="attached"><topic id="631mgtmtllpu7n8b7nk6g4gpbo" modified-by="" timestamp="1511314043396"><title>面试题</title><notes><html><xhtml:p>package com.atguigu.review;</xhtml:p><xhtml:p/><xhtml:p>public class Test {</xhtml:p><xhtml:p/><xhtml:p>	public static void main(String[] args) {</xhtml:p><xhtml:p>		Student stu = new Student();</xhtml:p><xhtml:p>		System.out.println(stu.getInfo());//结果？  年龄：10</xhtml:p><xhtml:p>		System.out.println(stu.getAge());//结果？20   如果子类重写，答案是10</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p/><xhtml:p>}</xhtml:p><xhtml:p>class Person{</xhtml:p><xhtml:p>	int age = 20;</xhtml:p><xhtml:p/><xhtml:p>	public int getAge() {</xhtml:p><xhtml:p>		return age;</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p/><xhtml:p>	public void setAge(int age) {</xhtml:p><xhtml:p>		this.age = age;</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p>class Student extends Person{</xhtml:p><xhtml:p>	int age = 10;</xhtml:p><xhtml:p>	/*public int getAge(){</xhtml:p><xhtml:p>		return age;</xhtml:p><xhtml:p>	}*/</xhtml:p><xhtml:p>	public String getInfo(){</xhtml:p><xhtml:p>		return "年龄：" + age;</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p></html><plain>package com.atguigu.review;&#13;
&#13;
public class Test {&#13;
&#13;
	public static void main(String[] args) {&#13;
		Student stu = new Student();&#13;
		System.out.println(stu.getInfo());//结果？  年龄：10&#13;
		System.out.println(stu.getAge());//结果？20   如果子类重写，答案是10&#13;
	}&#13;
&#13;
}&#13;
class Person{&#13;
	int age = 20;&#13;
&#13;
	public int getAge() {&#13;
		return age;&#13;
	}&#13;
&#13;
	public void setAge(int age) {&#13;
		this.age = age;&#13;
	}&#13;
	&#13;
}&#13;
class Student extends Person{&#13;
	int age = 10;&#13;
	/*public int getAge(){&#13;
		return age;&#13;
	}*/&#13;
	public String getInfo(){&#13;
		return "年龄：" + age;&#13;
	}&#13;
}</plain></notes></topic></topics></children></topic></topics></children></topic><topic id="72n4jmjmh6s6nf4squo79a5pog" modified-by="" timestamp="1511314091356"><title>方法</title><children><topics type="attached"><topic id="1v2914pr4mu7rh6cn14qrb167f" modified-by="" timestamp="1511314088790"><title svg:width="500">（1）子类继承父类时，一定会继承父类的所有的方法，包括私有的，但是由于private，在子类中无法直接操作，但是可以间接操作</title></topic><topic id="48r4u8i4ihtdnt9tm7pade2m8q" modified-by="" timestamp="1511314118016"><title svg:width="500">（2）当父类的方法实现不适用于子类时，子类可以对父类的方法的进行重写</title></topic></topics></children></topic><topic id="5li0ed00a9oh49cqusg3ajnkr9" modified-by="" timestamp="1511314144895"><title>构造器</title><children><topics type="attached"><topic id="38ndve9drhm4v9pmn7ql99ei2r" modified-by="" timestamp="1511314143759"><title>（1）子类继承父类时，不会继承父类的构造器</title></topic><topic id="25no2sc84dfboi41df8tdbh0br" modified-by="" timestamp="1511314161391"><title>（2）子类继承父类时，一定会调用父类的构造器</title><children><topics type="attached"><topic id="2kom373nk8bmb38fc46g1r5i42" modified-by="" timestamp="1511314155648"><title svg:width="500">如果父类有无参构造，那么子类会默认去调用父类的无参构造&#13;
如果父类没有无参构造，只有有参构造，那么子类必须在子类构造器中手动调用父类的有参构造</title></topic><topic id="011eojeugurl28817g2e5hr978" modified-by="" timestamp="1511314162985"><title>调用父类的无参构造的语句：super();&#13;
调用父类的有参构造的语句：super(实参列表);&#13;
而且这两个语句必须在子类的构造器的首行。</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="6evq13cee245jjhmvau9h909uh" modified-by="" timestamp="1511314412183"><title>继承的原则</title><children><topics type="attached"><topic id="08jbnbenq3s6cvvcs4vloilsv0" modified-by="" timestamp="1511314188181"><title>（1）单继承</title><children><topics type="attached"><topic id="00mfv7nn7f0ddo7q0gckp5q3ts" modified-by="" timestamp="1511314217719"><title svg:width="500">在Java中只支持单继承，也就是说一个类只能有一个直接父类     --》一个唯一的亲生父亲</title></topic></topics></children></topic><topic id="40socelajf9ujao8gq8dm6lja8" modified-by="" timestamp="1511314237457"><title>（2）多层继承</title><children><topics type="attached"><topic id="1ve9sh7eftkj9pkn6kj9cka0o4" modified-by="" timestamp="1511314359832"><title svg:width="500">在Java中父类还可以有父类，而且在子类中会继承父类以及父类的父类的所有的属性与方法			--》代代相传</title><children><topics type="attached"><topic id="46lk41vegtf6tehgv1eucmtfrp" modified-by="" timestamp="1511314355441"><title svg:width="500">子类对象在寻找一个方法、属性时，如果本类中找不到，会去直接父类中查找，如果直接父类中也找不到，在往上找，找到为止，一直追溯到java.lang.Object根父类中</title></topic><topic id="0mt1ua4earm12j83bcmll1nii1" modified-by="" timestamp="1511314403921"><title svg:width="500">通过super.属性和方法时，先从直接父类中查找，如果没有，再往上找，直到找到为止，一直可以到java.lang.Object</title></topic></topics></children></topic></topics></children></topic><topic id="28qe06lsb5k19tvus0acb1pdcq" modified-by="" timestamp="1511314435901"><title svg:width="500">（3）一个类可以有很多个子类，子类还可以有子类</title><children><topics type="attached"><topic id="3mr5qd8mov2rl128i9tam3anp4" modified-by="" timestamp="1511314435590"><title>子孙满堂</title></topic><topic id="4p0vi0923d6o5vu74sfrpe5pgn" modified-by="" timestamp="1511314439677"><title>开枝散叶</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="4p8vrodhpdg3s3d2asbkj1qdk7" modified-by="" timestamp="1511487667796"><title>多态</title><children><topics type="attached"><topic id="3u6l3hlcubqvb6p9igqm5a72v9" modified-by="" timestamp="1511487565282"><title>多态的表现形式</title><children><topics type="attached"><topic id="5hq81lal3a55cs2s1g1is1t80q" modified-by="" timestamp="1511487564270"><title svg:width="500">（1）方法的重载：同一个类中，功能多种实现形式&#13;
方法的重写：父子类中，功能的不同实现形式</title></topic><topic id="1126veqrothpk77riskk6pngal" modified-by="" timestamp="1511487579348"><title>（2）对象的多态性</title><children><topics type="attached"><topic id="7m4lb5g9dlhisk4vegp5o7je9o" modified-by="" timestamp="1511487577941"><title svg:width="500">编译时类型与运行时的类型不一致，编译时看“左边”，运行时看“右边”，&#13;
编译时从“父类”中寻找方法，运行时执行的是“子类”重写过的代码</title></topic><topic id="7ov600ap9kshq31cjihbfqmk9g" modified-by="" timestamp="1511487603814"><title>对象的多态性的前提：&#13;
（1）继承&#13;
（2）方法的重写&#13;
（3）多态引用</title><children><topics type="attached"><topic id="3942sc3b1ahikauns5u8hor6to" modified-by="" timestamp="1511487593427"><title>多态引用</title><children><topics type="attached"><topic id="2l0qanf0epa7qrqbvkolg224go" modified-by="" timestamp="1511487602503"><title>Person p = new Student();</title></topic></topics></children></topic><topic id="484m7t88gjalgni31eeouv53d1" modified-by="" timestamp="1511487616240"><title>本态引用</title><children><topics type="attached"><topic id="5fo5213fs1ocrbnn14uvgitjdl" modified-by="" timestamp="1511487625899"><title>Person p = new Person();</title></topic><topic id="32eb0idpjvps0voj5146d0ndj0" modified-by="" timestamp="1511487622974"><title>Student s = new Student();</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="6t59ccma0oc572i03tc0ig8r1u" modified-by="" timestamp="1511487649715"><title>多态的应用</title><children><topics type="attached"><topic id="0mcs1rt9iu1pokrdemf12a991b" modified-by="" timestamp="1511487649489"><title>（1）多态参数</title></topic><topic id="4gsfq9v7pj2cco930794ritg32" modified-by="" timestamp="1511487651031"><title>（2）多态数组</title></topic></topics></children></topic><topic id="62t5grm7blumo4ldg6oa784tdr" modified-by="" timestamp="1511487697651"><title>类型的转换</title><children><topics type="attached"><topic id="7uc4l5643vr8ct42sjq5f12i3h" modified-by="" timestamp="1511487689611"><title>向上转型</title><children><topics type="attached"><topic id="753il2hrremadr374jhn0gl8fd" modified-by="" timestamp="1511487688555"><title>子类的对象赋值给父类的变量</title></topic><topic id="4vhsqkubbfj2m0f2vr20gsa8mm" modified-by="" timestamp="1511487693397"><title>自动完成</title></topic></topics></children></topic><topic id="78ej1d6rcl2c3digmjoo2gbepm" modified-by="" timestamp="1511487838937"><title>向下转型</title><children><topics type="attached"><topic id="03pfe5eq9rg1o28ap0aq9llkdi" modified-by="" timestamp="1511487723372"><title>把父类的变量赋值给子类的变量</title></topic><topic id="7d7gclg5k27eg3bl3d09bl7frc" modified-by="" timestamp="1511487730172"><title>强制类型转换</title></topic><topic id="6mdak8u1b3c58jedsbvt189st8" modified-by="" timestamp="1511487739231"><title>如果想要向下转型成功</title><children><topics type="attached"><topic id="5pu99tc9e1536m5sg5e4uoqihj" modified-by="" timestamp="1511487753415"><title>父类的变量本身指向的就是该子类的对象</title></topic></topics></children></topic><topic id="617lhk6k55i9bli1jg3qdmbele" modified-by="" timestamp="1511487775766"><title>如何避免ClassCastException</title><children><topics type="attached"><topic id="7kb3stb6oje3vn9gsp7hi631p4" modified-by="" timestamp="1511487787544"><title>在向下转型之前，加判断</title><children><topics type="attached"><topic id="7mf113rsrrqvduegd66vqbtbro" modified-by="" timestamp="1511487815860"><title>if(变量  instanceof  子类类型){&#13;
	子类类型  temp = (子类类型)变量;&#13;
}</title></topic></topics></children></topic></topics></children></topic><topic id="7fovhfebf0moa3dnhjvq41p0gp" modified-by="" timestamp="1511487883723"><title>什么情况下需要向下转型</title><children><topics type="attached"><topic id="6ltlt0bng62m5mj9oi5bj3gvf4" modified-by="" timestamp="1511487882810"><title svg:width="500">因为一个对一旦向上转型后，那么就无法访问该子类对象中特有的方法，只能访问父类有的方法</title></topic><topic id="15qpv5vv302eedmvckkuf8n3t2" modified-by="" timestamp="1511487902759"><title svg:width="500">如果需要通过该对象，访问子类的特有的方法等，那么就需要向下转型</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic branch="folded" id="4qqbrcpo1grrhmnfjbair31n7c" modified-by="" timestamp="1511829582928"><title>3、关键字</title><children><topics type="attached"><topic id="2i4paqkufaa5ifc9bul7k48u6k" modified-by="" timestamp="1510970608521"><title>class</title><children><topics type="attached"><topic id="2lh2a6rlci64fb1svalleqmie5" modified-by="" timestamp="1510970613800"><title>声明类</title></topic></topics></children></topic><topic id="4t1jo4h58kjrrud4n6bor543ju" modified-by="" timestamp="1510970660015"><title>new</title><children><topics type="attached"><topic id="1e3tj5k3eppb26e1mdlstkjhbp" modified-by="" timestamp="1510970624637"><title>创建实例，创建对象</title></topic><topic id="4ui1qnj05kdauaucl9q0pqm58l" modified-by="" timestamp="1510970636117"><title>在堆中申请一块空间</title></topic><topic id="6nco08n3n1g9hke9n4hdqkgaj1" modified-by="" timestamp="1510970654844"><title>只要new就创建新的对象</title></topic><topic id="0seq23pqdvlmimm17meuvec166" modified-by="" timestamp="1510970666126"><title>new后面一定是构造器</title></topic></topics></children></topic><topic id="290pb9ojqa7qkuotb8fd2ik99j" modified-by="" timestamp="1510970716153"><title>this</title><children><topics type="attached"><topic id="2u124vpd3na305hh0krg67p356" modified-by="" timestamp="1510970691141"><title>当前对象</title><children><topics type="attached"><topic id="1tk3shrffrs5fle0s6mhso3q9o" modified-by="" timestamp="1510970707847"><title svg:width="500">（1）如果在构造器中，表示正在被创建的那个对象&#13;
（2）如果在其他方法中，表示调用该方法的那个对象</title></topic></topics></children></topic><topic id="5i0qmg0t8qqarlfr09ooiviij7" modified-by="" timestamp="1510970731363"><title>使用</title><children><topics type="attached"><topic id="5k0v864ek3br4mmk41l7p10ouo" modified-by="" timestamp="1511314579462"><title svg:width="500">（1）this.属性</title><children><topics type="attached"><topic id="5ut62vueqjcs569b82vmu56j26" modified-by="" timestamp="1511314708819"><title svg:width="500">当成员变量（属性名）与局部变量（形参）重名时，使用this.属性进行区别</title></topic></topics></children></topic><topic id="7ak0kf1u36jp470h5buph8ioca" modified-by="" timestamp="1511314924022"><title svg:width="500">（2）this.方法</title><children><topics type="attached"><topic id="24b9dl1smq3uu1mve3b33cgq06" modified-by="" timestamp="1511314950845"><title>表示调用“当前类”的方法</title></topic><topic id="5hml5o7cibuljv55d24t137rs2" modified-by="" timestamp="1511314906332"><title svg:width="500">如果子类继承了父类，子类没有重写父类的方法，this.方法也可能是从父类继承的方法</title></topic><topic id="0gdprqa1rbgi1pmouvjiaorp5s" modified-by="" timestamp="1511314938051"><title svg:width="500">如果子类继承了父类，子类重写父类的方法，this.方法就代表子类重写过的代码</title></topic></topics></children></topic><topic id="3gggi2r69trgvn2qtk2sj3lv7f" modified-by="" timestamp="1511314988584"><title svg:width="500">（3）this()或this(实参列表)</title><children><topics type="attached"><topic id="2iaobvcen4eibafvsnacodn46l" modified-by="" timestamp="1511314989968"><title svg:width="500">表示调用本类的其他构造器，而且必须在构造器的首行</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="3f2pemi2ldb3e7or44mipahv3n" modified-by="" timestamp="1511314554532"><title>super</title><children><topics type="attached"><topic id="450hbf0n84p789cb7vclgo298c" modified-by="" timestamp="1511314527901"><title>父类引用</title></topic><topic id="33p286blk682ccqdnian7o5cv9" modified-by="" timestamp="1511314955108"><title>使用</title><children><topics type="attached"><topic id="49keq0t77r8qdktv4b0di5gthi" modified-by="" timestamp="1511314572641"><title>（1）super.属性</title><children><topics type="attached"><topic id="1kadtop89djtrirt1sbgr43479" modified-by="" timestamp="1511314573736"><title svg:width="500">当子类的属性与父类的属性重名时，而且父类的属性没有私有化&#13;
如果需要调用父类的属性，那么通过super.属性进行区别</title></topic></topics></children></topic><topic id="49j98qj6thi79iije0r6oo3hm4" modified-by="" timestamp="1511314876591"><title>（2）super.方法</title><children><topics type="attached"><topic id="0pfv6e39alhb1dkjjm63ajrjgq" modified-by="" timestamp="1511314877860"><title svg:width="500">当子类的方法重写了父类的方法时，&#13;
如果需要调用父类的被重写的方法，那么通过super.方法进行调用</title></topic></topics></children></topic><topic id="47emr2tpede19gtumb8pumhgpn" modified-by="" timestamp="1511314968513"><title>（3）super()或super(实参列表)</title><children><topics type="attached"><topic id="294e6i580mjvnnb1d8ssjdo5da" modified-by="" timestamp="1511314971773"><title svg:width="500">当子类需要调用父类的构造器时，通过super()或super(实参列表)进行调用&#13;
&#13;
调用父类的无参构造的语句：super();&#13;
调用父类的有参构造的语句：super(实参列表);&#13;
而且这两个语句必须在子类的构造器的首行。</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="06odglqbmheqccf8vl3o3te1vk" modified-by="" timestamp="1511315248640"><title>权限修饰符</title><children><topics type="attached"><topic id="5sggqrilsbmli26s6sja7m3tef" modified-by="" timestamp="1511315262132"><title svg:width="500">三个单词，四种形式：&#13;
public；公共的，范围：任意位置，可以修饰类、成员&#13;
protected：受保护的，范围：本包或子类中，可以修饰成员&#13;
缺省：默认的，范围：本包，可以修饰类、成员&#13;
private：私有的，范围：本类中，可以修饰成员</title></topic><topic id="3ab4hoj9vt6l4e41989a5n6q70" modified-by="" timestamp="1511315248610"><xhtml:img xhtml:src="xap:attachments/6b5g48r4eekg4hpnjcmftcv0lb.png"/></topic></topics></children></topic><topic id="64cmi3c95mcqhql0r875blhs1t" modified-by="" timestamp="1511573417785"><title>static</title><children><topics type="attached"><topic id="3iagnibt6pq8jn35hkteif04hq" modified-by="" timestamp="1511573396250"><title>静态的</title></topic><topic id="744mouh7rk5ts0h9d7haulv66s" modified-by="" timestamp="1511573402249"><title>可以修饰成员</title></topic><topic id="29f7h3riaa80964ln0crf17mlh" modified-by="" timestamp="1511573424569"><title>（1）属性</title><children><topics type="attached"><topic id="0hbmm1fna9ohu4kg5ju772o9fc" modified-by="" timestamp="1511573433578"><title svg:width="500">	这个属性就称为类变量，它的值是所有对象共享的，存储在方法区&#13;
	它的get/set方法也是静态的</title></topic></topics></children></topic><topic id="56nq23rik95kgd0lorrj2anrrd" modified-by="" timestamp="1511573441017"><title>（2）方法</title><children><topics type="attached"><topic id="3nqgrlttjvmtidcs8cob3eps3b" modified-by="" timestamp="1511573442401"><title svg:width="500">这个方法就称为类方法，调用它不需要创建对象，直接可以通过”类名.方法“调用</title></topic></topics></children></topic><topic id="7tok0pu28i7pfckuhss0brmvis" modified-by="" timestamp="1511573449485"><title>（3）代码块	</title><children><topics type="attached"><topic id="1c4c1o1fod4tt47r3s2rso4evj" modified-by="" timestamp="1511573451157"><title svg:width="500">	用static修饰的代码块称为静态代码块。&#13;
	随着类的加载并初始时而执行，而且一个类的静态代码块只执行一次&#13;
	为静态变量赋值，如果静态变量有显式初始化和静态代码块初始化，它俩属于同级，谁在前谁先执行</title></topic></topics></children></topic><topic id="5bjh9b34ci7d8euql5echu4ncn" modified-by="" timestamp="1511573423492"><title>（4）内部类</title></topic></topics></children></topic><topic id="0siccnt2i1suf0tq2ugfrjq49g" modified-by="" timestamp="1511574055371"><title>final</title><children><topics type="attached"><topic id="2un9jdaqt2hb15haf474d8cuvn" modified-by="" timestamp="1511574055144"><title>最终的</title></topic><topic id="1be1q18hh2hebpd6bp91creife" modified-by="" timestamp="1511574065800"><title>可以修饰</title><children><topics type="attached"><topic id="6d0jgs9nc9rqpmk88deoc4msig" modified-by="" timestamp="1511574103090"><title>（1）类</title><children><topics type="attached"><topic id="3n8m41540tt4t6u6noo5d01oli" modified-by="" timestamp="1511574111124"><title>这个类不能被继承，俗称“太监类”</title></topic></topics></children></topic><topic id="5f7r70el8quqlm0ijfc4gufeoi" modified-by="" timestamp="1511574111337"><title>（2）方法</title><children><topics type="attached"><topic id="41ekmsi7qung8t9f79orleghln" modified-by="" timestamp="1511574112827"><title>这个方法不能被重写，像“圣旨”</title></topic></topics></children></topic><topic id="7uungf629aj5oitvdrn2afg1pk" modified-by="" timestamp="1511574073228"><title>（3）变量</title><children><topics type="attached"><topic id="7ofe1p0ims9bsmg6n7jlhsjihk" modified-by="" timestamp="1511574084495"><title>成员变量</title><children><topics type="attached"><topic id="35mcdrjk1dllq1to0f6d6o5d8t" modified-by="" timestamp="1511574113709"><title>常量</title><children><topics type="attached"><topic id="13ovf1bj63b5supotnj192v7jo" modified-by="" timestamp="1511574117677"><title>值不能被修改</title></topic></topics></children></topic><topic id="0kj2ic6806jpvhn8u9sm7jpcv5" modified-by="" timestamp="1511574309586"><title>必须手动初始化</title><children><topics type="attached"><topic id="1mli9e1ik9mc3rdgktcjv8l0hi" modified-by="" timestamp="1511574320416"><title>示例</title><notes><html><xhtml:p>package com.atguigu.review;</xhtml:p><xhtml:p/><xhtml:p>public class TestFinal {</xhtml:p><xhtml:p/><xhtml:p>}</xhtml:p><xhtml:p>class Human{</xhtml:p><xhtml:p>//	private static final String country = "中国";</xhtml:p><xhtml:p>	private static final String country;</xhtml:p><xhtml:p>	static{</xhtml:p><xhtml:p>		country = "中国";</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p>class Person{</xhtml:p><xhtml:p>//	final String country = "中国";</xhtml:p><xhtml:p>	private final String country;</xhtml:p><xhtml:p>	private String name;</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>/*	{</xhtml:p><xhtml:p>		country = "中国";</xhtml:p><xhtml:p>	}*/</xhtml:p><xhtml:p>	Person(){</xhtml:p><xhtml:p>		country = "中国";</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p/><xhtml:p>	public Person(String name) {</xhtml:p><xhtml:p>		super();</xhtml:p><xhtml:p>		country = "中国";</xhtml:p><xhtml:p>		this.name = name;</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>}</xhtml:p></html><plain>package com.atguigu.review;&#13;
&#13;
public class TestFinal {&#13;
&#13;
}&#13;
class Human{&#13;
//	private static final String country = "中国";&#13;
	private static final String country;&#13;
	static{&#13;
		country = "中国";&#13;
	}&#13;
}&#13;
class Person{&#13;
//	final String country = "中国";&#13;
	private final String country;&#13;
	private String name;&#13;
	&#13;
/*	{&#13;
		country = "中国";&#13;
	}*/&#13;
	Person(){&#13;
		country = "中国";&#13;
	}&#13;
&#13;
	public Person(String name) {&#13;
		super();&#13;
		country = "中国";&#13;
		this.name = name;&#13;
	}&#13;
	&#13;
}</plain></notes></topic></topics></children></topic></topics></children></topic><topic id="0c3iuej2nile8g6vg4v33uurle" modified-by="" timestamp="1511574088711"><title>局部变量</title><children><topics type="attached"><topic id="2p931g7bme3e30j84phvahoqvq" modified-by="" timestamp="1511574120233"><title>常量</title><children><topics type="attached"><topic id="2if631kl7mpr4qm6132k7rv82i" modified-by="" timestamp="1511574121707"><title>值不能被修改</title></topic></topics></children></topic><topic id="04galki9c706lqui0e3imrqsed" modified-by="" timestamp="1511574093294"><title>必须手动初始化</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="34v6rp5uu69fv8dsb3f2fk7enu" modified-by="" timestamp="1511574339008"><title>native</title><children><topics type="attached"><topic id="2a0a3hnge7m7v4jaubqe7nghjp" modified-by="" timestamp="1511574338045"><title>原生的</title></topic><topic id="2pkrrpaq8i7oapmuu7m81clt5t" modified-by="" timestamp="1511574343081"><title>可以修饰</title><children><topics type="attached"><topic id="78n011hiv3ij60htkcl7rh4ekv" modified-by="" timestamp="1511574391793"><title>方法</title><children><topics type="attached"><topic id="2pm63716k6ekbsun62qemo49jl" modified-by="" timestamp="1511574364756"><title>（1）表示这个方法的方法体是非Java语言实现</title></topic><topic id="3pn42a7vabavbugropllaljvds" modified-by="" timestamp="1511574383053"><title svg:width="500">（2）对于使用这个方法者来说，和普通的Java 方法一样使用</title></topic><topic id="1cnqqjonnpgi94ha0pas43ofos" modified-by="" timestamp="1511574400700"><title>（3）如果有需要，也可以进行重写</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic branch="folded" id="3o4t8tl92habn9b5v66afrmkr2" modified-by="" timestamp="1511829584842"><title>4、包</title><children><topics type="attached"><topic id="6rumm8qshosptbivho15gvkl9c" modified-by="" timestamp="1510970786395"><title>包的作用</title><children><topics type="attached"><topic id="4o5tmkd5jq28b6d1e0gttbuuo2" modified-by="" timestamp="1510970787624"><title>（1）避免类的重名&#13;
（2）访问权限的控制&#13;
（3）便于管理</title></topic></topics></children></topic><topic id="2b0ev4p0tinth2kr11cjv5ti6t" modified-by="" timestamp="1510970801970"><title>如何声明包</title><children><topics type="attached"><topic id="6ufmpnp8l22eelk6qv0rkjj76a" modified-by="" timestamp="1510970801141"><title>package 包;</title></topic><topic id="0bncgff23latmjbcc6f9rhm9ob" modified-by="" timestamp="1510970818723"><title>要求</title><children><topics type="attached"><topic id="0v3a9mqqid0m84hji60iope4n8" modified-by="" timestamp="1510970813898"><title>必须在源文件的首行，一个源文件只能有一句</title></topic><topic id="3goudkv26iendep29ptemroq5h" modified-by="" timestamp="1510970819851"><title svg:width="500">遵循命名规范，所有字母都小写，单词之间使用.，一般以公司的域名倒置</title></topic></topics></children></topic></topics></children></topic><topic id="4i9jrs9near912776ve17itoig" modified-by="" timestamp="1510970898141"><title>如何使用其他包的类</title><children><topics type="attached"><topic id="5dl2s08238imr6cadhn14l5f8b" modified-by="" timestamp="1510970838831"><title>需要import 包.类名;</title></topic><topic id="7luhldjr7sbsurmvo0d03mctou" modified-by="" timestamp="1510970859837"><title>要求</title><children><topics type="attached"><topic id="697q3qslqok720b4nhmnbjjj37" modified-by="" timestamp="1510970853292"><title>在package和class声明之间，可以多句</title></topic><topic id="1bnjr3f9v36s7l7s2srvv5enrl" modified-by="" timestamp="1510970893248"><title>被使用的类必须是public 或 protected（父子类）</title></topic></topics></children></topic><topic id="2ktjtrujedrdkceu2ih8jrtfr4" modified-by="" timestamp="1510971323765"><title>形式</title><children><topics type="attached"><topic id="29tp48c6o152v9p1oojoudlneo" modified-by="" timestamp="1510971033382"><title>一一列举</title><children><topics type="attached"><topic id="6387qb9esgrqpds0j5vb6rkaq2" modified-by="" timestamp="1510971034587"><title>import java.util.Random;&#13;
import java.util.Scanner;</title></topic></topics></children></topic><topic id="168ds11i1pgnhha0tqt47oj4iu" modified-by="" timestamp="1510971080902"><title>某个包的类</title><children><topics type="attached"><topic id="1v4gqf5gabikh1eumu9gqknegt" modified-by="" timestamp="1510971082156"><title>import java.util.*;</title></topic></topics></children></topic><topic id="7c1vcg53trlqgeg8obijm11ko0" modified-by="" timestamp="1510971336246"><title>静态导入</title><children><topics type="attached"><topic id="6uoa0rfua6ignhllof2fpgboi8" modified-by="" timestamp="1510971330750"><title>import static java.lang.Math.*;</title></topic><topic id="50diibuner05573tuinnopid51" modified-by="" timestamp="1510971341600"><title>System.out.println(PI);&#13;
System.out.println(sqrt(4));</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic branch="folded" id="1isn1028bmtue27eottiv97lj7" modified-by="" timestamp="1539745482483"><title>Overload和Override的区别</title><children><topics type="attached"><topic id="6jmqa4bi665lhi92laanlg2vrd" modified-by="" timestamp="1511316209273"><title svg:width="500">Overload：方法的重载&#13;
	在同一类，方法名称相同，形参列表不同的两个或多个方法称为重载。&#13;
Override：方法的重写&#13;
	在子类继承父类时，如果父类的方法实现不适用于子类，子类就可以对父类的方法进行重写，覆盖。</title></topic><topic id="43d5n1qrgviqntm450c1nanmhl" modified-by="" timestamp="1511316148101"><title/><children><topics type="attached"><topic id="4761htgu6s2n9ah31ko3itghvo" modified-by="" timestamp="1512100411574"><xhtml:img svg:height="271" svg:width="571" xhtml:src="xap:attachments/4mcckr8rc4k8qk796ccusp06qj.png"/></topic></topics></children></topic></topics></children></topic></topics></children></topic><title>面向对象</title></sheet><sheet id="2a2t83gpuehjdkts59gr80irc5" modified-by="" style-id="1pkvsjgemjhomahhj6p9o7gp4f" theme="xminddefaultthemeid" timestamp="1511313214549"><topic id="03re993mbt43s5uaer8m06ghoe" modified-by="" structure-class="org.xmind.ui.logic.right" timestamp="1511228350707"><title>数组</title><extensions><extension provider="org.xmind.ui.map.unbalanced"><content><right-number>-1</right-number></content></extension></extensions><children><topics type="attached"><topic id="5pluln4jse3u848o6c3f6ulcm3" modified-by="" timestamp="1511141557489"><title>数组的概念</title><children><topics type="attached"><topic id="707ri3m70u4eledim9nm6f42qt" modified-by="" timestamp="1511141538481"><title>数组的作用</title><children><topics type="attached"><topic id="3hqbbpgljpvl7bdaghd3n730lo" modified-by="" timestamp="1511141552130"><title>用来保存、管理一组相同数据类型的数据</title></topic></topics></children></topic><topic id="49mgb5eetma5qsfk5lvoq210em" modified-by="" timestamp="1511141680789"><title svg:width="500">把一组具有相同数据类型的变量使用同一个名字来进行管理，并且这些元素按照一定的顺序进行排列。这同一个名字我们称为【数组名】，每一个元素通过编号进行区别，这个编号我们称为【下标】或索引。元素的总个数就是【数组的长度】。</title></topic></topics></children></topic><topic id="3aq1tv5ruqon3an6l7ee6i2h44" modified-by="" timestamp="1511141744553"><title>数组如何声明和初始化</title><children><topics type="attached"><topic id="716mjrlrdssnf3o27le0k74i13" modified-by="" timestamp="1511141720314"><title>数组的声明</title><children><topics type="attached"><topic id="6cpnteo89n8oo7ngu0haqneb0j" modified-by="" timestamp="1511141709814"><title>数组的类型   数组名;</title></topic><topic id="6sub7hokid8tbvms5l5rph6cok" modified-by="" timestamp="1511141730098"><title>数组的元素的类型[]  数组名;</title><children><topics type="attached"><topic id="5hb83tl8e8c2cu5joe7g6hpqu0" modified-by="" timestamp="1511141735482"><title>推荐的方式</title></topic></topics></children></topic><topic id="4ra9jm1msi22k808ljka3coj3j" modified-by="" timestamp="1511141729370"><title>数组的元素的类型  数组名[];</title></topic></topics></children></topic><topic id="2qk1ubp1o2ba431n861u31kht4" modified-by="" timestamp="1511141753440"><title>初始化</title><children><topics type="attached"><topic id="5c1iahu9mf001s7kmfgn2v4nqb" modified-by="" timestamp="1511141758406"><title>动态初始化</title><children><topics type="attached"><topic id="4c478tr60joel6k2jk68b8hlio" modified-by="" timestamp="1511141803578"><title>格式：</title><children><topics type="attached"><topic id="7dlo75649cm75veptpfmla27dj" modified-by="" timestamp="1511141780096"><title>数组名 = new  元素的类型[数组的长度];</title></topic></topics></children></topic></topics></children></topic><topic id="0otsd7p9cr43s0ljfes1ujfg0v" modified-by="" timestamp="1511141805545"><title>静态初始化</title><children><topics type="attached"><topic id="73li4g8jif1e3tf4anpb5dvu3r" modified-by="" timestamp="1511141850802"><title>格式</title><children><topics type="attached"><topic id="21hrpdthrse1hnq80k4fu7q5o9" modified-by="" timestamp="1511141837012"><title>数组名 = new  元素的类型[]{元素列表};</title><children><topics type="attached"><topic id="1kogdm2d2pqjrc04j2qvd4c9u9" modified-by="" timestamp="1511141835604"><title>元素列表的每一个元素使用,分割</title></topic><topic id="0oerojrc5ju8sb8opikriohduq" modified-by="" timestamp="1511141843795"><title>元素列表的个数就是数组的长度</title></topic></topics></children></topic><topic id="3onesbec3rpdhbd8bgvjo6ogiu" modified-by="" timestamp="1511141856993"><title>简写形式</title><children><topics type="attached"><topic id="5u4ci9da12t489si5lt1c0ssmo" modified-by="" timestamp="1511141870864"><title>数组的元素的类型[]  数组名 = {元素列表};</title><children><topics type="attached"><topic id="7qdfpb8u0tu8e29tvnoqg0saap" modified-by="" timestamp="1511141890179"><title>只有声明和静态初始化在一行，才可以这么简写</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="0pkk118jk2kob4tm7jt6mttllg" modified-by="" timestamp="1511141966700"><title>数组的元素</title><children><topics type="attached"><topic id="5jgdfcrllqrpmrnbm3gr6o3rnr" modified-by="" timestamp="1511141912614"><title>表示形式</title><children><topics type="attached"><topic id="7pqr4eopbntindt8gml9m4k858" modified-by="" timestamp="1511141919710"><title>数组名[下标]</title><children><topics type="attached"><topic id="38of3ka5fm6cm5sb9ggod34ai7" modified-by="" timestamp="1511141961699"><title>下标的范围</title><children><topics type="attached"><topic id="7vsqlhupmgftm5stdmjt3bg3u8" modified-by="" timestamp="1511141961720"><title>[0，数组的长度-1]</title><children><topics type="attached"><topic id="2p2gpberlhpekbtpo6bkshcf4o" modified-by="" timestamp="1511141961699"><title>[0,  数组名.length -1]</title></topic></topics></children></topic><topic id="5q1hkfgtg2q7gpa6de8q3tsd6m" modified-by="" timestamp="1511141948567"><title>[0，数组的长度)</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="5bumnkdr29dl42r0km3bpgunrg" modified-by="" timestamp="1511141975801"><title>赋值</title><children><topics type="attached"><topic id="449srsoikt8erdfbctq938ejk4" modified-by="" timestamp="1511141982630"><title>数组名[下标] = 值;</title></topic></topics></children></topic></topics></children></topic><topic id="6g2aqu3ask8gb1teco17f9qcd1" modified-by="" timestamp="1511142007898"><title>数组的长度</title><children><topics type="attached"><topic id="7vgh9qm6s1duuu9r5t9ivnt5hk" modified-by="" timestamp="1511142011938"><title>数组名.length</title></topic></topics></children></topic><topic id="4vrkqdpnu4348s88s3umvrcf6r" modified-by="" timestamp="1511142027689"><title>数组的遍历</title><children><topics type="attached"><topic id="12c0bg9rf3keunk0resg87ovcv" modified-by="" timestamp="1511142047670"><title>for循环</title><children><topics type="attached"><topic id="3bege1t8a9n82fqpsql6d5o7cn" modified-by="" timestamp="1511142069984"><title>for(int i=0; i&lt;数组名.length; i++){&#13;
}</title></topic></topics></children></topic><topic id="73plt2d7l7h94o3q33gselme7a" modified-by="" timestamp="1511142070935"><title>foreach循环</title><children><topics type="attached"><topic id="7fbcnl2cuquibtn2vjq7bfgal9" modified-by="" timestamp="1511142092888"><title>for(数组的元素的类型   元素的临时名 : 数组名){&#13;
}</title></topic></topics></children></topic></topics></children></topic><topic branch="folded" id="0n1lf6n70s8gdfo44d9qbk2gkr" modified-by="" timestamp="1511226061157"><title>数组的算法</title><children><topics type="attached"><topic id="5v0agm7tu4ugtd3amhmt22811r" modified-by="" timestamp="1511142250165"><title>（1）在数组中找最大值/最小值</title><notes><html><xhtml:p>	//找最大值</xhtml:p><xhtml:p>	public static int max(int[] arr){</xhtml:p><xhtml:p>		//第一步：假设第一个元素最大</xhtml:p><xhtml:p>		int max = arr[0];</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//遍历后面的元素和max比较</xhtml:p><xhtml:p>		for (int i = 1; i &lt; arr.length; i++) {</xhtml:p><xhtml:p>			//当有比max的值，就把max修改为它的值</xhtml:p><xhtml:p>			if(max &lt; arr[i]){</xhtml:p><xhtml:p>				max = arr[i];</xhtml:p><xhtml:p>			}</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		return max;</xhtml:p><xhtml:p>	}</xhtml:p></html><plain>	//找最大值&#13;
	public static int max(int[] arr){&#13;
		//第一步：假设第一个元素最大&#13;
		int max = arr[0];&#13;
		&#13;
		//遍历后面的元素和max比较&#13;
		for (int i = 1; i &lt; arr.length; i++) {&#13;
			//当有比max的值，就把max修改为它的值&#13;
			if(max &lt; arr[i]){&#13;
				max = arr[i];&#13;
			}&#13;
		}&#13;
		&#13;
		return max;&#13;
	}</plain></notes></topic><topic id="1li20b233k93uj5ampotj5306d" modified-by="" timestamp="1511142356681"><title>（2）在数组中找最大值、最小值的下标</title><notes><html><xhtml:p>	//找最大值的下标</xhtml:p><xhtml:p>	public static int maxIndex(int[] arr){</xhtml:p><xhtml:p>		//第一步：假设第一个元素最大</xhtml:p><xhtml:p>		int index = 0;</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//arr[index] 和 后续的元素一一比较</xhtml:p><xhtml:p>		for (int i = 1; i &lt; arr.length; i++) {</xhtml:p><xhtml:p>			//当有比max的值，就把max修改为它的值</xhtml:p><xhtml:p>			if(arr[index] &lt; arr[i]){</xhtml:p><xhtml:p>				index = i;</xhtml:p><xhtml:p>			}</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>		return index;</xhtml:p><xhtml:p>	}</xhtml:p></html><plain>	//找最大值的下标&#13;
	public static int maxIndex(int[] arr){&#13;
		//第一步：假设第一个元素最大&#13;
		int index = 0;&#13;
		&#13;
		//arr[index] 和 后续的元素一一比较&#13;
		for (int i = 1; i &lt; arr.length; i++) {&#13;
			//当有比max的值，就把max修改为它的值&#13;
			if(arr[index] &lt; arr[i]){&#13;
				index = i;&#13;
			}&#13;
		}&#13;
		return index;&#13;
	}</plain></notes></topic><topic id="4t3k4jj79pulbtrdb6tc63in55" modified-by="" timestamp="1511142475019"><title>（3）数组元素的累加和，平均值</title><notes><html><xhtml:p>//求数组元素的总和</xhtml:p><xhtml:p>	public static long sum(int[] arr){</xhtml:p><xhtml:p>		long sum = 0;</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		for (int i = 0; i &lt; arr.length; i++) {</xhtml:p><xhtml:p>			sum += arr[i];</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		return sum;</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>	public static double avg(int[] arr){</xhtml:p><xhtml:p>		double sum = sum(arr);</xhtml:p><xhtml:p>		return sum/arr.length;</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p/></html><plain>//求数组元素的总和&#13;
	public static long sum(int[] arr){&#13;
		long sum = 0;&#13;
		&#13;
		for (int i = 0; i &lt; arr.length; i++) {&#13;
			sum += arr[i];&#13;
		}&#13;
		&#13;
		return sum;&#13;
	}&#13;
	public static double avg(int[] arr){&#13;
		double sum = sum(arr);&#13;
		return sum/arr.length;&#13;
	}&#13;
</plain></notes></topic><topic id="15t8ga6qotnpm71u8h7sciats9" modified-by="" timestamp="1511142939404"><title>（4）反转</title><notes><html><xhtml:p>	//反转</xhtml:p><xhtml:p>	public static void reverse(int[] arr){</xhtml:p><xhtml:p>		//如果有5个元素，应该交换2次或3次      arr.length/2</xhtml:p><xhtml:p> 		//如果有6个元素，应该交换3次                 arr.length/2</xhtml:p><xhtml:p>		//数组的收尾对应位置交换</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//次数</xhtml:p><xhtml:p>		for(int i=0; i&lt;arr.length/2; i++){</xhtml:p><xhtml:p>			//首尾交换</xhtml:p><xhtml:p>			int temp = arr[i];</xhtml:p><xhtml:p>			arr[i] = arr[arr.length-1-i];</xhtml:p><xhtml:p>			arr[arr.length-1-i] = temp;</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p/><xhtml:p>	</xhtml:p><xhtml:p>	//反转部分</xhtml:p><xhtml:p>	public static void reverse(int[] arr, int start ,int end){</xhtml:p><xhtml:p>		//次数     </xhtml:p><xhtml:p>		//假设start = 1, end = 5     次数2次    (end + 1 - start)/2  (5+1-1)/2  2</xhtml:p><xhtml:p>		//假设start = 1, end = 6  次数3次      (end + 2 - start)/2  (6+1-1)/2  3</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		for(int i=0; i&lt; (end + 1 - start)/2; i++){</xhtml:p><xhtml:p>			//首尾交换</xhtml:p><xhtml:p>			//arr[start],arr[start+1]...</xhtml:p><xhtml:p>			//arr[end],arr[end-1]...</xhtml:p><xhtml:p>			int temp = arr[start + i];</xhtml:p><xhtml:p>			arr[start + i] = arr[end -i];</xhtml:p><xhtml:p>			arr[end-i] = temp;</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>	}</xhtml:p></html><plain>	//反转&#13;
	public static void reverse(int[] arr){&#13;
		//如果有5个元素，应该交换2次或3次      arr.length/2&#13;
 		//如果有6个元素，应该交换3次                 arr.length/2&#13;
		//数组的收尾对应位置交换&#13;
		&#13;
		//次数&#13;
		for(int i=0; i&lt;arr.length/2; i++){&#13;
			//首尾交换&#13;
			int temp = arr[i];&#13;
			arr[i] = arr[arr.length-1-i];&#13;
			arr[arr.length-1-i] = temp;&#13;
		}&#13;
	}&#13;
&#13;
	&#13;
	//反转部分&#13;
	public static void reverse(int[] arr, int start ,int end){&#13;
		//次数     &#13;
		//假设start = 1, end = 5     次数2次    (end + 1 - start)/2  (5+1-1)/2  2&#13;
		//假设start = 1, end = 6  次数3次      (end + 2 - start)/2  (6+1-1)/2  3&#13;
		&#13;
		for(int i=0; i&lt; (end + 1 - start)/2; i++){&#13;
			//首尾交换&#13;
			//arr[start],arr[start+1]...&#13;
			//arr[end],arr[end-1]...&#13;
			int temp = arr[start + i];&#13;
			arr[start + i] = arr[end -i];&#13;
			arr[end-i] = temp;&#13;
		}&#13;
	}</plain></notes></topic><topic id="25hge0qc6kjbm50qdn95dvjh61" modified-by="" timestamp="1511143108011"><title>（5）复制</title><notes><html><xhtml:p>	//复制一个数组，从原数组的[0]元素开始复制，新数组的长度由使用者决定</xhtml:p><xhtml:p>	public static int[] copy(int[] src, int newLength){</xhtml:p><xhtml:p>		//1、创建新数组的对象</xhtml:p><xhtml:p>		int[] newArray = new int[newLength];</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//2、把原数组的元素复制到新数组中</xhtml:p><xhtml:p>		for(int i=0; i&lt;newArray.length &amp;&amp; i&lt;src.length; i++){</xhtml:p><xhtml:p>			newArray[i] = src[i];</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		return newArray;</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>	//复制一个数组，从原数组的[start]元素开始复制，新数组的长度由使用者决定</xhtml:p><xhtml:p>	public static int[] copy(int[] src, int start, int newLength){</xhtml:p><xhtml:p>		//1、创建新数组</xhtml:p><xhtml:p>		int[] newArray = new int[newLength];</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//2、把原数组的元素从[start]复制到新数组的[0]...</xhtml:p><xhtml:p>		for(int i=0; i&lt;newArray.length &amp;&amp; start+i&lt;src.length; i++){</xhtml:p><xhtml:p>			newArray[i] = src[start+i];</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		return newArray;</xhtml:p><xhtml:p>	}</xhtml:p></html><plain>	//复制一个数组，从原数组的[0]元素开始复制，新数组的长度由使用者决定&#13;
	public static int[] copy(int[] src, int newLength){&#13;
		//1、创建新数组的对象&#13;
		int[] newArray = new int[newLength];&#13;
		&#13;
		//2、把原数组的元素复制到新数组中&#13;
		for(int i=0; i&lt;newArray.length &amp;&amp; i&lt;src.length; i++){&#13;
			newArray[i] = src[i];&#13;
		}&#13;
		&#13;
		return newArray;&#13;
	}&#13;
	&#13;
	//复制一个数组，从原数组的[start]元素开始复制，新数组的长度由使用者决定&#13;
	public static int[] copy(int[] src, int start, int newLength){&#13;
		//1、创建新数组&#13;
		int[] newArray = new int[newLength];&#13;
		&#13;
		//2、把原数组的元素从[start]复制到新数组的[0]...&#13;
		for(int i=0; i&lt;newArray.length &amp;&amp; start+i&lt;src.length; i++){&#13;
			newArray[i] = src[start+i];&#13;
		}&#13;
		&#13;
		return newArray;&#13;
	}</plain></notes></topic><topic id="29mbi79kafe40cpo7mqbe6133e" modified-by="" timestamp="1511143124562"><title>（6）排序</title><children><topics type="attached"><topic id="0csuc5pksure782vh6upsfpi9s" modified-by="" timestamp="1511143189048"><title>冒泡排序</title><notes><html><xhtml:p>	//假设数组5个元素</xhtml:p><xhtml:p>	public static void pubSort3(int[] arr){</xhtml:p><xhtml:p>		//方式二：把大的往右沉</xhtml:p><xhtml:p>		//每一轮从左边开始比较</xhtml:p><xhtml:p>		//比较的轮数依然是n-1轮</xhtml:p><xhtml:p>		for(int i=1; i&lt;arr.length; i++){</xhtml:p><xhtml:p>			//每一轮从左边开始比较</xhtml:p><xhtml:p>			/*</xhtml:p><xhtml:p>			 * 第一轮：i=1， 比较4次，j=0,1,2,3   ,j&lt;arr.length-i  j&lt;5-1 j&lt;4 </xhtml:p><xhtml:p>			 * 第二轮：i=2，比较3次，j=0,1,2      ,j&lt;arr.length-i  j&lt;5-2 j&lt;3</xhtml:p><xhtml:p>			 * ...</xhtml:p><xhtml:p>			 */</xhtml:p><xhtml:p>			for(int j=0; j&lt;arr.length-i; j++){</xhtml:p><xhtml:p>				//如果左边的元比右边的元素大，交换</xhtml:p><xhtml:p>				if(arr[j] &gt; arr[j+1]){</xhtml:p><xhtml:p>					int temp = arr[j];</xhtml:p><xhtml:p>					arr[j] = arr[j+1];</xhtml:p><xhtml:p>					arr[j+1] = temp;</xhtml:p><xhtml:p>				}</xhtml:p><xhtml:p>			}</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>	//假设数组5个元素</xhtml:p><xhtml:p>	public static void pubSort2(int[] arr){</xhtml:p><xhtml:p>		//排序规则：每一轮通过相邻元素的比较，把小的往左边冒（或把大的往右边沉），每一轮都是把本轮的最小值冒出来（最大值沉下去）</xhtml:p><xhtml:p>		//经过n-1轮完成最终的排序</xhtml:p><xhtml:p>		//(1)方式一：把小的往左边冒，注意，每一轮都是从最右边往左边比较</xhtml:p><xhtml:p>		//i=0,i=1,i=2,i=3  i&lt;5-1 --&gt;  i&lt;4 --&gt;  i&lt;=3</xhtml:p><xhtml:p>		for(int i=0; i&lt;arr.length-1; i++){//一共n-1轮</xhtml:p><xhtml:p>			//每一轮都要从最右边往左边比较</xhtml:p><xhtml:p>			/*</xhtml:p><xhtml:p>			 * 第一轮：比较n-1次，比较4次， i=0, j=4,3,2,1 ,j&gt;i</xhtml:p><xhtml:p>			 * 第二轮：比较3次，i=1, j=4,3,2 ,j&gt;i</xhtml:p><xhtml:p>			 * ....</xhtml:p><xhtml:p>			 */</xhtml:p><xhtml:p>			for(int j=arr.length-1; j&gt;i; j--){</xhtml:p><xhtml:p>				//相邻的元素比较，而且如果右边的比左边的小，需要交换</xhtml:p><xhtml:p>				if(arr[j] &lt; arr[j-1]){</xhtml:p><xhtml:p>					int temp = arr[j];</xhtml:p><xhtml:p>					arr[j] = arr[j-1];</xhtml:p><xhtml:p>					arr[j-1] = temp;</xhtml:p><xhtml:p>				}</xhtml:p><xhtml:p>			}</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>	//冒泡排序：从小到大</xhtml:p><xhtml:p>	//如果数组是5个元素</xhtml:p><xhtml:p>	public static void pubSort(int[] arr){</xhtml:p><xhtml:p>		//排序规则：每一轮通过相邻元素的比较，把小的往左边冒（或把大的往右边沉），每一轮都是把本轮的最小值冒出来（最大值沉下去）</xhtml:p><xhtml:p>		//经过n-1轮完成最终的排序</xhtml:p><xhtml:p>		//(1)方式一：把小的往左边冒，注意，每一轮都是从最右边往左边比较</xhtml:p><xhtml:p>		for(int i=1; i&lt;arr.length; i++){//一共n-1轮</xhtml:p><xhtml:p>			//每一轮都要从最右边往左边比较</xhtml:p><xhtml:p>			/*</xhtml:p><xhtml:p>			 * 第一轮：比较n-1次，比较4次， i=1, j=4,3,2,1 ,j&gt;=i</xhtml:p><xhtml:p>			 * 第二轮：比较3次，i=2, j=4,3,2 ,j&gt;=i</xhtml:p><xhtml:p>			 * ....</xhtml:p><xhtml:p>			 */</xhtml:p><xhtml:p>			for(int j=arr.length-1; j&gt;=i; j--){</xhtml:p><xhtml:p>				//相邻的元素比较，而且如果右边的比左边的小，需要交换</xhtml:p><xhtml:p>				if(arr[j] &lt; arr[j-1]){</xhtml:p><xhtml:p>					int temp = arr[j];</xhtml:p><xhtml:p>					arr[j] = arr[j-1];</xhtml:p><xhtml:p>					arr[j-1] = temp;</xhtml:p><xhtml:p>				}</xhtml:p><xhtml:p>			}</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>	}</xhtml:p></html><plain>	//假设数组5个元素&#13;
	public static void pubSort3(int[] arr){&#13;
		//方式二：把大的往右沉&#13;
		//每一轮从左边开始比较&#13;
		//比较的轮数依然是n-1轮&#13;
		for(int i=1; i&lt;arr.length; i++){&#13;
			//每一轮从左边开始比较&#13;
			/*&#13;
			 * 第一轮：i=1， 比较4次，j=0,1,2,3   ,j&lt;arr.length-i  j&lt;5-1 j&lt;4 &#13;
			 * 第二轮：i=2，比较3次，j=0,1,2      ,j&lt;arr.length-i  j&lt;5-2 j&lt;3&#13;
			 * ...&#13;
			 */&#13;
			for(int j=0; j&lt;arr.length-i; j++){&#13;
				//如果左边的元比右边的元素大，交换&#13;
				if(arr[j] &gt; arr[j+1]){&#13;
					int temp = arr[j];&#13;
					arr[j] = arr[j+1];&#13;
					arr[j+1] = temp;&#13;
				}&#13;
			}&#13;
		}&#13;
	}&#13;
	&#13;
	//假设数组5个元素&#13;
	public static void pubSort2(int[] arr){&#13;
		//排序规则：每一轮通过相邻元素的比较，把小的往左边冒（或把大的往右边沉），每一轮都是把本轮的最小值冒出来（最大值沉下去）&#13;
		//经过n-1轮完成最终的排序&#13;
		//(1)方式一：把小的往左边冒，注意，每一轮都是从最右边往左边比较&#13;
		//i=0,i=1,i=2,i=3  i&lt;5-1 --&gt;  i&lt;4 --&gt;  i&lt;=3&#13;
		for(int i=0; i&lt;arr.length-1; i++){//一共n-1轮&#13;
			//每一轮都要从最右边往左边比较&#13;
			/*&#13;
			 * 第一轮：比较n-1次，比较4次， i=0, j=4,3,2,1 ,j&gt;i&#13;
			 * 第二轮：比较3次，i=1, j=4,3,2 ,j&gt;i&#13;
			 * ....&#13;
			 */&#13;
			for(int j=arr.length-1; j&gt;i; j--){&#13;
				//相邻的元素比较，而且如果右边的比左边的小，需要交换&#13;
				if(arr[j] &lt; arr[j-1]){&#13;
					int temp = arr[j];&#13;
					arr[j] = arr[j-1];&#13;
					arr[j-1] = temp;&#13;
				}&#13;
			}&#13;
		}&#13;
	}&#13;
	&#13;
	//冒泡排序：从小到大&#13;
	//如果数组是5个元素&#13;
	public static void pubSort(int[] arr){&#13;
		//排序规则：每一轮通过相邻元素的比较，把小的往左边冒（或把大的往右边沉），每一轮都是把本轮的最小值冒出来（最大值沉下去）&#13;
		//经过n-1轮完成最终的排序&#13;
		//(1)方式一：把小的往左边冒，注意，每一轮都是从最右边往左边比较&#13;
		for(int i=1; i&lt;arr.length; i++){//一共n-1轮&#13;
			//每一轮都要从最右边往左边比较&#13;
			/*&#13;
			 * 第一轮：比较n-1次，比较4次， i=1, j=4,3,2,1 ,j&gt;=i&#13;
			 * 第二轮：比较3次，i=2, j=4,3,2 ,j&gt;=i&#13;
			 * ....&#13;
			 */&#13;
			for(int j=arr.length-1; j&gt;=i; j--){&#13;
				//相邻的元素比较，而且如果右边的比左边的小，需要交换&#13;
				if(arr[j] &lt; arr[j-1]){&#13;
					int temp = arr[j];&#13;
					arr[j] = arr[j-1];&#13;
					arr[j-1] = temp;&#13;
				}&#13;
			}&#13;
		}&#13;
	}</plain></notes></topic><topic id="05bs9vq3mf4ugfvon3m6nmcvvs" modified-by="" timestamp="1511144958357"><title>直接选择排序</title><notes><html><xhtml:p>	//直接选择排序</xhtml:p><xhtml:p>	//基本原理：将待排序的元素分为已排序（初始为空）和未排序两组，依次将未排序的元素中值最小的元素放入已排序的组中。</xhtml:p><xhtml:p>	//[3,2,1,5,4]  从小到大排序</xhtml:p><xhtml:p>	/*</xhtml:p><xhtml:p>	 * 第一次：所有元素都属于未排序   把未排序的元素中的最小值找出来    arr[2] = 1 ，放入已排序组中     和第一个元素交换</xhtml:p><xhtml:p>	 * 		[1,2,3,5,4]</xhtml:p><xhtml:p>	 * 第二次：已排序的是[1]，未排序的是[2,3,5,4]，把未排序元素中的最小值找出  arr[1]=2，放入已排序组中  </xhtml:p><xhtml:p>	 * 		【1,2】，【3,5,4】</xhtml:p><xhtml:p>	 * ...</xhtml:p><xhtml:p>	 * </xhtml:p><xhtml:p>	 */</xhtml:p><xhtml:p>	//假设5个元素</xhtml:p><xhtml:p>	public static void selectSort(int[] arr){</xhtml:p><xhtml:p>		//次数</xhtml:p><xhtml:p>		for(int i=0; i&lt;arr.length-1; i++){</xhtml:p><xhtml:p>			//第一次，找最小值</xhtml:p><xhtml:p>			//假设每一轮的未排序元素的第一个最小</xhtml:p><xhtml:p>			int index = i;</xhtml:p><xhtml:p>			</xhtml:p><xhtml:p>			//找出本轮最小值</xhtml:p><xhtml:p>			/*</xhtml:p><xhtml:p>			 * int i=0 ,从哪些元素中找最小值  [0]~[4]   j=1,2,3,4</xhtml:p><xhtml:p>			 * int i=1，从哪些元素中找最小值[1]~[4]    j=2,3,4</xhtml:p><xhtml:p>			 * ...</xhtml:p><xhtml:p>			 */</xhtml:p><xhtml:p>			for(int j=i+1; j&lt;arr.length; j++){</xhtml:p><xhtml:p>				if(arr[index] &gt; arr[j]){</xhtml:p><xhtml:p>					index = j;</xhtml:p><xhtml:p>				}</xhtml:p><xhtml:p>			}</xhtml:p><xhtml:p>			</xhtml:p><xhtml:p>			//找出arr[index]值最小，下标是index</xhtml:p><xhtml:p>			//arr[i] 和 arr[index]交换</xhtml:p><xhtml:p>			if(i!=index){</xhtml:p><xhtml:p>				int temp = arr[i];</xhtml:p><xhtml:p>				arr[i] = arr[index];</xhtml:p><xhtml:p>				arr[index] = temp;</xhtml:p><xhtml:p>			}</xhtml:p><xhtml:p>			</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>	}</xhtml:p></html><plain>	//直接选择排序&#13;
	//基本原理：将待排序的元素分为已排序（初始为空）和未排序两组，依次将未排序的元素中值最小的元素放入已排序的组中。&#13;
	//[3,2,1,5,4]  从小到大排序&#13;
	/*&#13;
	 * 第一次：所有元素都属于未排序   把未排序的元素中的最小值找出来    arr[2] = 1 ，放入已排序组中     和第一个元素交换&#13;
	 * 		[1,2,3,5,4]&#13;
	 * 第二次：已排序的是[1]，未排序的是[2,3,5,4]，把未排序元素中的最小值找出  arr[1]=2，放入已排序组中  &#13;
	 * 		【1,2】，【3,5,4】&#13;
	 * ...&#13;
	 * &#13;
	 */&#13;
	//假设5个元素&#13;
	public static void selectSort(int[] arr){&#13;
		//次数&#13;
		for(int i=0; i&lt;arr.length-1; i++){&#13;
			//第一次，找最小值&#13;
			//假设每一轮的未排序元素的第一个最小&#13;
			int index = i;&#13;
			&#13;
			//找出本轮最小值&#13;
			/*&#13;
			 * int i=0 ,从哪些元素中找最小值  [0]~[4]   j=1,2,3,4&#13;
			 * int i=1，从哪些元素中找最小值[1]~[4]    j=2,3,4&#13;
			 * ...&#13;
			 */&#13;
			for(int j=i+1; j&lt;arr.length; j++){&#13;
				if(arr[index] &gt; arr[j]){&#13;
					index = j;&#13;
				}&#13;
			}&#13;
			&#13;
			//找出arr[index]值最小，下标是index&#13;
			//arr[i] 和 arr[index]交换&#13;
			if(i!=index){&#13;
				int temp = arr[i];&#13;
				arr[i] = arr[index];&#13;
				arr[index] = temp;&#13;
			}&#13;
			&#13;
		}&#13;
	}</plain></notes></topic></topics></children></topic><topic id="0irud7e9dbc6hn5jheeoatlva1" modified-by="" timestamp="1511158065487"><title>（7）数组的扩容</title><notes><html><xhtml:p>	private void kuorong(){</xhtml:p><xhtml:p>		//先扩容</xhtml:p><xhtml:p>		int[] newArray = new int[arr.length*2];</xhtml:p><xhtml:p>		//通过循环把原数组中的内容复制到新数组中</xhtml:p><xhtml:p>		for(int i=0; i&lt;arr.length; i++){</xhtml:p><xhtml:p>			newArray[i] = arr[i];</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>		//把新家的地址记录下来，下次存、取元素都从新家操作，旧家不要了</xhtml:p><xhtml:p>		arr = newArray;</xhtml:p><xhtml:p>	}</xhtml:p></html><plain>	private void kuorong(){&#13;
		//先扩容&#13;
		int[] newArray = new int[arr.length*2];&#13;
		//通过循环把原数组中的内容复制到新数组中&#13;
		for(int i=0; i&lt;arr.length; i++){&#13;
			newArray[i] = arr[i];&#13;
		}&#13;
		//把新家的地址记录下来，下次存、取元素都从新家操作，旧家不要了&#13;
		arr = newArray;&#13;
	}</plain></notes></topic><topic id="7hql5s3jd10vi0j6dq06js9gag" modified-by="" timestamp="1511225497853"><title>（8）数组的元素插入</title><notes><html><xhtml:p>package com.atguigu.array;</xhtml:p><xhtml:p/><xhtml:p>public class MyArrayList {</xhtml:p><xhtml:p>	private int[] arr = new int[5];//装数据</xhtml:p><xhtml:p>	private int total;//记录实际存储的元素的个数</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>	//在index插入数据data</xhtml:p><xhtml:p>	public void insert(int index, int data){</xhtml:p><xhtml:p>		//如果当前数组已满，需要先扩容</xhtml:p><xhtml:p>		if(total &gt;= arr.length){</xhtml:p><xhtml:p>			//(1)先创建一个新的更大的数组</xhtml:p><xhtml:p>			int[] newArray = new int[arr.length*2];</xhtml:p><xhtml:p>			//(2)把原来数组中的数据复制到新数组中</xhtml:p><xhtml:p>			for(int i=0; i&lt;arr.length; i++){</xhtml:p><xhtml:p>				newArray[i] = arr[i];</xhtml:p><xhtml:p>			}</xhtml:p><xhtml:p>			//(3)使得arr指向新数组</xhtml:p><xhtml:p>			arr = newArray;</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//1、先把index右边的元素右移</xhtml:p><xhtml:p>		/*</xhtml:p><xhtml:p>		 * 假设total=3,index=1</xhtml:p><xhtml:p>		 * 现在有值arr[0],arr[1],arr[2]，需要移动的是arr[2],arr[1]</xhtml:p><xhtml:p>		 * 假设total=5,index=1</xhtml:p><xhtml:p>		 * 现在有值arr[0],arr[1],arr[2],arr[3],arr[4]，需要移动的是,arr[4],arr[3],arr[2],arr[1]</xhtml:p><xhtml:p>		 */</xhtml:p><xhtml:p>		for(int i = total-1; i&gt;=index; i--){</xhtml:p><xhtml:p>			//右边的元素=左边的元素</xhtml:p><xhtml:p>			arr[i+1] = arr[i];</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//在index位置插入data</xhtml:p><xhtml:p>		arr[index]= data;</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//元素个数加1</xhtml:p><xhtml:p>		total++;</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p/></html><plain>package com.atguigu.array;&#13;
&#13;
public class MyArrayList {&#13;
	private int[] arr = new int[5];//装数据&#13;
	private int total;//记录实际存储的元素的个数&#13;
	&#13;
	&#13;
	//在index插入数据data&#13;
	public void insert(int index, int data){&#13;
		//如果当前数组已满，需要先扩容&#13;
		if(total &gt;= arr.length){&#13;
			//(1)先创建一个新的更大的数组&#13;
			int[] newArray = new int[arr.length*2];&#13;
			//(2)把原来数组中的数据复制到新数组中&#13;
			for(int i=0; i&lt;arr.length; i++){&#13;
				newArray[i] = arr[i];&#13;
			}&#13;
			//(3)使得arr指向新数组&#13;
			arr = newArray;&#13;
		}&#13;
		&#13;
		//1、先把index右边的元素右移&#13;
		/*&#13;
		 * 假设total=3,index=1&#13;
		 * 现在有值arr[0],arr[1],arr[2]，需要移动的是arr[2],arr[1]&#13;
		 * 假设total=5,index=1&#13;
		 * 现在有值arr[0],arr[1],arr[2],arr[3],arr[4]，需要移动的是,arr[4],arr[3],arr[2],arr[1]&#13;
		 */&#13;
		for(int i = total-1; i&gt;=index; i--){&#13;
			//右边的元素=左边的元素&#13;
			arr[i+1] = arr[i];&#13;
		}&#13;
		&#13;
		//在index位置插入data&#13;
		arr[index]= data;&#13;
		&#13;
		//元素个数加1&#13;
		total++;&#13;
	}&#13;
}&#13;
</plain></notes></topic><topic id="2cot4vvo5epen5d43t4q2d1j11" modified-by="" timestamp="1511225800311"><title>（9）数组的元素删除</title><children><topics type="attached"><topic id="2064tqvuhvfl80rtc3mna8j6o3" modified-by="" timestamp="1511225799130"><title>删除指定位置的元素</title><notes><html><xhtml:p>package com.atguigu.array;</xhtml:p><xhtml:p/><xhtml:p>public class MyArrayList {</xhtml:p><xhtml:p>	private int[] arr = new int[5];//装数据</xhtml:p><xhtml:p>	private int total;//记录实际存储的元素的个数</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>	//删除指定位置的元素</xhtml:p><xhtml:p>	public void delete(int index){</xhtml:p><xhtml:p>		//(1)把index右边的元素左移</xhtml:p><xhtml:p>		/*</xhtml:p><xhtml:p>		 * 假设现在total=3,index =1</xhtml:p><xhtml:p>		 * 有值的是arr[0],arr[1],arr[2]，需要移动的是arr[2]</xhtml:p><xhtml:p>		 * 假设现在total=5,index =1</xhtml:p><xhtml:p>		 * 现在有值arr[0],arr[1],arr[2],arr[3],arr[4]，需要移动的似乎arr[2],arr[3],arr[4]</xhtml:p><xhtml:p>		 */</xhtml:p><xhtml:p>		for(int i = index+1; i&lt;total; i++){</xhtml:p><xhtml:p>			//左边的元素=右边的元素</xhtml:p><xhtml:p>			arr[i-1] = arr[i];</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//(2)把最后一个元素的位置置为“空”（还原到默认值）</xhtml:p><xhtml:p>		arr[total-1] = 0;</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//(3)元素个数减一</xhtml:p><xhtml:p>		total--;</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p/></html><plain>package com.atguigu.array;&#13;
&#13;
public class MyArrayList {&#13;
	private int[] arr = new int[5];//装数据&#13;
	private int total;//记录实际存储的元素的个数&#13;
	&#13;
	//删除指定位置的元素&#13;
	public void delete(int index){&#13;
		//(1)把index右边的元素左移&#13;
		/*&#13;
		 * 假设现在total=3,index =1&#13;
		 * 有值的是arr[0],arr[1],arr[2]，需要移动的是arr[2]&#13;
		 * 假设现在total=5,index =1&#13;
		 * 现在有值arr[0],arr[1],arr[2],arr[3],arr[4]，需要移动的似乎arr[2],arr[3],arr[4]&#13;
		 */&#13;
		for(int i = index+1; i&lt;total; i++){&#13;
			//左边的元素=右边的元素&#13;
			arr[i-1] = arr[i];&#13;
		}&#13;
		&#13;
		//(2)把最后一个元素的位置置为“空”（还原到默认值）&#13;
		arr[total-1] = 0;&#13;
		&#13;
		//(3)元素个数减一&#13;
		total--;&#13;
	}&#13;
}&#13;
</plain></notes></topic><topic id="6teuucg9bvfkmcrb8nb4h34o2q" modified-by="" timestamp="1511226045292"><title>删除指定的元素值</title><notes><html><xhtml:p>package com.atguigu.array;</xhtml:p><xhtml:p/><xhtml:p>public class MyArrayList {</xhtml:p><xhtml:p>	private int[] arr = new int[5];//装数据</xhtml:p><xhtml:p>	private int total;//记录实际存储的元素的个数</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>	//删除指定位置的元素</xhtml:p><xhtml:p>	public void delete(int index){</xhtml:p><xhtml:p>		//(1)把index右边的元素左移</xhtml:p><xhtml:p>		/*</xhtml:p><xhtml:p>		 * 假设现在total=3,index =1</xhtml:p><xhtml:p>		 * 有值的是arr[0],arr[1],arr[2]，需要移动的是arr[2]</xhtml:p><xhtml:p>		 * 假设现在total=5,index =1</xhtml:p><xhtml:p>		 * 现在有值arr[0],arr[1],arr[2],arr[3],arr[4]，需要移动的似乎arr[2],arr[3],arr[4]</xhtml:p><xhtml:p>		 */</xhtml:p><xhtml:p>		for(int i = index+1; i&lt;total; i++){</xhtml:p><xhtml:p>			//左边的元素=右边的元素</xhtml:p><xhtml:p>			arr[i-1] = arr[i];</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//(2)把最后一个元素的位置置为“空”（还原到默认值）</xhtml:p><xhtml:p>		arr[total-1] = 0;</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//(3)元素个数减一</xhtml:p><xhtml:p>		total--;</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>	public int findValue(int value){</xhtml:p><xhtml:p>		//挨个遍历，一共有total，遍历total个</xhtml:p><xhtml:p>		for (int i = 0; i &lt; total; i++) {</xhtml:p><xhtml:p>			if(arr[i] == value){</xhtml:p><xhtml:p>				return i;</xhtml:p><xhtml:p>			}</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>		return -1;</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>	public void deleteValue(int value){</xhtml:p><xhtml:p>		//1、先找到value在数组中的index，这里以第一次找到为准</xhtml:p><xhtml:p>		int index = findValue(value);</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//2、删除index位置的元素</xhtml:p><xhtml:p>		if(index!=-1){</xhtml:p><xhtml:p>			delete(index);</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p/></html><plain>package com.atguigu.array;&#13;
&#13;
public class MyArrayList {&#13;
	private int[] arr = new int[5];//装数据&#13;
	private int total;//记录实际存储的元素的个数&#13;
	&#13;
	//删除指定位置的元素&#13;
	public void delete(int index){&#13;
		//(1)把index右边的元素左移&#13;
		/*&#13;
		 * 假设现在total=3,index =1&#13;
		 * 有值的是arr[0],arr[1],arr[2]，需要移动的是arr[2]&#13;
		 * 假设现在total=5,index =1&#13;
		 * 现在有值arr[0],arr[1],arr[2],arr[3],arr[4]，需要移动的似乎arr[2],arr[3],arr[4]&#13;
		 */&#13;
		for(int i = index+1; i&lt;total; i++){&#13;
			//左边的元素=右边的元素&#13;
			arr[i-1] = arr[i];&#13;
		}&#13;
		&#13;
		//(2)把最后一个元素的位置置为“空”（还原到默认值）&#13;
		arr[total-1] = 0;&#13;
		&#13;
		//(3)元素个数减一&#13;
		total--;&#13;
	}&#13;
	&#13;
	public int findValue(int value){&#13;
		//挨个遍历，一共有total，遍历total个&#13;
		for (int i = 0; i &lt; total; i++) {&#13;
			if(arr[i] == value){&#13;
				return i;&#13;
			}&#13;
		}&#13;
		return -1;&#13;
	}&#13;
	&#13;
	public void deleteValue(int value){&#13;
		//1、先找到value在数组中的index，这里以第一次找到为准&#13;
		int index = findValue(value);&#13;
		&#13;
		//2、删除index位置的元素&#13;
		if(index!=-1){&#13;
			delete(index);&#13;
		}&#13;
	}&#13;
}&#13;
</plain></notes></topic></topics></children></topic><topic id="4pl8fk3hvbia840op4qefss62o" modified-by="" timestamp="1511226041761"><title>（10）在数组中查找某个值的下标</title><notes><html><xhtml:p>package com.atguigu.array;</xhtml:p><xhtml:p/><xhtml:p>public class MyArrayList {</xhtml:p><xhtml:p>	private int[] arr = new int[5];//装数据</xhtml:p><xhtml:p>	private int total;//记录实际存储的元素的个数</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>	//删除指定位置的元素</xhtml:p><xhtml:p>	public void delete(int index){</xhtml:p><xhtml:p>		//(1)把index右边的元素左移</xhtml:p><xhtml:p>		/*</xhtml:p><xhtml:p>		 * 假设现在total=3,index =1</xhtml:p><xhtml:p>		 * 有值的是arr[0],arr[1],arr[2]，需要移动的是arr[2]</xhtml:p><xhtml:p>		 * 假设现在total=5,index =1</xhtml:p><xhtml:p>		 * 现在有值arr[0],arr[1],arr[2],arr[3],arr[4]，需要移动的似乎arr[2],arr[3],arr[4]</xhtml:p><xhtml:p>		 */</xhtml:p><xhtml:p>		for(int i = index+1; i&lt;total; i++){</xhtml:p><xhtml:p>			//左边的元素=右边的元素</xhtml:p><xhtml:p>			arr[i-1] = arr[i];</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//(2)把最后一个元素的位置置为“空”（还原到默认值）</xhtml:p><xhtml:p>		arr[total-1] = 0;</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//(3)元素个数减一</xhtml:p><xhtml:p>		total--;</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>	public int findValue(int value){</xhtml:p><xhtml:p>		//挨个遍历，一共有total，遍历total个</xhtml:p><xhtml:p>		for (int i = 0; i &lt; total; i++) {</xhtml:p><xhtml:p>			if(arr[i] == value){</xhtml:p><xhtml:p>				return i;</xhtml:p><xhtml:p>			}</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>		return -1;</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>	public void deleteValue(int value){</xhtml:p><xhtml:p>		//1、先找到value在数组中的index，这里以第一次找到为准</xhtml:p><xhtml:p>		int index = findValue(value);</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//2、删除index位置的元素</xhtml:p><xhtml:p>		if(index!=-1){</xhtml:p><xhtml:p>			delete(index);</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p/></html><plain>package com.atguigu.array;&#13;
&#13;
public class MyArrayList {&#13;
	private int[] arr = new int[5];//装数据&#13;
	private int total;//记录实际存储的元素的个数&#13;
	&#13;
	//删除指定位置的元素&#13;
	public void delete(int index){&#13;
		//(1)把index右边的元素左移&#13;
		/*&#13;
		 * 假设现在total=3,index =1&#13;
		 * 有值的是arr[0],arr[1],arr[2]，需要移动的是arr[2]&#13;
		 * 假设现在total=5,index =1&#13;
		 * 现在有值arr[0],arr[1],arr[2],arr[3],arr[4]，需要移动的似乎arr[2],arr[3],arr[4]&#13;
		 */&#13;
		for(int i = index+1; i&lt;total; i++){&#13;
			//左边的元素=右边的元素&#13;
			arr[i-1] = arr[i];&#13;
		}&#13;
		&#13;
		//(2)把最后一个元素的位置置为“空”（还原到默认值）&#13;
		arr[total-1] = 0;&#13;
		&#13;
		//(3)元素个数减一&#13;
		total--;&#13;
	}&#13;
	&#13;
	public int findValue(int value){&#13;
		//挨个遍历，一共有total，遍历total个&#13;
		for (int i = 0; i &lt; total; i++) {&#13;
			if(arr[i] == value){&#13;
				return i;&#13;
			}&#13;
		}&#13;
		return -1;&#13;
	}&#13;
	&#13;
	public void deleteValue(int value){&#13;
		//1、先找到value在数组中的index，这里以第一次找到为准&#13;
		int index = findValue(value);&#13;
		&#13;
		//2、删除index位置的元素&#13;
		if(index!=-1){&#13;
			delete(index);&#13;
		}&#13;
	}&#13;
}&#13;
</plain></notes></topic></topics></children></topic><topic id="4gisjc64mcgs5p4sr5esvh0tc7" modified-by="" timestamp="1511226768741"><title>二维数组</title><children><topics type="attached"><topic id="483jqci3096l9mjjujeehsgghk" modified-by="" timestamp="1511226087407"><title>如何声明</title><children><topics type="attached"><topic id="2jhkmrmvojvso1pvtotdd837t1" modified-by="" timestamp="1511226098474"><title>数组类型  数组名;</title><children><topics type="attached"><topic id="2ng3f4r0kel633omabilhtpgqe" modified-by="" timestamp="1511226239286"><title>数组类型是xx[][]</title></topic></topics></children></topic><topic id="4m3q7i2gpnj3c051iaugnjeamb" modified-by="" timestamp="1511226095162"><title>元素的类型[][]  数组名;</title></topic></topics></children></topic><topic id="7j7thb3235agso7qdui70eitu7" modified-by="" timestamp="1511226262853"><title>如何创建二维数组对象及初始化</title><children><topics type="attached"><topic id="0a35kcagp0iksr93q0eja1njjv" modified-by="" timestamp="1511226385331"><title>动态初始化</title><children><topics type="attached"><topic id="2e31huqhdl6s6045qtd413d1pe" modified-by="" timestamp="1511226375377"><title svg:width="500">数组名 = new 元素的数据类型[行长度][每一行的列长度];</title><children><topics type="attached"><topic id="6r951csd5vkfbe8d8etmajnht8" modified-by="" timestamp="1511226382083"><title>每一行的列数相同</title></topic></topics></children></topic><topic id="4po2efje349e61elvgb3cbquuq" modified-by="" timestamp="1511226419377"><title svg:width="500">数组名 = new 元素的数据类型[行长度][];</title><children><topics type="attached"><topic id="1ab4502ircus5iaqebvvio07qp" modified-by="" timestamp="1511226396604"><title>每一行的列数不确定</title></topic><topic id="4lr8g8e8f8683donquaa68r6or" modified-by="" timestamp="1511226415671"><title>每一行的行对象暂时是null</title></topic><topic id="5dbk5f8126g0gt64cbbk6kcc4j" modified-by="" timestamp="1511226437899"><title>创建每一行的行对象，即为行分配空间</title><children><topics type="attached"><topic id="7b7ilnnemu463f5qg0b4457uon" modified-by="" timestamp="1511226454777"><title>数组名[行下标] = new  元素的类型[该行的列数];</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="11kgaavju6f8lsi2jrtb41qr6k" modified-by="" timestamp="1511226272036"><title>静态初始化</title><children><topics type="attached"><topic id="7ufnrtfqqc952ajbplol4a7ke8" modified-by="" timestamp="1511226356385"><title svg:width="500">数组名 = new 元素的数据类型[][]{{x,x,x,x,....},{x,x,x},{x,x,x,x,x,x,x},.....};</title><children><topics type="attached"><topic id="1k6316bf1ghdehlss764dm8neg" modified-by="" timestamp="1511226331625"><title>{}中嵌套{}，里面的一个{}代表一行</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="6pbiji96t0ic77p1dr68p6424j" modified-by="" timestamp="1511226482802"><title>二维数组的长度，即行数</title><children><topics type="attached"><topic id="5i2r4i4oifbj1kujv3ul39o8jj" modified-by="" timestamp="1511226490353"><title>二维数组名.length</title></topic></topics></children></topic><topic id="2al4cpihrd28vmlfts00s0csqr" modified-by="" timestamp="1511226497943"><title>二维数组的行对象</title><children><topics type="attached"><topic id="1baiav4j11jq0b1nomtmo421r3" modified-by="" timestamp="1511226555460"><title>二维数组名[行下标]</title><children><topics type="attached"><topic id="6galqbrni9mpk9jbpt4f2m80vo" modified-by="" timestamp="1511226573657"><title>行下标的范围[0,二维数组名.length-1]</title></topic></topics></children></topic></topics></children></topic><topic id="00g5hg5ltegbsembjipqr607qe" modified-by="" timestamp="1511226517368"><title>二维数组的每一行的列数</title><children><topics type="attached"><topic id="1njseph02ihs3h47p5emks1m2c" modified-by="" timestamp="1511226523046"><title>二维数组名[行下标].length</title></topic></topics></children></topic><topic id="63lghte2dka642ukuusq5kg53f" modified-by="" timestamp="1511226547118"><title>二维数组的每一个元素</title><children><topics type="attached"><topic id="12klj7o485jeopg2hu63jskdb4" modified-by="" timestamp="1511226576176"><title>二维数组名[行下标][列下标]</title><children><topics type="attached"><topic id="1psls4ldtooshs0kdqkns9o8tf" modified-by="" timestamp="1511226599644"><title>注意列下标</title><children><topics type="attached"><topic id="5qbi4p5jouoo4ddrdv95fqdun3" modified-by="" timestamp="1511226596977"><title>每一行的列下标的范围可能是不一样</title></topic><topic id="5995okv3o47p7vslmm3d11im0q" modified-by="" timestamp="1511226608797"><title>[0, 二维数组名[行下标].length)</title></topic></topics></children></topic></topics></children></topic><topic id="7v4o6ph4q3s8qpvtrr57qgt9hq" modified-by="" timestamp="1511226553855"><title>二维数组名[行下标][列下标] = 值</title></topic></topics></children></topic><topic id="3fbvr9h1q0kq4shm6fi043lce5" modified-by="" timestamp="1511226687060"><title>二维数组的遍历</title><children><topics type="attached"><topic id="56oca06pcvfsqr60a95stv87g3" modified-by="" timestamp="1511226629858"><title>for</title><children><topics type="attached"><topic id="4g55ruu8fagvh0qfapj2q8jh4f" modified-by="" timestamp="1511226684865"><title>for(int i=0; i&lt;数组名.length; i++){&#13;
	for(int j=0; j&lt;数组名[i].length; j++){&#13;
			数组名[i][j]表示一个元素&#13;
	}&#13;
}</title></topic></topics></children></topic><topic id="6ggsijtbopfnklcvl493p23tn3" modified-by="" timestamp="1511226693725"><title>增强for</title><children><topics type="attached"><topic id="3k7edhmt6hd4js82jsh1j3j6i5" modified-by="" timestamp="1511226741152"><title>for(行类型  hang : 二维数组名){&#13;
	for(元素类型  lie : hang){&#13;
            lie就是代表每一个元素&#13;
    }&#13;
}</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic branch="folded" id="37s5r0ja2nd89md1ki4doc73sa" modified-by="" timestamp="1511228016709"><title>数组的内存图</title><children><topics type="attached"><topic branch="folded" id="7v0pevvj6vat54couatdv7f5i1" modified-by="" timestamp="1511227073393"><title>一维数组</title><children><topics type="attached"><topic branch="folded" id="440ul21evsljpasjomqg079pp3" modified-by="" timestamp="1511227061899"><title>元素是基本数据类型</title><children><topics type="attached"><topic id="61qtmiq34tefjv2tmb5l8pjiuh" modified-by="" timestamp="1511227059160"><xhtml:img xhtml:src="xap:attachments/5vkghi14jvlk65fppg6o4hfa9p.png"/></topic></topics></children></topic><topic id="0sj8sarfq12clu0pskqrdjo0fp" modified-by="" timestamp="1511227069664"><title>元素是引用数据类型，又称为对象数组</title><children><topics type="attached"><topic id="1bb4rrgl0kfvae3nprcq9gg774" modified-by="" timestamp="1511227069622"><xhtml:img xhtml:src="xap:attachments/6s2ns7qd47cat28qbd7bscqqvl.png"/></topic></topics></children></topic></topics></children></topic><topic id="0or7lh2uvt624munh8l3clrv3r" modified-by="" timestamp="1511227446422"><title>二维数组</title><children><topics type="attached"><topic id="0jd1dhnlebqhbgjbmcfgpmc45a" modified-by="" timestamp="1511227439230"><title>元素是基本数据类型</title><children><topics type="attached"><topic id="584t7brk6ic6nnm2knksfpt83s" modified-by="" timestamp="1511227243774"><title>规则</title><children><topics type="attached"><topic id="55h04mmioc27vlhabadfkne3dq" modified-by="" timestamp="1511227243738"><xhtml:img xhtml:src="xap:attachments/2f61lgrpcdvhikrrsd8j1qiicm.png"/></topic></topics></children></topic><topic id="4vl8lloa4gc5cvimsif4j1ufj9" modified-by="" timestamp="1511227444533"><title>不规则</title><children><topics type="attached"><topic id="5lv9fiadke44o5v3cki75q7jrr" modified-by="" timestamp="1511227444487"><xhtml:img xhtml:src="xap:attachments/7i6p41u8u8qol1cvf996b479bl.png"/></topic></topics></children></topic></topics></children></topic><topic id="235eu8ri1vn6qdd46lqg102k5h" modified-by="" timestamp="1511228008253"><title>元素是引用数据类型</title><children><topics type="attached"><topic id="36vjsjpug2rtm902patibtcis0" modified-by="" timestamp="1511227786346"><title>规则</title><children><topics type="attached"><topic id="1cki1v0d1vabmu9oe08phl5jsu" modified-by="" timestamp="1511227786282"><xhtml:img xhtml:src="xap:attachments/5huir3mgcdvsebp1m5h6t99ls7.png"/></topic></topics></children></topic><topic id="1mk7sal9l95lbn7t0mkq12kd3g" modified-by="" timestamp="1511228012031"><title>不规则</title><children><topics type="attached"><topic id="1k6p1nn9tr26ladjovrv8me4go" modified-by="" timestamp="1511228011968"><xhtml:img xhtml:src="xap:attachments/57tshhrtufepo7cgob4ptrhpdj.png"/></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="7fn2q400tmnimohqjg0586tvdk" modified-by="" timestamp="1511228033567"><title>数组的工具类</title><children><topics type="attached"><topic id="7450298378f359b1hg583tg7gn" modified-by="" timestamp="1511228030454"><title>java.util.Arrays</title></topic><topic id="0eosksm4i6g3dkr01r89fqtlje" modified-by="" timestamp="1511228187056"><title>静态方法</title><children><topics type="attached"><topic id="0niishdadh19qqof9q0ncr5vo9" modified-by="" timestamp="1511228092081"><title>（1）int   Arrays.binarySearch(int[] a ,int key)</title><children><topics type="attached"><topic id="6udpdqupihesg1bp6ec2onvu9r" modified-by="" timestamp="1511228073939"><title>在a数组中查找key的下标</title></topic><topic id="0ff4inv0280jdmjkaav4lca227" modified-by="" timestamp="1511228091168"><title svg:width="500">（1）数组a必须是有序的，否则结果不一定正确</title></topic><topic id="0clhu40ujjtru40hvsmmggrc7u" modified-by="" timestamp="1511228124982"><title svg:width="500">（2）如果key在a中存在，就返回它的下标，如果不存在，返回(-(插入点)-1)</title></topic></topics></children></topic><topic id="5lhrqk3rjslcurvo5oqejsokqm" modified-by="" timestamp="1511228147358"><title>（2）Arrays.fill(int[] a, int value)</title><children><topics type="attached"><topic id="286jus2beof50vb6qj9src98e6" modified-by="" timestamp="1511228161037"><title>给数组a的每一个元素都赋值为value</title></topic></topics></children></topic><topic id="0ncql4hb466n8uoas5q770t4gl" modified-by="" timestamp="1511228176458"><title>（3）Arrays.sort(int[])</title><children><topics type="attached"><topic id="74k18cltkl7dct7dkou8t6ma4i" modified-by="" timestamp="1511228185330"><title>排序，从小到大</title></topic></topics></children></topic><topic id="2d8uhmhnbqlpg1si6pp9o8apn8" modified-by="" timestamp="1511228201415"><title>（4）String  Arrays.toString(int[] a)</title><children><topics type="attached"><topic id="0a0ur8b5mji0b2hqan1n4ssl26" modified-by="" timestamp="1511228221587"><title svg:width="500">把数组的元素列表用字符串返回，形式[元素1，元素2，元素3.。。]</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic branch="folded" id="0t3lu72s5et0hk9qo5sgmspuua" modified-by="" timestamp="1511228358974"><title>命令行参数</title><children><topics type="attached"><topic id="43k8upf501d2u3iek0kqnloj67" modified-by="" timestamp="1511228248345"><title>主方法的参数</title></topic><topic id="766lki8udia5f7p0m2ppjm6a4d" modified-by="" timestamp="1511228258525"><title>java命令</title><children><topics type="attached"><topic id="1k4g3qv9hjiu9uo6d3l7kprc2u" modified-by="" timestamp="1511228278460"><title>java   包.类名   参数1  参数2   参数3 ....</title><children><topics type="attached"><topic id="0ht527tesof4baj7b396jtiscl" modified-by="" timestamp="1511228288447"><title>参数之间使用空格</title></topic></topics></children></topic></topics></children></topic><topic id="7rncoehh86ce8difd1h1fkstsn" modified-by="" timestamp="1511228339535"><title>eclipse</title><children><topics type="attached"><topic id="699f8pfi5nfpfp5hvs0v1cto5k" modified-by="" timestamp="1511228339482"><xhtml:img xhtml:src="xap:attachments/5e9ev25kilep8qj08nhbaqm0r5.png"/></topic></topics></children></topic></topics></children></topic><topic id="5hn2ofgsjo6adtq1bgig653gff" modified-by="" timestamp="1511228434610"><title>可变参数</title><children><topics type="attached"><topic id="5kuk7vdmpab576h3v31kr6ibgb" modified-by="" timestamp="1511228368248"><title>可变参数属于形参</title></topic><topic id="3ofgr3jvg1kd5f7e3tkja8n0jq" modified-by="" timestamp="1511228399607"><title>要求</title><children><topics type="attached"><topic id="1d3r7dsssipcsfg0prq40163s5" modified-by="" timestamp="1511228386449"><title svg:width="500">一个方法只能有一个可变参数，而且只能是最后一个</title></topic><topic id="7h6dvuv10327doulua18kd77bu" modified-by="" timestamp="1511228398889"><title>在声明它的方法中，当做数组处理</title></topic><topic id="422o66g6qs595bc28f79rjfjaf" modified-by="" timestamp="1511228428499"><title svg:width="500">对于调用这个方法者，可变参数的位置可以传，[0~n]个实参，也可以传对应类型数组对象</title></topic></topics></children></topic><topic id="52g60br5mgigvdi8ls66pu8gl4" modified-by="" timestamp="1511228501925"><title>可变参数的重载问题</title><children><topics type="attached"><topic id="1htlbs3bnbgm63aes88tl1iiu4" modified-by="" timestamp="1511228785110"><title>对于编译器来说不属于重载</title><children><topics type="attached"><topic id="3mrljrv4vh8s06vrh4vhnnv06v" modified-by="" timestamp="1511228783208"><title>不属于重载</title><children><topics type="attached"><topic id="0fjdpt6mg7melhbt2aurbg0vn0" modified-by="" timestamp="1511228783161"><title>	public static void main(String[] args) {&#13;
		System.out.println(getSum(1));&#13;
	}&#13;
	&#13;
	public static int getSum(int... args){&#13;
		return 0;&#13;
	}&#13;
	public static int getSum(int a,int... args){&#13;
		return 0;&#13;
	}</title><children><topics type="attached"><topic id="1c99stqnl6bb7p961pntnk8e9g" modified-by="" timestamp="1511228663740"><title>如果传一个整数时，不知道用谁好</title></topic></topics></children></topic><topic id="3hq1esshevbcfkepp585qvcf5v" modified-by="" timestamp="1511228781432"><title>	public static int getSum(int... args){&#13;
		return 0;&#13;
	}&#13;
	&#13;
	public static int getSum(int[] args){&#13;
		&#13;
	}</title><children><topics type="attached"><topic id="78o3rfo70fen2knviofsqvhdcr" modified-by="" timestamp="1511228554520"><title>但是它俩不完全等价</title><children><topics type="attached"><topic id="5vl9gcu1gfr5aohqo7uhmoibv5" modified-by="" timestamp="1511228551571"><title svg:width="500">因为int... args既可以传数组对象，又可以传 n个元素值</title></topic><topic id="1m78p5916jkd0odqum2too0f9n" modified-by="" timestamp="1511228564330"><title>int[]只能传数组对象</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="4fsvvgsqacpje3m8q5piqvc2e5" modified-by="" timestamp="1511228797921"><title>属于重载</title><children><topics type="attached"><topic id="3masd48vmacuq8d14a6bj0mk1t" modified-by="" timestamp="1511228801920"><title>	public static void main(String[] args) {&#13;
		System.out.println(getSum(1));&#13;
	}&#13;
	&#13;
	public static int getSum(int... args){&#13;
		return 0;&#13;
	}&#13;
	public static int getSum(int a){&#13;
		System.out.println("一个参数");&#13;
		return 0;&#13;
	}</title><children><topics type="attached"><topic id="27e61nl4f7qoobbi1pco98jr36" modified-by="" timestamp="1511228811276"><title>优先于确定参数个数</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><title>数组</title></sheet><sheet id="6eivvrk9du1r4j1cbiars0o465" modified-by="" style-id="4tu1p48ubmesvqad3rkk4o2in5" theme="xminddefaultthemeid" timestamp="1515820146780"><topic id="2ul034ag8lhhv78kr16cp16oh5" modified-by="" structure-class="org.xmind.ui.logic.right" timestamp="1512100303087"><title>JavaSE  API</title><extensions><extension provider="org.xmind.ui.map.unbalanced"><content><right-number>-1</right-number></content></extension></extensions><children><topics type="attached"><topic branch="folded" id="10j279t44jjt17j90bkpu6cjnn" modified-by="" timestamp="1511919244492"><title>java.lang.Object</title><children><topics type="attached"><topic id="2pbe3o6p4fgn4r1rddl177otrm" modified-by="" timestamp="1511572730743"><title>它是所有类型的根父类</title></topic><topic id="2g7488jcq0ta9g4ohg5c4sno65" modified-by="" timestamp="1511572759091"><title svg:width="500">一个类如果没有显式声明它的父类，这个类的直接父类就是Object</title></topic><topic id="1ud7hgpl9akkjeevv16ubi4a3s" modified-by="" timestamp="1511572813632"><title>理解</title><children><topics type="attached"><topic id="5rvsi084966cn5o5nphio6o14i" modified-by="" timestamp="1511572789226"><title svg:width="500">（1）Object类的所有方法，在所有对象中都有，包括数组对象</title></topic><topic id="0j9gmcogfotcpdensn97gkjhmp" modified-by="" timestamp="1511572795407"><title svg:width="500">（2）Object类的变量可以接受任意类型的对象&#13;
   Object类型的形参可以接受任意类型的对象作为实参&#13;
   Object[]类型的数组可以接受任意类型的对象作为它的元素</title></topic><topic id="7fk7a49ndojd5sfhhhk2d5fiki" modified-by="" timestamp="1511572828260"><title svg:width="500">（3）所有对象创建时，都会调用Object的无参构造</title></topic></topics></children></topic><topic id="1gqsf04bqb67boaqojfm0k50l8" modified-by="" timestamp="1511573316944"><title>方法</title><children><topics type="attached"><topic id="7snsivgmdfhe97e380tk13v1lm" modified-by="" timestamp="1511572837545"><title>（1）无参构造</title><children><topics type="attached"><topic id="5v31pq967mgh69tkmdi3j9n2kb" modified-by="" timestamp="1511572847903"><title>Object() </title><children><topics type="attached"><topic id="1970uovu7fqt3onrt93essiicd" modified-by="" timestamp="1511572849316"><title>所有对象创建时，都会调用Object的无参构造</title></topic></topics></children></topic></topics></children></topic><topic id="0j5osu03hep3385mg3los44t2u" modified-by="" timestamp="1511572876178"><title svg:width="500">（2）protected Object clone() throws CloneNotSupportedException</title><children><topics type="attached"><topic id="7bq0vqgeb145s8utiot89h9udc" modified-by="" timestamp="1511572929877"><title svg:width="500">如果子类要支持克隆，子类需要实现Cloneable接口，否则报CloneNotSupportedException</title></topic></topics></children></topic><topic id="2qn1o2oe0ppqkaqaototo854l8" modified-by="" timestamp="1511573358611"><title>（3）public boolean equals(Object obj)</title><children><topics type="attached"><topic id="2hb8e28a8i7jj2n4ejr4g0dolv" modified-by="" timestamp="1511572968855"><title>指示其他某个对象obj是否与此对象this“相等”。 </title></topic><topic id="2hrg2vt6go95ou9mvvlq1ud8qp" modified-by="" timestamp="1511572994112"><title svg:width="500">Object中的equals，等价于“==”比较，比较的是对象的地址</title></topic><topic id="14fkse5dqrtc7g5gfnc8smk2jl" modified-by="" timestamp="1511573014100"><title svg:width="500">如果子类需要比较的是属性的内容，那么一定要重写这个方法</title></topic></topics></children><marker-refs><marker-ref marker-id="flag-red"/></marker-refs></topic><topic id="3eq14iejp9ih6a7kisbd80a5qa" modified-by="" timestamp="1511573360548"><title>（4）public int hashCode()</title><children><topics type="attached"><topic id="2qi9cbg6ciclqturd1k3cj3m9g" modified-by="" timestamp="1511573050728"><title svg:width="500">在Object中默认这个方法返回的是 和“地址”相关的值</title></topic><topic id="10ehkgmn6b70dii0bk37s1ap6t" modified-by="" timestamp="1511573095320"><title svg:width="500">如果重写了equals，那么必须重写hashCode方法，而且参与equals比较的属性，一定要参与hashCode的计算</title></topic><topic id="5emrkq7haub70p1oeqf7b6jsu2" modified-by="" timestamp="1511573111394"><title>它俩的关系：</title><children><topics type="attached"><topic id="449fn08uo34f243c71nfdkh92c" modified-by="" timestamp="1511573127595"><title svg:width="500">两个对象的equals()返回true，两个对象的hashCode值？一定相等&#13;
两个对象的hashCode值不相等，两个对象equals方法结果？一定不相等&#13;
两个对象的hashCode值相等，两个对象equals方法结果？不一定相等</title></topic></topics></children></topic></topics></children><marker-refs><marker-ref marker-id="flag-red"/></marker-refs></topic><topic id="2fe74f18ccdbapsnk8p26nv77u" modified-by="" timestamp="1511573370292"><title>（5）public final Class&lt;?&gt; getClass()</title><children><topics type="attached"><topic id="246s0tuejfhcedpoo6vnk7qfas" modified-by="" timestamp="1511573191375"><title>返回某个对象的运行时类型，而不是编译时类型</title></topic></topics></children><marker-refs><marker-ref marker-id="flag-red"/></marker-refs></topic><topic id="449j1nkd7eq74brfemqlu6dg9r" modified-by="" timestamp="1511573218908"><title svg:width="500">（6）protected void finalize() throws Throwable</title><children><topics type="attached"><topic id="6c1p74qcbussagac1kg1ctvnkc" modified-by="" timestamp="1511573243610"><title svg:width="500">当这个对象被垃圾回收机制回收之前调用，而且只会调用一次</title></topic></topics></children></topic><topic id="59e58fnm23srfjaa6ip4pvan17" modified-by="" timestamp="1511573364450"><title>（7）public String toString()</title><children><topics type="attached"><topic id="2uc5fa1q86bnmgpdasjud9dc45" modified-by="" timestamp="1511573293517"><title svg:width="500">在Object中默认返回的是   这个对象的运行是类型@这个对象的hash值的十六进制表现形式</title></topic><topic id="0au2f6p4e26pi51shcohmgs6nj" modified-by="" timestamp="1511573300336"><title>子类完全可以重写</title></topic></topics></children><marker-refs><marker-ref marker-id="flag-red"/></marker-refs></topic><topic id="0am56jtvj639bcqr39de833us3" modified-by="" timestamp="1511573344506"><title svg:width="500">（8）剩下的notify,notifyAll和wait在多线程中使用</title></topic></topics></children></topic></topics></children></topic><topic branch="folded" id="14biqn6a09tajp5g7kdv67kb5d" modified-by="" timestamp="1511920346661"><title>包装类&#13;
java.lang</title><children><topics type="attached"><topic id="43vbdobctmil05gmjveriige6m" modified-by="" timestamp="1511919332472"><title>装箱与拆箱</title><children><topics type="attached"><topic id="4hjun1sjh4h5dns7ne7dthkkrm" modified-by="" timestamp="1511919329086"><title>装箱</title><children><topics type="attached"><topic id="15nmi0nnnkb26das6g4952s87i" modified-by="" timestamp="1511919287345"><title>JDK1.5之前手动装箱</title><children><topics type="attached"><topic id="70hvu1fjp6895ebdtu3fltqium" modified-by="" timestamp="1511919298846"><title>Integer i = new Integer(整数);</title></topic></topics></children></topic><topic id="6qsas6gcaf0lo6vlpf8b262vjq" modified-by="" timestamp="1511919305412"><title>JDK1.5之后自动装箱</title><children><topics type="attached"><topic id="2uebqi4mbramr9va3rml41hni7" modified-by="" timestamp="1511919316288"><title>Ineteger i = 整数;</title></topic></topics></children></topic></topics></children></topic><topic id="0sd57rifjit10fia8027nei0f4" modified-by="" timestamp="1511919451471"><title>拆箱</title><children><topics type="attached"><topic id="42t8krg1qs4iv2m0041gpptpi0" modified-by="" timestamp="1511919430078"><title>JDK1.5之前手动拆箱</title><children><topics type="attached"><topic id="0lcfs7f3l3980019r6cfj3vof8" modified-by="" timestamp="1511919447952"><title>Integer i = new Integer(整数);&#13;
int num = i.intValue();</title></topic></topics></children></topic><topic id="24apvr47o6i9l0515fmle501sq" modified-by="" timestamp="1511919475344"><title>JDK1.5之后自动拆箱</title><children><topics type="attached"><topic id="1rh7pnkm4hof2e83tu783nkk9q" modified-by="" timestamp="1511919480434"><title>Integer i = new Integer(整数);&#13;
int num = i;</title></topic></topics></children></topic></topics></children></topic><topic id="0qfauc9e6fpn845mif8441i0uf" modified-by="" timestamp="1511919353770"><title svg:width="500">原则：只能是对应的包装类和基本数据类型之间进行转换</title></topic></topics></children></topic><topic id="3ookc301uqhcvj2cp54hdnr2bh" modified-by="" timestamp="1511919405715"><title>对应的关系</title><children><topics type="attached"><topic id="4cjhht23v9vujn5k8t3cr0qsc4" modified-by="" timestamp="1511919365588"><title>byte</title><children><topics type="attached"><topic id="1ql5kqquue92s33hb36jmucd82" modified-by="" timestamp="1511919367998"><title>Byte</title></topic></topics></children></topic><topic id="5nolfbmumk64kta9hfsrusnfn5" modified-by="" timestamp="1511919370865"><title>short</title><children><topics type="attached"><topic id="3ggsha1ktobb8ohtmfu10e84ed" modified-by="" timestamp="1511919373045"><title>Short</title></topic></topics></children></topic><topic id="1a2i46geu5fcqfdrvnq5dg1dkk" modified-by="" timestamp="1511919375518"><title>int</title><children><topics type="attached"><topic id="3aklhutqkoca358ln7adt0vg8o" modified-by="" timestamp="1511919378247"><title>Integer</title></topic></topics></children></topic><topic id="0mbpha6qrnv4eq7v6bjcvroqqb" modified-by="" timestamp="1511919381021"><title>long</title><children><topics type="attached"><topic id="2rarbhbcpgejjja3mid7rm83f2" modified-by="" timestamp="1511919384215"><title>Long</title></topic></topics></children></topic><topic id="6h07pu0tfmrb970mqqcs7e7oh7" modified-by="" timestamp="1511919388684"><title>char</title><children><topics type="attached"><topic id="6tae47jd5irhjd2bm2pj2dadfl" modified-by="" timestamp="1511919392373"><title>Character</title></topic></topics></children></topic><topic id="2n8raqp6djasu37rj40ggm989g" modified-by="" timestamp="1511919396914"><title>float</title><children><topics type="attached"><topic id="3ckrtdb1m0k3v52320dgjal35a" modified-by="" timestamp="1511919399146"><title>Float</title></topic></topics></children></topic><topic id="649ckh6qncfmu8i3h6st24bggf" modified-by="" timestamp="1511919402089"><title>double</title><children><topics type="attached"><topic id="763l4smltp9e7u5anlh49b93qi" modified-by="" timestamp="1511919405436"><title>Double</title></topic></topics></children></topic><topic id="6rhd0f4kb131j50ggmiksnqjj9" modified-by="" timestamp="1511919409428"><title>boolean</title><children><topics type="attached"><topic id="0hb94u6pqotap3ceubqqp53p7o" modified-by="" timestamp="1511919414528"><title>Boolean</title></topic></topics></children></topic></topics></children></topic><topic id="12vmnki2rn22jfojc9vmqtv2gk" modified-by="" timestamp="1511919921267"><title>其他方法</title><children><topics type="attached"><topic id="57od12mblm26serhqjs16nb5e2" modified-by="" timestamp="1511919832844"><title>字符串与基本数据类型的转换</title><marker-refs><marker-ref marker-id="flag-red"/><marker-ref marker-id="star-red"/></marker-refs><children><topics type="attached"><topic id="3a1hou9skr1jaoeskda5shs3eq" modified-by="" timestamp="1511919768371"><title svg:width="500">public static int parseInt(String s)throws NumberFormatException</title><children><topics type="attached"><topic id="5fd36vqhr445vsursln8r94633" modified-by="" timestamp="1511919663651"><title>如果包含字母等非数字字符，会报错</title></topic></topics></children></topic><topic id="46vf22mskdup3ohcfl1pav8qiv" modified-by="" timestamp="1511919770017"><title svg:width="500">public static int parseInt(String s, int radix)throws NumberFormatException</title><children><topics type="attached"><topic id="2frag33kdkqap1t2e7bsh3detd" modified-by="" timestamp="1511919681206"><title>可以包含字母，但是要在基数范围内</title></topic><topic id="7hhrpddlt5r0t2335nm61f8asi" modified-by="" timestamp="1511919727698"><title svg:width="500">例如基数radix是20，可以包含的范围是0-9,a,b,c,d,e,f,g,h,i,j</title></topic></topics></children></topic><topic id="0la12jp1e6r6k4snk2n0kdu1lf" modified-by="" timestamp="1511919766216"><title svg:width="500">public static Integer valueOf(String s)throws NumberFormatException</title></topic><topic id="273qdvokfl4orfovik8s216sae" modified-by="" timestamp="1511919786550"><title>public static Integer valueOf(String s,&#13;
                              int radix)&#13;
                       throws NumberFormatException</title></topic></topics></children></topic><topic id="16s3oj3veurt1gt174ouqqfiet" modified-by="" timestamp="1511919902051"><title>像Integer中</title><children><topics type="attached"><topic id="06ln65897kp1c16rdbq2od8nqg" modified-by="" timestamp="1511919867257"><title>public static String toBinaryString(int i)</title><children><topics type="attached"><topic id="2fqd533mdmjcab1vasctjbfvep" modified-by="" timestamp="1511919873378"><title>二进制形式</title></topic></topics></children></topic><topic id="4f7ak25f0f0p562akcb6lml5fa" modified-by="" timestamp="1511919884224"><title>public static String toOctalString(int i)</title><children><topics type="attached"><topic id="1khhkkqftqug6v0goekl4de4cj" modified-by="" timestamp="1511919894507"><title>八进制形式</title></topic></topics></children></topic><topic id="3j8tv75fsk4h4vc1ps5cpl94fu" modified-by="" timestamp="1511919904219"><title>public static String toHexString(int i)</title><children><topics type="attached"><topic id="3alsag3m2tu1fa5d8ku3vpbbfl" modified-by="" timestamp="1511919910319"><title>十六进制形式</title></topic></topics></children></topic></topics></children></topic><topic id="1cabbic9b4svntqj311sibcbbi" modified-by="" timestamp="1511919981962"><title>像Character中</title><children><topics type="attached"><topic id="4conlbad3hvvvh2gr6i1am421a" modified-by="" timestamp="1511919984676"><title>public static char toLowerCase(char ch)</title><children><topics type="attached"><topic id="3fq6l97veurcf9rhpvsrf3fmdf" modified-by="" timestamp="1511919990008"><title>转小写</title></topic></topics></children></topic><topic id="6otan9lui3t8qnmgsgqn1jhkoc" modified-by="" timestamp="1511919990404"><title>public static char toUpperCase(char ch)</title><children><topics type="attached"><topic id="63nd637823qi8rmqitmjuncg1j" modified-by="" timestamp="1511919992873"><title>转大写</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="0pa1u1qas8njs2dg6oirjp0ur7" modified-by="" timestamp="1511920256663"><title>包装类对象的缓存问题（常量对象）</title><children><topics type="attached"><topic id="32j2jsup1boh6v9d2cr1nbo85r" modified-by="" timestamp="1511920051872"><title>Byte,Short,Integer,Long</title><children><topics type="attached"><topic branch="folded" id="4v8dn3ol2qrt5jn8frg155ue37" modified-by="" timestamp="1511920058225"><title>-128~127</title></topic></topics></children></topic><topic id="68njg2ao47che8v4okmt7sqhm4" modified-by="" timestamp="1511920223526"><title>Float,Double</title><children><topics type="attached"><topic id="55knjtsl1bq4hgk32qhqjulv81" modified-by="" timestamp="1511920230638"><title>没有缓存</title></topic></topics></children></topic><topic id="4shignrtg2hrovu6igetv8tufc" modified-by="" timestamp="1511920249461"><title>Character</title><children><topics type="attached"><topic id="4ed5gui4a9tdr6aam1a2ob7ceh" modified-by="" timestamp="1511920256431"><title>0~127</title></topic></topics></children></topic><topic id="2svngppcr0aousvdic8tigkkgc" modified-by="" timestamp="1511920263029"><title>Boolean</title><children><topics type="attached"><topic id="3pi7id9v4uav4afjfditcjg043" modified-by="" timestamp="1511920262766"><title>true</title></topic><topic id="4899snbseipib74mivnf7ddarf" modified-by="" timestamp="1511920266687"><title>false</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic branch="folded" id="4v8n48u8qtcslu3npop5ju4r7g" modified-by="" timestamp="1515820030379"><title>java.lang.String</title><children><topics type="attached"><topic id="1de1hgjmfi5mhg6u887b4gcdu8" modified-by="" timestamp="1511920462248"><title>字符串类型的特点</title><children><topics type="attached"><topic id="63sm0jv4b1itplpu9jdr8kgicq" modified-by="" timestamp="1511920354137"><title>1、不能被继承</title><children><topics type="attached"><topic id="2ru5mg1u9eklbbqrk7ttpalcta" modified-by="" timestamp="1511920369501"><title>因为String是final修饰的类</title></topic></topics></children></topic><topic id="1qr0261lp7ns9eetdmjsfnqe4e" modified-by="" timestamp="1511920388073"><title svg:width="500">2、字符串对象是常量对象，一旦创建就不能修改，一旦修改就是新对象</title></topic><topic id="2k1h5u99lc8b3phjcs01up547h" modified-by="" timestamp="1511920482775"><title svg:width="500">3、因为字符串对象是常量对象，那么可以共享，字符串常量对象是在常量池中</title><children><topics type="attached"><topic id="5uupursohrqlchumt0fgsk6hq3" modified-by="" timestamp="1511920508157"><title>常量池在哪里</title><children><topics type="attached"><topic id="7bl0e9kdoahpefsoc75dvchrm7" modified-by="" timestamp="1511920496205"><title>JDK1.6，方法区</title></topic><topic id="5jqtj8mg4ji07ojop76tm2vs7f" modified-by="" timestamp="1511920507885"><title>JDK1.7，堆</title></topic><topic id="5s4mo6a03it0kbb797imute42e" modified-by="" timestamp="1511920513240"><title>JDK1.8，元空间</title></topic></topics></children></topic></topics></children></topic><topic id="7ek0j9up5js4ich5e62td49t9d" modified-by="" timestamp="1511920450934"><title>4、任何字符串字面量都是String的对象</title></topic><topic id="45skslraki1t52vft6ineoebh9" modified-by="" timestamp="1511920460658"><title>5、字符串底层使用字符数组存储</title></topic><topic id="7e9897rv790rsgmrq65bvnv4n8" modified-by="" timestamp="1511920475832"><title>6、字符数组是private final修饰符</title></topic></topics></children></topic><topic id="3sipceqie7g9sp24b0ss1vogja" modified-by="" timestamp="1511920608142"><title>拼接和比较</title><children><topics type="attached"><topic branch="folded" id="6q4ipc65lleqt8fd3b0aac7di8" modified-by="" timestamp="1511920776296"><title>1、创建对象的个数</title><children><topics type="attached"><topic id="0lk1b6962377ku2sfuan1fv59p" modified-by="" timestamp="1511920562380"><title>String str1 = "hello";&#13;
String str2 = "hello";</title><children><topics type="attached"><topic id="75u81sh3g3g9a8ug46a57gh8g0" modified-by="" timestamp="1511920569648"><title>一个，在常量池</title></topic></topics></children></topic><topic id="6v739ujm814t12dk8oggfmmrmr" modified-by="" timestamp="1511920585748"><title>String str1 = new String("hello");&#13;
String str2 = new String("hello");</title><children><topics type="attached"><topic id="0t8o0jkjv0hctip63vmcnm6qkh" modified-by="" timestamp="1511920596230"><title>三个</title><children><topics type="attached"><topic id="0tgn2j7jp7l4lp5e437f2kl5n5" modified-by="" timestamp="1511920595988"><title>一个在常量池</title></topic><topic id="799of2p517dpu834lf73knpoa5" modified-by="" timestamp="1511920600597"><title>两个在堆中</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="3o454c9jnli355jumjr09lk07j" modified-by="" timestamp="1511920781475"><title>2、拼接和比较</title><children><topics type="attached"><topic id="2kb03pcrj50nmfcmvrecim8kcc" modified-by="" timestamp="1511920688570"><title svg:width="500">原则：+两边都是常量，结果也是常量，+两边有一个是变量，结果就不是常量，在堆中，如果结果使用了intern()，那么是常量</title><notes><html><xhtml:p>	@Test</xhtml:p><xhtml:p>	public void test3(){</xhtml:p><xhtml:p>		String str1 = "hello";</xhtml:p><xhtml:p>		String str2 = "java";</xhtml:p><xhtml:p>		String str3 = "hellojava";</xhtml:p><xhtml:p>		String str4 = "hello" + "java";//常量与常量拼接，还是常量</xhtml:p><xhtml:p>		String str5 = "hello" + str2;//常量与变量拼接，结果在堆中</xhtml:p><xhtml:p>		String str6 = str1 + str2;//变量与变量拼接，结果也在堆中</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		System.out.println("str3 == str4  " + (str3 == str4));//true</xhtml:p><xhtml:p>		System.out.println("str3 == str5  " + (str3 == str5));//false</xhtml:p><xhtml:p>		System.out.println("str3 == str6  " + (str3 == str6));//false</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		final String str7 = "hello";</xhtml:p><xhtml:p>		final String str8 = "java";</xhtml:p><xhtml:p>		String str9 = str7 + str8;//常量与常量拼接</xhtml:p><xhtml:p>		System.out.println("str3 == str9   " + (str3 == str9));//true</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		String str10 = (str1 + str2).intern();//intern()的结果放常量池</xhtml:p><xhtml:p>		System.out.println(str3 == str10);//true</xhtml:p><xhtml:p>	}</xhtml:p></html><plain>	@Test&#13;
	public void test3(){&#13;
		String str1 = "hello";&#13;
		String str2 = "java";&#13;
		String str3 = "hellojava";&#13;
		String str4 = "hello" + "java";//常量与常量拼接，还是常量&#13;
		String str5 = "hello" + str2;//常量与变量拼接，结果在堆中&#13;
		String str6 = str1 + str2;//变量与变量拼接，结果也在堆中&#13;
		&#13;
		System.out.println("str3 == str4  " + (str3 == str4));//true&#13;
		System.out.println("str3 == str5  " + (str3 == str5));//false&#13;
		System.out.println("str3 == str6  " + (str3 == str6));//false&#13;
		&#13;
		final String str7 = "hello";&#13;
		final String str8 = "java";&#13;
		String str9 = str7 + str8;//常量与常量拼接&#13;
		System.out.println("str3 == str9   " + (str3 == str9));//true&#13;
		&#13;
		String str10 = (str1 + str2).intern();//intern()的结果放常量池&#13;
		System.out.println(str3 == str10);//true&#13;
	}</plain></notes></topic></topics></children></topic></topics></children></topic><topic id="3s9d1fgg85hl7j8jil3adqaosp" modified-by="" timestamp="1511922741191"><title>常用的方法</title><children><topics type="attached"><topic id="4bv3hoig3sbvkbami94c0dg7rl" modified-by="" timestamp="1511922129632"><title>1、基本方法</title><children><topics type="attached"><topic id="0ojbela9en1csu3vc72uhvre5o" modified-by="" timestamp="1511920792476"><title>（1）int length()</title><children><topics type="attached"><topic id="30q6fkugcrl34iq8utcu5m585l" modified-by="" timestamp="1511920749163"><title>返回字符串的长度，即字符的个数</title></topic></topics></children></topic><topic id="6as1d6nvc4a2v96v4dvl4k67uo" modified-by="" timestamp="1511921518125"><title>（2）字符串的比较</title><children><topics type="attached"><topic id="6h0aae076jnd5rhr3sa3aka4re" modified-by="" timestamp="1511920851721"><title>boolean  equals(String other)</title><children><topics type="attached"><topic id="33c5hldl95481lot861iqiirsp" modified-by="" timestamp="1511920836025"><title>this和other进行内容比较</title></topic><topic id="21cq4kv3n7ta2v129sqa7gu7e4" modified-by="" timestamp="1511920847693"><title>对Object的equals进行重写</title></topic><topic id="7879dnoujq8s2sb1s9k6tbv0rj" modified-by="" timestamp="1511920857283"><title>严格区分大小写</title></topic></topics></children></topic><topic id="7js7rgsbv0prohc27l8rmiqqib" modified-by="" timestamp="1511920885209"><title svg:width="500">boolean equalsIgnoreCase(String anotherString)</title><children><topics type="attached"><topic id="5t09lu0tm6ec0knjmtk8sg9ovr" modified-by="" timestamp="1511920884216"><title>this和anotherString进行内容比较</title></topic><topic id="2a9ev0qo8d1qi7pljdp0s6ise4" modified-by="" timestamp="1511920892184"><title>不区分大小写</title></topic></topics></children></topic><topic id="7dab158p8e858drnhr5340flnq" modified-by="" timestamp="1511921518157"><title>自然排序</title><children><topics type="attached"><topic id="36hiiah8oqlog36i320237btob" modified-by="" timestamp="1511921518125"><title>public int compareTo(String anotherString)</title><children><topics type="attached"><topic id="0f1brqvc9berk06bjk9jlgn3d0" modified-by="" timestamp="1511921131138"><title>如果是ASCII范围内，按照ASCII值的顺序</title></topic></topics></children></topic></topics></children></topic><topic id="06nlb2j9bo7k8gelkrcci080vt" modified-by="" timestamp="1511921539142"><title>定制排序</title><children><topics type="attached"><topic id="1r6rt50l61dptsra1emfh7jv75" modified-by="" timestamp="1511921589662"><title>java.text.Collator</title><notes><html><xhtml:p>		String str3 = "中国";//Z</xhtml:p><xhtml:p>		String str4 = "美国";//M</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//如果想要按照字典顺序</xhtml:p><xhtml:p>		//找定制排序，实现了java.util.Comparator接口，重写int compare(String s1,String s2)</xhtml:p><xhtml:p>		//java.text.Collator</xhtml:p><xhtml:p>		Collator c = Collator.getInstance();</xhtml:p><xhtml:p>		int result = c.compare(str3, str4);</xhtml:p><xhtml:p>		System.out.println(result);//中 &gt; 美</xhtml:p></html><plain>		String str3 = "中国";//Z&#13;
		String str4 = "美国";//M&#13;
		&#13;
		//如果想要按照字典顺序&#13;
		//找定制排序，实现了java.util.Comparator接口，重写int compare(String s1,String s2)&#13;
		//java.text.Collator&#13;
		Collator c = Collator.getInstance();&#13;
		int result = c.compare(str3, str4);&#13;
		System.out.println(result);//中 &gt; 美</plain></notes></topic></topics></children></topic></topics></children></topic><topic id="5o29psrd79t55ll5fjlk7avi4o" modified-by="" timestamp="1511922016690"><title>（3）去掉前后空格</title><children><topics type="attached"><topic id="31o240ur40n6935tvjelovd15a" modified-by="" timestamp="1511922025069"><title>String trim()</title></topic></topics></children></topic><topic id="07b17obc5h4l9c72j3edm8omib" modified-by="" timestamp="1511922104059"><title>（4）转大小写</title><children><topics type="attached"><topic id="7aknkr69q5r8ds65v0prk5qmnm" modified-by="" timestamp="1511922092283"><title>String toUpperCase()</title></topic><topic id="596sql86g54m814p46vhpbh6mo" modified-by="" timestamp="1511922105569"><title>public String toLowerCase()</title></topic></topics></children></topic><topic id="73dclqghlvgq7vm1eun0neie1f" modified-by="" timestamp="1511922170687"><title>（5）是否是空字符串</title><children><topics type="attached"><topic id="11b18hfsnu282rj5hp2s5leoet" modified-by="" timestamp="1511922162827"><title>方式一</title><children><topics type="attached"><topic id="7il2ipegmk90i3q2c96crop0gh" modified-by="" timestamp="1511922169994"><title>"".equals(字符串)</title></topic></topics></children></topic><topic id="2ns34irj9ss122sa9k2nau48lq" modified-by="" timestamp="1511922175601"><title>方式二</title><children><topics type="attached"><topic id="31iobf6rg1llt331jfgnmsg5ve" modified-by="" timestamp="1511922187004"><title>isEmpty()</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="0ok0g5ilote646kjuur6icum3k" modified-by="" timestamp="1511922340160"><title>2、和字节相关</title><children><topics type="attached"><topic id="4v80nrkqo2gobk3orni2mfj5v4" modified-by="" timestamp="1511922286409"><title>编码：把字符串转成字节数组</title><children><topics type="attached"><topic id="4lp20vniqesk26g5uglfuvoqtu" modified-by="" timestamp="1511922244864"><title>byte[] getBytes()</title><children><topics type="attached"><topic id="706g0iuvddqaqqo9e9a6efh2l6" modified-by="" timestamp="1511922253760"><title>平台默认编码方式进行编码</title></topic></topics></children></topic><topic id="5t8t2gnce7hqthqvadsf26ms4o" modified-by="" timestamp="1511922254211"><title>byte[] getBytes(字符编码方式)</title><children><topics type="attached"><topic id="7h5t6643dtshjjhau7fbtkjh1t" modified-by="" timestamp="1511922260057"><title>按照指定的编码方式</title></topic></topics></children></topic></topics></children></topic><topic id="3i884cukbihmjrj09jdfn105ig" modified-by="" timestamp="1511922333889"><title>解码：把字节数组转成字符串</title><children><topics type="attached"><topic id="5875rb6g5hqubpksk34ibjf2p6" modified-by="" timestamp="1511922299880"><title>new String(byte[])</title></topic><topic id="72vt2vlfqr93coo1vj5duaalb1" modified-by="" timestamp="1511922314398"><title>new String(byte[],int offset, int length)</title></topic><topic id="1u2uhdoln1gdo1nfj8odnltoh2" modified-by="" timestamp="1511922329969"><title>new String(byte[], 字符解码方式)</title></topic><topic id="4mdeq17kjs2fqa9h06qfbuqkft" modified-by="" timestamp="1511922336285"><title>....</title></topic></topics></children></topic><topic id="14moi9l5pp2hd5qqhvpdpdaa6d" modified-by="" timestamp="1511922357095"><title>乱码</title><children><topics type="attached"><topic id="5eblplv8a78d22023jmnat2b66" modified-by="" timestamp="1511922356284"><title>（1）编码方式与解码方式不一致</title></topic><topic id="4aeihpr7g8nusnsnqpougquid3" modified-by="" timestamp="1511922362306"><title>（2）缺字节</title></topic></topics></children></topic></topics></children></topic><topic id="624oh6g9t06s5dtpldcqtrhl2m" modified-by="" timestamp="1511922431483"><title>3、和字符相关</title><children><topics type="attached"><topic id="798l2ljhh2rgo1hmppta7e76rc" modified-by="" timestamp="1511922388949"><title>把字符串转字符数组</title><children><topics type="attached"><topic id="7rb4k4pc1v50ditp1ur2ggjt4k" modified-by="" timestamp="1511922396208"><title>char[]  toCharArray()</title></topic></topics></children></topic><topic id="62oiq27oelvrigmot7lvcr6rso" modified-by="" timestamp="1511922428002"><title>把字符数组转字符串</title><children><topics type="attached"><topic id="6dqpopi2m3pv1j4tvuvv6iaka1" modified-by="" timestamp="1511922413129"><title>new String(char[])</title></topic><topic id="4urikkv8a987g312ffehklbj0e" modified-by="" timestamp="1511922426265"><title>new String(char[],int offset, int count	)</title></topic><topic id="1ccrnn26kbuk5mvv4r7rilbuse" modified-by="" timestamp="1511922430739"><title>....</title></topic></topics></children></topic><topic id="0qifi4qhiccd2a32luceq35d4j" modified-by="" timestamp="1511922438874"><title>取指定位置的字符</title><children><topics type="attached"><topic id="5ie43fohn2ktmcsuju54lp8k9m" modified-by="" timestamp="1511922458385"><title>char charAt(index)</title></topic></topics></children></topic></topics></children></topic><topic id="66qs03hohja62oia2mpq6nr0l9" modified-by="" timestamp="1511922492663"><title>4、是否以xx开头和结尾</title><children><topics type="attached"><topic id="6hlhs65od29evrrl3g99t4gv6n" modified-by="" timestamp="1511922491113"><title>boolean startsWith(xx)</title></topic><topic id="36pcq0kdrs7b7uu4jlt22rbqu1" modified-by="" timestamp="1511922497555"><title>boolean endsWith(xx)</title></topic></topics></children></topic><topic id="0ovs28dmk3s87svl69476e4l85" modified-by="" timestamp="1511922588193"><title>5、字符串截取</title><children><topics type="attached"><topic id="7sihkv2bcagmcup77kj0859u7u" modified-by="" timestamp="1511922594471"><title>String subString(int start)</title><children><topics type="attached"><topic id="3oajsq6us529pekjlf7j9pa4r1" modified-by="" timestamp="1511922605388"><title>从[start,最后]</title></topic></topics></children></topic><topic id="2srm3edujfeqafoe81obbc7sjo" modified-by="" timestamp="1511922605669"><title>String subString(int start, int end)</title><children><topics type="attached"><topic id="50j3lq310gm63u5j7neobeftd0" modified-by="" timestamp="1511922613262"><title>从[start,end)</title></topic></topics></children></topic></topics></children></topic><topic id="40t4gqcl1vna0803ebps9a3ajf" modified-by="" timestamp="1511922637415"><title>6、拆分</title><children><topics type="attached"><topic id="56l9h8dvmcpt6qtu1oqonsalb9" modified-by="" timestamp="1511922653711"><title>String[]  split(支持正则)</title></topic></topics></children></topic><topic id="39iu60l0fh1vkicd8jl02qr0u3" modified-by="" timestamp="1511922684394"><title>7、查找</title><children><topics type="attached"><topic id="07q60h85dv1r2j8nb33n39j5cu" modified-by="" timestamp="1511922683343"><title>是否包含</title><children><topics type="attached"><topic id="0d5cpqnhs0ev5s0es9mrt4c8qb" modified-by="" timestamp="1511922681531"><title>boolean contains(子串)</title></topic></topics></children></topic><topic id="17t2fps029r0nbigkk9lr9m82r" modified-by="" timestamp="1511922718727"><title>查找索引位置</title><children><topics type="attached"><topic id="712gg1qqdmoj0ot77j61046ujt" modified-by="" timestamp="1511922709507"><title>int indexOf(xxx)</title><children><topics type="attached"><topic id="6n0744t6jbskcnp0qh76nahnif" modified-by="" timestamp="1511922709175"><title>如果存在返回索引</title></topic><topic id="5rqb6fo8juvbklq0bc2opaqbfi" modified-by="" timestamp="1511922717408"><title>如果不存在返回-1</title></topic></topics></children></topic><topic id="12ke60c5rem6bfpiul0c642i9p" modified-by="" timestamp="1511922728506"><title>int lastIndexOf(xx)</title></topic></topics></children></topic></topics></children></topic><topic id="5fepnlmrdtbd6diaoqdmtrook8" modified-by="" timestamp="1511922775322"><title>8、替换</title><children><topics type="attached"><topic id="3ggsi0t2p8kt02q2ritiodqfpv" modified-by="" timestamp="1511922772598"><title>String  replace(目标子串， 新子串)</title></topic><topic id="58bdt3b5k93vcon2f3sb3uhok1" modified-by="" timestamp="1511922784337"><title>String  replaceAll(目标子串， 新子串)</title><children><topics type="attached"><topic id="6mq2jndf1v8i03e723v5tl2mqs" modified-by="" timestamp="1511922789938"><title>支持正则</title></topic></topics></children></topic><topic id="21q7tpi0255ve3urkh66vsa7qg" modified-by="" timestamp="1511922783975"><title>String  replaceFirst(目标子串， 新子串)</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic branch="folded" id="5qaqmkco9ad79q9alj6mhcdiug" modified-by="" timestamp="1515820142867"><title svg:width="500">java.lang.StringBuffer和java.lang.StringBuilder</title><children><topics type="attached"><topic id="25lbg4uq9ga60jlgsr2lliq3dc" modified-by="" timestamp="1512092449591"><title>StringBuffer是JDK1.0就有，是线程安全的</title></topic><topic id="3cg1lke7sl1obmjqkr5thqinrc" modified-by="" timestamp="1512092468882"><title>StringBuilder是JDK1.5引入，是线程不安全</title></topic><topic id="16dktm0em6thiidopa11nesaos" modified-by="" timestamp="1512092693264"><title>和String的区别</title><children><topics type="attached"><topic id="0mdjep69f4bvs5phc57ehefvnh" modified-by="" timestamp="1512092906088"><title svg:width="500">（1）String对象是常量对象，是不能修改的，StringBuffer和StringBuilder是字符串缓冲区，可变字符序列，可以修改的</title><children><topics type="attached"><topic id="5mtmmpb4tqr7t36g2e8thh4qac" modified-by="" timestamp="1512092905372"><title>String一旦涉及修改就产生新的String对象</title></topic><topic id="6ggk53mlf6694nransm4vuhasb" modified-by="" timestamp="1512092939535"><title svg:width="500">StringBuilder和StringBuffer不会产生新的StringBuilder和StringBufffer对象</title></topic></topics></children></topic><topic id="1h0mgsbjlj2qd38r88agtivm4i" modified-by="" timestamp="1512092638683"><title>（2）赋值的方式</title><children><topics type="attached"><topic id="53iuralfipb4j9e6g7if993kt1" modified-by="" timestamp="1512092659026"><title>只有String支持，String str  = "xxx";</title></topic></topics></children></topic><topic id="7jtom4qq9i63bv0114q37102vb" modified-by="" timestamp="1512092706639"><title>（3）拼接</title><children><topics type="attached"><topic id="34gp83fhqrlsljdps3i4d1gsjj" modified-by="" timestamp="1515820074695"><title>String支持+</title><children><topics type="attached"><topic id="15lmmgm9s0230d3b6rf1dpb0ev" modified-by="" timestamp="1515820088801"><title>每一次拼接产生新对象，浪费空间和时间</title></topic></topics></children></topic><topic id="4u3oos08m4f2m2ji7g2ccdmge6" modified-by="" timestamp="1515820089703"><title>append</title><children><topics type="attached"><topic id="3o2njr1s6k7s5rvk63svauq45j" modified-by="" timestamp="1515820096131"><title>不会产生新对象</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="49q03mcpnqmpu73kso31umeu4u" modified-by="" timestamp="1512092860723"><title>常用的方法</title><children><topics type="attached"><topic id="5n31vfn16l832ilr4a0s8ben7r" modified-by="" timestamp="1512092737462"><title>（1）拼接</title><children><topics type="attached"><topic id="5et4fb6sscocqa1ljckpalm5k4" modified-by="" timestamp="1512092732241"><title>append(xx)</title></topic><topic id="2tn91reltd6qbks98r607nb4qf" modified-by="" timestamp="1512100211398"><title>支持连写</title><children><topics type="attached"><topic id="6q79lhe44opnppsiulgqpa9p9s" modified-by="" timestamp="1512100241647"><title>sBuilder.append(xx).append(yyy).append(zzz)...</title></topic></topics></children></topic></topics></children></topic><topic id="1bt3f5pnltu3r53e81mhn34mf5" modified-by="" timestamp="1512092753629"><title>（2）插入</title><children><topics type="attached"><topic id="2vfhabnm8ufeqn581q5f4etjoq" modified-by="" timestamp="1512092763946"><title>insert(index，xx）</title></topic></topics></children></topic><topic id="61cd7po3glh2u68jteb241i194" modified-by="" timestamp="1512092777782"><title>（3）删除</title><children><topics type="attached"><topic id="42vivl8iob00e4jf4681j1gc63" modified-by="" timestamp="1512092793582"><title>delete(start, end)</title></topic></topics></children></topic><topic id="2o3qdg7fj1r0dnk7arn3c9gpmd" modified-by="" timestamp="1512092800696"><title>（4）替换</title><children><topics type="attached"><topic id="7d02vs512umv88ek4i3f3g9g6g" modified-by="" timestamp="1512092826115"><title>setCharAt(index, char)</title></topic></topics></children></topic><topic id="3pkjauovojhrr7obemba30trvv" modified-by="" timestamp="1512092854906"><title>（5）反转</title><children><topics type="attached"><topic id="6ifmi34cv09v8hbsosmknfjtf8" modified-by="" timestamp="1512092858917"><title>reverse()</title></topic></topics></children></topic><topic id="1ivj7pp0f4h4gi4mehnj9qi092" modified-by="" timestamp="1512092864903"><title>....</title></topic></topics></children></topic></topics></children></topic><topic branch="folded" id="1vra7003fqrqf3pdsrsnokievb" modified-by="" timestamp="1515820144672"><title>JDK1.8之前日期时间</title><children><topics type="attached"><topic id="7itpm9nkcv5ij85n0cfms1b6r5" modified-by="" timestamp="1512093076789"><title>java.util.Date</title><children><topics type="attached"><topic id="365llcr9lhtfh0r632bpi5piih" modified-by="" timestamp="1512093051418"><title>（1）两个构造器</title><children><topics type="attached"><topic id="44qhos66p062mtthfned8u6ner" modified-by="" timestamp="1512093042257"><title>new Date()</title><children><topics type="attached"><topic id="01mrco0d8thlojtpclc64cpo5l" modified-by="" timestamp="1512093050653"><title>获取当前系统日期时间</title></topic></topics></children></topic><topic id="2oa7gpb4sf5dkef8s030a76ipq" modified-by="" timestamp="1512093062566"><title>new Date(long 毫秒)</title><children><topics type="attached"><topic id="1mnp6kg25nuavgvq8gpiqb773o" modified-by="" timestamp="1512093072150"><title>根据毫秒数获取日期时间对象</title></topic></topics></children></topic></topics></children></topic><topic id="0ob7nucq86nqjaa367f75opsjf" modified-by="" timestamp="1512093092109"><title>（2）把某个日期时间对象转成毫秒数</title><children><topics type="attached"><topic id="1h2r1th9q66r6tlfliq2dkiu6l" modified-by="" timestamp="1512093099707"><title>long  getTime()</title></topic></topics></children></topic></topics></children></topic><topic id="4gjodje7qnm47u4ovj8ipaobq5" modified-by="" timestamp="1512093160981"><title>java.lang.System</title><children><topics type="attached"><topic id="42jde0kc0vrn7vnpvrrqhsrvat" modified-by="" timestamp="1512093187702"><title>long System.currentTimeMillis()</title></topic></topics></children></topic><topic id="1kqia483k55ulasjrhevsprepb" modified-by="" timestamp="1512093733062"><title>java.util.Calendar</title><children><topics type="attached"><topic id="4t07lellbtbo3l921bm1kkj5cp" modified-by="" timestamp="1512093712836"><title>（1）获取实例对象</title><children><topics type="attached"><topic id="4qfi9k1ocao1hdmf2kvl3ea0h4" modified-by="" timestamp="1512093704428"><title>Calendar.getInstance()</title><children><topics type="attached"><topic id="2q597l4n1oktdslcgnbssi6m07" modified-by="" timestamp="1512093711891"><title>获取平台默认</title></topic></topics></children></topic><topic id="7r987bk5rhpbv83son64ofn3od" modified-by="" timestamp="1512093730709"><title>Calendar.getInstance(时区，语言环境)</title></topic></topics></children></topic><topic id="1bo4q8e77ane88ecrot44hebet" modified-by="" timestamp="1512093755958"><title>（2）get(常量字段）</title><children><topics type="attached"><topic id="373r7t1uh2susarq60vdia4se1" modified-by="" timestamp="1512093749834"><title>YEAR</title></topic><topic id="1i01e0rsdkghoj7pf3jajiqsbf" modified-by="" timestamp="1512093755608"><title>MONTH</title></topic><topic id="2d0chdbj476qiet174dl63fg8m" modified-by="" timestamp="1512093758114"><title>....</title></topic></topics></children></topic></topics></children></topic><topic id="4ka0c0u593bjmg1uh7j35opgud" modified-by="" timestamp="1512093848722"><title svg:width="500">java.text.DateFormat及其java.text.SimpleDateFormat</title><children><topics type="attached"><topic id="1k64p23sqnj5ppu2hagu8i2kpg" modified-by="" timestamp="1512093805953"><title>（1）构造器</title><children><topics type="attached"><topic id="68mdj0ei64uf9qafvuskbj2t2p" modified-by="" timestamp="1512093816803"><title svg:width="500">SimpleDateFormat sf = new SimpleDateFormat("模式");</title></topic></topics></children></topic><topic id="26gkq9jc7n81718l89nck1opbo" modified-by="" timestamp="1512093846474"><title>（2）把日期转成字符串</title><children><topics type="attached"><topic id="0jj0edjrur83ej46ikhf3f9nbj" modified-by="" timestamp="1512093847847"><title>public final String format(Date date)</title></topic></topics></children></topic><topic id="585rv53h3hqajue58f4uovbd30" modified-by="" timestamp="1512093875335"><title>（3）把字符串转成日期</title><children><topics type="attached"><topic id="4qk914qfuftf3qfpfmho1uq2jf" modified-by="" timestamp="1512093879745"><title>public Date parse(String source)</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic branch="folded" id="4qndefimcaon7h3et6edqiosim" modified-by="" timestamp="1515820146780"><title>JDK1.8日期时间</title><children><topics type="attached"><topic id="1ve8dvugehsfb69dfkcgl8j8t3" modified-by="" timestamp="1515820123053"><title>相关的包</title><children><topics type="attached"><topic id="2oocdnvqei2ig9ek6s094dna7l" modified-by="" timestamp="1512094607019"><xhtml:img xhtml:src="xap:attachments/10cc9al02v36r37mud3rhem55s.png"/></topic></topics></children></topic><topic id="1r30bqmcm31t1cet8ooskof4jb" modified-by="" timestamp="1515820124386"><title>本地日期时间</title><children><topics type="attached"><topic id="582sj8pha6aaoasbin1cgf96td" modified-by="" timestamp="1512094654169"><title>java.time.LocalDate</title></topic><topic id="6lh0m6hrjjjcc9snt3cnsq2l8t" modified-by="" timestamp="1512094654190"><title>java.time.LocalTme</title></topic><topic id="7mhnfk76cr1gl4sjkdb9dq3v9n" modified-by="" timestamp="1512094654206"><title>java.time.LocalDateTime</title></topic><topic id="7jqjdpmf0oaifqu3eb50n1f6cc" modified-by="" timestamp="1512094669519"><title>对应旧版本java.util.Calendar</title></topic><topic id="3tbnj77orhtlc1be9a14kv9pba" modified-by="" timestamp="1512099624185"><title>方法列表</title><children><topics type="attached"><topic id="1dho7aua15q1n9v5qh0epj3cud" modified-by="" timestamp="1512099629286"><xhtml:img svg:height="413" svg:width="631" xhtml:src="xap:attachments/180bu4nrpmcs85ct1a199vr00b.png"/></topic></topics></children></topic></topics></children></topic><topic id="7h8k07ujfjn740k2u7vioo99jb" modified-by="" timestamp="1515820127266"><title>日期时间格式化</title><children><topics type="attached"><topic id="08nobg466k3ujh6n2ea1h9ntm0" modified-by="" timestamp="1512099920100"><title>java.time.format.DateTimeFormatter</title><children><topics type="attached"><topic id="10dhkn153hg8l85tpk34s6lo6r" modified-by="" timestamp="1512099927633"><title>format</title><children><topics type="attached"><topic id="2sbdnh5au25qo3nlub4v1mt48j" modified-by="" timestamp="1512099946651"><title>把日期时间对象转字符串</title></topic></topics></children></topic><topic id="2bjim6rcbmo56ks78j9kdsd079" modified-by="" timestamp="1512099936648"><title>parse</title><children><topics type="attached"><topic id="2krdheneck17kksba8ubkvfr5u" modified-by="" timestamp="1512099942222"><title>把字符串转日期时间对象</title></topic></topics></children></topic></topics></children></topic><topic id="1mn5n1a6kfr95qibieiog56omj" modified-by="" timestamp="1512099734133"><title>三种形式获取DateTimeFormatter对象</title><children><topics type="attached"><topic id="6otgr0d0ket60pg09lsb6okmfh" modified-by="" timestamp="1512099790410"><title>标准格式的常量对象</title><children><topics type="attached"><topic id="1crljl2l4oet7vm1408d1i18u0" modified-by="" timestamp="1512094957323"><title svg:width="500">LocalDate date = LocalDate.now();&#13;
System.out.println(date.format(DateTimeFormatter.ISO_DATE));</title></topic><topic id="4gq1bhbp0g7d7ggnobpk5l6knn" modified-by="" timestamp="1512099796565"><title svg:width="500">DateTimeFormatter formatter = DateTimeFormatter.ISO_DATE;&#13;
String format = formatter.format(LocalDate.now());</title></topic></topics></children></topic><topic id="1mo6284v5e1dkriuickm3q1abt" modified-by="" timestamp="1512095003460"><title>Style</title><children><topics type="attached"><topic id="768219a9asbv5546s0hgvkfpgp" modified-by="" timestamp="1512099849208"><title svg:width="500">DateTimeFormatter dt = DateTimeFormatter.ofLocalizedDate(FormatStyle.FULL);&#13;
String string = dt.format(LocalDate.now());</title><children><topics type="attached"><topic id="3qe73i4io4nistn0kc4dgg3e69" modified-by="" timestamp="1512095421320"><title>FormatStyle.FULL</title><children><topics type="attached"><topic id="5fu45o5ljdgomnobfd5fl4hh7c" modified-by="" timestamp="1512095255652"><title>日期</title></topic></topics></children></topic><topic id="11mgbod3g5orn4fqkd40mmf6qs" modified-by="" timestamp="1512095468566"><title>FormatStyle.LONG</title><children><topics type="attached"><topic id="3j6evutf4vhtgcs7iotv8h72f4" modified-by="" timestamp="1512095394017"><title>日期时间</title></topic><topic id="26uvktefipvcc771nb77a24aic" modified-by="" timestamp="1512095429007"><title>日期</title></topic><topic id="12rnh7hrugflq5vd0jlpnnv386" modified-by="" timestamp="1512095515307"><title>时间</title></topic></topics></children></topic><topic id="1hfqacqiu1na1re5u0k42n30i5" modified-by="" timestamp="1512095517334"><title>FormatStyle.MEDIUM </title><children><topics type="attached"><topic id="2d5lq76bgppfgcvshnnmbchqqp" modified-by="" timestamp="1512095429873"><title>日期</title></topic><topic id="7od905ion1q864ts15mhggev22" modified-by="" timestamp="1512095469445"><title>日期时间</title></topic><topic id="7abkd0cj52s26ol84c6fblsl1e" modified-by="" timestamp="1512095517305"><title>时间</title></topic></topics></children></topic><topic id="3ped99f7ksjqmvbfjpav33idnl" modified-by="" timestamp="1512095518263"><title>FormatStyle.SHORT</title><children><topics type="attached"><topic id="73s8dcf5q1432fs3aa4s4f72go" modified-by="" timestamp="1512095431077"><title>日期</title></topic><topic id="7pnvdloob9mo4imq1st17gesni" modified-by="" timestamp="1512095470374"><title>日期时间</title></topic><topic id="5n3gfnndqfqk4dolp40jqrc5fs" modified-by="" timestamp="1512095518237"><title>时间</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="1dhunlfe5ja2lvnn4p1k43tj2o" modified-by="" timestamp="1512095544298"><title>自定义格式</title><children><topics type="attached"><topic id="0h5ko04d58vr3ua03lu4iscqs0" modified-by="" timestamp="1512095548786"><title svg:width="500">DateTimeFormatter op = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");&#13;
System.out.println(op.format(LocalDateTime.now()));</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="6n0mg96qbge7ckuacoul8c1ahs" modified-by="" timestamp="1512095630261"><title>日期的间隔</title><children><topics type="attached"><topic id="0i702m85gv2tek2bi3u1u90dih" modified-by="" timestamp="1512095631625"><title>Period</title></topic></topics></children></topic><topic id="2lvgo1h321uaqukcrtohrjngnv" modified-by="" timestamp="1512095617738"><title>时间的间隔</title><children><topics type="attached"><topic id="55kqm2tfh9v2rjk4t776qbed6f" modified-by="" timestamp="1512095629890"><title>Duration</title></topic></topics></children></topic></topics></children></topic><topic id="1p5k75gbt1e333o0f4sgab5gpm" modified-by="" timestamp="1512100302723"><title>java.lang.Math</title></topic><topic id="6537dr600hkh4u1tadde39lv8b" modified-by="" timestamp="1512100314505"><title>排序</title><children><topics type="attached"><topic id="7frdoht7it6p83bb18fo9ad71n" modified-by="" timestamp="1512100314287"><title>java.lang.Comparable</title></topic><topic id="4hmlaoo4321k4qmc74d68ob9va" modified-by="" timestamp="1512100320316"><title>java.lang.Comparator</title></topic></topics></children></topic></topics></children></topic><title>API</title></sheet><sheet id="622etqlloeh3af5gl1l7oapmja" modified-by="" style-id="52uu5g07ehufrlgna6s0eokgph" theme="xminddefaultthemeid" timestamp="1512955459015"><topic id="08aebva4ut5v8fch6dtfnoc509" modified-by="" structure-class="org.xmind.ui.logic.right" timestamp="1511747561976"><title>23种设计模式</title><extensions><extension provider="org.xmind.ui.map.unbalanced"><content><right-number>-1</right-number></content></extension></extensions><children><topics type="attached"><topic id="07enc8kgbmgqr6lse8r1h6vvcp" modified-by="" timestamp="1511574509010"><title>设计模式</title><children><topics type="attached"><topic id="7sqtgj2lg8usr3sa7bafgeo4r8" modified-by="" timestamp="1511574453499"><title>套路</title></topic><topic id="67df5p60isvvrntr6187q0n9b5" modified-by="" timestamp="1511574514400"><title>框架</title><children><topics type="attached"><topic id="3ra232dd3hkdtdgah27ednrrus" modified-by="" timestamp="1511574534632"><title>设计模式 + 反射 + 泛型 + 注解/配置文件等</title></topic></topics></children></topic></topics></children></topic><topic id="0r4lv2bevfjnkdkpp8b3pvqd44" modified-by="" timestamp="1512810176407"><title>单例设计模式</title><children><topics type="attached"><topic id="07fe5crf53o33sv0ftup581h8o" modified-by="" timestamp="1511574610961"><title>最简单，考的最多的一个设计模式</title></topic><topic id="6p769nq5ncfieanrcd68l32rca" modified-by="" timestamp="1511574633002"><title>要点</title><children><topics type="attached"><topic id="69o2745968r4ud8tftu4vbjb22" modified-by="" timestamp="1511574632251"><title>（1）构造器私有化</title></topic><topic id="1kfe8rio5edfvu4ed3pk7k64as" modified-by="" timestamp="1511574647740"><title>（2）在本类中创建这个唯一的实例</title></topic></topics></children></topic><topic id="6fqea5mbv1cm1v56skmvq1om2o" modified-by="" timestamp="1512810177470"><title>分类</title><children><topics type="attached"><topic id="0fl36cqtrdr31aiv5jrb4ds6df" modified-by="" timestamp="1511574689845"><title>饿汉式</title><children><topics type="attached"><topic id="0t9td9nj20uhu24hpllknh5c5n" modified-by="" timestamp="1511574686755"><title>形式一</title><children><topics type="attached"><topic id="4g805nvo2i3257oaidlje17dt1" modified-by="" timestamp="1511574688195"><title svg:width="500">class Hungry{&#13;
	public static final Hungry INSTANCE = new Hungry();&#13;
	private Hungry(){&#13;
	}&#13;
}</title></topic></topics></children></topic><topic id="3oam60ip70drun509u739ovcjo" modified-by="" timestamp="1511574700120"><title>形式二</title><children><topics type="attached"><topic id="0rrubtumd3d9245hoe15rh3eg5" modified-by="" timestamp="1511574702194"><title svg:width="500">class Hungry{&#13;
	private static final Hungry INSTANCE = new Hungry();&#13;
	private Hungry(){&#13;
	}&#13;
	public static Hungry getInstance(){&#13;
		return INSTANCE;&#13;
	}&#13;
}</title></topic></topics></children></topic></topics></children></topic><topic id="6a1lb3tt56rfsnjcslrvebc5fh" modified-by="" timestamp="1512810191634"><title>懒汉式</title><children><topics type="attached"><topic id="4c0fbfav4k5rahbp30b3rg0nd0" modified-by="" timestamp="1511574725641"><title>形式一：（有线程安全问题）</title><children><topics type="attached"><topic id="37os09gmeeg4ljvl6oc28oklrr" modified-by="" timestamp="1511574727423"><title>class Lazy{&#13;
	private static Lazy instance;&#13;
	private Lazy(){&#13;
	}&#13;
	//延迟创建对象&#13;
	public static Lazy getInstance(){&#13;
		if(instance == null){&#13;
			instance = new Lazy();&#13;
		}&#13;
		return instance;&#13;
	}&#13;
}</title></topic></topics></children></topic><topic id="6uldaq01hoqeic05vmcrrgpcmf" modified-by="" timestamp="1512955456518"><title>形式二：解决线程安全问题</title><notes><html><xhtml:p>//懒汉式</xhtml:p><xhtml:p>class Lazy{</xhtml:p><xhtml:p>	//2、在类中声明一个静态变量用来存储这个唯一的对象</xhtml:p><xhtml:p>	private static Lazy instance;</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>	//1、构造器私有化</xhtml:p><xhtml:p>	private Lazy(){</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>	//3、提供一个静态方法用来返回这个唯一的对象，并在第一次获取这个对象时，创建这个唯一的对象</xhtml:p><xhtml:p>	/*synchronized public static Lazy getInstance(){</xhtml:p><xhtml:p>		if(instance == null){</xhtml:p><xhtml:p>			instance = new Lazy();</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>		return instance;</xhtml:p><xhtml:p>	}*/</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>	//考虑的性能</xhtml:p><xhtml:p>	public static Lazy getInstance(){</xhtml:p><xhtml:p>		if(instance == null){//为了效率高</xhtml:p><xhtml:p>			synchronized(Lazy.class){</xhtml:p><xhtml:p>				if(instance == null){//双重条件判断，更安全</xhtml:p><xhtml:p>					instance = new Lazy();</xhtml:p><xhtml:p>				}</xhtml:p><xhtml:p>			}</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>		return instance;</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p></html><plain>//懒汉式&#13;
class Lazy{&#13;
	//2、在类中声明一个静态变量用来存储这个唯一的对象&#13;
	private static Lazy instance;&#13;
	&#13;
	//1、构造器私有化&#13;
	private Lazy(){&#13;
		&#13;
	}&#13;
	&#13;
	//3、提供一个静态方法用来返回这个唯一的对象，并在第一次获取这个对象时，创建这个唯一的对象&#13;
	/*synchronized public static Lazy getInstance(){&#13;
		if(instance == null){&#13;
			instance = new Lazy();&#13;
		}&#13;
		return instance;&#13;
	}*/&#13;
	&#13;
	//考虑的性能&#13;
	public static Lazy getInstance(){&#13;
		if(instance == null){//为了效率高&#13;
			synchronized(Lazy.class){&#13;
				if(instance == null){//双重条件判断，更安全&#13;
					instance = new Lazy();&#13;
				}&#13;
			}&#13;
		}&#13;
		return instance;&#13;
	}&#13;
}</plain></notes><children><topics type="attached"><topic id="3jn9r9jbsgnrlmclc8ov5hf81o" modified-by="" timestamp="1512955459014"><title>public class Lazy{&#13;
	private static Lazy instance;&#13;
	private Lazy(){}&#13;
	public static Lazy getInstance(){&#13;
		if(instance == null){&#13;
			synchronized(Lazy.class){&#13;
				if(instance == null){&#13;
					instance = new Lazy();&#13;
				}&#13;
			}&#13;
		}&#13;
		return instance;&#13;
	}&#13;
}</title></topic></topics></children></topic></topics></children></topic><topic id="51b7ilrld7igapainn6uhnop5b" modified-by="" timestamp="1512955433718"><title>枚举式</title><children><topics type="attached"><topic id="6592l7kjfcnt7rm0lct9q9paal" modified-by="" timestamp="1512810189110"><title>enum Single{&#13;
	INSTANCE&#13;
}</title></topic><topic id="53idm9k4ilmvdrqtmnh7eq53il" modified-by="" timestamp="1512955426651"><title>特殊的饿汉式</title></topic></topics></children><marker-refs><marker-ref marker-id="flag-red"/></marker-refs></topic></topics></children></topic></topics></children><marker-refs><marker-ref marker-id="star-red"/><marker-ref marker-id="flag-red"/></marker-refs></topic><topic id="7p8c8fbv3711jehp7jce488leb" modified-by="" timestamp="1511746464763"><title>模板设计模式（识别）</title><children><topics type="attached"><topic id="3lpnltn1njba7p57fv22g43gbd" modified-by="" timestamp="1511746360052"><title>使用的情景</title><children><topics type="attached"><topic id="3u98v7rffr8h40mnbv56qacb5c" modified-by="" timestamp="1511746461042"><title svg:width="500">当某个功能在实现时，它的主体的算法结构是确定的，只是其中的某一个或几个步骤无法给出具体的实现，那么这个时候，把这个或几个的步骤抽取成抽象方法，由子类去给出具体的实现，那么子类继承父类时，既可以保留父类的主体算法结构，又可以对这几个抽象部分给出具体的实现</title></topic></topics></children></topic><topic id="6518o0sba28icaucna694fdrj8" modified-by="" timestamp="1511746709850"><title>示例代码</title><notes><html><xhtml:p>例如：计算某段代码的执行时间</xhtml:p><xhtml:p/><xhtml:p>算法结构：</xhtml:p><xhtml:p>1、获取开始时间</xhtml:p><xhtml:p>2、执行代码</xhtml:p><xhtml:p>3、获取结束时间</xhtml:p><xhtml:p>4、计算差值</xhtml:p><xhtml:p/><xhtml:p>public abstract class CalTime{</xhtml:p><xhtml:p>	public final long getTime(){</xhtml:p><xhtml:p>		//1、获取开始时间</xhtml:p><xhtml:p>		long start = System.currentTimeMillis();</xhtml:p><xhtml:p/><xhtml:p>		//2、执行代码</xhtml:p><xhtml:p>		doWork();</xhtml:p><xhtml:p/><xhtml:p>		//3、获取结束时间</xhtml:p><xhtml:p>		long end = System.currentTimeMillis();</xhtml:p><xhtml:p/><xhtml:p>		//4、计算差值</xhtml:p><xhtml:p>		return end - start;</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p/><xhtml:p>	protected abstract void doWork();</xhtml:p><xhtml:p/><xhtml:p>}</xhtml:p><xhtml:p/><xhtml:p>class MyCalTime extends CalTime{</xhtml:p><xhtml:p>	public void doWork(){</xhtml:p><xhtml:p>		.......</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p></html><plain>例如：计算某段代码的执行时间&#13;
&#13;
算法结构：&#13;
1、获取开始时间&#13;
2、执行代码&#13;
3、获取结束时间&#13;
4、计算差值&#13;
&#13;
public abstract class CalTime{&#13;
	public final long getTime(){&#13;
		//1、获取开始时间&#13;
		long start = System.currentTimeMillis();&#13;
&#13;
		//2、执行代码&#13;
		doWork();&#13;
&#13;
		//3、获取结束时间&#13;
		long end = System.currentTimeMillis();&#13;
&#13;
		//4、计算差值&#13;
		return end - start;&#13;
	}&#13;
&#13;
	protected abstract void doWork();&#13;
&#13;
}&#13;
&#13;
class MyCalTime extends CalTime{&#13;
	public void doWork(){&#13;
		.......&#13;
	}&#13;
}</plain></notes></topic></topics></children></topic><topic id="3eeug3633tpqn6ld1pmvs9fein" modified-by="" timestamp="1511747590861"><title>工厂设计模式</title><children><topics type="attached"><topic id="1k6u90ur9n4br3v40bokboisim" modified-by="" timestamp="1511747632315"><title>为什么要用工厂模式</title><children><topics type="attached"><topic id="7r51vcl62aee86ug005rgrfk0u" modified-by="" timestamp="1511747628758"><title svg:width="500">把创建对象者与对象的使用者分离（把创建者与使用者分离）</title></topic><topic id="6l4jhrk9jd080dkbdraqounc9m" modified-by="" timestamp="1511747640541"><title>解耦合</title></topic></topics></children></topic><topic id="6ugks251puesk6642vioamlkhe" modified-by="" timestamp="1511747661845"><title>形式</title><children><topics type="attached"><topic id="2evncf6hns7350t9envucrc1i0" modified-by="" timestamp="1511747821077"><title>1、简单工厂模式</title><children><topics type="attached"><topic id="32ucuubflfo0l3dfr2qvfsri42" modified-by="" timestamp="1511747685568"><title>特点</title><children><topics type="attached"><topic id="2uf9nis92p16quih9a0ghver3f" modified-by="" timestamp="1511747698277"><title>一个工厂生产所有产品</title></topic></topics></children></topic><topic id="64ggaaiqs5jlde81nb3lf4qj7m" modified-by="" timestamp="1511747720589"><title>缺点</title><children><topics type="attached"><topic id="47ehmvj9f93arp7bfb40vkgsbv" modified-by="" timestamp="1511747738515"><title>增加一个新产品， 就要修改工厂类代码</title><children><topics type="attached"><topic id="07f3a8vh8vnpqqqp71r9vftke5" modified-by="" timestamp="1511747774618"><title svg:width="500">违反了“对扩展开发，对修改关闭”的面向对象的设计原则</title></topic></topics></children></topic></topics></children></topic><topic id="79gisjq5173ddbncifoq2fif4o" modified-by="" timestamp="1511747814448"><title>优点</title><children><topics type="attached"><topic id="7tg8co2qksgi2so9rg357ss3aq" modified-by="" timestamp="1511747819044"><title>类少，简单</title></topic></topics></children></topic><topic id="1lg6qu0k2ecptlpg153qigl5lk" modified-by="" timestamp="1511748009668"><title>示例代码</title><notes><html><xhtml:p>//1、产品的接口</xhtml:p><xhtml:p>interface  Car{</xhtml:p><xhtml:p>	void run();</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p/><xhtml:p>//2、各种产品</xhtml:p><xhtml:p>class Benz implements Car{</xhtml:p><xhtml:p>	public void run(){</xhtml:p><xhtml:p>			...</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p/><xhtml:p>class BMW implements Car{</xhtml:p><xhtml:p>	public void run(){</xhtml:p><xhtml:p>			...</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p/><xhtml:p>//3、工厂</xhtml:p><xhtml:p>class SimpleFactory {</xhtml:p><xhtml:p/><xhtml:p>	public static Car getCar(String type){</xhtml:p><xhtml:p>		if("benz".equals(type)){</xhtml:p><xhtml:p>			return new Benz();</xhtml:p><xhtml:p>		}else if("bmw".equals(type)){</xhtml:p><xhtml:p>			return new BMW();</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p/><xhtml:p>		return null;</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p/><xhtml:p/><xhtml:p>//4、使用者</xhtml:p><xhtml:p/><xhtml:p>Car  car = SimpleFactory.getCar("benz");</xhtml:p><xhtml:p>car.run();</xhtml:p></html><plain>//1、产品的接口&#13;
interface  Car{&#13;
	void run();&#13;
}&#13;
&#13;
//2、各种产品&#13;
class Benz implements Car{&#13;
	public void run(){&#13;
			...&#13;
	}&#13;
}&#13;
&#13;
class BMW implements Car{&#13;
	public void run(){&#13;
			...&#13;
	}&#13;
}&#13;
&#13;
//3、工厂&#13;
class SimpleFactory {&#13;
&#13;
	public static Car getCar(String type){&#13;
		if("benz".equals(type)){&#13;
			return new Benz();&#13;
		}else if("bmw".equals(type)){&#13;
			return new BMW();&#13;
		}&#13;
&#13;
		return null;&#13;
	}&#13;
}&#13;
&#13;
&#13;
//4、使用者&#13;
&#13;
Car  car = SimpleFactory.getCar("benz");&#13;
car.run();</plain></notes></topic></topics></children></topic><topic id="7puus1ujg68d9lpaoff00r2bsj" modified-by="" timestamp="1511748044170"><title>2、工厂方法模式</title><children><topics type="attached"><topic id="2g43pe05kg7td8nau0s1m60bvn" modified-by="" timestamp="1511747701538"><title>特点</title><children><topics type="attached"><topic id="76u0ucppter3p465ggerhdav2n" modified-by="" timestamp="1511747708921"><title>一个产品配一个工厂</title></topic></topics></children></topic><topic id="6smmh2ok2d7c0eetf0s40aer45" modified-by="" timestamp="1511747783115"><title>缺点</title><children><topics type="attached"><topic id="130uklt83b1eqrb3d62oln3u5l" modified-by="" timestamp="1511747786049"><title>类比较多</title></topic></topics></children></topic><topic id="426dirt3rdmauf1028aetg793l" modified-by="" timestamp="1511747790411"><title>优点</title><children><topics type="attached"><topic id="38d60ckrscalhb4i24mnb98f59" modified-by="" timestamp="1511747810810"><title svg:width="500">增加一个新产品，对原来的代码不需要修改，只需要增加对应的工厂即可</title></topic></topics></children></topic><topic id="0gi1nats063kg81s9sbp337miv" modified-by="" timestamp="1511748226772"><title>示例代码</title><notes><html><xhtml:p>//1、产品的接口</xhtml:p><xhtml:p>interface  Car{</xhtml:p><xhtml:p>	void run();</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p/><xhtml:p>//2、各种产品</xhtml:p><xhtml:p>class Benz implements Car{</xhtml:p><xhtml:p>	public void run(){</xhtml:p><xhtml:p>			...</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p/><xhtml:p>class BMW implements Car{</xhtml:p><xhtml:p>	public void run(){</xhtml:p><xhtml:p>			...</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p/><xhtml:p>//3、各种工厂</xhtml:p><xhtml:p>interface  Factory{</xhtml:p><xhtml:p>	Car getCar();</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p/><xhtml:p>class BenzFactory implements Factory{</xhtml:p><xhtml:p>	public Benz getCar(){</xhtml:p><xhtml:p>		return new Benz();</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p/><xhtml:p>class BMWFactory implements Factory{</xhtml:p><xhtml:p>	public BMW getCar(){</xhtml:p><xhtml:p>		return new BMW();</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p/><xhtml:p>//4、使用者</xhtml:p><xhtml:p>BenzFactory f = new BenzFactory();</xhtml:p><xhtml:p/><xhtml:p>Car car = f.getCar();</xhtml:p><xhtml:p/><xhtml:p>car.run();</xhtml:p><xhtml:p/></html><plain>//1、产品的接口&#13;
interface  Car{&#13;
	void run();&#13;
}&#13;
&#13;
//2、各种产品&#13;
class Benz implements Car{&#13;
	public void run(){&#13;
			...&#13;
	}&#13;
}&#13;
&#13;
class BMW implements Car{&#13;
	public void run(){&#13;
			...&#13;
	}&#13;
}&#13;
&#13;
//3、各种工厂&#13;
interface  Factory{&#13;
	Car getCar();&#13;
}&#13;
&#13;
class BenzFactory implements Factory{&#13;
	public Benz getCar(){&#13;
		return new Benz();&#13;
	}&#13;
}&#13;
&#13;
class BMWFactory implements Factory{&#13;
	public BMW getCar(){&#13;
		return new BMW();&#13;
	}&#13;
}&#13;
&#13;
//4、使用者&#13;
BenzFactory f = new BenzFactory();&#13;
&#13;
Car car = f.getCar();&#13;
&#13;
car.run();&#13;
</plain></notes></topic></topics></children></topic><topic id="6s04oud701jjvpie9t92a9akqp" modified-by="" timestamp="1511747676766"><title>3、抽象工厂设计模式</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><title>设计模式</title></sheet><sheet id="49h3dmkalf1lbsn2ate9jopuba" modified-by="" style-id="487gi5ovjek2lvp9sjqneegdtc" theme="xminddefaultthemeid" timestamp="1512526360438"><topic id="17mrtu3l8chvr316vtlolrv07t" modified-by="" structure-class="org.xmind.ui.logic.right" timestamp="1511917490164"><title>面向对象高级特性</title><extensions><extension provider="org.xmind.ui.map.unbalanced"><content><right-number>-1</right-number></content></extension></extensions><children><topics type="attached"><topic branch="folded" id="1paeq8kqq69qcoreld5icu5r7e" modified-by="" timestamp="1512526360438"><title>抽象</title><children><topics type="attached"><topic id="26lq6ojq91drvctqd194cmlj19" modified-by="" timestamp="1511746062378"><title>为什么会有抽象类</title><children><topics type="attached"><topic id="3flq27ks2u6m029ei8m064pjf1" modified-by="" timestamp="1511746060709"><title svg:width="500">当子类中都有一个共同的方法，每一个子类都有不同的实现，在父类中又要体现所有子类的共同的特点，所以要体现有这个方法，但是在父类中又无法给出具体的实现，那么这个时候就需要把这个方法声明为抽象的，而包含抽象方法的类，必须是抽象类</title></topic><topic id="56fh3u1p97qapvi46m1dek242b" modified-by="" timestamp="1511746062367"><title svg:width="500">某个父类仅仅是表示一个抽象的概念，不希望它被实例化，这个时候父类中可能没有抽象方法，但是我们也把它声明为抽象类</title></topic></topics></children></topic><topic id="123ijf5ufk02e9tkmv621643i8" modified-by="" timestamp="1511746077195"><title>如何声明抽象类</title><children><topics type="attached"><topic id="4nte0l0akjtd9l457l1gdoi2q1" modified-by="" timestamp="1511746081151"><title>语法格式</title><children><topics type="attached"><topic id="78sclc0ffelqj69gv8luujj2bl" modified-by="" timestamp="1511746082334"><title>[public/缺省] abstract class 类名{&#13;
}</title></topic></topics></children></topic></topics></children></topic><topic id="2s6ln2a41ik1mi005guu7p765b" modified-by="" timestamp="1511746096316"><title>如何声明抽象方法</title><children><topics type="attached"><topic id="7tinf1bmpm2jn2micln2jve6tt" modified-by="" timestamp="1511746101722"><title>语法格式</title><children><topics type="attached"><topic id="2mumclp913nt2ejnmknedj5mep" modified-by="" timestamp="1511746171478"><title svg:width="500">[public/protected/缺省]  abstract   返回值类型   方法名([形参列表]);</title><children><topics type="attached"><topic id="3u5381ju238ve24u8h89c2n34p" modified-by="" timestamp="1511746185994"><title>抽象方法是不能private,static,final修饰的</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="0d1jfqfrqcsnua5k2kngt17uvc" modified-by="" timestamp="1511746211072"><title>抽象类的特点</title><children><topics type="attached"><topic id="7ci60vi3d439aabh6la3bh5apt" modified-by="" timestamp="1511746212456"><title svg:width="500">（1）抽象类不能实例化&#13;
（2）抽象类可以包含抽象方法，也可以没有抽象方法。&#13;
如果一个类有抽象方法，那么这个类必须是抽象类，&#13;
如果一个抽象类没有抽象方法，那么它的用意是不想实例化，用它仅仅表示一个抽象的概念。&#13;
（3）抽象类生来就是用来被继承的，那么子类在继承它的时候，必须重写（实现）抽象父类的抽象方法，&#13;
否则该子类也得是抽象类。&#13;
（4）抽象类的变量与子类的对象构成多态引用。&#13;
（5）抽象类除了不能实例化，可以包含抽象方法，其他的和非抽象类是一样的，&#13;
可以有成员变量（类变量、实例变量）、构造器、代码块（静态代码块和非静态代码块）&#13;
方法（静态方法、非静态方法）</title></topic></topics></children></topic><topic id="2ff3r3hk6t1gva75bht27r6p31" modified-by="" timestamp="1511746228241"><title>抽象类不能实例化，为什么要有构造器呢？</title><children><topics type="attached"><topic id="7hljroh7pr5a9an2qtk8iks6jd" modified-by="" timestamp="1511746233915"><title svg:width="500">子类在继承该类时，一定要调用它的构造器，为属性初始化。</title><children><topics type="attached"><topic id="3dp2qh9n1p52f49hpvfbkjous8" modified-by="" timestamp="1511746262782"><title>因为构造器的作用有两点</title><children><topics type="attached"><topic id="01ujrfombs96jta9iln15lunna" modified-by="" timestamp="1511746262111"><title>（1）和new一起创建对象</title></topic><topic id="4kssbig2sem414f7i5bmoc464c" modified-by="" timestamp="1511746274933"><title>（2）为属性初始化</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic branch="folded" id="689idmgjbepi4ep6e5c9ktn66i" modified-by="" timestamp="1512526359231"><title>接口</title><children><topics type="attached"><topic id="5ucmhu24dj50qkppneuq5g68o9" modified-by="" timestamp="1511746785541"><title>接口即代表行为标准，功能标准</title></topic><topic id="4da2cknbt8vhqhjhfp1g7q2t2u" modified-by="" timestamp="1511746986735"><title>如何声明一个接口？</title><children><topics type="attached"><topic id="4tgoe6vuqilq7bo70n04hmjt79" modified-by="" timestamp="1511746992062"><title>语法结构</title><children><topics type="attached"><topic id="5igv1qs304u3fcf2e8857m5hkq" modified-by="" timestamp="1511746993186"><title>[public/缺省] interface 接口名{&#13;
}</title></topic></topics></children></topic></topics></children></topic><topic id="12mht89p2484t7apl6pkckl5v4" modified-by="" timestamp="1511747006749"><title>如何实现接口？</title><children><topics type="attached"><topic id="4nrn13nokgabbgvkpg4adfullg" modified-by="" timestamp="1511747023551"><title>语法结构</title><children><topics type="attached"><topic id="0jk10oauuk4he90o7uip7875l3" modified-by="" timestamp="1511747024980"><title svg:width="500">[public/缺省] class 子类名 [extends 父类名] implements  接口名1，接口名2。。。{&#13;
	//要实现接口的所有抽象方法&#13;
}</title></topic></topics></children></topic></topics></children></topic><topic id="5o8cp338iokj94q9feebr93e9i" modified-by="" timestamp="1511747134822"><title>接口的特点</title><children><topics type="attached"><topic id="24eln82jcppeijs8aaqj8jo9sa" modified-by="" timestamp="1511747112136"><title>JDK1.7</title><children><topics type="attached"><topic id="30php8rsf5hlg8oj2f6ccckk16" modified-by="" timestamp="1511747114072"><title svg:width="500">JDK1.7：&#13;
（1）接口不能实例化&#13;
（2）接口只能有全局静态的常量和公共的抽象方法&#13;
（3）接口中不能有构造器，因为它没有属性需要初始化，又不能创建对象&#13;
（4）接口生来用来被实现的，那么实现类（像子类）在实现它时，必须实现（和重写要求一样）接口的&#13;
所有抽象方法，否则该实现类也得是抽象类&#13;
（5）一个类可以同时实现多个接口&#13;
（6）一个类还可以继承父类又实现接口，但是必须先继承后实现&#13;
（7）接口与接口之间是继承关系，一个接口可以继承多个接口&#13;
（8）接口与实现类的对象之间构成多态引用</title></topic></topics></children></topic><topic id="6611cktbpm1cpgjskjvlmbt3o7" modified-by="" timestamp="1511747145811"><title>JDK1.8</title><children><topics type="attached"><topic id="6sisbmqcmhc2k58v0ie07tqob2" modified-by="" timestamp="1511747209402"><title svg:width="500">其他的和JDK1.7一样，不一样的是：&#13;
JDK1.8之后，接口中除了全局静态的常量和公共的抽象方法以外，可以有静态方法和默认方法</title><children><topics type="attached"><topic id="3tqv5qo96euci3f05qttp6pc7g" modified-by="" timestamp="1511747196151"><title>接口中的静态方法</title><children><topics type="attached"><topic id="7v80fhtoo1rb64v28t0c6b0riv" modified-by="" timestamp="1511747194942"><title svg:width="500">当接口的所有实现类，对这个方法的实现是一样的，这个方法就设计在接口中，设计为静态方法</title></topic><topic id="3ho2il8t1s3hlf5309dtmanhf1" modified-by="" timestamp="1511747200572"><title>如何调用</title><children><topics type="attached"><topic id="14ngpp1dokp2r4o9st528o5k07" modified-by="" timestamp="1511747205688"><title>接口名.方法</title></topic></topics></children></topic></topics></children></topic><topic id="3ci070vn5iertsm1k055sgmjk3" modified-by="" timestamp="1511747466454"><title>接口中的默认方法</title><children><topics type="attached"><topic id="57gf1e45aea59rqadcd3rm9ofd" modified-by="" timestamp="1511747261595"><title svg:width="500">当接口的大多数实现类，对这个方法的实现是一样，那么这个方法的实现就可以在接口中提供默认实现，如果某个实现类觉得他不合适，只需要重写它即可</title></topic><topic id="3ueqak93ahucgjdkmqs74qdh33" modified-by="" timestamp="1511747302860"><title>如何调用</title><children><topics type="attached"><topic id="3qh3souakitd10m8g054ht1m7h" modified-by="" timestamp="1511747302037"><title>实现类外</title><children><topics type="attached"><topic id="3aqguqh5qs2mcjcl3id7kvsrd8" modified-by="" timestamp="1511747302018"><title>实现类对象.方法</title></topic></topics></children></topic><topic id="3mav7dkjk2k3ageo2d7dg12v8b" modified-by="" timestamp="1511747329806"><title>实现类中</title><children><topics type="attached"><topic id="68lh8jqu05h48l9cqh772c67hm" modified-by="" timestamp="1511747328308"><title svg:width="500">如果实现类要重写该默认方法，但是又想调用接口中的默认实现</title></topic><topic id="2fihn3q16ealhkj9c90nmnipo7" modified-by="" timestamp="1511747339312"><title>接口名.super.方法</title></topic></topics></children></topic></topics></children></topic><topic id="1pfec4j3q62g3lel02u0koqlag" modified-by="" timestamp="1511747376830"><title>什么情况下需要重写</title><children><topics type="attached"><topic id="13ojndejcqqdddbgju9d6jrnbn" modified-by="" timestamp="1511747373525"><title>接口中的默认实现不适合该实现类</title></topic><topic id="4m95lf2fevuv6ib1tr1c80gaq7" modified-by="" timestamp="1511747383155"><title>必须重写</title><children><topics type="attached"><topic id="6l0g11t7hfb47h9mjqd2aq3op6" modified-by="" timestamp="1511747454317"><title svg:width="500">一个类同时实现了多个接口，而多个接口中都相同的默认方法（方法名和形参列表都相同），这个时候实现类必须做出选择，要重写，如果需要保留其中一个的话，通过接口名.super.方法，保留它的默认实现</title></topic></topics></children></topic></topics></children></topic><topic id="6lrim758b6mrpod9uo3t4m44jj" modified-by="" timestamp="1511747475302"><title>类优先原则</title><children><topics type="attached"><topic id="4cs419onrk99p5519s53njqc7l" modified-by="" timestamp="1511747524680"><title svg:width="500">当一个类继承了父类，又实现了接口，而且父类中的某个方法与接口中的默认方法一样（方法名和形参列表），默认保留的是父类中的方法实现</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic branch="folded" id="7ia5a5520b8e8d8ei531imdsac" modified-by="" timestamp="1512526357787"><title>枚举</title><children><topics type="attached"><topic id="1j0vdmir49eefkm55jcufsklvg" modified-by="" timestamp="1511832334881"><title svg:width="500">枚举是指某个类型的对象是有限个，在类型中一一创建并列举它的对象</title></topic><topic id="65t48r4dd5sndlsfam6rkp9j0u" modified-by="" timestamp="1511832383251"><title>JDK1.5之前，如何解决</title><children><topics type="attached"><topic id="3omaj95f2kgf76kof7qje1fave" modified-by="" timestamp="1511832369927"><title>（1）构造器私有化</title></topic><topic id="16v4k852661sm5j02hmji73qpo" modified-by="" timestamp="1511832381966"><title>（2）通过常量的方式创建好所有对象</title></topic><topic id="48domp1vd060almp5nb2ggfu8b" modified-by="" timestamp="1511832417126"><title>示例</title><notes><html><xhtml:p>class Week{</xhtml:p><xhtml:p>	public static final Week MONDAY = new Week();</xhtml:p><xhtml:p>	public static final Week TUESDAY = new Week();</xhtml:p><xhtml:p>	public static final Week WEDNESDAY = new Week();</xhtml:p><xhtml:p>	public static final Week THURSDAY = new Week();</xhtml:p><xhtml:p>	public static final Week FRIDAY = new Week();</xhtml:p><xhtml:p>	public static final Week SATURDAY = new Week();</xhtml:p><xhtml:p>	public static final Week SUNDAY = new Week();</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>	private Week(){</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p/><xhtml:p/><xhtml:p>Week w = Week.MONDAY;</xhtml:p></html><plain>class Week{&#13;
	public static final Week MONDAY = new Week();&#13;
	public static final Week TUESDAY = new Week();&#13;
	public static final Week WEDNESDAY = new Week();&#13;
	public static final Week THURSDAY = new Week();&#13;
	public static final Week FRIDAY = new Week();&#13;
	public static final Week SATURDAY = new Week();&#13;
	public static final Week SUNDAY = new Week();&#13;
	&#13;
	private Week(){&#13;
		&#13;
	}&#13;
}&#13;
&#13;
&#13;
Week w = Week.MONDAY;</plain></notes></topic></topics></children></topic><topic id="0mtbis72dor198m903rlr8hbtr" modified-by="" timestamp="1511832491652"><title>JDK1.5之后，如何解决</title><children><topics type="attached"><topic id="5lpd8tddk3fr03qot6rr1tur1t" modified-by="" timestamp="1511832486061"><title>如何声明</title><children><topics type="attached"><topic id="1qokinkjcg5v0vkvqmokm4mhnv" modified-by="" timestamp="1511832472742"><title>[修饰符] enum  枚举类型名{&#13;
	常量对象列表&#13;
}</title></topic><topic id="0pspajk423pg160pqcef1ss3g1" modified-by="" timestamp="1511832487609"><title>[修饰符] enum  枚举类型名{&#13;
	常量对象列表;&#13;
	其他成员;&#13;
}</title></topic></topics></children></topic><topic id="0kitt3dt52hi3v44gcpa45cslj" modified-by="" timestamp="1511832830624"><title>特点</title><children><topics type="attached"><topic id="1aqosu7ifs8d5h0dko7bkgbfqj" modified-by="" timestamp="1511832519457"><title>（1）枚举类型中的构造器都是私有化</title></topic><topic id="32c97albste0k5bmcot59ji8fo" modified-by="" timestamp="1511832546476"><title svg:width="500">（2）常量对象列表必须在首行，如果常量对象列表后面还有其他的代码，那么要用;结束</title></topic><topic id="66bvntbi20d3e41i65j85or9dl" modified-by="" timestamp="1511832762090"><title svg:width="500">（3）枚举类型不能继承别的类型，因为它默认继承java.lang.Enum</title><children><topics type="attached"><topic id="5imsvrabh4u58hbdenskuvqksv" modified-by="" timestamp="1511832741911"><title>它有一些方法</title><children><topics type="attached"><topic id="2en4e889vp49l0adodbpan6l4n" modified-by="" timestamp="1511832610160"><title>name()</title><children><topics type="attached"><topic id="2onobn15p3d90oo1jvuq6l8fgp" modified-by="" timestamp="1511832619099"><title>返回常量对象名</title></topic></topics></children></topic><topic id="16r3fftdfs7b6hk72hpf3ebebs" modified-by="" timestamp="1511832624528"><title>ordinal()</title><children><topics type="attached"><topic id="7bp0a4o08dlbuvb54472dphcvq" modified-by="" timestamp="1511832636602"><title>返回常量对象的序号，从0开始</title></topic></topics></children></topic><topic id="1opncbqtbhv7blr0g8imppbjkq" modified-by="" timestamp="1511832670253"><title svg:width="500">实现了java.lang.Comparable接口，重写compareTo()，按照常量对象的顺序排序</title><children><topics type="attached"><topic id="66v5169umvf91v01n665bhhhab" modified-by="" timestamp="1511832684812"><title>如果自己的枚举类中不适合，可以重写</title></topic></topics></children></topic><topic id="3i64hb27fv50q4upi66h26uemd" modified-by="" timestamp="1511832748662"><title>toString()</title><children><topics type="attached"><topic id="4i6iadg1m3007utrc9b05aeehg" modified-by="" timestamp="1511832750046"><title>返回常量对象名</title><children><topics type="attached"><topic id="07i5bubda8p6nnil79ngvlke4t" modified-by="" timestamp="1511832752852"><title>可以重写</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="7chqneahq8uauc9nfghf89adrg" modified-by="" timestamp="1511832793557"><title>API中没有的方法</title><children><topics type="attached"><topic id="7gk0ondc2g2slp3vmjtnrhvbt3" modified-by="" timestamp="1511832783117"><title>枚举类型名.values()</title><children><topics type="attached"><topic branch="folded" id="2ionc3k8atllnajog1noa4kdce" modified-by="" timestamp="1511832792630"><title>返回枚举常量对象组成的数组</title></topic></topics></children></topic><topic id="2u9acbec8p04ovubkv0g2v5spg" modified-by="" timestamp="1511832811881"><title>枚举类型名.valueOf（常量对象的名称）</title><children><topics type="attached"><topic id="1mqtj04mdkb2ahagmna2tc8im0" modified-by="" timestamp="1511832822714"><title>返回某一个指定的对象</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="6lnia719nojagpv5imdg3pdeha" modified-by="" timestamp="1511832907003"><title>（4）switch对枚举加入支持</title><children><topics type="attached"><topic id="2hqdc4jacooj2mab1ms6ue3388" modified-by="" timestamp="1511832908346"><title>switch(枚举类型表达式){&#13;
	case 常量对象名1:&#13;
		语句;&#13;
		[break;]&#13;
	case 常量对象名2:&#13;
		语句;&#13;
		[break;]&#13;
	case 常量对象名3:&#13;
		语句;&#13;
		[break;]	&#13;
	default:&#13;
		语句;&#13;
		[break;]		&#13;
}</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic branch="folded" id="65i9jlphpqp40p1ro47gbtp0go" modified-by="" timestamp="1512526355415"><title>注解</title><children><topics type="attached"><topic id="3ci3p3ba2tu4ujtk7cporv7k39" modified-by="" timestamp="1511917536068"><title>概念</title><children><topics type="attached"><topic id="2saf0do1vc9kvuli43lvk8mkng" modified-by="" timestamp="1511917533462"><title>代码级别的注释</title></topic><topic id="7etj8kf7rl7c2vbv04jdq5catr" modified-by="" timestamp="1511917542666"><title>给代码读取的注释</title><children><topics type="attached"><topic id="3s4vi33qdr3fa8enhs23lfe2f6" modified-by="" timestamp="1511917567576"><title>不同普通的注释（给人看的）</title><children><topics type="attached"><topic id="7vdt2bltk42qatbqjqgk8cnuk6" modified-by="" timestamp="1511917554139"><title>单行注释</title></topic><topic id="7p6nc7ivi7ii4adpmriubjpsa4" modified-by="" timestamp="1511917558136"><title>多行注释</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="4lslfhoe04lu2h5no2ke83c3il" modified-by="" timestamp="1511917616934"><title>四种</title><children><topics type="attached"><topic id="0bs3m24qv0oproosliigfku7ei" modified-by="" timestamp="1511919202075"><title>1、编译器的格式检查</title><children><topics type="attached"><topic id="5atm2m0o21moqf3r9rkbi1em8t" modified-by="" timestamp="1511917656968"><title svg:width="500">（1）@Override：告知编译器对该方法按照“重写”的要求进行格式检查</title></topic><topic id="2f7pg4hqagf5h5udb79enu8fo3" modified-by="" timestamp="1511917686705"><title svg:width="500">（2）@SuppressWarnings：告知编译器抑制警告</title></topic><topic id="1vr69h1kure7bn1h7vluph4gj2" modified-by="" timestamp="1511917700125"><title svg:width="500">（3）@Deprecated：告知编译器某个元素是已过时，有人用了就弹出警告</title></topic></topics></children><marker-refs><marker-ref marker-id="flag-red"/></marker-refs></topic><topic id="6f57ejkqgbmd6g9it98vhdv9iu" modified-by="" timestamp="1511918051824"><title>2、文档注释</title><children><topics type="attached"><topic id="1npi2c3g2610keg3hei80bhhg5" modified-by="" timestamp="1511917791112"><title>（1）@version</title><children><topics type="attached"><topic id="5dr9hsa4o35lrq9sgtg1dg8ic3" modified-by="" timestamp="1511917796851"><title>指定当前版本</title></topic></topics></children></topic><topic id="64nagkslt62go4gch4h5553n0l" modified-by="" timestamp="1511917797087"><title>（2）@author</title><children><topics type="attached"><topic id="6fuggojblgoam6nc91ini9ft1u" modified-by="" timestamp="1511917800644"><title>指定作者</title></topic></topics></children></topic><topic id="19864n0m5iq9mkuregakgjqhh4" modified-by="" timestamp="1511917801049"><title>（3）@since</title><children><topics type="attached"><topic id="74de6ovi6oshvfbpcnh5qkf11q" modified-by="" timestamp="1511917808102"><title>指定从哪个版本开始</title></topic></topics></children></topic><topic id="4545kfps2ln6jc62u1kdi3c2j4" modified-by="" timestamp="1511917808425"><title>（4）@see</title><children><topics type="attached"><topic id="7hbu5djecok1c96ren9b5i2llp" modified-by="" timestamp="1511917814251"><title>另请参阅</title></topic></topics></children></topic><topic id="1ljsl24jbhpap71ijk1rro2dmi" modified-by="" timestamp="1511917922163"><title>（5）param</title><children><topics type="attached"><topic id="7oa0gahq60g1tbqiahd672kjfe" modified-by="" timestamp="1511917830486"><title>指定当前方法的形参信息</title></topic><topic id="42bri3p998b025ivilai6v433p" modified-by="" timestamp="1511917857409"><title>可以多个</title></topic><topic id="5hnf0cavqakgo74tnkfacf0orm" modified-by="" timestamp="1511917899057"><title>只有方法有形参才能标记</title></topic><topic id="1qi4jqj8kf8ns7j20dgas8ngdn" modified-by="" timestamp="1511917927034"><title>格式：</title><children><topics type="attached"><topic id="5g7k8t7ppc1vjodclodleao8bq" modified-by="" timestamp="1511917961297"><title>@param  形参名  形参类型   形参的描述信息</title></topic></topics></children></topic></topics></children></topic><topic id="3mljegutd04ijn3trubmps7s7s" modified-by="" timestamp="1511917963103"><title>（6）@return</title><children><topics type="attached"><topic id="2mvg834o7gs6j14lknpk575p2q" modified-by="" timestamp="1511917838308"><title>指定当前方法的返回值信息</title></topic><topic id="2sbcu5u7nlpridqimljroi7v0j" modified-by="" timestamp="1511917887758"><title svg:width="500">一个方法只能有一个，如果方法是void，就不能标记@return</title></topic><topic id="4ki6f56fn8bmjbrbllifhc5jk5" modified-by="" timestamp="1511917966966"><title>格式</title><children><topics type="attached"><topic id="3f9csf3hgesidiiv0hk2i3op9m" modified-by="" timestamp="1511917984388"><title>@return  返回值的类型  返回值的描述</title></topic></topics></children></topic></topics></children></topic><topic id="2fpp1eukort9tarkkm2afasq62" modified-by="" timestamp="1511917988178"><title>（7）@exception</title><children><topics type="attached"><topic id="3c5gqjh72l6h9prmg9c0in8bvk" modified-by="" timestamp="1511917850249"><title>指定当前方法抛出异常的信息</title></topic><topic id="77cab2enhifs4vcnbvugobss5n" modified-by="" timestamp="1511917860645"><title>可以多个</title></topic><topic id="5g63q46tca2aepg3bp0g4k17nh" modified-by="" timestamp="1511917910812"><title>只有方法抛出异常才能标记</title></topic><topic id="6a7bnu3j0rn43pd5knig9r9e8a" modified-by="" timestamp="1511917988145"><title>格式</title><children><topics type="attached"><topic id="7lkdrfngdj76g1jjr04a8jrnn1" modified-by="" timestamp="1511918008220"><title>@exception  异常类型  异常的描述</title></topic></topics></children></topic></topics></children></topic><topic id="4vqk1c77jnev9ef4ued454rqr1" modified-by="" timestamp="1511918060800"><title>结合javadoc.exe</title></topic></topics></children></topic><topic id="6q6s426jtc27i46e1l2ea05edm" modified-by="" timestamp="1511918170782"><title>3、JUnit的单元测试</title><children><topics type="attached"><topic id="3irhnqm8idhqjasecu4ckpjhth" modified-by="" timestamp="1511918113242"><title svg:width="500">白盒测试，程序员自己的测试，在程序员知道当前的代码的功能的</title></topic><topic id="3mmd3c6oc5qa2volnsotgpskk4" modified-by="" timestamp="1511919207034"><title>@Test</title><children><topics type="attached"><topic id="1i0phft813c04gbi15ofgfa709" modified-by="" timestamp="1511918126217"><title>加在方法上</title></topic><topic id="2e4gplntc5cq4lgdae1qnomk0c" modified-by="" timestamp="1511918145033"><title svg:width="500">这个方法必须是公共的，无参，无返回值，不能是static</title></topic></topics></children><marker-refs><marker-ref marker-id="flag-red"/></marker-refs></topic><topic id="1d5scs7ti5lej0jfdtmhbs101f" modified-by="" timestamp="1511918155978"><title>@Before</title><children><topics type="attached"><topic id="4opu33d3v7v6hfjmn0qne6bj9b" modified-by="" timestamp="1511918168416"><title>在@Test标记的方法之前运行</title></topic></topics></children></topic><topic id="3smfq1empd0hspipcfulbic0ro" modified-by="" timestamp="1511918176460"><title>@After</title><children><topics type="attached"><topic id="05qji2jnm6jf4vru8bd74vb1ul" modified-by="" timestamp="1511918182001"><title>在@Test标记的方法之后运行</title></topic></topics></children></topic></topics></children></topic><topic id="64m91btiaethhdkn4b6bt0pqvj" modified-by="" timestamp="1511917634028"><title>4、各大框架等替代配置文件</title></topic></topics></children></topic><topic id="1fo7vqknsmah8gl96tfb5semv8" modified-by="" timestamp="1511918278865"><title>注解的三个部分</title><children><topics type="attached"><topic id="31nakhmje8tvuadp2h0d9bpfd9" modified-by="" timestamp="1511918258186"><title>1、声明</title><children><topics type="attached"><topic id="444gjo0447sg4abdfkb1kr2tcd" modified-by="" timestamp="1511918268705"><title>一般都是别人声明好的</title></topic></topics></children></topic><topic id="766umok5etsjm4jh5inljsba93" modified-by="" timestamp="1511918277696"><title>2、使用</title></topic><topic id="3150qnca940prgok46nhi4gjd0" modified-by="" timestamp="1511918394462"><title>3、读取</title><children><topics type="attached"><topic id="5r5eboo2sm634ppcactrkd023h" modified-by="" timestamp="1511918314205"><title>例如：@Override等，由javac.exe</title></topic><topic id="2g0biqkeuijosidjlub7imegkc" modified-by="" timestamp="1511918337187"><title>例如：@author,@param等，由javadoc.exe</title></topic><topic id="7esl8lo63ddsddfuj6e7jvvpti" modified-by="" timestamp="1511918362839"><title>例如：@Test等，由JUnit相关的类读取</title></topic><topic id="7v09oc0aesqvgpu50jku4qm3cq" modified-by="" timestamp="1511918385809"><title>例如：@WebServlet等，由Tomcat读取</title></topic><topic id="7drtkj7eijl5ijfk79nol4f55c" modified-by="" timestamp="1511918390680"><title>...</title></topic><topic id="61apg0har9pnv6b1hmr7goi94n" modified-by="" timestamp="1511918442474"><title svg:width="500">如果自己要读取，通过反射，而且只能读取@Retention(RetentionPolicy.RUNTIME)</title><marker-refs><marker-ref marker-id="flag-red"/></marker-refs></topic></topics></children></topic></topics></children></topic><topic id="0car5k1iu5ml4io29buvo3t5na" modified-by="" timestamp="1511918461504"><title>注解的声明</title><children><topics type="attached"><topic id="07hfq956fige8n3hftq8f77o62" modified-by="" timestamp="1511918498667"><title>（1）无参</title><children><topics type="attached"><topic id="68d2gkvf4t01rlrsftri7ifkvd" modified-by="" timestamp="1511918497771"><title>声明格式</title><children><topics type="attached"><topic id="3mbag8sda6s4blj863mdgcl9bk" modified-by="" timestamp="1511918497745"><title>@元注解&#13;
[修饰符]  @interface  注解名{}</title></topic></topics></children></topic><topic id="2pno6qri1qi0ho3e0dhblkp9bc" modified-by="" timestamp="1511918503636"><title>使用格式</title><children><topics type="attached"><topic id="5jqjgbjqd54ll1nje7vidb21ri" modified-by="" timestamp="1511918507195"><title>@注解名</title></topic></topics></children></topic></topics></children></topic><topic id="7pclal6qnl79mem6cth6oodauv" modified-by="" timestamp="1511918530826"><title>（2）有参</title><children><topics type="attached"><topic id="1fvg8dgt1djlgl44kjgoa0kq5h" modified-by="" timestamp="1511918514593"><title>声明格式</title><children><topics type="attached"><topic id="2iavvinjrph9m45ut0h0okoipv" modified-by="" timestamp="1511918578595"><title>@元注解&#13;
[修饰符]  @interface  注解名{&#13;
		配置参数&#13;
}</title><children><topics type="attached"><topic id="0knl9d6ec78hqo4ug86jifjcoc" modified-by="" timestamp="1511918687425"><title>配置参数</title><children><topics type="attached"><topic id="74sk7tp32nknjsnlcacruao4qr" modified-by="" timestamp="1511918561960"><title>格式</title><children><topics type="attached"><topic id="27cp9onneei49lnabkogfs6uf6" modified-by="" timestamp="1511918573108"><title>数据类型  参数名();</title></topic></topics></children></topic><topic id="1tghesidjl4gm6bcu67jjlv855" modified-by="" timestamp="1511918586763"><title>一个注解可以有多个配置参数</title></topic><topic id="1je11cgonasdm9jq9v5tb144v1" modified-by="" timestamp="1511918600587"><title>配置参数可以有默认值</title><children><topics type="attached"><topic id="7i680rck3l4i8cq10aj24q4o9p" modified-by="" timestamp="1511918611245"><title>数据类型  参数名() default 默认值;</title></topic></topics></children></topic><topic id="1k825ojujl9og9pdv67egb7m2g" modified-by="" timestamp="1511918695620"><title>配置参数的类型有要求</title><children><topics type="attached"><topic id="3if8dgjk9ssujq37ia7jdlca3k" modified-by="" timestamp="1511918696921"><title svg:width="500">类型只能是八种基本数据类型、String类型、Class类型、enum类型、Annotation类型、以上所有类型的数组</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="7ltk1t546185smo0it59r09dkn" modified-by="" timestamp="1511918529701"><title>使用格式</title><children><topics type="attached"><topic id="5ko4dgsa3q2n7usge8k1csrusk" modified-by="" timestamp="1511918775201"><title>@注解(参数赋值)</title><children><topics type="attached"><topic id="1pdhsu7qcc9jvulh0goosst6mr" modified-by="" timestamp="1511918749893"><title svg:width="500">如果配置参数有默认值，那么可以在使用时不需要赋值</title></topic><topic id="6274oemmur297o42kcje0ocijn" modified-by="" timestamp="1511918774266"><title svg:width="500">如果配置参数只有一个，而且名称是value，那么可以在赋值时省略value=</title></topic><topic id="24960ap9cuta9osrk3n38g61eh" modified-by="" timestamp="1511918801539"><title>参数赋值的格式</title><children><topics type="attached"><topic id="74fdkro8tlv64ueg93jpaqv88v" modified-by="" timestamp="1511918793597"><title>参数名 = 参数值</title></topic><topic id="7vtglb5js346j2bl145eb2777c" modified-by="" timestamp="1511918801291"><title>如果多个使用,分割</title></topic><topic id="2amvhrl3huo5bmbdvilnlhs5uj" modified-by="" timestamp="1511918826288"><title>如果配置参数的类型是数组类型</title><children><topics type="attached"><topic id="1qd2cathn1sfskpv769snqjtuu" modified-by="" timestamp="1511918825010"><title>如果只有一个元素，那么可以省略{}</title></topic><topic id="55om8socthbec4paj2f6pm180n" modified-by="" timestamp="1511918834732"><title>如果是多个元素，那么需要{}</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="58p4npruqf2q9ibu5dehr25o6t" modified-by="" timestamp="1511918908335"><title>元注解</title><children><topics type="attached"><topic id="33ep2egso61hhdabpdavtc2gti" modified-by="" timestamp="1511919217073"><title>@Target</title><children><topics type="attached"><topic id="5a8mg0dl44id41sro9029ukbk4" modified-by="" timestamp="1511918924799"><title>指定某个注解它的使用目标位置</title></topic><topic id="7vsb86l3nlklflirpitiovpijf" modified-by="" timestamp="1511919026737"><title>如何指定它</title><children><topics type="attached"><topic id="6mdeh5d8jjf2s6oqdj9kmo4eup" modified-by="" timestamp="1511918988982"><title>它配置参数的类型是一个枚举数组</title><children><topics type="attached"><topic id="4ot6hl0ooq0af15mk27936o2p3" modified-by="" timestamp="1511918954355"><title>ElementType枚举类型</title><children><topics type="attached"><topic id="14c0rq5v76iu60f5q003csl48c" modified-by="" timestamp="1511918974289"><title>常量对象有：TYPE, FIELD,METHOD等</title></topic></topics></children></topic></topics></children></topic><topic id="78qeg09specr4vje2jnliiqebu" modified-by="" timestamp="1511919003118"><title>配置参数的名称是value</title></topic><topic id="7kar397hrkm6mcqtktk3954vjb" modified-by="" timestamp="1511919014065"><title>如果只有一个</title><children><topics type="attached"><topic id="378n56isj6n8rck9i7qi2ostfi" modified-by="" timestamp="1511919024844"><title>@Target(ElementType.METHOD)</title></topic></topics></children></topic><topic id="167s7dg6q1akuhkg4asu99rion" modified-by="" timestamp="1511919033154"><title>如果是多个</title><children><topics type="attached"><topic id="0jupci7l04j9jf1k6np65ude4h" modified-by="" timestamp="1511919055560"><title svg:width="500">@Target({ElementType.METHOD,ElementType.FIELD,。。。。})</title></topic></topics></children></topic></topics></children></topic></topics></children><marker-refs><marker-ref marker-id="flag-red"/></marker-refs></topic><topic id="1nfc1tjc6bhfau80pbh9h4k8cg" modified-by="" timestamp="1511919219270"><title>@Retention</title><children><topics type="attached"><topic id="3b4tcrhgvepct1dr4cp6jd1k14" modified-by="" timestamp="1511919073126"><title>指定某个注解的生命周期，可以保留到什么阶段</title></topic><topic id="44lug4evbflt26autqqg6fn3ff" modified-by="" timestamp="1511919128332"><title>如何指定它</title><children><topics type="attached"><topic id="0bi5v9g4r9n33klmtnuiqk2v74" modified-by="" timestamp="1511919092780"><title>它的配置参数的类型是一个枚举类型</title><children><topics type="attached"><topic id="6rd6etfhitav6qfn1v39822vts" modified-by="" timestamp="1511919106250"><title>RetentionPolicy类型</title><children><topics type="attached"><topic id="519sbjdn5pdhohrb2b4opkevci" modified-by="" timestamp="1511919112261"><title>常量对象有三个</title><children><topics type="attached"><topic id="63ab3q3dj6ort8sq8u326ao80e" modified-by="" timestamp="1511919120770"><title>SOURCE,CLASS,RUNTIME</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="7ib9frllt186khvvfcd7l995p5" modified-by="" timestamp="1511919126873"><title>配置参数的名称是value</title></topic><topic id="3sp64cn2ac3nvtmque9q8sstnm" modified-by="" timestamp="1511919156357"><title>@Retention(RetentionPolicy.RUNTIME)</title></topic></topics></children></topic></topics></children><marker-refs><marker-ref marker-id="flag-red"/></marker-refs></topic><topic id="362auqgi6sfak0bfrhulvc2ego" modified-by="" timestamp="1511919164800"><title>@Documented</title><children><topics type="attached"><topic id="59qfan5o72veerh3pjef9o7dq9" modified-by="" timestamp="1511919177672"><title>表示是否javadoc读取</title></topic></topics></children></topic><topic id="4780tsqmodetgghdb8vtn4krou" modified-by="" timestamp="1511919180412"><title>@Inherited</title><children><topics type="attached"><topic id="5n7nf0c580t68olcpl85bbd641" modified-by="" timestamp="1511919184721"><title>是否被子类继承</title></topic></topics></children></topic><topic id="0iv5v9ua4mg3865odb7ls98hcl" modified-by="" timestamp="1511918910394"><title>在java.lang.annotation包</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><title>面向对象高级特性</title></sheet><sheet id="4nghoqu4d99o19riu3bt4rhg5p" modified-by="" style-id="3u7qgl6ll5f24vpenqoulp67kb" theme="xminddefaultthemeid" timestamp="1512348456698"><topic id="6566uch9c9rq9gq1u4vv8tjp5e" modified-by="" structure-class="org.xmind.ui.logic.right" timestamp="1512348250842"><title>异常</title><extensions><extension provider="org.xmind.ui.map.unbalanced"><content><right-number>-1</right-number></content></extension></extensions><children><topics type="attached"><topic id="7f4avca8lpbjmbp680l3urm20p" modified-by="" timestamp="1512095704245"><title>1、什么是异常</title><children><topics type="attached"><topic id="2s12sm7aon8vhrj635canf9b7g" modified-by="" timestamp="1512095688419"><title>哪些不是异常</title><children><topics type="attached"><topic id="4i2pstmpcujglkcv0so4e03e0n" modified-by="" timestamp="1512095687633"><title>语法错误</title></topic><topic id="1eji6qvhknhpv76arcnh691qb9" modified-by="" timestamp="1512095692705"><title>逻辑错误</title></topic></topics></children></topic><topic id="43g7tgunjuvkbp3dpgqcf0gdfv" modified-by="" timestamp="1512095726655"><title>不可预知的非正常的情况</title><children><topics type="attached"><topic id="60gmq3gaatbiiv9lt6lv14uhpo" modified-by="" timestamp="1512095767547"><title svg:width="500">例如：网络中断，用户不合适的输入，硬盘已满，操作系统崩溃，内存溢出等</title></topic></topics></children></topic></topics></children></topic><topic id="2il9h3aa31v4evlnccvll4qunh" modified-by="" timestamp="1512100646011"><title>2、异常的体系结构</title><children><topics type="attached"><topic id="47e3q4ubbg8nfkopcgl50gn5k7" modified-by="" timestamp="1512095830460"><title>java.lang.Throwable</title><children><topics type="attached"><topic id="3jpnu4dtuovmb66h5gmedbeikr" modified-by="" timestamp="1512095813009"><title>所有异常和错误的超类</title></topic><topic id="5ueka1t3lggc5r2jh60rv2jedc" modified-by="" timestamp="1512095836530"><title svg:width="500">（1）只有这个类型或它子类的对象才能被“抛出”</title></topic><topic id="5a12h5l6lba44h0lcm5ffd1rb8" modified-by="" timestamp="1512095843065"><title svg:width="500">（2）只有这个类型或它子类的对象才能被“捕获”</title></topic></topics></children></topic><topic id="7gcif5dif9vkikrj7fd0bue7q3" modified-by="" timestamp="1512096059949"><title>分为两大类</title><children><topics type="attached"><topic id="50pvkmelc35f76ua9vf6h09tl4" modified-by="" timestamp="1512095866245"><title>java.lang.Error</title><children><topics type="attached"><topic id="181i6ee58c7aua8p0bioec7cfk" modified-by="" timestamp="1512095865726"><title>严重</title></topic><topic id="7p7c258lp4cmt8g6qlqqsmoimf" modified-by="" timestamp="1512095948313"><title>例如：VirtualMachineError</title><children><topics type="attached"><topic id="3aij2ehsu21enae4vfl9s2c3q9" modified-by="" timestamp="1512095947455"><title>StackOverflowError</title></topic><topic id="6t1octb74cb79k1obtoec0i1ej" modified-by="" timestamp="1512095987852"><title> OutOfMemoryError</title><children><topics type="attached"><topic id="10es37uuecbmckpdg4t14u125d" modified-by="" timestamp="1512095977358"><title>简称OOM</title></topic><topic id="0kfigqvsv1815rt7e13ijni0t5" modified-by="" timestamp="1512096010596"><title>如何解决</title><children><topics type="attached"><topic id="4jkopupk1n0a6gn9rrh7hshuiu" modified-by="" timestamp="1512096003146"><title>设计合理</title></topic><topic id="4fb9v8900o6rjenhc9lr1k7ear" modified-by="" timestamp="1512096018774"><title>修改JVM的参数</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="6tshpqoev9r89fi57882uf2412" modified-by="" timestamp="1512096082048"><title>java.lang.Exception</title><children><topics type="attached"><topic id="5m14mr4roo2g7dj40nujcfkpda" modified-by="" timestamp="1512096145126"><title>运行时异常RuntimeException</title><children><topics type="attached"><topic id="4usb8huk4faphqjib3l2bu332q" modified-by="" timestamp="1512096145005"><title>空指针异常：NullPointerException</title></topic><topic id="5ridcoeu9t0su0n3eib5jdefe0" modified-by="" timestamp="1512096145005"><title>数组下标越界异常：ArrayIndexOutOfBoundsException</title></topic><topic id="4tgq5ther0qre38kjq3f24j7o9" modified-by="" timestamp="1512096145005"><title>类型转换异常：ClassCastException</title></topic><topic id="0q2fjnlkj6vo7pc0mimk1h2s98" modified-by="" timestamp="1512096145005"><title>算术异常：ArithmeticException</title></topic><topic id="2fsmcvlotstmsv3ljjpcfu8e4u" modified-by="" timestamp="1512096145005"><title>数字格式化：NumberFormatException</title></topic></topics></children></topic><topic id="1tk2av437th4udrhur1cjqr3rd" modified-by="" timestamp="1512096111703"><title>编译时异常，受检异常</title><children><topics type="attached"><topic id="3k9gk3seocj0fc77j9el77toct" modified-by="" timestamp="1512096110405"><title svg:width="500">在编译阶段必须要求你编写代码去处理，否则编译不通过</title></topic><topic id="7luhktumn8j19p2bab42lj6dtb" modified-by="" timestamp="1512096127994"><title>例如：SQLException,IOException等</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="1ki1cgodt64u1vd0lnprd2r4rm" modified-by="" timestamp="1512347859546"><title>异常的处理机制</title><children><topics type="attached"><topic id="0lsqfqh6ekds4hiqfb977s08pt" modified-by="" timestamp="1512096180833"><title>1、过程描述</title><children><topics type="attached"><topic id="09pj9225fm3j13tu7fmst0i3ts" modified-by="" timestamp="1512096283458"><title svg:width="500">Java虚拟机会在发生异常的那句代码的位置，创建一个异常的对象，并且抛出，这个时候，它会检测有没有try..catch，如果有对应的catch，那么程序正常运行，如果没有合适的catch，会被往上抛出，如果一路上都没有被catch，最终会导致程序终止运行。</title></topic></topics></children></topic><topic id="45ktitlrebalmtnre5opel03l7" modified-by="" timestamp="1512097208354"><title>2、两种方式</title><children><topics type="attached"><topic id="43ahv76lci953l7e8prabe46jj" modified-by="" timestamp="1512097205966"><title>try...catch</title><children><topics type="attached"><topic id="31scspp3di7v8nkhj08e6e2ki2" modified-by="" timestamp="1512096307883"><title>语法结构</title><children><topics type="attached"><topic id="09q7ifcc8253j5gr4nqmioa765" modified-by="" timestamp="1512096413086"><title>try{&#13;
	可能发生异常的代码&#13;
}catch(异常的类型 e){&#13;
	捕获该异常后如何处理&#13;
}catch(异常的类型 e){&#13;
	捕获该异常后如何处理&#13;
}catch(异常的类型 e){&#13;
	捕获该异常后如何处理&#13;
}&#13;
...&#13;
finally{&#13;
	不管是否发生异常都要执行的代码&#13;
}&#13;
&#13;
下面的代码</title></topic></topics></children></topic><topic id="55scvd5emsfu7r9r23e0788cv2" modified-by="" timestamp="1512096545384"><title>执行特点</title><children><topics type="attached"><topic id="73b5n387bkaf6amvdq51tv7fb0" modified-by="" timestamp="1512096423812"><title svg:width="500">（1）如果try中没有异常，那么如果有finally，就执行finally，然后再执行[下面的代码]</title></topic><topic id="5htgd5e654kvtmln9gd5nhbc0u" modified-by="" timestamp="1512096511258"><title svg:width="500">（2）如果try中有异常，try剩下的代码就不执行了，直接去找对应的catch，如果有对应的catch，就执行，然后如果有finally，就执行finally，然后再执行[下面的代码]</title></topic><topic id="0ha35r5kgnsmrh02r2a3j3je8t" modified-by="" timestamp="1512096505887"><title svg:width="500">（2）如果try中有异常，try剩下的代码就不执行了，直接去找对应的catch，如果没有对应的catch，然后如果有finally，就执行finally，[下面的代码]就不执行，抛出上级</title></topic></topics></children></topic><topic id="1kvkojelf9ue66hkrkh14neoge" modified-by="" timestamp="1512097274758"><title>语法特点</title><children><topics type="attached"><topic id="3mbee0n4grmvf8e17d1tvfgqd7" modified-by="" timestamp="1512096531771"><title>可能没有catch</title></topic><topic id="6fdcrkhku3oauu1vfs46dfu9j3" modified-by="" timestamp="1512096540443"><title>可能没有finally</title></topic><topic id="3atdlu3mo20m6itmcsbrf6mcf6" modified-by="" timestamp="1512097292960"><title>多个catch异常类型的顺序是"子上父下"</title></topic></topics></children></topic><topic id="52e3vv2tolucq54obp8r7du0t2" modified-by="" timestamp="1512347940298"><title>return和finally并存如何执行</title><children><topics type="attached"><topic id="5itto4oururjjet213bc75tsdd" modified-by="" timestamp="1512347937923"><title svg:width="500">如果finally中有return，那么一定是从finally中返回</title></topic><topic id="3icav5u2qfhhehvolkm2atdq7g" modified-by="" timestamp="1512347987442"><title svg:width="500">如果finally中没有return，会先执行finally中的语句，然后return结束，但是返回的值是在执行finally之前就赋好值的</title></topic></topics></children></topic></topics></children></topic><topic id="2k6p3mshedthr52tbqhugttv2o" modified-by="" timestamp="1512097253111"><title>throws</title><children><topics type="attached"><topic id="1bma70pqkn631crvlbr373pcok" modified-by="" timestamp="1512097221150"><title>语法结构</title><children><topics type="attached"><topic id="178uurq9gds0jkn9na4k7eq6d5" modified-by="" timestamp="1512097246310"><title svg:width="500">[修饰符] 返回值类型  方法名(形参列表) 抛出的异常列表</title></topic></topics></children></topic><topic id="4ob2aige9jjgftrgvv651ohmmi" modified-by="" timestamp="1512097298908"><title>注意</title><children><topics type="attached"><topic id="537j32a7fj30nff9to532u3c66" modified-by="" timestamp="1512097273913"><title>(1)throws后面可以是多个异常，不分顺序</title></topic><topic id="3bvirko6d1qmpk5ql3rpueub2c" modified-by="" timestamp="1512097306764"><title>(2)如果方法重写</title><children><topics type="attached"><topic id="15iph6jtvlb48lsb34u8gomqo7" modified-by="" timestamp="1512097323660"><title svg:width="500">重写方法抛出的异常&lt;=被重写方法抛出的异常类型</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="2dqqvvfkkj364l6tv7b52sfj9q" modified-by="" timestamp="1512348160389"><title>自定义异常</title><children><topics type="attached"><topic id="5dkl7a1s09sqno257us1d6vvgt" modified-by="" timestamp="1512348052059"><title svg:width="500">1、自定义异常一定要继承Throwable或它的子类</title><children><topics type="attached"><topic id="3huert951cku724hid17n7u2ua" modified-by="" timestamp="1512348066500"><title>原因是因为</title><children><topics type="attached"><topic id="2p9v4h3jtbb08bo7bd6uuqasuq" modified-by="" timestamp="1512348066423"><title svg:width="500">（1）只有这个类型或它子类的对象才能被“抛出”</title></topic><topic id="1a4k63cb0ba71gc3f3hmnihvbt" modified-by="" timestamp="1512348066423"><title svg:width="500">（2）只有这个类型或它子类的对象才能被“捕获”</title></topic></topics></children></topic></topics></children></topic><topic id="5396738voe57skso2sljf2kfg6" modified-by="" timestamp="1512348114670"><title>2、一般来说声明两个或以上的构造器</title><children><topics type="attached"><topic id="71hsd09fdrui25iclgoak4eeem" modified-by="" timestamp="1512348114401"><title>（1）无参构造</title></topic><topic id="2reuo7gm11dudi8l47f0rae102" modified-by="" timestamp="1512348125935"><title>（2）异常类型(String message)</title></topic></topics></children></topic><topic id="6k561nm9ag91q8c0v5kjiutdjq" modified-by="" timestamp="1512348143356"><title>3、都需要序列化</title></topic><topic id="6otvp9d4pa0drsm1aqno7e41hn" modified-by="" timestamp="1512348212240"><title svg:width="500">4、自定义异常的对象只能自己new并手动抛出，使用throw关键字</title><children><topics type="attached"><topic id="145d7tch6pm99rggmsdavfk3c7" modified-by="" timestamp="1512348234081"><title svg:width="500">当然抛出后，就可以通过throws继续往上抛或使用try..catch处理</title></topic></topics></children></topic></topics></children></topic><topic id="5g9jpfg9m4fj3njcc9t0rcn552" modified-by="" timestamp="1512100471965"><title>异常的关键字</title><children><topics type="attached"><topic id="70e92rcgutdan7bu3mq77cemij" modified-by="" timestamp="1512348390654"><title>try</title><children><topics type="attached"><topic id="01drvgcmbdjlegh3redoc4fp6a" modified-by="" timestamp="1512348403317"><title>尝试执行某些代码，看是否发生异常</title></topic></topics></children></topic><topic id="32uid9geed0pngqoq908kn40ec" modified-by="" timestamp="1512348404258"><title>catch</title><children><topics type="attached"><topic id="5jb3vl950bqbod3n7ekjsq81o0" modified-by="" timestamp="1512348407715"><title>捕获异常</title></topic></topics></children></topic><topic id="4acrmnvurlqgcbhsfc720n4jbt" modified-by="" timestamp="1512348407973"><title>finally</title><children><topics type="attached"><topic id="2ut4bffl47v4611hjpuurju7ps" modified-by="" timestamp="1512348415620"><title>不管是否发生异常都要执行的代码</title></topic></topics></children></topic><topic id="0c22ksmosv8gvkqcilpv9sug5p" modified-by="" timestamp="1512348416427"><title>throw</title><children><topics type="attached"><topic id="27e4r0q8aufo7s1pdimk1rqpvl" modified-by="" timestamp="1512348434832"><title>手动抛出异常</title><children><topics type="attached"><topic id="60qijhonurvijp534hj7513b9e" modified-by="" timestamp="1512348434071"><title>系统预定义异常</title></topic><topic id="49h6tmpoi5l7repvu487nushhk" modified-by="" timestamp="1512348439679"><title>用户自定义异常</title></topic></topics></children></topic></topics></children></topic><topic id="6i2k8v8u45ftdvrqhsf70v2ff2" modified-by="" timestamp="1512348445912"><title>throws</title><children><topics type="attached"><topic id="3jive9ahrrisvja9bf6otca8hg" modified-by="" timestamp="1512348456698"><title>把异常抛出上级</title></topic></topics></children></topic></topics></children></topic><topic id="252f9i5nrk8b5sn2qei2m5jju5" modified-by="" timestamp="1512348340346"><title>异常</title><children><topics type="attached"><topic id="3u32fu497plh8cc4p7lhjk2af0" modified-by="" timestamp="1512348269418"><title>抛</title><children><topics type="attached"><topic id="7e20lgsg6lb2a6smk7ab7p11i0" modified-by="" timestamp="1512348268166"><title>1、JVMnew并且抛出</title></topic><topic id="7iif5niold5ed91400472v022a" modified-by="" timestamp="1512348284183"><title>2、自己new并通过throw抛出</title></topic></topics></children></topic><topic id="684ujmb39142bk9e3bpciqietk" modified-by="" timestamp="1512348304213"><title>处理</title><children><topics type="attached"><topic id="3k4kf1rbtde3qna1fda7q51qg4" modified-by="" timestamp="1512348301270"><title>1、throws继续抛给上级</title></topic><topic id="76epp43svm0ta9uglepbbcrde7" modified-by="" timestamp="1512348320065"><title>2、当下处理try..catch</title></topic></topics></children></topic><topic id="2siel6gkoq320dkfakc315ddat" modified-by="" timestamp="1512348352537"><title>捕获</title><children><topics type="attached"><topic id="77pb52j9bqnnlqlo388oogd6g6" modified-by="" timestamp="1512348352514"><title>try..catch</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><title>异常</title></sheet><sheet id="3acqbte3erbs5kg5jfvrkfceje" modified-by="" style-id="0np7olv4942cm091r7iqm49rcu" theme="xminddefaultthemeid" timestamp="1512526339657"><topic id="0gnm66o3pat99evhljt4eq2ic2" modified-by="" structure-class="org.xmind.ui.logic.right" timestamp="1512526339657"><title>集合</title><extensions><extension provider="org.xmind.ui.map.unbalanced"><content><right-number>-1</right-number></content></extension></extensions><children><topics type="attached"><topic id="28fi7oaguvbatr7uok1hetdgo7" modified-by="" timestamp="1512435722362"><title>概念</title><children><topics type="attached"><topic id="2320uor4q5knkm76c4hvm35b4j" modified-by="" timestamp="1512435585722"><title>集合是一个容器</title><children><topics type="attached"><topic id="26bno4okrunh67m1ao6r4f8bvc" modified-by="" timestamp="1512435579263"><title>是一个用来装对象的容器</title></topic></topics></children></topic><topic id="05q2loqgb40vjkop6ulm3oa2i3" modified-by="" timestamp="1512442034188"><title>数据结构</title><children><topics type="attached"><topic id="2cfvd1u8aqhm4e9r410ij20p3v" modified-by="" timestamp="1512435727057"><title>1、物理结构</title><children><topics type="attached"><topic id="1on8gniu67c1ge8qm17pcp9pov" modified-by="" timestamp="1512435759131"><title>数组也是一个容器</title><children><topics type="attached"><topic id="7caqfr83ft1pauo9pqf064lbau" modified-by="" timestamp="1512435608737"><title>缺点</title><children><topics type="attached"><topic id="57er2imq8r6gamrtirs6n7qks2" modified-by="" timestamp="1512435606061"><title>（1）长度固定</title></topic><topic id="6v9qgin8pgr93itsj1bfv5d0g4" modified-by="" timestamp="1512435621476"><title>（2）无法直接获取有效元素的个数</title></topic></topics></children></topic><topic id="25hqe82hjhlobog8a91hu4719g" modified-by="" timestamp="1512435700735"><title svg:width="500">在实际开发中，基本数据类型一般用数组，引用数据类型一般用集合</title></topic><topic id="1gqkeg7854jo22imi6qpu8coiu" modified-by="" timestamp="1512435805694"><title svg:width="500">数组是依据“数组名+下标”来确定某个元素，数组名中存储的是数组的首地址</title></topic></topics></children></topic><topic id="6s7qfjvt6koatc8lv845l26ecp" modified-by="" timestamp="1512435735438"><title>链表</title><children><topics type="attached"><topic id="0c1nu6o7sevvqcg0d71h0a6sfv" modified-by="" timestamp="1512435755741"><title>不仅仅存储数据，还有存储前/后元素的引用</title></topic></topics></children></topic></topics></children></topic><topic id="0atup8t0d3ionrf9q6r8irfuiq" modified-by="" timestamp="1512435865090"><title>2、逻辑结构</title><children><topics type="attached"><topic id="2b283nlr7nglre4q1aridng0h1" modified-by="" timestamp="1512435875200"><title>动态数组</title><children><topics type="attached"><topic id="2enroc5egcoth4ilfrtjmfbm4u" modified-by="" timestamp="1512435899931"><title>底层是数组，可以通过扩容的方式实现动态数组</title></topic></topics></children></topic><topic id="7rbqu7av9uehg88hraama9ulg7" modified-by="" timestamp="1512435901960"><title>链表</title><children><topics type="attached"><topic id="7fbmpm7b157fn1jhtosho3jnls" modified-by="" timestamp="1512435971204"><title>结合Node</title><children><topics type="attached"><topic id="0ptbpja9fuvhgi4inmrgam6j63" modified-by="" timestamp="1512435970325"><title>双向链表</title><children><topics type="attached"><topic id="125k13mtkmdftd8qld6fe32p1u" modified-by="" timestamp="1512435970296"><title>class Node{&#13;
	Node pre;&#13;
	Object data;&#13;
	Node next;&#13;
}</title></topic></topics></children></topic><topic id="43b9kcf6a75hv1d8e28kqoh2q9" modified-by="" timestamp="1512435976392"><title>单向链表</title><children><topics type="attached"><topic id="3kn9198njr3jccvet46b5hif0r" modified-by="" timestamp="1512435979921"><title>class Node{&#13;
	Object data;&#13;
	Node next;&#13;
}</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="7udau202h7b5t5pv0qvskk4p00" modified-by="" timestamp="1512435987461"><title>树</title><children><topics type="attached"><topic id="5tv2vt2n41d95d9til54oqvccv" modified-by="" timestamp="1512435994428"><title>经典的代表</title><children><topics type="attached"><topic id="7m9tfs3ff6udfrkmfo5sovjqj0" modified-by="" timestamp="1512436005165"><title>二叉树</title><children><topics type="attached"><topic id="7rot11gerttga36nmc0sf7kk12" modified-by="" timestamp="1512436013434"><title>class Node{&#13;
	Node left;&#13;
	Object data;&#13;
	Node right;&#13;
}</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="7p8j1k1tuoe5hd8ouan9vvupfi" modified-by="" timestamp="1512436067275"><title>栈</title><children><topics type="attached"><topic id="6s5s1qeuo90e6u5975bdpoidj0" modified-by="" timestamp="1512436027868"><title>先进后出</title></topic><topic id="06974rlo02dsaknknac1ehu52s" modified-by="" timestamp="1512436067035"><title>添加的顺序</title></topic><topic id="7hp9vjrpmbbaf5l3tkitoqllse" modified-by="" timestamp="1512436073338"><title>出栈的顺序</title></topic></topics></children></topic><topic id="3kvj8ti3k8p2r1jj3k9bo6mp0v" modified-by="" timestamp="1512436080058"><title>队列</title><children><topics type="attached"><topic id="4hg837j7od54dbs6ia5i6lic7u" modified-by="" timestamp="1512436041285"><title>先进先出</title></topic><topic id="2eo4ekkh7k51qd857s2npo9m20" modified-by="" timestamp="1512436079791"><title>添加的顺序</title></topic><topic id="36g8jq65r9dgf3uavpml38945f" modified-by="" timestamp="1512436086226"><title>出队列的顺序</title></topic></topics></children></topic><topic id="19s1vomrofdkmvs9m6tgg2fuvl" modified-by="" timestamp="1512435864850"><title>堆</title></topic><topic id="3trgl3jhe7ksvhvth1fp7bu419" modified-by="" timestamp="1512435868223"><title>....</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="50u003g0h1ac0jabd5rj4qs9qe" modified-by="" timestamp="1512526007875"><title>Collection</title><children><topics type="attached"><topic id="7nbsitji7q8jgqo696bjmfl2un" modified-by="" timestamp="1512436149870"><title>java.util.Collection是一个接口，是个根接口</title></topic><topic id="4ja37c0dk066s6056delvhv7l0" modified-by="" timestamp="1512436194451"><title>Collection没有直接的实现类，它有两个子接口</title><children><topics type="attached"><topic id="387jb1hmuirl1uu8athe019shu" modified-by="" timestamp="1512525981660"><title>java.util.List</title><children><topics type="attached"><topic id="2nijmipjs61objrmbgcg25lci3" modified-by="" timestamp="1512436946716"><title>有序的（添加顺序），可重复的</title><children><topics type="attached"><topic id="7gi020d0rns2ii851e2j8icoqe" modified-by="" timestamp="1512436479044"><title>java.util.Vector动态数组</title><children><topics type="attached"><topic id="6irfjprotfp2vaasegd3r27l7h" modified-by="" timestamp="1512436307092"><title>JDK1.0就有，最早</title></topic><topic id="6fqn5moq7p2a9k0j4lfq0t4ppd" modified-by="" timestamp="1512436331248"><title>支持Enumeration迭代方式</title><children><topics type="attached"><topic id="6bsqiifi44bs3johlh3tjgio0k" modified-by="" timestamp="1512436341403"><title>当然也支持Iterator，foreach</title></topic></topics></children></topic><topic id="0k2j46njhuf2ep93oemp3l7988" modified-by="" timestamp="1512436329404"><title>线程安全的</title></topic><topic id="632sn6athc5cmapi8jr4hplm0l" modified-by="" timestamp="1512436380440"><title>扩容算法</title><children><topics type="attached"><topic id="3kf0vn27g33dddsa9qr6nmb4jb" modified-by="" timestamp="1512436410435"><title svg:width="500">如果没有指定扩容参数，那么默认扩大为原来的2倍</title><children><topics type="attached"><topic id="4mcst4a2r6eeal1hnjgci3n2bk" modified-by="" timestamp="1512436416849"><title>默认初始容量是10</title></topic></topics></children></topic><topic id="20pioha6op2fi31qqet15jjhq7" modified-by="" timestamp="1512436400499"><title svg:width="500">如果指定了扩容参数，那么就按照指定参数值进行扩容</title></topic></topics></children></topic></topics></children></topic><topic id="1ektihcp37e44tba9mmk6d0r7r" modified-by="" timestamp="1512436485383"><title>java.util.ArrayList动态数组</title><children><topics type="attached"><topic id="3him3sq8j4id6g5t5te7lidvup" modified-by="" timestamp="1512436437755"><title>相对Vector来说新一点</title></topic><topic id="7stgeiv4qofr1libje6n2dgt68" modified-by="" timestamp="1512436449468"><title>只支持Iterator，foreach</title></topic><topic id="5on81dcihmrqucqna71j5abtor" modified-by="" timestamp="1512436454462"><title>线程不安全的</title></topic><topic id="7dhcot7t3egkd7hjpciem82n1r" modified-by="" timestamp="1512436461435"><title>扩容算法</title><children><topics type="attached"><topic id="7hh8qoduaja3ffpd53nn24luhq" modified-by="" timestamp="1512436468121"><title>扩大为原来的1.5倍</title></topic></topics></children></topic></topics></children></topic><topic id="734m9emps0lppnup612m15e4hv" modified-by="" timestamp="1512436578072"><title>java.util.LinkedList双向链表</title><children><topics type="attached"><topic id="58rd2k3a8i0t4a8fkio9jk7d5c" modified-by="" timestamp="1512436519841"><title>相对于动态数组来说的优势</title><children><topics type="attached"><topic id="2engmfhddvsogsjcujv5v4o8hq" modified-by="" timestamp="1512436539330"><title svg:width="500">在插入和删除操作比较频繁时，链表的方式效率更高</title></topic></topics></children></topic><topic id="3jdpsm1o15tea7cbab6laraqdc" modified-by="" timestamp="1512436611353"><title>相对于动态数组来说的劣势</title><children><topics type="attached"><topic id="0nlppgnuv5lk9atmgf78ktuksu" modified-by="" timestamp="1512436631389"><title>如果根据索引信息来查找的话，每次都要现统计</title></topic></topics></children></topic></topics></children></topic><topic id="31p1na24cu2h6qo4njhhm6uics" modified-by="" timestamp="1512437245876"><title>java.util.Stack</title><children><topics type="attached"><topic id="1ttm17nahe4k2mncmmvva2bqkd" modified-by="" timestamp="1512436962292"><title>是Vector的子类</title></topic><topic id="53lfh90r99qqsvffr0ins42lu7" modified-by="" timestamp="1512437097263"><title>特征的方法</title><children><topics type="attached"><topic id="7talr4ul98e0q2rfqckcc39lo4" modified-by="" timestamp="1512436978206"><title>peek()</title><children><topics type="attached"><topic id="1g2fhmg3i6s4hbk2pes9ujdkcd" modified-by="" timestamp="1512436992999"><title>查看栈顶的元素，但不移除</title></topic></topics></children></topic><topic id="4p336kn71n5mgo23rmldb4sa9s" modified-by="" timestamp="1512437052737"><title>pop()</title><children><topics type="attached"><topic id="3eo971flkq52lg9e19tlhnhs64" modified-by="" timestamp="1512437063502"><title>获取栈顶的元素，并移除</title></topic></topics></children></topic><topic id="5ifol4t2hsgnmoslso12m2tok5" modified-by="" timestamp="1512437072770"><title>push()</title><children><topics type="attached"><topic id="02ml76ful88lj7s5sgbr62bg02" modified-by="" timestamp="1512437096707"><title>压入栈，添加的位置在栈顶</title></topic></topics></children></topic><topic id="4kg8ut5fs7a97i73t45s1ohtgl" modified-by="" timestamp="1512437105344"><title>search(Object)</title><children><topics type="attached"><topic id="3rieb0pdpl1tja725l3l5q44j6" modified-by="" timestamp="1512437116688"><title>返回位置，以 1 为基数</title></topic></topics></children></topic></topics></children></topic><topic id="6tomdknrtdcrv02n778u2u0u7r" modified-by="" timestamp="1512437045349"><title>逻辑结构</title><children><topics type="attached"><topic id="188a7f8d7vpj3ff8os5qsaq1kf" modified-by="" timestamp="1512437240736"><children><topics type="attached"><topic id="2rdebgtf4mjqig11m5o791360m" modified-by="" timestamp="1512437243402"><xhtml:img svg:height="167" svg:width="216" xhtml:src="xap:attachments/1jgtte76pr8jeh54b8cv82ugga.png"/></topic></topics></children></topic></topics></children></topic><topic id="6b3m7im9buqe0kuvib3dd09752" modified-by="" timestamp="1512437252735"><title>底层</title><children><topics type="attached"><topic id="551n8aej1kt0rk9vj73u0jgeoh" modified-by="" timestamp="1512437252455"><title>数组</title></topic><topic id="37tk6b86b0nd4rl2eeqt7keuda" modified-by="" timestamp="1512437292658"><title svg:width="500">每次添加到后面，栈顶是数组的后面[size-1]号元素，栈底是数组的[0]元素</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="6jr5b6923tjrkagjhfu4ad7pta" modified-by="" timestamp="1512436279891"><title>列表，序列</title></topic><topic id="6401gjc5egl2h8213kae85047k" modified-by="" timestamp="1512439522749"><title>补充Collection的方法</title><children><topics type="attached"><topic id="1qp6k6652m10cmdmtvcnuduoeg" modified-by="" timestamp="1512439647289"><title>和index相关的方法</title><children><topics type="attached"><topic id="6qfqnanvjkfemece94v0shdn9b" modified-by="" timestamp="1512439558255"><title>(1)添加</title><children><topics type="attached"><topic id="326rea4ussj4ckeua4h12rfbhb" modified-by="" timestamp="1512439557297"><title>add(int index, E element) </title></topic><topic id="68okdi8ll40q6073qe9ussfot4" modified-by="" timestamp="1512439559533"><title>addAll(int index, Collection&lt;? extends E&gt; c) </title></topic></topics></children></topic><topic id="656ehhjduvbo7v5sdf7ccnavb9" modified-by="" timestamp="1512439572202"><title>（2）删除</title><children><topics type="attached"><topic id="4m3ed3d5tfughagbaholmquqm4" modified-by="" timestamp="1512439575236"><title>remove(int index) </title></topic></topics></children></topic><topic id="01175uorq8m3t1ni3cu884h2c6" modified-by="" timestamp="1512439608613"><title>（3）查找</title><children><topics type="attached"><topic id="4l2103mckv75voin9s3n3qj696" modified-by="" timestamp="1512439598969"><title>indexOf(Object o) </title></topic><topic id="1m53d4kvlhjs2pg5g134ansba1" modified-by="" timestamp="1512439602988"><title>lastIndexOf(Object o) </title></topic><topic id="6o0fjp03ct5slbtn4qqn6d6igt" modified-by="" timestamp="1512439613003"><title>get(int index) </title></topic></topics></children></topic><topic id="4afaosas9qc4fe7s1jqrjpk0jk" modified-by="" timestamp="1512439625707"><title>（4）替换</title><children><topics type="attached"><topic id="5mmt21401fsrik7i5srubojkit" modified-by="" timestamp="1512439627059"><title>set(int index, E element) </title></topic></topics></children></topic><topic id="57nhd9q35a8dv9ikqef6drt5ol" modified-by="" timestamp="1512439654400"><title>（5）截取</title><children><topics type="attached"><topic id="2aurp0elq15ov7i527s7ab8m77" modified-by="" timestamp="1512439656217"><title>subList(int fromIndex, int toIndex)</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children><notes><html><xhtml:p>请描述List的各种实现类的区别</xhtml:p><xhtml:p>ArrayList：动态数组（JDK1.2），每次扩容为原来的1.5倍，支持Iterator和foreach迭代，线程不安全的</xhtml:p><xhtml:p>Vector：旧版的动态数组（JDK1.0），默认每次扩容为原来的2倍，支持旧版Enumeration，还支持Iterator和foreach迭代，线程安全的</xhtml:p><xhtml:p>LinkedList：双向链表，在添加和删除时 效率比较高，不需要移动大量的元素，只需要修改前后元素引用关系</xhtml:p><xhtml:p>Stack：Stack是Vector的子类，具有后进先出的特点</xhtml:p></html><plain>请描述List的各种实现类的区别&#13;
ArrayList：动态数组（JDK1.2），每次扩容为原来的1.5倍，支持Iterator和foreach迭代，线程不安全的&#13;
Vector：旧版的动态数组（JDK1.0），默认每次扩容为原来的2倍，支持旧版Enumeration，还支持Iterator和foreach迭代，线程安全的&#13;
LinkedList：双向链表，在添加和删除时 效率比较高，不需要移动大量的元素，只需要修改前后元素引用关系&#13;
Stack：Stack是Vector的子类，具有后进先出的特点</plain></notes></topic><topic id="3l00ml6ob7d3mtfav4k4rpiq7e" modified-by="" timestamp="1512525991548"><title>java.util.Set</title><children><topics type="attached"><topic id="76vpovek8ok9q7qqosqrf6imnv" modified-by="" timestamp="1512438043425"><title>无序的（添加顺序），不可重复的</title><children><topics type="attached"><topic id="2l3lbamudgf1lmt6o209h4cull" modified-by="" timestamp="1512438351931"><title>java.util.HashSet</title><children><topics type="attached"><topic id="0jf0g01nisqgiq0t5cfirse7el" modified-by="" timestamp="1512438068846"><title>无序，不可重复</title></topic><topic id="2b6ovn9ckg9mftu53ccrlai528" modified-by="" timestamp="1512438091249"><title>依赖于元素的hashCode和equals方法</title></topic><topic id="73uvq5q3ckimf1kudj4c2pv6rj" modified-by="" timestamp="1512438431739"><title>equals和hashCode</title><children><topics type="attached"><topic id="4n8kmi5s706obvgvhm6vrkf9jh" modified-by="" timestamp="1512438384277"><title svg:width="500">hash值不同，这两个对象一定不同，可以不调用equals</title></topic><topic id="653aq3nj2i6t9g2t6abf8p8ib9" modified-by="" timestamp="1512438431263"><title>equals如果相同，hashCode一定相同</title></topic><topic id="3k0f1r2ds6qlcjn3fjn2cgr9cb" modified-by="" timestamp="1512438458557"><title svg:width="500">hash值相同，这两个对象不一定相等，所以一定要调用equals方法进行确认</title></topic></topics></children></topic></topics></children></topic><topic id="5q25aisspnh5nr5ph7setbujsb" modified-by="" timestamp="1512438620408"><title>java.util.TreeSet</title><children><topics type="attached"><topic id="4niopllnfvhsjhhdevldf59ls1" modified-by="" timestamp="1512438510409"><title svg:width="500">不按添加顺序，但是按照元素“大小”顺序存储，不可重复</title></topic><topic id="4jq3k9jd2e0cm8vkt5i6639s0t" modified-by="" timestamp="1512438824014"><title>不可重复，依据元素是否“大小相等”</title><children><topics type="attached"><topic id="49nl7d89v3d0s662gt6mhp4trm" modified-by="" timestamp="1512438839330"><title>调用元素的compareTo或定制比较器的compare</title></topic></topics></children></topic><topic id="7v24aiusst9cgoht3eqe0t68st" modified-by="" timestamp="1512438640957"><title svg:width="500">添加到TreeSet的元素一定要支持可比较大小，可排序</title><children><topics type="attached"><topic id="5aood7uh37d5t7ps501tftd9ph" modified-by="" timestamp="1512438644351"><title>自然排序</title><children><topics type="attached"><topic id="7hahetvunt86dr5ffqtrrp5se9" modified-by="" timestamp="1512438673500"><title svg:width="500">要求元素类型本身要实现java.lang.Comparable接口，并重写int compareTo(Object)方法</title></topic></topics></children></topic><topic id="71v0gr3dq3u38louros8i93n27" modified-by="" timestamp="1512438785920"><title>定制排序</title><children><topics type="attached"><topic id="7ac2euuhrb0vv0dn045n1i6lmo" modified-by="" timestamp="1512438801051"><title>要为TreeSet指定一个定制比较器对象</title><children><topics type="attached"><topic id="56ths4h7dknc484462jg4oeep9" modified-by="" timestamp="1512438815437"><title>TreeSet set = new TreeSet(定制比较器对象);</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="32k5ia32ajokh2s9alfo587kcl" modified-by="" timestamp="1512438910065"><title>java.util.LinkedHashSet</title><children><topics type="attached"><topic id="30g9c8uhtacibmvudg7ehuu24b" modified-by="" timestamp="1512438885123"><title svg:width="500">比较HashSet多了一个顺序维护，所以在添加和删除时，比HashSet效率低，遍历查找时效率高</title></topic><topic id="4nt57mi893jv4rq023d2iook7u" modified-by="" timestamp="1512438916227"><title>继承HashSet</title></topic></topics></children></topic></topics></children></topic><topic id="3fnvrrehsrfh77dhbtvacjufg4" modified-by="" timestamp="1512440566198"><title>底层实现</title><children><topics type="attached"><topic id="427eln1se4ir8gpc70pgnub5pc" modified-by="" timestamp="1512440550358"><title>HashSet</title><children><topics type="attached"><topic id="2lh8ovi0aj753lk2kf5go99thj" modified-by="" timestamp="1512440553769"><title>HashMap</title></topic></topics></children></topic><topic id="198sk7olcqb3ruval9p8uhv6rq" modified-by="" timestamp="1512440558564"><title>TreeSet</title><children><topics type="attached"><topic id="12bhohtear975f01oaift0og2b" modified-by="" timestamp="1512440566000"><title>TreeMap</title></topic></topics></children></topic><topic id="1550pis7i00dl5juc7efpll6ka" modified-by="" timestamp="1512440572304"><title>LinkedHashSet</title><children><topics type="attached"><topic id="5e8alb96afb770ctbdkbp60k65" modified-by="" timestamp="1512440576671"><title>LinkedHashMap</title></topic></topics></children></topic></topics></children></topic><topic id="0mkkd5gu8bvhf77gmi31vsr3vn" modified-by="" timestamp="1512440613874"><title svg:width="500">Set的元素其实也是一对，只不过它的value是共享同一个常量对象Object对象</title></topic></topics></children><notes><html><xhtml:p>5、请描述Set的各种实现类的区别</xhtml:p><xhtml:p>HashSet：无序的，不可重复的，依据元素的hashCode()和equals方法</xhtml:p><xhtml:p>		HashSet底层实现是HashMap，它的value是一个Object的常量对象</xhtml:p><xhtml:p>TreeSet：不保证添加顺序，但是会按照元素的“大小”顺序进行排列，不可重复，</xhtml:p><xhtml:p>		依据元素的自然排序Comparable（compareTo())或定制排序Comparator(compare())规则进行排序</xhtml:p><xhtml:p>		TreeSet底层实现是TreeMap，它的value是一个Object的常量对象</xhtml:p><xhtml:p>LinkedHashSet：是HashSet的子类，除了有HashSet的特点，它还要在HashSet基础上维护元素的添加的顺序，所以在添加和删除时比HashSet慢一点</xhtml:p><xhtml:p>		LinkedHashSet的底层实现是LinkedHashMap，它的value是一个Object的常量对象</xhtml:p></html><plain>5、请描述Set的各种实现类的区别&#13;
HashSet：无序的，不可重复的，依据元素的hashCode()和equals方法&#13;
		HashSet底层实现是HashMap，它的value是一个Object的常量对象&#13;
TreeSet：不保证添加顺序，但是会按照元素的“大小”顺序进行排列，不可重复，&#13;
		依据元素的自然排序Comparable（compareTo())或定制排序Comparator(compare())规则进行排序&#13;
		TreeSet底层实现是TreeMap，它的value是一个Object的常量对象&#13;
LinkedHashSet：是HashSet的子类，除了有HashSet的特点，它还要在HashSet基础上维护元素的添加的顺序，所以在添加和删除时比HashSet慢一点&#13;
		LinkedHashSet的底层实现是LinkedHashMap，它的value是一个Object的常量对象</plain></notes></topic></topics></children></topic><topic id="3918lrttk2u4gbmhrddjmgboub" modified-by="" timestamp="1512437476406"><title>遍历</title><children><topics type="attached"><topic id="5el3b8iq2hk42kjiol12dihu8f" modified-by="" timestamp="1512437402820"><title>（1）直接foreach</title><children><topics type="attached"><topic id="3hmdfgb6ma1hs33mhpfl482tsb" modified-by="" timestamp="1512437374692"><title>语法结构</title><children><topics type="attached"><topic id="4sapmmgftihaatd8cpoeg9vinb" modified-by="" timestamp="1512437400182"><title>for(集合的元素类型  element : 集合名){&#13;
}</title></topic></topics></children></topic><topic id="1gm7db8qfc7g0afkaejshgh713" modified-by="" timestamp="1512437453467"><title svg:width="500">在遍历时，效率高，但是不适用于遍历的同时对集合进行修改，特别是影响集合元素个数的操作</title></topic></topics></children></topic><topic id="1eb3mchshgpup0c6e6gofheh2r" modified-by="" timestamp="1512437626375"><title>（2）Iterator迭代器</title><children><topics type="attached"><topic id="3hh3ij8hfo06vocsc5sb5eamu2" modified-by="" timestamp="1512437507237"><title>语法结构</title><children><topics type="attached"><topic id="7fscjfkl19fivd2ptcdl92m2ei" modified-by="" timestamp="1512437503721"><title>Iterator iter = 集合对象.iterator();</title></topic><topic id="1t7sishjpi6lpcp3llngopnvmn" modified-by="" timestamp="1512437546761"><title>while(iter.hasNext()){&#13;
	Object element = iter.next();&#13;
	//可以使用iter.remove()进行移除&#13;
}</title></topic></topics></children></topic><topic id="2o8f0kr4g3pcsfh01pg3359ssm" modified-by="" timestamp="1512437930763"><title>Iterator是一个接口</title><children><topics type="attached"><topic id="51sv80snkmb9ohm54m18gjgq9q" modified-by="" timestamp="1512437958584"><title svg:width="500">在每一类集合中，都有自己的实现类，通过内部类的形式来实现Iterator接口</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="3kbmihro6l2sve7i7lqsv1gnif" modified-by="" timestamp="1512439213402"><title>继承关系图</title><children><topics type="attached"><topic id="0ioniml24fougq60an65tvqs0h" modified-by="" timestamp="1512439220728"><xhtml:img svg:height="215" svg:width="338" xhtml:src="xap:attachments/5q5s9rb2hu3klmnthvg4p2fllc.png"/></topic></topics></children></topic><topic id="2muf5g16fc258nn26k75e488fh" modified-by="" timestamp="1512439477658"><title>Collection的常用方法</title><children><topics type="attached"><topic id="0cg1c742n1atir6mi4c6r8r9td" modified-by="" timestamp="1512439292329"><title>（1）添加</title><children><topics type="attached"><topic id="79v0ebliki9q5p90unqsrb4a0f" modified-by="" timestamp="1512439283421"><title>(1)add(Object obj)</title><children><topics type="attached"><topic id="3rukbm6fjhuqnrljm9jc3rhg1u" modified-by="" timestamp="1512439290960"><title>添加一个元素到集合中</title></topic></topics></children></topic><topic id="42itvr68au9dbq974831bj1j7d" modified-by="" timestamp="1512439298306"><title>(2)addAll(Collection other)</title><children><topics type="attached"><topic id="67cka5if20sa9oj4kokq32fbcn" modified-by="" timestamp="1512439315299"><title svg:width="500">把other集合中的元素一一添加到当前集合中，一次添加多个</title></topic></topics></children></topic></topics></children></topic><topic id="1ggcv0i945etljb924cmcjh2lg" modified-by="" timestamp="1512439336924"><title>（2）删除</title><children><topics type="attached"><topic id="74mfbn91accll8eu9aksmmli4g" modified-by="" timestamp="1512439325923"><title>remove(Object obj)</title><children><topics type="attached"><topic id="05mui9p3vl34igkqpko2rk6juv" modified-by="" timestamp="1512439336776"><title>删除一个元素</title></topic></topics></children></topic><topic id="7ikavn4guui6jn9nu69or15jgb" modified-by="" timestamp="1512439339154"><title>removeAll(Collection other)</title><children><topics type="attached"><topic id="2c2f5qlk63dc5fl0ih9tps7run" modified-by="" timestamp="1512439353649"><title>从当前集合中删除它俩的交集</title><children><topics type="attached"><topic id="0m8na27nsisglspt35t13oukto" modified-by="" timestamp="1512439363263"><title>this -  this ∩ other</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="1lmal37p06thmrvmcjacf8njhn" modified-by="" timestamp="1512439380354"><title>（3）查找</title><children><topics type="attached"><topic id="3nsgl6m2os93onhl64fgk86kqe" modified-by="" timestamp="1512439382292"><title>contains(Object obj)</title><children><topics type="attached"><topic id="55h0fpsgc8issoicf1tlbi7uuu" modified-by="" timestamp="1512439393521"><title>在当前集合中查找一个元素</title></topic></topics></children></topic><topic id="5teb0vn40rahh91gb3fs3b6rvl" modified-by="" timestamp="1512439394865"><title>containsAll(Collection c)</title><children><topics type="attached"><topic id="6pf2vqrfqt0fbucfu55loc1p4q" modified-by="" timestamp="1512439413933"><title>判断c是否是当前集合的子集</title></topic></topics></children></topic></topics></children></topic><topic id="2equrq7sc97fjs8ivugpphaicr" modified-by="" timestamp="1512439476229"><title>（4）其他</title><children><topics type="attached"><topic id="5p2p2rtpqlg41pbn1s9kbvehqf" modified-by="" timestamp="1512439425714"><title>size()</title><children><topics type="attached"><topic id="2tkm9ir325n2k9hv7e79as458n" modified-by="" timestamp="1512439431549"><title>获取有效元素的个数</title></topic></topics></children></topic><topic id="6q6aiumpggdlvefc31627k5o7j" modified-by="" timestamp="1512439453165"><title>retainsAll(Collection other)</title><children><topics type="attached"><topic id="65sdivcib8dbh98hqv67bj3o5c" modified-by="" timestamp="1512439465240"><title>把this ∩ other赋值给当前集合</title><children><topics type="attached"><topic id="5je8r27oc05dmthaij13k7p0u8" modified-by="" timestamp="1512439469176"><title>this =  this ∩ other</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="201r1h5pg5ffb31hrq7jhappjm" modified-by="" timestamp="1512439495468"><title>（5）遍历</title><children><topics type="attached"><topic id="211tv8oml3jlq15h4j42n55gir" modified-by="" timestamp="1512439490501"><title>Iterator iterator()</title></topic><topic id="1src9rv3s0v8omg6matvplvpb6" modified-by="" timestamp="1512439496660"><title>Object[] toArray()</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="02n1vtsp75rroogqkt5ojsk6mc" modified-by="" timestamp="1512525799827"><title>Map</title><children><topics type="attached"><topic id="6g6fb77sr1o2qguoktgdj920jr" modified-by="" timestamp="1512525728381"><title>Map的特点</title><children><topics type="attached"><topic id="4h1127834h9sk1m5uq1vtki827" modified-by="" timestamp="1512525744055"><title svg:width="500">Map的元素，即存储的映射关系（key,value），其类型是Entry类型，它是Map的内部子接口，在各种Map的实现类中，都用内部类的方式来实现Entry接口</title></topic><topic id="0tgfmn4jgpmeruulvtkmjqb060" modified-by="" timestamp="1512525714042"><title svg:width="500">Map的key不可重复，而且一旦添加到map中，key不建议修改，特别是参与hashCode和equals方法的属性，或参与compareTo或compare方法比较的属性</title></topic></topics></children><marker-refs><marker-ref marker-id="flag-red"/></marker-refs></topic><topic id="3di9old3vbc7aqgj636kai32ea" modified-by="" timestamp="1512526154606"><title>Map的常用方法</title><children><topics type="attached"><topic id="4htma4or2smb1a8l0h4uv6k93i" modified-by="" timestamp="1512526154490"><title>常用的方法</title><children><topics type="attached"><topic id="2lucbc885u5a5mdftfkb99qjlk" modified-by="" timestamp="1507600999151"><title>1、添加</title><children><topics type="attached"><topic id="2hos0rsqt99tstjre78jsb3b36" modified-by="" timestamp="1507600998189"><title>put(key,value)</title></topic><topic id="33f6r3qpffrfm7315v3v7uiqnj" modified-by="" timestamp="1507601024832"><title>putAll(Map)</title></topic></topics></children></topic><topic id="56i7alnf4qhq6k7ndejt2v0i2d" modified-by="" timestamp="1507601036906"><title>2、有效键值对数</title><children><topics type="attached"><topic id="039se0ndkc0vmbcugheks6fe1p" modified-by="" timestamp="1507601040090"><title>size</title></topic></topics></children></topic><topic id="0enevd4tb6cbjnksfu0tfjo0qk" modified-by="" timestamp="1507601048418"><title>3、根据key获取value</title><children><topics type="attached"><topic id="0fksn90va2o2ebjv98m1luh1of" modified-by="" timestamp="1507601052051"><title>get(key)</title></topic></topics></children></topic><topic id="2tsqmfgso2umkordpoelkvoluf" modified-by="" timestamp="1507601066384"><title>4、是否包含某个key/value</title><children><topics type="attached"><topic id="7ib41im9plilib26gcg1kq2pon" modified-by="" timestamp="1507601065847"><title>containsKey()</title></topic><topic id="1sk6dj1l6otk77klbf9tiesgkt" modified-by="" timestamp="1507601072445"><title>containsValue()</title></topic></topics></children></topic><topic id="1hgg7up9jt7t6gf4vs1hd3ga3e" modified-by="" timestamp="1507601078387"><title>5、删除</title><children><topics type="attached"><topic id="55da6guusc58lred3qb2ts1d5s" modified-by="" timestamp="1507601083344"><title>remove(key)</title></topic></topics></children></topic><topic id="6vegu51rdlqbltnbiuhg3mcgoj" modified-by="" timestamp="1507602469912"><title>6、和迭代相关</title><children><topics type="attached"><topic id="3915ovl46d3fpqpv38qis3lsr7" modified-by="" timestamp="1507601103214"><title>遍历所有的key</title><children><topics type="attached"><topic id="16tgtjctslo8hnvntnj9fichme" modified-by="" timestamp="1507601108557"><title>Set  keySet()</title></topic></topics></children></topic><topic id="5a6blv3v9t72kjcndpds6fb9ce" modified-by="" timestamp="1507601116005"><title>遍历所有的value</title><children><topics type="attached"><topic id="65l6qljgct9vivicffv3p7g81o" modified-by="" timestamp="1507601122991"><title>Collection values()</title></topic></topics></children></topic><topic id="31g0vadsj56vuica8st55q54d2" modified-by="" timestamp="1507601137057"><title>遍历所有的映射关系</title><children><topics type="attached"><topic id="4d9ck9hj6m5ijob49p0lsr2v69" modified-by="" timestamp="1507601136365"><title>Set  entrySet()</title></topic><topic id="6pmv5jkodo0q3s0g6jmdmuegq8" modified-by="" timestamp="1507601166083"><title>Set的元素是Entry类型</title></topic></topics></children></topic></topics></children><marker-refs><marker-ref marker-id="flag-red"/></marker-refs></topic></topics></children></topic></topics></children></topic><topic id="1odr967fon3vihdphtd52crcha" modified-by="" timestamp="1512525608023"><title>Map的常见实现类</title><children><topics type="attached"><topic id="2fjg2vmetk1hl5j1ivvvposjhc" modified-by="" timestamp="1512525621745"><title>Hashtable</title><children><topics type="attached"><topic id="0iufvg18h4mjpl5vqt7r50ep50" modified-by="" timestamp="1512525621707"><title>JDK1.0就有的，属于旧版HashMap，线程安全的</title></topic></topics></children></topic><topic id="1m2i503tq69dmr85iuvvfbc6s7" modified-by="" timestamp="1512525631081"><title>HashMap</title><children><topics type="attached"><topic id="5eluj8ibodd01ae8k93i6ats6f" modified-by="" timestamp="1512525633103"><title svg:width="500">它的key不可重复的，依据key的hashCode()和equals()方法，线程不安全的&#13;
	JDK1.7时底层实现是数组+链表&#13;
	JDK1.8时底层实现是数组+链表+红黑树</title></topic></topics></children></topic><topic id="4fv418fh2p4cl28ufqs3g30g31" modified-by="" timestamp="1512525756660"><title>TreeMap</title><children><topics type="attached"><topic id="0ed04kh5eihl9glsa4baoaeada" modified-by="" timestamp="1512525758512"><title svg:width="500">它的key不可重复的，按照key的“大小”顺序进行排列,&#13;
	依据key的自然排序Comparable（compareTo())或定制排序Comparator(compare())规则进行排序</title></topic></topics></children></topic><topic id="5s3l9ibu6qofekdpipor7peh6m" modified-by="" timestamp="1512525764842"><title>LinkedHashMap</title><children><topics type="attached"><topic id="386fjc75u14t7hjn9c6f1o82le" modified-by="" timestamp="1512525772558"><title svg:width="500">它是HashMap的子类，在HashMap的基础上同时要维护添加的顺序</title></topic></topics></children></topic><topic id="3iako0s0p2ir1om7u7mjpp7m85" modified-by="" timestamp="1512525772882"><title>Properties</title><children><topics type="attached"><topic id="5ichsaq7unenqnittnf89p74qb" modified-by="" timestamp="1512525774570"><title svg:width="500">Properties是Hashtable的子类，它的key和value的类型都是String类型</title></topic></topics></children></topic></topics></children></topic><topic id="20e251b4sm4cta25qo7vnafrmq" modified-by="" timestamp="1512525942627"><title>高频面试题：HashMap的底层实现过程</title><children><topics type="attached"><topic branch="folded" id="7i02740fqe54ebncoppu1esv2f" modified-by="" timestamp="1512525900667"><title>JDK1.7时底层实现是数组+链表</title><children><topics type="attached"><topic id="2eeabmu77b4hh7slv8h4pthd6m" modified-by="" timestamp="1512525872345"><title svg:width="500">		当我们要添加一个新的映射关系时，&#13;
		(1)先取出key，算出它的hash值&#13;
		(2)如果数组是空的，会先建立一个长度为16的数组table&#13;
		(3)如果数组不为空，这个时候要判断数组的长度是否达到临界点（数组长度*0.75），如果已经达到临界点，应该先对数组进行扩容，扩大为2倍&#13;
		一旦扩容，要重头开始（以前元素要重新排序位置，对新添加的映射关系也要重写计算key的hash值，和index）&#13;
		(4)会根据key的hash值与table数组的长度做一个“按位与&amp;”的运算，计算出要存储的下标index&#13;
		(5)先判断table[index]是否为空，如果为空，直接放进去，放进去之前会构建一个Entry类型对象&#13;
		(6)如果table[index]不是空的，那么调用key的equals方法与table[index]的key做比较，如果table[index]下面还有链表，&#13;
		可能需要与table[index]下面的链表的元素一一比较，直到遇到了equals为true或都不相同&#13;
		(7)如果有一个equals返回true，那么就把value给替换&#13;
		(8)如果equals都不相等，那么把当前映射关系构建的Entry对象，放在此链表的表头，把原来的对象作为我的next</title></topic></topics></children></topic><topic branch="folded" id="3m7quuf1iqnkm3q1rnnmaegt2r" modified-by="" timestamp="1512525935608"><title>	JDK1.8时底层实现是数组+链表+红黑树</title><children><topics type="attached"><topic id="091vvbti5t4n9cat6j09ov4036" modified-by="" timestamp="1512525925839"><title svg:width="500">		当我们要添加一个新的映射关系时，&#13;
		(1)先取出key，算出它的hash值&#13;
		(2)如果数组是空的，会先建立一个长度为16的数组table&#13;
		(3)如果数组不为空，这个时候要判断数组的长度是否达到临界点（数组长度*0.75），如果已经达到临界点，应该先对数组进行扩容，扩大为2倍&#13;
		一旦扩容，要重头开始（以前元素要重新排序位置，对新添加的映射关系也要重写计算key的hash值，和index）&#13;
		(4)会根据key的hash值与table数组的长度做一个“按位与&amp;”的运算，计算出要存储的下标index&#13;
		(5)先判断table[index]是否为空，如果为空，直接放进去，放进去之前会构建一个Entry类型对象&#13;
		(6)如果table[index]不是空的，那么调用key的equals方法与table[index]的key做比较，如果table[index]下面有树或者链表，&#13;
		可能需要与table[index]下面的链表或树的元素一一比较，直到遇到了equals为true或都不相同&#13;
		(7)如果有一个equals返回true，那么就把value给替换&#13;
		(8)如果都不相等，如果现在已经是树，就直接添加到该树的叶子节点上。&#13;
		(9)如果都不相等，如果现在不是树，而是链表，看当前链表的长度是否达到8个，如果没有达到8个，直接添加到链表的尾部&#13;
		(10)如果已经达到8个，此时要检查数组table的长度是否达到64，如果没有达到64，先扩容，一旦扩容，一切从头开始&#13;
		(11)如果达到64，把该链表变成一颗红黑树</title></topic><topic id="1pgnr0g6kjr0qhqjkcf6devf6j" modified-by="" timestamp="1512525919315"><title svg:width="500">		什么时候树会变回链表？&#13;
		每次进行resize()，会检查树的叶子节点的总数是否&lt;6个，如果&lt;6个，会把这个红黑树变回链表</title></topic></topics></children></topic></topics></children><marker-refs><marker-ref marker-id="flag-red"/></marker-refs></topic></topics></children></topic><topic id="3f4d7krchp4mtp60o55k9k9qkj" modified-by="" timestamp="1512526046768"><title>集合框架图</title><children><topics type="attached"><topic id="2570es2m50da5cr3s1v9cfqtei" modified-by="" timestamp="1512526050132"><title/><xhtml:img align="top" svg:height="195" svg:width="400" xhtml:src="xap:attachments/31p9tmvks74ldpdg9i3hrls6te.png"/></topic></topics></children></topic><topic id="7r6rhm0h22fl7839ht5ak1d225" modified-by="" timestamp="1512526072081"><title>集合工具类</title><children><topics type="attached"><topic id="07pr9labpv828jfimejpe25mhi" modified-by="" timestamp="1512526132977"><title>java.util.Collections</title><children><topics type="attached"><topic id="0ftkdiid5jrg7pr728maij7n1q" modified-by="" timestamp="1512526132797"><title>操作集合的各种静态方法</title><children><topics type="attached"><topic id="419kmr4o646t5rrbrk03lpa45a" modified-by="" timestamp="1507682493708"><title>1、Collections.addAll(Collection, T... elements)</title></topic><topic id="3eo70dcglukoo942vf73rpipii" modified-by="" timestamp="1507682527530"><title>2、binarySearch(List, T target)</title><children><topics type="attached"><topic id="469h0npglk1ishh1r0e6rvpcbe" modified-by="" timestamp="1507682560166"><title>对List的元素类型有要求，必须支持可比较大小</title></topic></topics></children></topic><topic id="0hfr01f26rd1vqedtd8pog79f5" modified-by="" timestamp="1507682625118"><title>3、max/min(Collection)</title><children><topics type="attached"><topic id="2315273gmp5fimgcpr5sk7v5dv" modified-by="" timestamp="1507682617449"><title svg:width="500">对Collection的元素类型有要求，必须支持可比较大小</title></topic></topics></children></topic><topic id="6j1ria28oml2jgb1tuhd224116" modified-by="" timestamp="1507682646647"><title>4、sort(List)</title><children><topics type="attached"><topic id="6ete5q4bhvdhipukn2bdogp4c8" modified-by="" timestamp="1507682654890"><title>元素必须实现Comparable</title></topic></topics></children></topic><topic id="58k7s6ncsjgscgaghicn3b0kmo" modified-by="" timestamp="1507682664954"><title>5、sort(List,Comparator)</title><children><topics type="attached"><topic id="4j5emqt6dfldq23l1684l7kcg2" modified-by="" timestamp="1507682674280"><title>按照指定比较器进行排序</title></topic></topics></children></topic><topic id="0jal36pnn02ugra9ba1rpt2h1d" modified-by="" timestamp="1507682701356"><title>6、如果想要获得线程安全的集合对象</title><children><topics type="attached"><topic id="6iskef1n28eo94ecsi837moi79" modified-by="" timestamp="1507682718337"><title>synchronizedXXX(集合)</title></topic></topics></children></topic><topic id="5g6qv99jadier5lhn89fjg3ktl" modified-by="" timestamp="1507682743073"><title>7、。。。。</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><title>集合</title></sheet><sheet id="22e1gpherm488c1ehcifl9l642" modified-by="" style-id="31b5jq57p22ds18878d8pnd3aq" theme="xminddefaultthemeid" timestamp="1512527723485"><topic id="6vl3kjcke9fkr4ihgc1ko8o2l3" modified-by="" structure-class="org.xmind.ui.logic.right" timestamp="1512527700975"><title>泛型</title><extensions><extension provider="org.xmind.ui.map.unbalanced"><content><right-number>-1</right-number></content></extension></extensions><children><topics type="attached"><topic id="7p8aaan2cmqafo4uffi877hp7r" modified-by="" timestamp="1512526396048"><title>概念</title><children><topics type="attached"><topic id="34ecqqddp2r8nmpptv3te5rn7a" modified-by="" timestamp="1512526392730"><title>类型参数，参数化的类型</title></topic><topic id="5bthfmpjl24t3i9lav57sueug9" modified-by="" timestamp="1512526404231"><title>比喻：标签</title></topic></topics></children></topic><topic id="7q1t38kqea8bvjvfrrmikddff6" modified-by="" timestamp="1512526421484"><title>形式</title><children><topics type="attached"><topic id="4k9c35rpoc754dk4mlhq8sm36k" modified-by="" timestamp="1512526609137"><title>1、泛型类、泛型接口</title><children><topics type="attached"><topic id="097ktj4vg3lo159fgdstba6sk6" modified-by="" timestamp="1512526439480"><title>语法格式</title><children><topics type="attached"><topic id="5fi1k8m43d5k0hlism29cqf9e7" modified-by="" timestamp="1512526499865"><title svg:width="500">[修饰符]  class/interface  类名/接口名&lt;类型参数列表&gt;{&#13;
}</title><children><topics type="attached"><topic id="12j6kbsf8fbp8lcui09bjheljo" modified-by="" timestamp="1512526497179"><title>多个之间使用,分割</title></topic><topic id="52224rstkc4r84gaa2e8cmhjk0" modified-by="" timestamp="1512526569715"><title>类型参数习惯命名</title><children><topics type="attached"><topic id="4e8lvsrkjo8g9lcgog5q3rm2nb" modified-by="" timestamp="1512526528220"><title svg:width="500">原则：尽量见名知意，尽量是1个大写字母，或大写字母加数字</title></topic><topic id="1umf81ckn42csvme1r1knk8tsg" modified-by="" timestamp="1512526541695"><title>E</title><children><topics type="attached"><topic id="0fqglver65pogfusei46d1l737" modified-by="" timestamp="1512526539619"><title>Element</title></topic></topics></children></topic><topic id="7pe28a6gi3pokb13d2dcm5onbt" modified-by="" timestamp="1512526544702"><title>K</title><children><topics type="attached"><topic id="1jm50lueivorure9crpvdl3j7l" modified-by="" timestamp="1512526546924"><title>Key</title></topic></topics></children></topic><topic id="5n44f4e356bo0fnrhdghl7571p" modified-by="" timestamp="1512526549452"><title>V</title><children><topics type="attached"><topic id="7va8309m0cmfi8aq5ahvngvsll" modified-by="" timestamp="1512526552267"><title>Value</title></topic></topics></children></topic><topic id="26adjnj25jad4iccj1g8jdmmj3" modified-by="" timestamp="1512526554292"><title>T</title><children><topics type="attached"><topic id="2s86ic4471ial6739dkp806986" modified-by="" timestamp="1512526558361"><title>Type</title></topic></topics></children></topic><topic id="5on02vrtnvvtpaqub1odbv0ba0" modified-by="" timestamp="1512526564036"><title>T1,T2</title></topic><topic id="6jd8lmi5avutstbnuqqsqvnnpg" modified-by="" timestamp="1512526568910"><title>U1,U2</title></topic><topic id="5jf7mj37dqco0rt03rfqbsha39" modified-by="" timestamp="1512526574172"><title>R</title><children><topics type="attached"><topic id="65ctg9unehcbjl76t40auija75" modified-by="" timestamp="1512526579270"><title>ReturnType</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="76c1o8k93ev31smtc3n5ihpe9k" modified-by="" timestamp="1512526963008"><title>注意</title><children><topics type="attached"><topic id="5s78n1rebpperbpl6ov3fvsp40" modified-by="" timestamp="1512526643548"><title>（1）泛型形参由泛型实参决定</title><children><topics type="attached"><topic id="5s8n5n7qkbbhphrugnla9k81pq" modified-by="" timestamp="1512526659007"><title>在使用这个泛型类时</title><children><topics type="attached"><topic id="3qqfheojnk0no0l6is5n7vqpul" modified-by="" timestamp="1512526683965"><title>（1）创建对象</title><children><topics type="attached"><topic id="6et6kf9g7g10dpc8r30a2931kn" modified-by="" timestamp="1512526697509"><title svg:width="500">ArrayList&lt;Student&gt; list = new ArrayList&lt;Student&gt;();</title></topic></topics></children></topic><topic id="14aef37sf5mpa9tchcg87h1mvl" modified-by="" timestamp="1512526706680"><title>（2）继承类或实现接口</title><children><topics type="attached"><topic id="0ugpdraluicgrabp1hpqfr5j1e" modified-by="" timestamp="1512526683299"><title svg:width="500">class Student implements Comparable&lt;Student&gt;</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="5jdav77bblb0nbvs04umebkqdu" modified-by="" timestamp="1512526740772"><title svg:width="500">（2）泛型实参必须指定为引用数据类型，不能是基本数据类型</title></topic><topic id="5smhii98hu9a2s55clh82bjtuc" modified-by="" timestamp="1512526797336"><title svg:width="500">（3）泛型形参在声明它的类或接口中，当做某种已知的类型来使用的，可以用它声明属性、方法的形参类型，方法的返回值类型，方法的局部变量类型等</title></topic><topic id="6nmijecbnmcjb3u4gu1uso5hru" modified-by="" timestamp="1512526817059"><title>（4）泛型形参不能用于</title><children><topics type="attached"><topic id="673v10ea7kvj1d5c5nme0hoac0" modified-by="" timestamp="1512526816426"><title>不能作为异常的类型</title></topic><topic id="1q296m2eiu77940tt1fg5hg1co" modified-by="" timestamp="1512526828254"><title>不能用于静态成员上面</title></topic></topics></children></topic><topic id="13b7mjse7no72ovegk9p6oglh1" modified-by="" timestamp="1512526972881"><title>（5）泛型</title><children><topics type="attached"><topic id="5l827cvape0uo2faj32etsu066" modified-by="" timestamp="1512526983585"><title>不能用于创建数组对象</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="3t0iuslfvjrpij3lfi76k43r6a" modified-by="" timestamp="1512527218355"><title>2、泛型方法</title><children><topics type="attached"><topic id="7b3idbf6ugh3sh30dgop9nbpj8" modified-by="" timestamp="1512527022941"><title>语法格式</title><children><topics type="attached"><topic id="3v1ota5bantpgtj1b2m2umdpuc" modified-by="" timestamp="1512527061968"><title svg:width="500">[修饰符]  &lt;类型参数列表&gt;  返回值类型   方法名(形参列表)</title></topic></topics></children></topic><topic id="740boj84jds5qillub1ih878j1" modified-by="" timestamp="1512527086349"><title>泛型方法可以是静态方法，也可以是非静态方法</title></topic><topic id="72eohl113t4gbnbqdq2o9jgdrn" modified-by="" timestamp="1512527101525"><title svg:width="500">静态方法如果要用泛型，只能使用泛型方法的形式</title></topic><topic id="5994cm224qqmlq5doicukln2om" modified-by="" timestamp="1512527137128"><title svg:width="500">泛型方法的类型形参只适用于当前方法，和别的方法无关</title></topic><topic id="3ta5d4kcmtu6137c1he3n3icu9" modified-by="" timestamp="1512527217078"><title svg:width="500">泛型方法的泛型形参由调用该方法时实参的类型决定</title><children><topics type="attached"><topic id="6qnc83cl9qqfi62p3lqvdk895b" modified-by="" timestamp="1512527192158"><title svg:width="500">此时实参，即决定了泛型方法形参的值，又决定了泛型方法形参的类型</title></topic></topics></children></topic><topic id="2p2uqdtsglikld3v4aljn7k2dv" modified-by="" timestamp="1512527248651"><title svg:width="500">泛型方法的泛型形参也不能是指定为基本数据类型，可以用它的包装类，也不能用于异常类型</title></topic></topics></children></topic></topics></children></topic><topic id="4o889qr3pfksf0ehd4smte42fd" modified-by="" timestamp="1512527324468"><title>泛型的通配符</title><children><topics type="attached"><topic id="2j5ah6pnj0vlmf757qelb60ssu" modified-by="" timestamp="1512527274598"><title>1、?</title><children><topics type="attached"><topic id="7i0tbbo6am77sllo10eohnve5l" modified-by="" timestamp="1512527315292"><title>代表任意类型</title><children><topics type="attached"><topic id="0nf1hi1rcobo0urvv0rlh8781c" modified-by="" timestamp="1512527303254"><title svg:width="500">如果是集合，例如ArrayList&lt;?&gt;，这样的集合不能添加元素</title></topic></topics></children></topic></topics></children></topic><topic id="75ko6ep3guiub860ekgs11jpai" modified-by="" timestamp="1512527331779"><title>2、?  extends 父类</title><children><topics type="attached"><topic id="5g1h5fsr08n7tk9d5md92qsrrj" modified-by="" timestamp="1512527359351"><title>上限</title><children><topics type="attached"><topic id="4ppesl8bu2dk9a82al0aqdu54q" modified-by="" timestamp="1512527354950"><title>?代表父类本身或父类的子类类型可以</title></topic><topic id="6n0ljgefnalh9bfg7d1s9f05ie" modified-by="" timestamp="1512527446129"><title svg:width="500">如果是集合，例如ArrayList&lt;?  extends 父类&gt;，这样的集合不可以添加</title></topic></topics></children></topic></topics></children></topic><topic id="6oo8jeb59g83decvtl4i4ner0e" modified-by="" timestamp="1512527337389"><title>3、?  super 子类</title><children><topics type="attached"><topic id="2kgmo6hmvqpq49f3m2qeetgtvo" modified-by="" timestamp="1512527393239"><title>下限</title><children><topics type="attached"><topic id="2irk869ogpvrumeecgukf1hqr9" modified-by="" timestamp="1512527391383"><title>?代表子类本身或子类的父类类型可以</title></topic><topic id="65doa9heg3bpijgb3jh062aifk" modified-by="" timestamp="1512527467505"><title svg:width="500">如果是集合，例如ArrayList&lt;?  super 子类&gt;，这样的集合，可以添加，仅限于添加子类或子类的子类对象</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="5vho1s700tehp34lvc9ujnt4fu" modified-by="" timestamp="1512527708927"><title>JDK1.7的简写法</title><children><topics type="attached"><topic id="7d71d3ifjcsjtb3tm5oi06dvb7" modified-by="" timestamp="1512527723485"><title>ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();</title></topic></topics></children></topic></topics></children></topic><title>泛型</title></sheet><sheet id="2srcirs5amlnljothj4ontt1tc" modified-by="" style-id="300p0s8tu6a10jpkdrn3k4dlne" theme="xminddefaultthemeid" timestamp="1512785479117"><topic id="1ndl0c9nbm47rr122ada1u23jv" modified-by="" structure-class="org.xmind.ui.logic.right" timestamp="1512784015509"><title>IO流</title><extensions><extension provider="org.xmind.ui.map.unbalanced"><content><right-number>-1</right-number></content></extension></extensions><children><topics type="attached"><topic id="41vev3pfofevtqod42lgvk3pie" modified-by="" timestamp="1512696385784"><title>IO</title><children><topics type="attached"><topic id="5f083lqj4otgdhhv5nallf2lq2" modified-by="" timestamp="1512696394309"><title>I</title><children><topics type="attached"><topic id="7l3r4kecem67g3kkuc1tgh1oge" modified-by="" timestamp="1512696382622"><title>input</title></topic><topic id="1otifhm6nlhaoqjq8ntrfs4fr5" modified-by="" timestamp="1512696398692"><title>输入</title></topic></topics></children></topic><topic id="5ov0vcc0ummsmebcsgksr19ojl" modified-by="" timestamp="1512696399048"><title>O</title><children><topics type="attached"><topic id="08a8smr6pqhpvnrp68odtbudu3" modified-by="" timestamp="1512696392697"><title>output</title></topic><topic id="5gma8hgbfpso1kdnqt9sf5b90a" modified-by="" timestamp="1512696402939"><title>输出</title></topic></topics></children></topic></topics></children></topic><topic id="007veen4bh7f39tr35ncdubh0s" modified-by="" timestamp="1512696481538"><title>IO流的分类</title><children><topics type="attached"><topic id="1p19fhfm9ofuqtjho25934lp5l" modified-by="" timestamp="1512696435503"><title>1、按照IO流的数据流动方向分</title><children><topics type="attached"><topic id="3ortfrorsqbgsb6v5br91henvb" modified-by="" timestamp="1512696435177"><title>输入流</title></topic><topic id="62ccdmlm4v6cu6uqkhmb6f48ak" modified-by="" timestamp="1512696437961"><title>输出流</title></topic></topics></children></topic><topic id="0nosqloerejmg0nba3mvb1lch4" modified-by="" timestamp="1512696467057"><title>2、按照IO流的数据处理的最小单位分</title><children><topics type="attached"><topic id="61u9e2q8roh64r8pc333p7b63q" modified-by="" timestamp="1512696466782"><title>字节流</title></topic><topic id="7cp2neb0s7al97n5hfvrrdc8cj" modified-by="" timestamp="1512696470101"><title>字符流</title></topic></topics></children></topic><topic id="3r965plun3pkp4j1b65be5crd3" modified-by="" timestamp="1512696499390"><title>3、根据IO流的作用分</title><children><topics type="attached"><topic id="0om2huem0p2dp11mj5hvkuhqvj" modified-by="" timestamp="1512696517667"><title>节点流</title><children><topics type="attached"><topic id="2ilpmb1k7r7c68fssvaucs9chp" modified-by="" timestamp="1512696518933"><title>例如：文件IO流</title><children><topics type="attached"><topic id="313bk1r0u82dat8msfaoama75s" modified-by="" timestamp="1512696526033"><title>连接文件节点</title></topic></topics></children></topic></topics></children></topic><topic id="4drua0oo926u3k7r4hpc8oq0hu" modified-by="" timestamp="1512696529138"><title>处理流</title><children><topics type="attached"><topic id="56folae3o7n59pout4t078qpnd" modified-by="" timestamp="1512696557201"><title svg:width="500">在节点流的基础上增加其他功能，例如缓冲，编码解码，序列化等</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="4fuuoor5b9tccrkrehcpdpe4l9" modified-by="" timestamp="1512696602858"><title>IO流的四个抽象基类，超级父类</title><children><topics type="attached"><topic id="751uf317rc1hh9541t1kkpeung" modified-by="" timestamp="1512696608053"><title>InputStream</title><children><topics type="attached"><topic id="4oo3tn3ak3h2kgefokutv0cla7" modified-by="" timestamp="1512696612015"><title>字节输入流</title></topic></topics></children></topic><topic id="15s8r4ae8pll9br4fia5qte2lh" modified-by="" timestamp="1512696614469"><title>OutputStream</title><children><topics type="attached"><topic id="2eou71a3ki85vc9bq35hs5irsu" modified-by="" timestamp="1512696617464"><title>字节输出流</title></topic></topics></children></topic><topic id="28cqsctj82bep98nkoa9v7ag32" modified-by="" timestamp="1512696621039"><title>Reader</title><children><topics type="attached"><topic id="5agdhflmrrdaomq5po18alkgq9" modified-by="" timestamp="1512696634287"><title>字符输入流</title></topic></topics></children></topic><topic id="2c19vp51kip2434p52h8o5a6fh" modified-by="" timestamp="1512696636514"><title>Writer</title><children><topics type="attached"><topic id="6pg51risajd2u7qf3oavft3jnb" modified-by="" timestamp="1512696644603"><title>字符输出流</title></topic></topics></children></topic></topics></children></topic><topic branch="folded" id="2o0f8keq7ubl4f3hjnpm8k8iif" modified-by="" timestamp="1512779890521"><title>和文件相关的IO流</title><children><topics type="attached"><topic id="25gv7qre5moeor1qcgp4ikotpo" modified-by="" timestamp="1512696812214"><title>类型</title><children><topics type="attached"><topic id="3dh394ihue99olp72dcimr6bab" modified-by="" timestamp="1512696812026"><title>FileInputStream</title><children><topics type="attached"><topic id="69vigb5cacmodmdjp1cthk69kd" modified-by="" timestamp="1512696686568"><title>文件字节输入流</title></topic><topic id="5q7cubu6o31alh7sjln1pmj9bq" modified-by="" timestamp="1512696694477"><title>读取任意类型的文件</title></topic></topics></children></topic><topic id="1ssl4dh3261pp5bn46a54ro28u" modified-by="" timestamp="1512696812053"><title>FileOutputStream</title><children><topics type="attached"><topic id="23esnamnbotig7slp29hf2n4vl" modified-by="" timestamp="1512696705401"><title>文件字节输出流</title></topic><topic id="2n53mmcfof1ojuv33773fdjdrv" modified-by="" timestamp="1512696714884"><title>写数据到任意类型的文件</title></topic></topics></children></topic><topic id="36avf7v0lcujfhab4jta57u6eq" modified-by="" timestamp="1512696812091"><title>FileReader</title><children><topics type="attached"><topic id="6lkhltr5614s0pcusjr7fn7t81" modified-by="" timestamp="1512696724459"><title>文件字符输入流</title></topic><topic id="6n13r71hs931jcdi9ff9scfpql" modified-by="" timestamp="1512696750952"><title>只能读取纯文本文件</title><children><topics type="attached"><topic id="02ffjtsliskkulvs2h5uo0uv3j" modified-by="" timestamp="1512696737583"><title>.java</title></topic><topic id="0vvtvdvacqu4vn3ntnqm5sh375" modified-by="" timestamp="1512696741429"><title>.txt</title></topic><topic id="215e82bltuqvp9eopu7fan077d" modified-by="" timestamp="1512696744544"><title>.html</title></topic><topic id="0ofdm1mraehthmn6ql0u5s8ofr" modified-by="" timestamp="1512696748082"><title>.js</title></topic><topic id="460iv64rdlf3ijnk22fptbismr" modified-by="" timestamp="1512696750732"><title>.css</title></topic><topic id="3jc60516adjnifp9eqq8j2544i" modified-by="" timestamp="1512696753273"><title>....</title></topic></topics></children></topic></topics></children></topic><topic id="6tsauk7s8li8v7tlkpanm1ljih" modified-by="" timestamp="1512696812181"><title>FileWriter</title><children><topics type="attached"><topic id="1ic62b2ueu9spe3qth3dlabss0" modified-by="" timestamp="1512696780059"><title>文件字符输出流</title></topic><topic id="1ed88pl6qpp3lske2gv96jhmpg" modified-by="" timestamp="1512696791039"><title>只能把数据保存到纯文本文件中</title></topic></topics></children></topic></topics></children></topic><topic id="2fr74ktgli1qcog1u2juudsgct" modified-by="" timestamp="1512696832497"><title>读取</title><children><topics type="attached"><topic id="2ounkughhp95et5le2rb0m1ou6" modified-by="" timestamp="1512697023555"><title>（1）读取一个纯文本文件</title><notes><html><xhtml:p>形式一：</xhtml:p><xhtml:p>//(1)指定要读取的文件</xhtml:p><xhtml:p>File file = new File("upload/exam.txt");</xhtml:p><xhtml:p/><xhtml:p>//(2)创建文本文件的输入流</xhtml:p><xhtml:p>FileReader fr = null;</xhtml:p><xhtml:p/><xhtml:p>try{</xhtml:p><xhtml:p>	fr = new FileReader(file);</xhtml:p><xhtml:p/><xhtml:p>	//(3)在当前程序中创建一个字符数组，用来保存每一次读取的文本信息</xhtml:p><xhtml:p>	char[] data = new char[10];</xhtml:p><xhtml:p/><xhtml:p>	//(4)用来记录每一次读取的字符个数</xhtml:p><xhtml:p>	int len;</xhtml:p><xhtml:p/><xhtml:p>	//(5)用来拼接从文件读取的信息</xhtml:p><xhtml:p>	StringBuilder sb = new StringBuilder();</xhtml:p><xhtml:p/><xhtml:p>	//(6)循环读取</xhtml:p><xhtml:p>	while((len = fr.read(data))!=-1){</xhtml:p><xhtml:p>		sb.append(new String(data,0,len));</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>	System.out.println(sb);</xhtml:p><xhtml:p>}catch(Exception e){</xhtml:p><xhtml:p>	//....</xhtml:p><xhtml:p>}finally{</xhtml:p><xhtml:p>	//(7)释放资源</xhtml:p><xhtml:p>	try{</xhtml:p><xhtml:p>		if(fr!=null){</xhtml:p><xhtml:p>			fr.close();</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>	}catch(Exception e){</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p/><xhtml:p>形式二：</xhtml:p><xhtml:p>File file = new File("upload/exam.txt");</xhtml:p><xhtml:p/><xhtml:p>try(</xhtml:p><xhtml:p>	FileReader fr = new FileReader(file);</xhtml:p><xhtml:p>){</xhtml:p><xhtml:p>	char[] data = new char[10];</xhtml:p><xhtml:p>	int len;</xhtml:p><xhtml:p>	StringBuilder sb = new StringBuilder();</xhtml:p><xhtml:p>	while((len = fr.read(data))!=-1){</xhtml:p><xhtml:p>		sb.append(new String(data,0,len));</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>	System.out.println(sb);</xhtml:p><xhtml:p>}catch(Exception e){</xhtml:p><xhtml:p>	//....</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p/></html><plain>形式一：&#13;
//(1)指定要读取的文件&#13;
File file = new File("upload/exam.txt");&#13;
&#13;
//(2)创建文本文件的输入流&#13;
FileReader fr = null;&#13;
&#13;
try{&#13;
	fr = new FileReader(file);&#13;
&#13;
	//(3)在当前程序中创建一个字符数组，用来保存每一次读取的文本信息&#13;
	char[] data = new char[10];&#13;
&#13;
	//(4)用来记录每一次读取的字符个数&#13;
	int len;&#13;
&#13;
	//(5)用来拼接从文件读取的信息&#13;
	StringBuilder sb = new StringBuilder();&#13;
&#13;
	//(6)循环读取&#13;
	while((len = fr.read(data))!=-1){&#13;
		sb.append(new String(data,0,len));&#13;
	}&#13;
	System.out.println(sb);&#13;
}catch(Exception e){&#13;
	//....&#13;
}finally{&#13;
	//(7)释放资源&#13;
	try{&#13;
		if(fr!=null){&#13;
			fr.close();&#13;
		}&#13;
	}catch(Exception e){&#13;
	}&#13;
}&#13;
&#13;
形式二：&#13;
File file = new File("upload/exam.txt");&#13;
&#13;
try(&#13;
	FileReader fr = new FileReader(file);&#13;
){&#13;
	char[] data = new char[10];&#13;
	int len;&#13;
	StringBuilder sb = new StringBuilder();&#13;
	while((len = fr.read(data))!=-1){&#13;
		sb.append(new String(data,0,len));&#13;
	}&#13;
	System.out.println(sb);&#13;
}catch(Exception e){&#13;
	//....&#13;
}&#13;
</plain></notes></topic><topic id="2di93q2chbmnlk990e9ir5d5lb" modified-by="" timestamp="1512697164623"><title>（2）读取任意类型的文件</title><notes><html><xhtml:p>//(1)指定文件</xhtml:p><xhtml:p>File file = new File(".....");</xhtml:p><xhtml:p/><xhtml:p>//(2)创建字节输入流</xhtml:p><xhtml:p>try(</xhtml:p><xhtml:p/><xhtml:p>	FileInputStream fis = new FileInputStream(file);</xhtml:p><xhtml:p>){</xhtml:p><xhtml:p>	//(3)创建字节数组，用来存储每次读取的内容</xhtml:p><xhtml:p>	byte[] data = new byte[1024];</xhtml:p><xhtml:p>	//(4)用len记录每次读取的字节数</xhtml:p><xhtml:p>	int len;</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>	//(5)循环读取</xhtml:p><xhtml:p>	while( (len = fis.read(data)) !=-1){</xhtml:p><xhtml:p>		//......</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p/><xhtml:p>	</xhtml:p><xhtml:p>}catch(Exception e){</xhtml:p><xhtml:p>	//...</xhtml:p><xhtml:p>}</xhtml:p></html><plain>//(1)指定文件&#13;
File file = new File(".....");&#13;
&#13;
//(2)创建字节输入流&#13;
try(&#13;
&#13;
	FileInputStream fis = new FileInputStream(file);&#13;
){&#13;
	//(3)创建字节数组，用来存储每次读取的内容&#13;
	byte[] data = new byte[1024];&#13;
	//(4)用len记录每次读取的字节数&#13;
	int len;&#13;
	&#13;
	//(5)循环读取&#13;
	while( (len = fis.read(data)) !=-1){&#13;
		//......&#13;
	}&#13;
&#13;
	&#13;
}catch(Exception e){&#13;
	//...&#13;
}</plain></notes></topic></topics></children></topic><topic id="2uibbmae7nkgcj3g4hs0o9b75m" modified-by="" timestamp="1512696860845"><title>保存</title><children><topics type="attached"><topic id="2fm2mcmecjf2gsc8pna50r3r80" modified-by="" timestamp="1512697412332"><title>（1）把数据保存到一个纯文本文件</title><notes><html><xhtml:p>//(1)指定要保存的文件</xhtml:p><xhtml:p>File file = new File("....");</xhtml:p><xhtml:p/><xhtml:p>try(</xhtml:p><xhtml:p>	FileWriter fw = new FileWriter(file);</xhtml:p><xhtml:p>){</xhtml:p><xhtml:p>	String info = "....."; //要写入到文件的数据内容</xhtml:p><xhtml:p>	fw.write(info);</xhtml:p><xhtml:p/><xhtml:p>	//或</xhtml:p><xhtml:p>	char[] data = new char[1024];</xhtml:p><xhtml:p>	//...把数据保存到data中</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>	fw.write(data，0，len);</xhtml:p><xhtml:p>}catch(Exception e){</xhtml:p><xhtml:p>	//....</xhtml:p><xhtml:p>}</xhtml:p></html><plain>//(1)指定要保存的文件&#13;
File file = new File("....");&#13;
&#13;
try(&#13;
	FileWriter fw = new FileWriter(file);&#13;
){&#13;
	String info = "....."; //要写入到文件的数据内容&#13;
	fw.write(info);&#13;
&#13;
	//或&#13;
	char[] data = new char[1024];&#13;
	//...把数据保存到data中&#13;
	&#13;
	fw.write(data，0，len);&#13;
}catch(Exception e){&#13;
	//....&#13;
}</plain></notes></topic><topic id="1e51acknnd2e3rlap8r5j90j4i" modified-by="" timestamp="1512697400644"><title>（2）把数据保存到一个任意类型的文件</title><notes><html><xhtml:p>//(1)指定要保存的文件</xhtml:p><xhtml:p>File file = new File("....");</xhtml:p><xhtml:p/><xhtml:p>try(</xhtml:p><xhtml:p>	FileOutputSream fos  = new FileOutputSream(file);</xhtml:p><xhtml:p>){</xhtml:p><xhtml:p>	byte[] data = ....; //用来存储要输出到文件的内容</xhtml:p><xhtml:p/><xhtml:p>	fos.write(data,0 ,len);</xhtml:p><xhtml:p>}catch(Exception e){</xhtml:p><xhtml:p>	//....</xhtml:p><xhtml:p>}</xhtml:p></html><plain>//(1)指定要保存的文件&#13;
File file = new File("....");&#13;
&#13;
try(&#13;
	FileOutputSream fos  = new FileOutputSream(file);&#13;
){&#13;
	byte[] data = ....; //用来存储要输出到文件的内容&#13;
&#13;
	fos.write(data,0 ,len);&#13;
}catch(Exception e){&#13;
	//....&#13;
}</plain></notes></topic></topics></children></topic><topic id="4881bkusv66lldudd1fi3rttio" modified-by="" timestamp="1512698291157"><title>复制</title><children><topics type="attached"><topic id="15em53i209l38o11eembdjt4c4" modified-by="" timestamp="1512698347987"><title>一边读一边写</title><children><topics type="attached"><topic id="1m9cd93df6lreopjl8t38kktmf" modified-by="" timestamp="1512698347131"><title>纯文本文件</title><notes><html><xhtml:p>	public static void main(String[] args) {</xhtml:p><xhtml:p>		//(1)创建源文件对象</xhtml:p><xhtml:p>		File src = new File("1.txt");</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//(2)创建目标文件对象</xhtml:p><xhtml:p>		File dest = new File("2.txt");</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//(3)创建输入流</xhtml:p><xhtml:p>		FileReader fr = null;</xhtml:p><xhtml:p>		//(4)创建输出流</xhtml:p><xhtml:p>		FileWriter fw = null;</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		try {</xhtml:p><xhtml:p>			fr = new FileReader(src);</xhtml:p><xhtml:p>//			fw = new FileWriter(dest);//覆盖模式</xhtml:p><xhtml:p>			fw = new FileWriter(dest,true);//追加模式</xhtml:p><xhtml:p>			</xhtml:p><xhtml:p>			//(5)一边读一边写</xhtml:p><xhtml:p>			//从fr读一些，就写入fw一些</xhtml:p><xhtml:p>			char[] data = new char[6];//1024</xhtml:p><xhtml:p>			while(true){</xhtml:p><xhtml:p>				int len = fr.read(data);</xhtml:p><xhtml:p>				if(len == -1){</xhtml:p><xhtml:p>					break;</xhtml:p><xhtml:p>				}</xhtml:p><xhtml:p>				fw.write(data,0,len);//本次读了几个字符，就写几个字符</xhtml:p><xhtml:p>			}</xhtml:p><xhtml:p>		} catch (FileNotFoundException e) {</xhtml:p><xhtml:p>			e.printStackTrace();</xhtml:p><xhtml:p>		} catch (IOException e) {</xhtml:p><xhtml:p>			e.printStackTrace();</xhtml:p><xhtml:p>		} finally{</xhtml:p><xhtml:p>			try {</xhtml:p><xhtml:p>				if(fr!=null){</xhtml:p><xhtml:p>					fr.close();</xhtml:p><xhtml:p>				}</xhtml:p><xhtml:p>			} catch (IOException e) {</xhtml:p><xhtml:p>				e.printStackTrace();</xhtml:p><xhtml:p>			}</xhtml:p><xhtml:p>			</xhtml:p><xhtml:p>			try {</xhtml:p><xhtml:p>				if(fw!=null){</xhtml:p><xhtml:p>					fw.close();</xhtml:p><xhtml:p>				}</xhtml:p><xhtml:p>			} catch (IOException e) {</xhtml:p><xhtml:p>				e.printStackTrace();</xhtml:p><xhtml:p>			}</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>	}</xhtml:p></html><plain>	public static void main(String[] args) {&#13;
		//(1)创建源文件对象&#13;
		File src = new File("1.txt");&#13;
		&#13;
		//(2)创建目标文件对象&#13;
		File dest = new File("2.txt");&#13;
		&#13;
		//(3)创建输入流&#13;
		FileReader fr = null;&#13;
		//(4)创建输出流&#13;
		FileWriter fw = null;&#13;
		&#13;
		try {&#13;
			fr = new FileReader(src);&#13;
//			fw = new FileWriter(dest);//覆盖模式&#13;
			fw = new FileWriter(dest,true);//追加模式&#13;
			&#13;
			//(5)一边读一边写&#13;
			//从fr读一些，就写入fw一些&#13;
			char[] data = new char[6];//1024&#13;
			while(true){&#13;
				int len = fr.read(data);&#13;
				if(len == -1){&#13;
					break;&#13;
				}&#13;
				fw.write(data,0,len);//本次读了几个字符，就写几个字符&#13;
			}&#13;
		} catch (FileNotFoundException e) {&#13;
			e.printStackTrace();&#13;
		} catch (IOException e) {&#13;
			e.printStackTrace();&#13;
		} finally{&#13;
			try {&#13;
				if(fr!=null){&#13;
					fr.close();&#13;
				}&#13;
			} catch (IOException e) {&#13;
				e.printStackTrace();&#13;
			}&#13;
			&#13;
			try {&#13;
				if(fw!=null){&#13;
					fw.close();&#13;
				}&#13;
			} catch (IOException e) {&#13;
				e.printStackTrace();&#13;
			}&#13;
		}&#13;
	}</plain></notes></topic><topic id="2bqud1m111jvi9eo27fekbr72g" modified-by="" timestamp="1512698365914"><title>任意类型文件</title><notes><html><xhtml:p>	public static void main(String[] args) {</xhtml:p><xhtml:p>		// (1)创建源文件对象</xhtml:p><xhtml:p>		File src = new File("2.jpeg");// 完整的描述：路径+文件名+后缀名</xhtml:p><xhtml:p/><xhtml:p>		// (2)创建目标文件对象</xhtml:p><xhtml:p>		File dest = new File("3.jpg");</xhtml:p><xhtml:p/><xhtml:p>		// (3)创建输入流</xhtml:p><xhtml:p>		// (4)创建输出流</xhtml:p><xhtml:p/><xhtml:p>		try (</xhtml:p><xhtml:p>				FileInputStream fis = new FileInputStream(src); </xhtml:p><xhtml:p>				FileOutputStream fos = new FileOutputStream(dest);</xhtml:p><xhtml:p>			) {</xhtml:p><xhtml:p/><xhtml:p>			byte[] data = new byte[10];</xhtml:p><xhtml:p/><xhtml:p>			int len;</xhtml:p><xhtml:p>			while ((len = fis.read(data)) != -1) {</xhtml:p><xhtml:p>				fos.write(data, 0, len);</xhtml:p><xhtml:p>			}</xhtml:p><xhtml:p/><xhtml:p>		} catch (FileNotFoundException e) {</xhtml:p><xhtml:p>			e.printStackTrace();</xhtml:p><xhtml:p>		} catch (IOException e) {</xhtml:p><xhtml:p>			e.printStackTrace();</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>	}</xhtml:p></html><plain>	public static void main(String[] args) {&#13;
		// (1)创建源文件对象&#13;
		File src = new File("2.jpeg");// 完整的描述：路径+文件名+后缀名&#13;
&#13;
		// (2)创建目标文件对象&#13;
		File dest = new File("3.jpg");&#13;
&#13;
		// (3)创建输入流&#13;
		// (4)创建输出流&#13;
&#13;
		try (&#13;
				FileInputStream fis = new FileInputStream(src); &#13;
				FileOutputStream fos = new FileOutputStream(dest);&#13;
			) {&#13;
&#13;
			byte[] data = new byte[10];&#13;
&#13;
			int len;&#13;
			while ((len = fis.read(data)) != -1) {&#13;
				fos.write(data, 0, len);&#13;
			}&#13;
&#13;
		} catch (FileNotFoundException e) {&#13;
			e.printStackTrace();&#13;
		} catch (IOException e) {&#13;
			e.printStackTrace();&#13;
		}&#13;
	}</plain></notes></topic></topics></children></topic></topics></children></topic><topic id="1fb6jdpu2b6ecnu8e5hdvnatp8" modified-by="" timestamp="1512698199428"><title>File</title><children><topics type="attached"><topic id="7ar3nspiuu7s0grenga3ogvs6h" modified-by="" timestamp="1512697465333"><title>用来表示一个文件或者一个目录</title><children><topics type="attached"><topic id="7cjgiq8m584dv0l1pdnko7uunm" modified-by="" timestamp="1512697473613"><title>实际上是一个抽象的路径名</title></topic></topics></children></topic><topic id="0if02gvgd0ubuuud03vevlksie" modified-by="" timestamp="1512698236152"><title>获取文件或目录的一些信息</title><children><topics type="attached"><topic id="2cbimqk0bqvrucjmgkal8udngg" modified-by="" timestamp="1512697866272"><title>（1）获取文件的大小</title><children><topics type="attached"><topic id="3fmbdt2bjtii42ii3jt2onktq7" modified-by="" timestamp="1512697517658"><title>long length()</title></topic><topic id="0472t0lq11ipkva5demtlit500" modified-by="" timestamp="1512697699927"><title>如果要获取目录的大小，必须编写递归</title><notes><html><xhtml:p>	public long getDirLength(File dir){</xhtml:p><xhtml:p>		if(dir.isFile()){//如果是文件，直接返回文件的大小</xhtml:p><xhtml:p>			return dir.length();</xhtml:p><xhtml:p>		}else if(dir.isDirectory()){</xhtml:p><xhtml:p>			long sum = 0;</xhtml:p><xhtml:p>			File[] listFiles = dir.listFiles();</xhtml:p><xhtml:p>			for (File sub : listFiles) {</xhtml:p><xhtml:p>//				sum += 下一级的大小;</xhtml:p><xhtml:p>				sum += getDirLength(sub);</xhtml:p><xhtml:p>			}</xhtml:p><xhtml:p>			return sum;</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>		return 0;//既不是文件又不是文件夹，不存在</xhtml:p><xhtml:p>	}</xhtml:p></html><plain>	public long getDirLength(File dir){&#13;
		if(dir.isFile()){//如果是文件，直接返回文件的大小&#13;
			return dir.length();&#13;
		}else if(dir.isDirectory()){&#13;
			long sum = 0;&#13;
			File[] listFiles = dir.listFiles();&#13;
			for (File sub : listFiles) {&#13;
//				sum += 下一级的大小;&#13;
				sum += getDirLength(sub);&#13;
			}&#13;
			return sum;&#13;
		}&#13;
		return 0;//既不是文件又不是文件夹，不存在&#13;
	}</plain></notes></topic><topic id="6s9o2qjmv3t23aia78p500c8uu" modified-by="" timestamp="1512697875632"><title>如果文件不存在，返回0</title></topic></topics></children></topic><topic id="1g2d1ldqqsaquhm4v4g6fm82i7" modified-by="" timestamp="1512697613733"><title>（2）获取文件或目录的名称</title><children><topics type="attached"><topic id="3g4ke3hb29fq8a7p8d82ksrh6j" modified-by="" timestamp="1512697619083"><title>String getName()</title></topic></topics></children></topic><topic id="4eb18g8f8r5lpf07oeprej0np7" modified-by="" timestamp="1512697719967"><title>（3）获取文件或目录的路径</title><children><topics type="attached"><topic id="6pi97kr90om3k3mc96gl5j8llp" modified-by="" timestamp="1512697721348"><title svg:width="500">	String getPath()：获取路径&#13;
	String getAbsolutePath()：获取绝对路径&#13;
	String getCanonicalPath()：获取规范路径，例如：../   /</title></topic></topics></children></topic><topic id="75klpmhudr6gfnidk0gu0a8r0g" modified-by="" timestamp="1512697764000"><title>（4）获取文件的后缀名</title><children><topics type="attached"><topic id="23erov9ekb4kgrk1p24kg1vrgl" modified-by="" timestamp="1512697763300"><title svg:width="500">String name = file.getName();//得到文件名   包含扩展名</title></topic><topic id="53q6tcm3hhcgnj8q49ilagmtkk" modified-by="" timestamp="1512697765807"><title svg:width="500">String ext = name.substring(name.lastIndexOf('.'));</title></topic></topics></children></topic><topic id="09jgjt0bmc0u7km80nlt1t5pe6" modified-by="" timestamp="1512697876572"><title>（5）获取文件的最后修改时间</title><children><topics type="attached"><topic id="6bqm8fcdajnjotfs5fsoe8vtuk" modified-by="" timestamp="1512697810627"><title>long  lastModified()</title><children><topics type="attached"><topic id="7dlsblm3do5jm9vi6sqj9p0efd" modified-by="" timestamp="1512697814236"><title>毫秒数</title></topic></topics></children></topic><topic id="3gsif1quc3evvm6vuhiveknqhn" modified-by="" timestamp="1512697878120"><title>如果文件不存在，返回0</title></topic></topics></children></topic><topic id="2pqfo0plla7n8b18gkk6otmdrj" modified-by="" timestamp="1512698254338"><title>（6）获取上一级目录</title><children><topics type="attached"><topic id="53h12gpqpofg206rvqv8pps3b7" modified-by="" timestamp="1512698254091"><title>String getParent()</title></topic><topic id="7n4tjav476j6mnv3go6oa9737f" modified-by="" timestamp="1512698263049"><title>File getParentFile()</title></topic></topics></children></topic></topics></children></topic><topic id="1ps7s8jp4k367k0r293upjj5te" modified-by="" timestamp="1512698014073"><title>判断</title><children><topics type="attached"><topic id="68906ft083p7as3pproon2plq9" modified-by="" timestamp="1512697879989"><title>（1）是否是文件</title><children><topics type="attached"><topic id="3aneqhjs94hp4vcacvqsqtn9r1" modified-by="" timestamp="1512697888570"><title>isFile()</title><children><topics type="attached"><topic id="2msirgdilcp8pshr18kvhtq5ps" modified-by="" timestamp="1512697921397"><title svg:width="500">仅当file代表的文件存在，并且是个文件，才返回true</title></topic></topics></children></topic><topic id="0kfj1jksb8vu014jcvq4ei8jf0" modified-by="" timestamp="1512697887933"><title>如果文件不存在，返回false</title></topic></topics></children></topic><topic id="1vsg9tkeuucmuj88dmcibukvjm" modified-by="" timestamp="1512697954076"><title>（2）是否是目录</title><children><topics type="attached"><topic id="0hc2qk1t88jh4bmtkma38evma5" modified-by="" timestamp="1512697905812"><title>isDirectory()</title><children><topics type="attached"><topic id="3htciltianmlkhnuf0rdcvef31" modified-by="" timestamp="1512697952417"><title svg:width="500">仅当file对象代表的目录存在，并且是个文件夹目录，才返回true</title></topic></topics></children></topic><topic id="7urbh2na00ha5a5j64mfdoih03" modified-by="" timestamp="1512697961499"><title>如果对应的不存在，返回false</title></topic></topics></children></topic><topic id="5f6t9gnup1b52vigv5up3i830v" modified-by="" timestamp="1512697980698"><title>（3）是否存在</title><children><topics type="attached"><topic id="1r4upt24jt0jhmcuo6koor78mo" modified-by="" timestamp="1512697986053"><title>exists()</title></topic></topics></children></topic><topic id="4h59kjjl38as3l6701sdq55915" modified-by="" timestamp="1512697994200"><title>（4）是否隐藏</title><children><topics type="attached"><topic id="6ne25n3c5ammur849ba84g4df1" modified-by="" timestamp="1512698000371"><title>isHidden()</title></topic></topics></children></topic><topic id="2oat4a3v5cfic9g09i2gd9c45s" modified-by="" timestamp="1512698008415"><title>（5）文件是否可读</title><children><topics type="attached"><topic id="0gphia4skkvlv97qournjdqjro" modified-by="" timestamp="1512698013830"><title>canRead()</title></topic></topics></children></topic><topic id="1qus8eenipfehdk5hkvnt3k5pj" modified-by="" timestamp="1512698020658"><title>（6）文件是否可写</title><children><topics type="attached"><topic id="72j5vgda040vhfb91kfjbcvjd5" modified-by="" timestamp="1512698027883"><title>canWrite()</title></topic></topics></children></topic></topics></children></topic><topic id="5p85u4o49pehvr46s6bf878hhl" modified-by="" timestamp="1512698175990"><title>操作</title><children><topics type="attached"><topic id="18co879f4c6ob5o6kchos9f21p" modified-by="" timestamp="1512698045727"><title>（1）创建文件</title><children><topics type="attached"><topic id="57oaq9rs3mvjh2rbndq6u6c9b3" modified-by="" timestamp="1512698051504"><title>createNewFile()</title></topic></topics></children></topic><topic id="2ega6om76msju01ujm447fbpqq" modified-by="" timestamp="1512698062478"><title>（2）创建目录</title><children><topics type="attached"><topic id="6mkc159e0uc3rknhnlo9vbomm6" modified-by="" timestamp="1512698083344"><title>mkdir()</title><children><topics type="attached"><topic id="5t3de4i8fdqu43b2bjiaipbs8q" modified-by="" timestamp="1512698090689"><title>如果父目录不存在，那么创建失败</title></topic></topics></children></topic><topic id="63qcr58sv2csdnuet2mt6mumi0" modified-by="" timestamp="1512698069193"><title>mkdirs()</title><children><topics type="attached"><topic id="6nqb4rj1e5u3flna724h977ced" modified-by="" timestamp="1512698083077"><title>如果父目录不存在，也一并创建</title></topic></topics></children></topic></topics></children></topic><topic id="3pl01rjv766b2o64lkl9so5v2v" modified-by="" timestamp="1512698113690"><title>（3）删除文件或目录</title><children><topics type="attached"><topic id="5s0ruo23u9d2ikfjsiqpun83o5" modified-by="" timestamp="1512698103664"><title>delete()</title></topic><topic id="3qrlk0t6o9avbskcg1hu2fdjsf" modified-by="" timestamp="1512698110577"><title>只能删空目录</title></topic><topic id="5pmvhtgrajjl6oe4d2btjpmc51" modified-by="" timestamp="1512698156201"><title>如果要删除有内容的目录，需要使用递归</title><notes><html><xhtml:p>	public void delDir(File file){		</xhtml:p><xhtml:p>		//如果是目录</xhtml:p><xhtml:p>		if(file.isDirectory()){</xhtml:p><xhtml:p>			//(2)先获取下一级，并删除下一级</xhtml:p><xhtml:p>			//a：获取下一级</xhtml:p><xhtml:p>			File[] listFiles = file.listFiles();</xhtml:p><xhtml:p>			//b：遍历并删除下一级</xhtml:p><xhtml:p>			for (File sub : listFiles) {</xhtml:p><xhtml:p>				//这是一个重复的过程</xhtml:p><xhtml:p>				delDir(sub);//调用自己</xhtml:p><xhtml:p>			}</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//删除自己</xhtml:p><xhtml:p>		file.delete();</xhtml:p><xhtml:p>	}</xhtml:p></html><plain>	public void delDir(File file){		&#13;
		//如果是目录&#13;
		if(file.isDirectory()){&#13;
			//(2)先获取下一级，并删除下一级&#13;
			//a：获取下一级&#13;
			File[] listFiles = file.listFiles();&#13;
			//b：遍历并删除下一级&#13;
			for (File sub : listFiles) {&#13;
				//这是一个重复的过程&#13;
				delDir(sub);//调用自己&#13;
			}&#13;
		}&#13;
		&#13;
		//删除自己&#13;
		file.delete();&#13;
	}</plain></notes></topic></topics></children></topic><topic id="00jk0egbnkcdp3l0b97pe2pmfu" modified-by="" timestamp="1512698183994"><title>（4）重命名</title><children><topics type="attached"><topic id="5f0ogsb25i1cu9edssm4sk9ppj" modified-by="" timestamp="1512698194337"><title>renameTo(File newFile)</title></topic></topics></children></topic></topics></children></topic><topic id="1q1lpfqu2p2st4ng49rcuv76f9" modified-by="" timestamp="1512698205593"><title>操作文件夹</title><children><topics type="attached"><topic id="23itvottcres7jinul89pmslsq" modified-by="" timestamp="1512698221881"><title>获取它的下一级</title><children><topics type="attached"><topic id="7aos4huetck1rvess6uu6saji9" modified-by="" timestamp="1512698220902"><title>String[] list();</title></topic><topic id="3p4hppcepfqndhi6bi03onjq3v" modified-by="" timestamp="1512698230551"><title>File[] listFiles()</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="1a8v2m4klucui8kjbemui2jtj7" modified-by="" timestamp="1512781667483"><title>处理流</title><children><topics type="attached"><topic id="7m5evf0ba5jaf6h1ju22f494ne" modified-by="" timestamp="1512779942539"><title>缓冲流</title><children><topics type="attached"><topic id="3jprc07jn5nr57ohoveibppu0g" modified-by="" timestamp="1512779926615"><title>作用：增加缓冲区，提供效率</title></topic><topic id="1iv0iqio19o63reta8teer5ppp" modified-by="" timestamp="1512780953516"><title>类型</title><children><topics type="attached"><topic id="09hsqnfhh6kapri8o716d3mtj0" modified-by="" timestamp="1512779982699"><title>BufferedInputStream</title><children><topics type="attached"><topic id="6ocvb48rbf2p3mik5a2kbrov7q" modified-by="" timestamp="1512779991054"><title>包装InputStream</title><children><topics type="attached"><topic id="00mtgkcs0khdtkiucgr8g7olg8" modified-by="" timestamp="1512780024776"><title svg:width="500">例如：FileInputStream、DataInputStream、ObjectInputStream等</title></topic></topics></children></topic></topics></children></topic><topic id="7itqjrhat09rs54m0u2e03t4i0" modified-by="" timestamp="1512780027061"><title>BufferedOutputStream</title><children><topics type="attached"><topic id="0ajs5aajtg294iq1pgh0b18t6c" modified-by="" timestamp="1512780034980"><title>包装OutputStream</title><children><topics type="attached"><topic id="4bmpqbq4n2467dm23pptr7uq6l" modified-by="" timestamp="1512780067049"><title svg:width="500">例如：FileOutputStream、DataOutputStream、ObjectOutputStream等</title></topic></topics></children></topic></topics></children></topic><topic id="1ifpg9vljge394ce8fr71635t4" modified-by="" timestamp="1512780893929"><title>BufferedReader</title><children><topics type="attached"><topic id="3p7pdh650qd2bu6hcga0oek2t5" modified-by="" timestamp="1512780075857"><title>包装Reader</title><children><topics type="attached"><topic id="0i7rkju6iii8p2d5s9ifhfg28l" modified-by="" timestamp="1512780099728"><title>例如：FileReader、InputStreamReader等</title></topic></topics></children></topic><topic id="0cf8g39htl0bvav6g6iksv9do9" modified-by="" timestamp="1512780907758"><title>String readLine()</title><children><topics type="attached"><topic id="2ojh96f1lcrac0724p4tm56k90" modified-by="" timestamp="1512780918223"><title>判断是否读完，使用 ==null</title></topic></topics></children></topic></topics></children></topic><topic id="5trs5a5gmkj8t517hif42hpu2a" modified-by="" timestamp="1512780920069"><title>BufferedWriter</title><children><topics type="attached"><topic id="7sv0e3v9tiv0f9pgqg8p4u03r6" modified-by="" timestamp="1512780107186"><title>包装Writer</title><children><topics type="attached"><topic id="5d4dl8d3dpu1nl3pdsq3pvuvqg" modified-by="" timestamp="1512780125312"><title>例如：FileWriter，OutputStreamWriter等</title></topic></topics></children></topic><topic id="29ap9rb2frn5k3jrdtc578l56j" modified-by="" timestamp="1512780932550"><title>write(String) + newLine()</title></topic></topics></children></topic><topic id="24b0e85k7771g3fmi5cui1ruio" modified-by="" timestamp="1512781005882"><title>缓冲区的大小</title><children><topics type="attached"><topic id="3hidibnoqj78devvjk35ebqa00" modified-by="" timestamp="1512780984666"><title>字节流</title><children><topics type="attached"><topic id="3htgph4en6pgsi1t8t85lipa70" modified-by="" timestamp="1512781005578"><title>8192字节</title></topic></topics></children></topic><topic id="6evt09phoue3mqdk9hsepe3ohv" modified-by="" timestamp="1512781009114"><title>字符流</title><children><topics type="attached"><topic id="47eqjvqlo9bsb5qp785umio7ho" modified-by="" timestamp="1512781013070"><title>8192字符</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="3makmna9fqvrmqoudjnqo5dvjd" modified-by="" timestamp="1512781190966"><title>数据流</title><children><topics type="attached"><topic id="3uhfgi0rksebii59ktnc69t57i" modified-by="" timestamp="1512781077200"><title svg:width="500">作用：可以处理Java的基本数据类型+字符串（UTF-8修改版）</title></topic><topic id="4ihtq5vc7lku6oeclskuajltcm" modified-by="" timestamp="1512781092446"><title>类型</title><children><topics type="attached"><topic id="153sjrfl8bnmdpbnluvkl8h08g" modified-by="" timestamp="1512781100210"><title>DataOutputStream</title><children><topics type="attached"><topic id="6sh1nfrhdhcsinu2a65a4lic9p" modified-by="" timestamp="1512781127335"><title>writeXxx()</title><children><topics type="attached"><topic id="0oc6858lof0d0el84ughgh7lol" modified-by="" timestamp="1512781139757"><title>writeInt(int)</title></topic><topic id="13um4dmijeu8ecgdh4euh2ksm7" modified-by="" timestamp="1512781142987"><title>writeDouble(double)</title></topic><topic id="010ila5cvb08mj3g1p1rjskvb6" modified-by="" timestamp="1512781147488"><title>writeChar(char)</title></topic><topic id="3vfuv8qgnq612r5reb1v562bt8" modified-by="" timestamp="1512781150492"><title>writeUTF(String)</title></topic></topics></children></topic></topics></children></topic><topic id="0koive5ipqcbu22h1grs59tf5h" modified-by="" timestamp="1512781154006"><title>DataInputStream</title><children><topics type="attached"><topic id="48ss07bir47g5hdo8qiml73ejp" modified-by="" timestamp="1512781181401"><title>readXxx()</title><children><topics type="attached"><topic id="22sqtdb5tt5nf4j60imjecf3g3" modified-by="" timestamp="1512781168993"><title>int readInt()</title></topic><topic id="7208bbubi5tp66lt0ch80qi078" modified-by="" timestamp="1512781175049"><title>double readDouble()</title></topic><topic id="794gf87kc3g9jt4mm4hsphvfhg" modified-by="" timestamp="1512781181149"><title>char readChar()</title></topic><topic id="4rra2j7c11vltqklh99es6ftv0" modified-by="" timestamp="1512781186803"><title>String readUTF()</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="17av3gacrk1vfb0fao91q35bk4" modified-by="" timestamp="1512781211285"><title>注意：</title><children><topics type="attached"><topic id="0alvaa35ocgkh3lndt6ufe8t7h" modified-by="" timestamp="1512781210247"><title svg:width="500">（1）DataOutputStream写，用DataInputStream读取</title></topic><topic id="5kupi9vf8rq4snmsrb4erd5khf" modified-by="" timestamp="1512781275052"><title>（2）写的顺序和读的顺序要一致</title><children><topics type="attached"><topic id="3a4uhfcflvtlfg8ueqiqraance" modified-by="" timestamp="1512781300956"><title svg:width="500">写与读之间需要配置文件等形式进行沟通顺序和类型</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="3etraldgkb79porvj4t63lvpv3" modified-by="" timestamp="1512781415636"><title>对象流</title><children><topics type="attached"><topic id="2upbolt4n810gvd8lv2irb48to" modified-by="" timestamp="1512781346651"><title>作用：可以处理Java对象等</title></topic><topic id="6p3aomkqggb9t8gp8eb9jq27gh" modified-by="" timestamp="1512781361793"><title>类型</title><children><topics type="attached"><topic id="380rdc34ub7c3nvm7tm64pe2er" modified-by="" timestamp="1512781398988"><title>ObjectOutputStream</title><children><topics type="attached"><topic id="3gpbdu1m9dppr1ca2okf6jdkpi" modified-by="" timestamp="1512781376608"><title>writeObject(Object)</title></topic><topic id="23lpi7a3cmn1mr7jdrm5b6pjj3" modified-by="" timestamp="1512781405087"><title>对象的序列化</title></topic></topics></children></topic><topic id="4qb8650c9ndr0cotuuk95n90sm" modified-by="" timestamp="1512781405303"><title>ObjectInputStream</title><children><topics type="attached"><topic id="7r5riguph5knpg48h8ukd45l5c" modified-by="" timestamp="1512781395221"><title>Object  readObject()</title></topic><topic id="3btj6fvb9u00598kkv5opkqoti" modified-by="" timestamp="1512781410987"><title>对象的反序列化</title></topic></topics></children></topic></topics></children></topic><topic id="0ilcuj0quqhfal9nuug6knunce" modified-by="" timestamp="1512785464319"><title>注意</title><children><topics type="attached"><topic id="7rfat08vgriqej5rn5kbjclh85" modified-by="" timestamp="1512781478781"><title svg:width="500">（1）凡是要序列化的对象，它的类型必须实现java.io.Serializable接口</title><children><topics type="attached"><topic id="71kohsj96fljkktl0if7rcqmqc" modified-by="" timestamp="1512781500767"><title>否则会报：NotSerializableExecption</title></topic></topics></children></topic><topic id="7fcfk9ahvv9fu7k2aope16cret" modified-by="" timestamp="1512781473317"><title svg:width="500">（2）如果属性涉及到其他的引用数据类型，那么这个类型也必须实现java.io.Serializable接口</title></topic><topic id="2jvom53135b30qimq1tt7df0bj" modified-by="" timestamp="1512781562150"><title svg:width="500">（3）如果某个属性不想要序列化，那么可以在属性之前加transient</title><children><topics type="attached"><topic id="7p03093fk0cpmq3sr4ngf03uqo" modified-by="" timestamp="1512781557449"><title svg:width="500">一旦加了这个关键字修饰，该属性的值会在序列化的过程中，被忽略</title></topic><topic id="4rh9dbm7i9nf6em95ohqp2mgd5" modified-by="" timestamp="1512781579498"><title svg:width="500">一旦加了这个关键字修饰，该属性在反序列化的过程中，它的值就赋默认值</title></topic></topics></children></topic><topic id="1v9ubqdgacv9aq8rkk6e432hj6" modified-by="" timestamp="1512781636514"><title svg:width="500">（4）在实现java.io.Serializable接口时，最好加一个常量：序列化版本ID</title><children><topics type="attached"><topic id="2mhkupgt40mdbhhk3j9pbqiurv" modified-by="" timestamp="1512781639062"><title>private static final long serialVersionUID = 1L;</title></topic></topics></children></topic><topic id="7n3l97nb04k0vlsrgc6rg3dnug" modified-by="" timestamp="1512785479117"><title>（5）静态的属性不能序列化</title></topic></topics></children></topic></topics></children></topic><topic id="04flf07sgt6657sjujvkfllh61" modified-by="" timestamp="1512781723740"><title>打印流</title><children><topics type="attached"><topic id="1riinrd09i1rorns1lm54u78sh" modified-by="" timestamp="1512781720417"><title svg:width="500">作用：可以打印各种类型的数据，最终都是以字符的形式打印，如果是引用数据类型，就调用它的toString()</title></topic><topic id="5jortdcb5jjsoq09eo2ljtejcn" modified-by="" timestamp="1512781732329"><title>类型</title><children><topics type="attached"><topic id="7plqjsgmqch9en8i076vonq86j" modified-by="" timestamp="1512781746844"><title>PrintStream</title><children><topics type="attached"><topic id="23f8cs87ghfkkqlo7iujki6jmr" modified-by="" timestamp="1512781742524"><title>代表</title><children><topics type="attached"><topic id="7i7nl2td7e11f84agob1hjta18" modified-by="" timestamp="1512781745814"><title>System.out</title></topic></topics></children></topic><topic id="2djb8ltetvbj6fs6qumi5hcfm7" modified-by="" timestamp="1512781754478"><title>方法</title><children><topics type="attached"><topic id="0a88lpf1am475qbaaph5maet0s" modified-by="" timestamp="1512781753604"><title>print(xxx)</title></topic><topic id="1kfqsag60mq9pkeee8o6g80m1s" modified-by="" timestamp="1512781758434"><title>println(xxx)</title></topic></topics></children></topic></topics></children></topic><topic id="7il7s8mpc0ssdgds9ptsn23e9c" modified-by="" timestamp="1512781825931"><title>PrintWriter</title><children><topics type="attached"><topic id="42p7dplqumdscdtsrtkloapdcn" modified-by="" timestamp="1512781825878"><title>方法</title><children><topics type="attached"><topic id="791muu3trmp4kplbp1cau4fmmv" modified-by="" timestamp="1512781753604"><title>print(xxx)</title></topic><topic id="0o8vbl3v958cau2ta6es6biann" modified-by="" timestamp="1512781758434"><title>println(xxx)</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="0gbqlnrcu8qea046n5hnm5coai" modified-by="" timestamp="1512784707519"><title>NIO（了解）</title><children><topics type="attached"><topic id="7l65312j5246d7dv1jh89uif95" modified-by="" timestamp="1512781857975"><title>NIO</title><children><topics type="attached"><topic id="71s08pq67sve9v9jsl40ag86vm" modified-by="" timestamp="1512781878671"><title>Non - Blocking IO</title><children><topics type="attached"><topic id="2tbnfg6rlqk5vbpr0ci2ijn5r4" modified-by="" timestamp="1512781884663"><title>非阻塞式IO</title></topic></topics></children></topic></topics></children></topic><topic id="55tqk3g37nql0qqnlmdlvft60a" modified-by="" timestamp="1512782161515"><title>NIO和IO的区别</title><children><topics type="attached"><topic id="4ukn6krqu4urle0aqlcr5pvbfa" modified-by="" timestamp="1512782102477"><title>区别一</title><children><topics type="attached"><topic id="4bk7sc29na39rsc6ln5ubve4kf" modified-by="" timestamp="1512782102341"><title svg:width="500">IO是面向流，是单向的，从某个流中要么只能读，要么只能写</title><children><topics type="attached"><topic id="4qcf5dlgmgh75ul248viass456" modified-by="" timestamp="1512781951199"><title>例如：要读文件</title><children><topics type="attached"><topic id="3t5j9eugj4290e6petju0fnqmc" modified-by="" timestamp="1512781950451"><title>FileInputStream</title></topic><topic id="52r6o96glng5aaggb4easq2dok" modified-by="" timestamp="1512781956475"><title>FileReader</title></topic></topics></children></topic><topic id="0qk0k518sbb7nu479t78lqdufn" modified-by="" timestamp="1512781971890"><title>类型即决定可以进行的操作</title></topic></topics></children></topic><topic id="6270691q3lfr1qps2baf0n9rhg" modified-by="" timestamp="1512782102398"><title svg:width="500">NIO是面向通道+缓冲区，即可以是单向的，又可以是双向的</title><children><topics type="attached"><topic id="575ap3ng31aj79k3vai0bijrii" modified-by="" timestamp="1512782015977"><title>例如：ByteBuffer</title><children><topics type="attached"><topic id="56qtjiloqb8rhfrhgka9pgsmdb" modified-by="" timestamp="1512782017868"><title>put</title><children><topics type="attached"><topic id="0s5g2cldoit25688sld07clqd5" modified-by="" timestamp="1512782022551"><title>往里写</title></topic></topics></children></topic><topic id="2j5vrc88a55uq698annrrali0i" modified-by="" timestamp="1512782022798"><title>get</title><children><topics type="attached"><topic id="5dfp0i7p7vjk89pvtovkn3li5d" modified-by="" timestamp="1512782026159"><title>往外读</title></topic></topics></children></topic></topics></children></topic><topic id="4k1c3d9etkph1f61kbpj0j2b3f" modified-by="" timestamp="1512782052536"><title>例如：FileChannel</title><children><topics type="attached"><topic id="183ustaeh6vq826mcav5doud2u" modified-by="" timestamp="1512782051939"><title>既可以指定为只读</title></topic><topic id="57fceut77j22onn69cv8omim7u" modified-by="" timestamp="1512782059436"><title>又可以指定为可读可写</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="6a3m8tdjivtvg3l881e0001qsg" modified-by="" timestamp="1512782138101"><title>区别二</title><children><topics type="attached"><topic id="55su10mh2qqempjdrtn0g08c1e" modified-by="" timestamp="1512782132236"><title svg:width="500">IO是阻塞式的，一旦某个线程在读，此时没有可读的数据，会一直等待</title></topic><topic id="6cgaotoki0v02q1ui670p1c5f3" modified-by="" timestamp="1512782156766"><title>NIO是非阻塞式</title></topic></topics></children></topic><topic id="7h2esd91skea2ijnfr9mlson5f" modified-by="" timestamp="1512782165482"><title>区别三</title><children><topics type="attached"><topic id="59oscr3u8jvofg23gd4n51o8k3" modified-by="" timestamp="1512782173793"><title>NIO可以使用选择器</title></topic></topics></children></topic></topics></children></topic><topic id="31q6seol0dk7njm6fsfup8ld49" modified-by="" timestamp="1512782239793"><title>和新的IO的API相关的</title><children><topics type="attached"><topic id="3nmt1305p6aoa15v2t4vfsh6uq" modified-by="" timestamp="1512782243186"><title>Path</title><children><topics type="attached"><topic id="5vmp6303fusqu98upsmgg2pgof" modified-by="" timestamp="1512782246685"><title>是一个接口</title></topic></topics></children></topic><topic id="1u05enlkj9c0ud0ut2ddp4jvr5" modified-by="" timestamp="1512782273852"><title>Paths</title><children><topics type="attached"><topic id="15ip5j5hga0t6k880atahfk77u" modified-by="" timestamp="1512782263200"><title>用来获取Path的对象</title></topic><topic id="4r9bj7ukdgn78nl65vrc09onen" modified-by="" timestamp="1512782273013"><title>Paths.get(URI)</title></topic><topic id="5hhpe54r9eg3ps15sv6ac33rf0" modified-by="" timestamp="1512782287882"><title>Paths.get(String first, String...  others)</title></topic></topics></children></topic><topic id="359irhetl6gofrfabf8mq7sv4r" modified-by="" timestamp="1512782323838"><title>Files</title><children><topics type="attached"><topic id="1btaf8vfi8a6sbnsacjh5ul1fj" modified-by="" timestamp="1512782330270"><title>工具类</title><children><topics type="attached"><topic id="7uabga8dq795iaiov4l3dhdm5d" modified-by="" timestamp="1512782333051"><title>静态方法</title></topic></topics></children></topic><topic id="735bi93osn1bpr45qi4esgmm8l" modified-by="" timestamp="1512782321296"><title>和Path用来替代原来的File</title></topic><topic id="7e0uhq7i2nfnp50qj48qndlnhl" modified-by="" timestamp="1512783036767"><title>方法</title><children><topics type="attached"><topic id="06bji05dbcpnbnlnd7dv4fqfhr" modified-by="" timestamp="1512782417172"><title>创建文件</title><children><topics type="attached"><topic id="7iqph4avimhfrdl91nt1metcs5" modified-by="" timestamp="1512782443267"><title>createFile</title><children><topics type="attached"><topic id="7somb6ctv52g7j57rcpf1q3ghp" modified-by="" timestamp="1512782584855"><title svg:width="500">如果文件已存在，直接报异常</title></topic></topics></children></topic><topic id="0veaqa2vmbmj3jt0vho383b6nq" modified-by="" timestamp="1512782432570"><title>和File类的createNewFile()区别</title><children><topics type="attached"><topic id="6g1tea1q1fecliagj0ld5u77oq" modified-by="" timestamp="1512782442431"><title>如果文件已存在，不提示</title></topic></topics></children></topic></topics></children></topic><topic id="13ddodf2ukjskr9tpb584gik8q" modified-by="" timestamp="1512782413148"><title>创建目录</title><children><topics type="attached"><topic id="4mh9o066u9v5te9nch1erg49q1" modified-by="" timestamp="1512782780350"><title>createDirectory</title><children><topics type="attached"><topic id="6mqjupad4upgr9ppnca16gkocq" modified-by="" timestamp="1512782779298"><title>替代原来的File的mkdir</title></topic><topic id="5vmne8dv9flvke5ksc92tv4m9s" modified-by="" timestamp="1512782789606"><title>不同的是，如果目录已存在，就会报异常</title></topic></topics></children></topic><topic id="5ulp0q53ke5flm6genalt6p2u6" modified-by="" timestamp="1512782791713"><title>createDirectories</title><children><topics type="attached"><topic id="683p5vn6rcemajoaff2sjjo9mv" modified-by="" timestamp="1512782794633"><title>替代原来的File的mkdirs</title></topic><topic id="3bsspbjedk4ecqfs71gni91bpf" modified-by="" timestamp="1512782791661"><title>不同的是，如果目录已存在，就会报异常</title></topic></topics></children></topic></topics></children></topic><topic id="5qeirs48ksf86jmop0pqntne99" modified-by="" timestamp="1512782810791"><title>复制文件</title><children><topics type="attached"><topic id="13vd3aqddk73e9rbcib6h3p38r" modified-by="" timestamp="1512782809539"><title>copy</title></topic><topic id="4q92q3h8l2rlohkp5fergkdsle" modified-by="" timestamp="1512782867935"><title>区别</title><children><topics type="attached"><topic id="7fphlugr0t6tahl99otqvvj870" modified-by="" timestamp="1512782838397"><title>如果目标文件不存在，直接创建</title></topic><topic id="0sbhml0eo6nhj72snpq32eh4l8" modified-by="" timestamp="1512782866358"><title svg:width="500">如果目标文件已存在，要看是覆盖模式吗</title></topic><topic id="060vdnb30lbt4ucp6hpi0j8ett" modified-by="" timestamp="1512782875047"><title>默认情况下，已存在，会报异常</title></topic></topics></children></topic></topics></children></topic><topic id="6tdflm356ujkmek50m280h6uvr" modified-by="" timestamp="1512782878783"><title>读取文件</title><children><topics type="attached"><topic id="3u68tr5dhisslu7pk284miabts" modified-by="" timestamp="1512782931917"><title>readAllLines(Path path) </title><children><topics type="attached"><topic id="0dkoll2js68p9u5fodgqsrvhmd" modified-by="" timestamp="1512782906327"><title>读取文件，返回List&lt;String&gt;</title></topic><topic id="2dejcul07rgcjra3ju3ck87rr4" modified-by="" timestamp="1512782931095"><title>默认是StandardCharsets.UTF_8</title></topic><topic id="4auk1a1lifub7ckvg6le32to0e" modified-by="" timestamp="1512782941900"><title>可以自己指定字符编码方式</title><children><topics type="attached"><topic id="5591624lec4soau39iccc74rj6" modified-by="" timestamp="1512783030795"><title>Charset.forName(字符集名称)</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="1rfrgc1knrhsedg91etvafusda" modified-by="" timestamp="1512783038817"><title>....</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="7au9pr38hardj2mefv07lrh9ns" modified-by="" timestamp="1512784190308"><title>通道</title><children><topics type="attached"><topic id="6r76kkrvf23v9apcjvsc4mmotb" modified-by="" timestamp="1512784156099"><title>主要是四种类型</title><children><topics type="attached"><topic id="4norqkvvtcfl83j4bfd19e3u9i" modified-by="" timestamp="1512784173277"><title>和文件读取和存储相关的</title><children><topics type="attached"><topic id="2ml46r34jdkvjkihgkolljb6nm" modified-by="" timestamp="1512784173241"><title>FileChannel</title></topic></topics></children></topic><topic id="62s9v3miiipinvbrtv54qovooo" modified-by="" timestamp="1512784072356"><title>和TCP服务器端使用</title><children><topics type="attached"><topic id="6qecsrvqgd08e06nbnndqb4v07" modified-by="" timestamp="1512784078491"><title>ServerSocketChannel</title></topic></topics></children></topic><topic id="4rmru7lrhdn5a9379iqb7m18t1" modified-by="" timestamp="1512784089753"><title>和TCP的客户端使用</title><children><topics type="attached"><topic id="54phtbkedqelhhgbgv2o13qjct" modified-by="" timestamp="1512784100849"><title>SocketChannel</title></topic></topics></children></topic><topic id="2p021b169kjr3u20n7obp0d3sr" modified-by="" timestamp="1512784111181"><title>和UDP的两端使用</title><children><topics type="attached"><topic id="0bsepka666ms0ckj3p6kh7n424" modified-by="" timestamp="1512784117745"><title>DatagramChannel</title></topic></topics></children></topic></topics></children></topic><topic id="6ad5np11o3nucr2j5gt3m8k4hg" modified-by="" timestamp="1512784188159"><title>必须和缓冲区结合才能使用</title></topic><topic id="6d443bkch7eoer9i9cckv8u6ag" modified-by="" timestamp="1512784195658"><title>它的对象的创建</title><children><topics type="attached"><topic id="5vkhb4vmj83jv2hcd3gvmbhgqn" modified-by="" timestamp="1512784199447"><title>例如：</title><children><topics type="attached"><topic id="2vr7iuapq5qc90t5qgn8hdjtdh" modified-by="" timestamp="1512784212968"><title>FileChannel.open(xxx)</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="3olul3e6uhsgrgfbp4nc37jcdj" modified-by="" timestamp="1512784585962"><title>缓冲区</title><children><topics type="attached"><topic id="26gh1lca9i74f5culm2hsde172" modified-by="" timestamp="1512784272294"><title>主要是7大类型</title><children><topics type="attached"><topic id="1b66lbrljgjri7j9n8l7ukl17u" modified-by="" timestamp="1512784283789"><title>ByteBuffer</title><children><topics type="attached"><topic id="612bd20kn6kr5djlo4jkmjbelc" modified-by="" timestamp="1512784304017"><title>MappedByteBuffer</title></topic></topics></children></topic><topic id="2fe2937temb3db977tu5du9as4" modified-by="" timestamp="1512784250296"><title>ShortBuffer</title></topic><topic id="7ljfbm02jf2ou90tshjbinvlk3" modified-by="" timestamp="1512784254411"><title>IntBuffer</title></topic><topic id="6sdmhj1lapiantqqjo4spae4uu" modified-by="" timestamp="1512784257708"><title>LongBuffer</title></topic><topic id="77q0re8c39jubvk9udqk7lk3aa" modified-by="" timestamp="1512784261273"><title>FloatBuffer</title></topic><topic id="7vl0tiq6gko7057gmarqrf5j5e" modified-by="" timestamp="1512784267172"><title>DoubleBuffer</title></topic><topic id="1omm89q4goavcinm61covpirdh" modified-by="" timestamp="1512784271429"><title>CharBuffer</title></topic><topic id="1iu3n5daarq5hpm0phedbflf8q" modified-by="" timestamp="1512784280127"><title>除了boolean</title></topic></topics></children></topic><topic id="6g3h2csv014hvbrrk3p6q39on0" modified-by="" timestamp="1512784408931"><title>属性</title><children><topics type="attached"><topic id="4211j31ommq1k83ilfn43uhvon" modified-by="" timestamp="1512784326593"><title>（1）capacity：容量</title><children><topics type="attached"><topic id="4p1f72e890ec0sh3pbdkk0sd7l" modified-by="" timestamp="1512784335961"><title>总大小，一旦创建就固定</title></topic></topics></children></topic><topic id="0r1f3cj2lro8be3mq54vmogluo" modified-by="" timestamp="1512784346838"><title>（2）limit：限制</title><children><topics type="attached"><topic id="1i4ktvqe9q29t4oeujr8tmmama" modified-by="" timestamp="1512784367155"><title>可读或可写的最大索引的位置</title></topic></topics></children></topic><topic id="2kelso2plrl6c7o12r41q3da9u" modified-by="" timestamp="1512784385234"><title>（3）position：当前位置</title><children><topics type="attached"><topic id="53eqeo1ul8kcgdt6ngt4mvmsoq" modified-by="" timestamp="1512784391623"><title>当前正在读或写的位置</title></topic></topics></children></topic><topic id="4ll37c2p99009hinhfeki53eku" modified-by="" timestamp="1512784407394"><title>（4）mark：标记的位置</title></topic><topic id="6nb5mklbiqjl59fibfipollmle" modified-by="" timestamp="1512784438088"><title>0&lt;=mark&lt;=position&lt;=limit&lt;=capacity</title></topic></topics></children></topic><topic id="0vlo46icn16pj9b00mggm0atrf" modified-by="" timestamp="1512784554192"><title>方法</title><children><topics type="attached"><topic id="0hoiacjbtd45aco74jb7jigsnd" modified-by="" timestamp="1512784464101"><title>(1)put</title><children><topics type="attached"><topic id="5gk2o0su6gjbjnikrgemshj90a" modified-by="" timestamp="1512784460088"><title>往缓冲区写</title></topic><topic id="6jiiqk2vhfr0ik6d3m8171u4p3" modified-by="" timestamp="1512784481679"><title>或者调用通道.read(xx)</title><children><topics type="attached"><topic id="100l41i1bdemnehv2lj0jumkkv" modified-by="" timestamp="1512784487552"><title>也相当于往缓冲区写</title></topic></topics></children></topic></topics></children></topic><topic id="5f62ar2tmjd02o3ui2j259lbqq" modified-by="" timestamp="1512784505395"><title>（2）get</title><children><topics type="attached"><topic id="7d7la1at5a79q0ler1vasm7ch3" modified-by="" timestamp="1512784505022"><title>从缓冲区取</title></topic><topic id="62m78eqb29mhp24kpqm9j649ri" modified-by="" timestamp="1512784515649"><title>或者调用通道.write(xx)</title><children><topics type="attached"><topic id="7mmg14psbpnn20tf72ltijejtk" modified-by="" timestamp="1512784523876"><title>也相当于从缓冲区取数据</title></topic></topics></children></topic></topics></children></topic><topic id="6gpcdms1o3ei3g73j2iehmunno" modified-by="" timestamp="1512784542330"><title>（3）flip()</title><children><topics type="attached"><topic id="7vscqe5fj8ubdq96h171bec5sj" modified-by="" timestamp="1512784553931"><title>切换读写模式</title></topic></topics></children></topic><topic id="5urgqclghsv2jsiaq7tlqpcrk7" modified-by="" timestamp="1512784562384"><title>（4）clear（）</title><children><topics type="attached"><topic id="1itna0pcceuu283qg7e9lovrj0" modified-by="" timestamp="1512784570299"><title>重新使用缓冲区</title></topic></topics></children></topic></topics></children></topic><topic id="4pofqe9d6cnevtvl3s0iqp5cg7" modified-by="" timestamp="1512784671334"><title>示例</title><children><topics type="attached"><topic id="4600ihcrb4uudm34cq7np7ivg1" modified-by="" timestamp="1512784651564"><title>（1）读文件</title><notes><html><xhtml:p>	@Test</xhtml:p><xhtml:p>	public void test() throws IOException{</xhtml:p><xhtml:p>		Path path = Paths.get("1.txt");</xhtml:p><xhtml:p>		FileChannel fc = FileChannel.open(path, StandardOpenOption.READ);//打开通道</xhtml:p><xhtml:p>		ByteBuffer bb = ByteBuffer.allocate(1024);</xhtml:p><xhtml:p>		StringBuilder sb = new StringBuilder();</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		while(true){</xhtml:p><xhtml:p>			//把数据放到缓冲区</xhtml:p><xhtml:p>			int len = fc.read(bb);//把数据装到缓冲区    对于缓冲区来说是存储，相当于put</xhtml:p><xhtml:p>			if(len&lt;=0){</xhtml:p><xhtml:p>				break;</xhtml:p><xhtml:p>			}</xhtml:p><xhtml:p>			//切换</xhtml:p><xhtml:p>			bb.flip();</xhtml:p><xhtml:p>			</xhtml:p><xhtml:p>			//从缓冲区读取数据</xhtml:p><xhtml:p>			byte[] data = new byte[10];</xhtml:p><xhtml:p>			bb.get(data,0,bb.limit());</xhtml:p><xhtml:p>		//	System.out.println(new String(data,0,bb.limit()));</xhtml:p><xhtml:p>			sb.append(new String(data,0,bb.limit()));</xhtml:p><xhtml:p>			</xhtml:p><xhtml:p>			bb.clear();</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		System.out.println(sb);</xhtml:p><xhtml:p>	}</xhtml:p></html><plain>	@Test&#13;
	public void test() throws IOException{&#13;
		Path path = Paths.get("1.txt");&#13;
		FileChannel fc = FileChannel.open(path, StandardOpenOption.READ);//打开通道&#13;
		ByteBuffer bb = ByteBuffer.allocate(1024);&#13;
		StringBuilder sb = new StringBuilder();&#13;
		&#13;
		while(true){&#13;
			//把数据放到缓冲区&#13;
			int len = fc.read(bb);//把数据装到缓冲区    对于缓冲区来说是存储，相当于put&#13;
			if(len&lt;=0){&#13;
				break;&#13;
			}&#13;
			//切换&#13;
			bb.flip();&#13;
			&#13;
			//从缓冲区读取数据&#13;
			byte[] data = new byte[10];&#13;
			bb.get(data,0,bb.limit());&#13;
		//	System.out.println(new String(data,0,bb.limit()));&#13;
			sb.append(new String(data,0,bb.limit()));&#13;
			&#13;
			bb.clear();&#13;
		}&#13;
		&#13;
		System.out.println(sb);&#13;
	}</plain></notes></topic><topic id="31iridbuairsbcs5ktrj58cs9t" modified-by="" timestamp="1512784670660"><title>（2）复制文件</title><notes><html><xhtml:p>	@Test</xhtml:p><xhtml:p>	public void testCopy()throws Exception{</xhtml:p><xhtml:p>		long start = System.currentTimeMillis();</xhtml:p><xhtml:p>		FileChannel fc = FileChannel.open(Paths.get("software/ideaIU-Ultimate-2017.1.4.exe"), StandardOpenOption.READ);</xhtml:p><xhtml:p>		FileChannel to = FileChannel.open(Paths.get("2.exe"), StandardOpenOption.WRITE,StandardOpenOption.CREATE_NEW);</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		ByteBuffer bb = ByteBuffer.allocate(10);//定义缓冲区大小</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		while(fc.read(bb)!=-1){//读取数据到缓冲区，即往缓冲区写  相当于put</xhtml:p><xhtml:p>			bb.flip();//修改limit为position  然后position为0       没有这个，就从position开始读到limit,limit=capacity，position为写完的位置</xhtml:p><xhtml:p>			</xhtml:p><xhtml:p>			to.write(bb);</xhtml:p><xhtml:p>			</xhtml:p><xhtml:p>			bb.clear();//limit变成capicity  position=0   没有这个，那么就会重复写第一次读取的内容，一会文件大小就很大，爆了</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		fc.close();</xhtml:p><xhtml:p>		to.close();</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		long end = System.currentTimeMillis();</xhtml:p><xhtml:p>		System.out.println("ByteBuffer:"+ (end-start));</xhtml:p><xhtml:p>	}</xhtml:p></html><plain>	@Test&#13;
	public void testCopy()throws Exception{&#13;
		long start = System.currentTimeMillis();&#13;
		FileChannel fc = FileChannel.open(Paths.get("software/ideaIU-Ultimate-2017.1.4.exe"), StandardOpenOption.READ);&#13;
		FileChannel to = FileChannel.open(Paths.get("2.exe"), StandardOpenOption.WRITE,StandardOpenOption.CREATE_NEW);&#13;
		&#13;
		ByteBuffer bb = ByteBuffer.allocate(10);//定义缓冲区大小&#13;
		&#13;
		while(fc.read(bb)!=-1){//读取数据到缓冲区，即往缓冲区写  相当于put&#13;
			bb.flip();//修改limit为position  然后position为0       没有这个，就从position开始读到limit,limit=capacity，position为写完的位置&#13;
			&#13;
			to.write(bb);&#13;
			&#13;
			bb.clear();//limit变成capicity  position=0   没有这个，那么就会重复写第一次读取的内容，一会文件大小就很大，爆了&#13;
		}&#13;
		&#13;
		fc.close();&#13;
		to.close();&#13;
		&#13;
		long end = System.currentTimeMillis();&#13;
		System.out.println("ByteBuffer:"+ (end-start));&#13;
	}</plain></notes></topic><topic id="5ajdbilst8kto9894i9stur0m8" modified-by="" timestamp="1512784696117"><title>（3）物理映射复制文件（速度超快）</title><notes><html><xhtml:p>	@Test</xhtml:p><xhtml:p>	public void test2()throws Exception{</xhtml:p><xhtml:p>		long start = System.currentTimeMillis();</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		FileChannel from = FileChannel.open(Paths.get("software/ideaIU-Ultimate-2017.1.4.exe"), StandardOpenOption.READ);</xhtml:p><xhtml:p>		FileChannel to = FileChannel.open(Paths.get("3.exe"), StandardOpenOption.READ,StandardOpenOption.WRITE,StandardOpenOption.CREATE_NEW);//如果CREAD,如果文件已经存在不会报错，但是会从文件头开始写</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>		MappedByteBuffer fbb = from.map(MapMode.READ_ONLY, 0, from.size());</xhtml:p><xhtml:p>		MappedByteBuffer tbb = to.map(MapMode.READ_WRITE, 0, from.size());</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		tbb.put(fbb);</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		from.close();</xhtml:p><xhtml:p>		to.close();</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		long end = System.currentTimeMillis();</xhtml:p><xhtml:p>		System.out.println("ByteBuffer:"+ (end-start));</xhtml:p><xhtml:p>	}</xhtml:p></html><plain>	@Test&#13;
	public void test2()throws Exception{&#13;
		long start = System.currentTimeMillis();&#13;
		&#13;
		FileChannel from = FileChannel.open(Paths.get("software/ideaIU-Ultimate-2017.1.4.exe"), StandardOpenOption.READ);&#13;
		FileChannel to = FileChannel.open(Paths.get("3.exe"), StandardOpenOption.READ,StandardOpenOption.WRITE,StandardOpenOption.CREATE_NEW);//如果CREAD,如果文件已经存在不会报错，但是会从文件头开始写&#13;
	&#13;
		MappedByteBuffer fbb = from.map(MapMode.READ_ONLY, 0, from.size());&#13;
		MappedByteBuffer tbb = to.map(MapMode.READ_WRITE, 0, from.size());&#13;
		&#13;
		tbb.put(fbb);&#13;
		&#13;
		from.close();&#13;
		to.close();&#13;
		&#13;
		long end = System.currentTimeMillis();&#13;
		System.out.println("ByteBuffer:"+ (end-start));&#13;
	}</plain></notes></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics><topics type="detached"><topic id="3d0tk8imk524ni0aakh61rk7nn" modified-by="" timestamp="1512697581878"><title>length</title><position svg:x="983" svg:y="457"/><children><topics type="attached"><topic id="38nvcpr68nk5rkc2cnajh187ot" modified-by="" timestamp="1512697537662"><title>数组</title><children><topics type="attached"><topic id="2uiqhjfa5dk9npnqiem3tj87nm" modified-by="" timestamp="1512697547534"><title>数组的长度</title><children><topics type="attached"><topic id="79u00tbmj7ee9e10iu2f7i5iq3" modified-by="" timestamp="1512697561010"><title>int  len = arr.length;</title><children><topics type="attached"><topic id="2gei37cuphoc50nvcuk6qdhjsm" modified-by="" timestamp="1512697563286"><title>属性</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="34r2iak5cgfpkjmkak50rusjo0" modified-by="" timestamp="1512697571672"><title>字符串的长度</title><children><topics type="attached"><topic id="4dg9d31rt2tv5eb9rqj0uorr1n" modified-by="" timestamp="1512697580155"><title>int len = str.length();</title></topic></topics></children></topic><topic id="0v7p6ellgme79l6f5a2plhac3o" modified-by="" timestamp="1512697586417"><title>文件的长度</title><children><topics type="attached"><topic id="7ikmbca7oiergkushieb3h31l4" modified-by="" timestamp="1512697592648"><title>long len = file.length();</title></topic></topics></children></topic></topics></children></topic><topic id="44ipuv3jfqr9gort9k8i2ae7ns" modified-by="" timestamp="1512784028077"><title>org.apache工具包</title><position svg:x="-238" svg:y="906"/></topic></topics></children></topic><title>IO流</title></sheet><sheet id="7v051a451qiuj0e60timfm40r7" modified-by="" style-id="3482hp5csuf60d6r2su8h350er" theme="xminddefaultthemeid" timestamp="1513039034912"><topic id="0jh6ocu530vfag7v9k22itg740" modified-by="" structure-class="org.xmind.ui.logic.right" timestamp="1512957852242"><title>多线程</title><extensions><extension provider="org.xmind.ui.map.unbalanced"><content><right-number>-1</right-number></content></extension></extensions><children><topics type="attached"><topic id="1okhv2frtj48nhs8ijekrrm75q" modified-by="" timestamp="1512955578936"><title>概念</title><children><topics type="attached"><topic id="5svjjfbh9ff9djm8via0g7lfi5" modified-by="" timestamp="1512955584232"><title>程序</title><children><topics type="attached"><topic id="36crg0glo54cn0c5ofhnl2ukj9" modified-by="" timestamp="1512955630830"><title svg:width="500">为了完成某个任务或功能，选择某个编程语言而编写的一组代码指令的集合</title></topic></topics></children></topic><topic id="7q8udblrrvek36gem3gjko52jc" modified-by="" timestamp="1512955714723"><title>进程</title><children><topics type="attached"><topic id="33qebe12rgd3qje9qupo0fn5j4" modified-by="" timestamp="1512955768184"><title svg:width="500">程序的一次运行，是操作系统管理和调度的最小单位，每一个进程之间内存是相互独立的，如果进程之间要通信比较麻烦，可以通过文件，或网络通信方式等</title></topic></topics></children></topic><topic id="59qjikkeq268lp9q24haridn4u" modified-by="" timestamp="1512955772367"><title>线程</title><children><topics type="attached"><topic id="7442ufh5ebfhbvj2ccr718kui3" modified-by="" timestamp="1512955822823"><title svg:width="500">是进程中的其中一条执行路径，是CPU调度任务的最小单位</title><children><topics type="attached"><topic id="40fcbraruitd0sll9hs4fvfi9h" modified-by="" timestamp="1512955834503"><title>线程是共享同一个进程的内存</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="060rclpn1qprqe0si8evo4m1tk" modified-by="" timestamp="1512958805321"><title>如何开启主线程以外的线程</title><children><topics type="attached"><topic id="0tcf3ehm1s0tp68rmdn7uqu780" modified-by="" timestamp="1512955889831"><title>方式一：继承java.lang.Thread类</title><children><topics type="attached"><topic id="25qhnkej0c6keko9uo9lofdhlt" modified-by="" timestamp="1512955892648"><title>步骤</title><children><topics type="attached"><topic id="2te1tbffj3tbcbcblpp4a7fggh" modified-by="" timestamp="1512955894097"><title>①继承Thread类&#13;
②重写public void run(){}&#13;
	编写线程体，即该线程需要完成的任务代码&#13;
③创建线程对象&#13;
④启动线程：线程对象.start();</title></topic></topics></children></topic></topics></children></topic><topic id="63cfk8m8rk1vs30dl9vh6t5cic" modified-by="" timestamp="1512955910981"><title>方式二：实现java.lang.Runnable接口</title><children><topics type="attached"><topic id="5a6eud203tqa7un71ilq0acmb8" modified-by="" timestamp="1512955919995"><title>步骤</title><children><topics type="attached"><topic id="1onrjkr6qtorikgtcmc94dtbo3" modified-by="" timestamp="1512955921415"><title>①实现java.lang.Runnable接口&#13;
②实现public void run(){}&#13;
	编写线程体，即该线程需要完成的任务代码&#13;
③创建线程对象&#13;
④启动线程：借助Thread类的对象&#13;
		new Thread(自定义线程对象).start();</title></topic></topics></children></topic></topics></children></topic><topic id="7jv34hi0951po58jg02vr8fsd5" modified-by="" timestamp="1512955950989"><title>经典面试题</title><children><topics type="attached"><topic id="73u17ng0ge6mh3eb29dm0gnmva" modified-by="" timestamp="1512955955145"><title>两种方式的区别</title><children><topics type="attached"><topic id="2obqh6kj35h8j1kl5dqjjpn9dp" modified-by="" timestamp="1512955956721"><title svg:width="500">区别：&#13;
（1）继承Thread类会有单继承的限制&#13;
	实现Runnable接口不会有单继承的限制&#13;
（2）继承Thread类的方式，共享数据方面比较麻烦，使用static方式	&#13;
	实现Runnable接口，共享数据时，只需要共用同一个的Runnable接口的实现类的对象即可&#13;
（3）继承Thread类的方式，同步的锁的选择要么选择一个static对象作为锁，要么选择“类名.class即当前类Class对象”	&#13;
	实现Runnable接口，同步锁可以直接选择this对象</title></topic></topics></children></topic></topics></children></topic></topics></children><marker-refs><marker-ref marker-id="flag-red"/></marker-refs></topic><topic id="2sp58k5023n8hoqqja5801sld6" modified-by="" timestamp="1512958798644"><title>线程安全问题</title><children><topics type="attached"><topic id="13mvqtnf41a60ev42n7i34t6fv" modified-by="" timestamp="1512956017288"><title>前提条件</title><children><topics type="attached"><topic id="3d5a9csc1sftb7rtgakr1hhhmv" modified-by="" timestamp="1512956018795"><title>（1）有多个线程&#13;
（2）共享数据&#13;
（3）多条语句操作共享数据</title></topic></topics></children></topic><topic id="1f8olcjsb9qeo8lteo76628rg8" modified-by="" timestamp="1512956032721"><title>解决方法</title><children><topics type="attached"><topic id="3huo3m83culpogugah95msugt4" modified-by="" timestamp="1512957235914"><title>同步synchronized</title><children><topics type="attached"><topic id="55bjdboj5cofv44s37dhp98nrf" modified-by="" timestamp="1512956844519"><title>形式</title><children><topics type="attached"><topic id="1oiabjr573kmmddrl6701itcng" modified-by="" timestamp="1512956841016"><title>同步代码块</title><children><topics type="attached"><topic id="3o8k474l998gqq53442g45t0d9" modified-by="" timestamp="1512956842385"><title>synchronized(锁对象){&#13;
	同步代码，即需要加锁的代码&#13;
}</title></topic></topics></children></topic><topic id="57h5d425rdce9j2khsnas475hl" modified-by="" timestamp="1512956856775"><title>同步方法</title><children><topics type="attached"><topic id="32vgroct6ob167n79ujrjmbt74" modified-by="" timestamp="1512956858081"><title svg:width="500">synchronized [修饰符] 返回值类型 方法名(形参列表)抛出的异常列表</title></topic></topics></children></topic></topics></children></topic><topic id="6v8qdbsj5pu2msm39uqqig45g3" modified-by="" timestamp="1512957181411"><title>同步锁</title><children><topics type="attached"><topic id="5oebf0r2dctchd3mh2reqoqkaa" modified-by="" timestamp="1512957182730"><title svg:width="500">（1）任意类型的对象&#13;
（2）保证使用共享数据的多个线程，共用同一个锁对象</title></topic></topics></children></topic><topic id="1kr8lf55m9223eujfstuclheam" modified-by="" timestamp="1512957208502"><title>锁的范围</title><children><topics type="attached"><topic id="5gocr24c989dn4lk0rm2nu61od" modified-by="" timestamp="1512957213539"><title>同步代码块：范围&#13;
（1）不能太大：机会不均匀&#13;
（2）不能太小：安全问题没解决&#13;
（3）最好锁一次任务代码</title></topic></topics></children></topic><topic id="287e7nctt56dvjd41v8mnm62bh" modified-by="" timestamp="1512957235939"><title>同步方法的锁：</title><children><topics type="attached"><topic id="6k7a1ites6o5ej2o2d74i65lt6" modified-by="" timestamp="1512957235914"><title svg:width="500">静态方法的锁：当前类的Class对象，即当前类名.class&#13;
非静态方法的锁：当前对象，this</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children><marker-refs><marker-ref marker-id="flag-red"/></marker-refs></topic><topic id="39f27dqu35vpuaklrgmkrhajnf" modified-by="" timestamp="1512957442521"><title>线程通信</title><children><topics type="attached"><topic id="6gpcso1hbnqba1eqi14v07kgfd" modified-by="" timestamp="1512957265587"><title>问题：生产者消费者问题</title><children><topics type="attached"><topic id="1m6t9b5ab892tf67kpphb0sgl9" modified-by="" timestamp="1512957287114"><title>问题</title><children><topics type="attached"><topic id="5v2h2bvgke37jhgu0nhc11fv75" modified-by="" timestamp="1512957288944"><title>现象描述</title><children><topics type="attached"><topic id="535cdsmpggkl69vk8s3ha74cs6" modified-by="" timestamp="1512957356455"><title svg:width="500">有多个线程共享一个缓冲区（例如：数据仓库，文件等），有的线程往里放数据，有的线程往外取数据</title><children><topics type="attached"><topic id="59n60fjf29aak75c5r8st8kq6t" modified-by="" timestamp="1512957382482"><title>问题有两个</title><children><topics type="attached"><topic id="4t01h8o1unlicb92lj2acpei6n" modified-by="" timestamp="1512957397147"><title>问题：线程安全问题</title><children><topics type="attached"><topic id="5p4bhimgjd00pdn93838ucflsn" modified-by="" timestamp="1512957381489"><title>因为有共享数据</title></topic><topic id="7ute2oqsh8d3ldgibgos99gf8l" modified-by="" timestamp="1512957403125"><title>如何解决：同步</title></topic></topics></children></topic><topic id="71pgte2bsdmvkdvhgi0h63gmv0" modified-by="" timestamp="1512957406427"><title>问题：缓冲区大小有限的</title><children><topics type="attached"><topic id="2rtulrpvcdqai9ghas1tn3e75k" modified-by="" timestamp="1512957416912"><title>如何解决：线程通信</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="0ncn4p7i0hb5sb1b47qjhqkcl6" modified-by="" timestamp="1512957522587"><title>线程通信的方法</title><children><topics type="attached"><topic id="6gunik3hgcs3sj2rlbkfm79fvs" modified-by="" timestamp="1512957455146"><title>（1）wait()&#13;
（2）notify()和notifyAll()</title><children><topics type="attached"><topic id="3al13o3ti6ekd4k04jr7h9mrjd" modified-by="" timestamp="1512957463723"><title>在java.lang.Object</title><children><topics type="attached"><topic id="4ukl213hadbfp6g4c64hfdlrn5" modified-by="" timestamp="1512957498555"><title>为什么？</title><children><topics type="attached"><topic id="02f8v5cs7hc87856pad0qnpvuo" modified-by="" timestamp="1512957495815"><title svg:width="500">线程通信依赖于锁对象，即wait()和notify()是由锁对象调用</title></topic><topic id="0lthmtis10fj82h048f7epgie2" modified-by="" timestamp="1512957514996"><title svg:width="500">锁对象可能是任意类型的对象，那么这些方法只能在Object类中声明</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="54h3bgo4k64usnu1aj04eedapt" modified-by="" timestamp="1512957683060"><title>面试题：wait()和sleep()的异同？</title><children><topics type="attached"><topic id="3f279amhvu99vol7uu400o4p4p" modified-by="" timestamp="1512957579300"><title>同</title><children><topics type="attached"><topic id="0cm8p4fe7in3oal2ejpscehe1e" modified-by="" timestamp="1512957593188"><title svg:width="500">这两个方法都会导致当前线程从运行状态到阻塞状态</title></topic></topics></children></topic><topic id="0c3s6gu7fl4th6ft5h3bc8a2va" modified-by="" timestamp="1512957726228"><title>不同</title><children><topics type="attached"><topic id="2r0cq9ljpab69n1iq4a1ga4ke6" modified-by="" timestamp="1512957619608"><title>从阻塞回到就绪状态</title><children><topics type="attached"><topic id="7cbu41f6qt05gu0lrcg9h8rkpv" modified-by="" timestamp="1512957618839"><title>sleep()睡眠时间到了</title></topic><topic id="4lo7mb9m65u61c4gjqolfkij62" modified-by="" timestamp="1512957678200"><title>wait()也可以设置时间，但更多时候是通过notify()</title></topic></topics></children></topic><topic id="110bmmnqfdqhdpdi7e7gpvh73i" modified-by="" timestamp="1512957702449"><title>声明的类不同</title><children><topics type="attached"><topic id="5lsa7b6jejvp677vuvl5bffka7" modified-by="" timestamp="1512957722425"><title>wait是Object中，非静态方法</title></topic><topic id="2cqfvmcasu7n868cs6b8o56o5j" modified-by="" timestamp="1512957717593"><title>sleep是Thread类中，静态方法</title></topic></topics></children></topic><topic id="66ug9rsn9h56hqi0pmvddvl9tv" modified-by="" timestamp="1512957751477"><title>锁释放问题</title><children><topics type="attached"><topic id="5cils58au4i0iorbtp5nohjrjp" modified-by="" timestamp="1512957769349"><title>sleep：不会释放锁的</title><children><topics type="attached"><topic id="3c7251te8oh6f2pldvg1g06fob" modified-by="" timestamp="1512957780566"><title>例如：在卫生间睡着了，锁还在手上</title></topic></topics></children></topic><topic id="13419ugjq0cgr6e837brocmsj5" modified-by="" timestamp="1512957788717"><title>wait()：会释放锁的</title><children><topics type="attached"><topic id="7h5q1pmgb21e4bape6365ft14g" modified-by="" timestamp="1512957811761"><title svg:width="500">例如：抢到锁了，但是因为一些条件不满足，就释放锁，由其他线程执行</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="2avt0ni8eipc5uddirtp2drgus" modified-by="" timestamp="1512958688496"><title>java.lang.Thread</title><children><topics type="attached"><topic id="1heiojr27fkt2rqvv8afusc49d" modified-by="" timestamp="1512958676132"><title>方法</title><children><topics type="attached"><topic id="765qtdnnbs2uerb4p196pqrj5h" modified-by="" timestamp="1512958428412"><title>1、获取线程名称的方法</title><children><topics type="attached"><topic id="1jurfgjflaqca3k77soc8m9dbc" modified-by="" timestamp="1512958431577"><title>getName()</title></topic></topics></children></topic><topic id="5u4b0sjle5c516uq0uf5kmt9k0" modified-by="" timestamp="1512958443618"><title>2、获取当前线程对象</title><children><topics type="attached"><topic id="6p1vigauec109n1bpj8l01ulf3" modified-by="" timestamp="1512958457508"><title>Thread.currentThread()</title></topic></topics></children></topic><topic id="1bu3usr2qg2jc9dbtqgd27u4m1" modified-by="" timestamp="1512958479698"><title>3、线程休眠</title><children><topics type="attached"><topic id="4fp1g8r0p2gd2vkvc8fdu417ns" modified-by="" timestamp="1512958477919"><title>Thread.sleep(毫秒)</title></topic><topic id="2eh2i3e333hi6038nr9blaa4b8" modified-by="" timestamp="1512958484768"><title>Thread.sleep(毫秒，纳秒)</title></topic></topics></children></topic><topic id="1i6kq5st1ti3keflaggfbh819v" modified-by="" timestamp="1512958601854"><title>4、线程的优先级</title><children><topics type="attached"><topic id="14rc87m10luhhc820bni2m5a2p" modified-by="" timestamp="1512958522447"><title>getPriority()</title></topic><topic id="39oitt350noio61vi5dgmla94q" modified-by="" timestamp="1512958531853"><title>setPriority()</title><children><topics type="attached"><topic id="52knjnae1nkei6etn1s806n6lv" modified-by="" timestamp="1512958568811"><title>优先级的范围是1-10</title><children><topics type="attached"><topic id="748icc73lcjs8ie8k4omg9dpdb" modified-by="" timestamp="1512958568378"><title>MAX_PRIORITY:10</title></topic><topic id="18ttp8slua3gl9fclhub8ssher" modified-by="" timestamp="1512958565561"><title>MIN_PRIORITY:1</title></topic><topic id="75bvbcki7m9mu9kgh5v5o6a230" modified-by="" timestamp="1512958582837"><title>NORMAL_PRIORITY:5</title></topic></topics></children></topic></topics></children></topic><topic id="6jj2jca018d8ptsgft498hi4br" modified-by="" timestamp="1512958613311"><title>注意：业务逻辑不能依赖于优先级</title></topic></topics></children></topic><topic id="63uiu1brrgml5mdk47dja6aicd" modified-by="" timestamp="1512958622690"><title>5、加塞</title><children><topics type="attached"><topic id="5mtm4ebgo4ooglldu3ubmku0r1" modified-by="" timestamp="1512958630633"><title>join()</title><children><topics type="attached"><topic id="0bu53joa6c4llv84be0js7svcd" modified-by="" timestamp="1512958652538"><title svg:width="500">这句代码写在那个线程体中，哪个线程被加塞，被调用这个join()的线程加塞</title></topic></topics></children></topic></topics></children></topic><topic id="5u0se0pts56it3hl7j0hg3e0dq" modified-by="" timestamp="1512958674158"><title>6、run()：所有线程都要写</title></topic><topic id="65plbehinkgoveoair6had8cr4" modified-by="" timestamp="1512958682984"><title>7、start()：启动线程</title></topic></topics></children></topic><topic id="63cracnpsokr1ot3i5n1i7nceu" modified-by="" timestamp="1512958719208"><title>生命周期</title><children><topics type="attached"><topic id="56j865fo41h6cpn52p220h5jt4" modified-by="" timestamp="1512958731132"><title/><xhtml:img svg:height="189" svg:width="400" xhtml:src="xap:attachments/1ve8c3k91r26620auhutao4jkv.png"/></topic></topics></children></topic></topics></children></topic></topics></children></topic><title>多线程</title></sheet><sheet id="7068ei3mi62j73rqnq32qdi3sa" modified-by="" style-id="0kstj9p5njfq9famsfnsd1bk44" theme="xminddefaultthemeid" timestamp="1513125511380"><topic id="7ahcc0rkuhkv2avc0ktoru1mph" modified-by="" structure-class="org.xmind.ui.logic.right" timestamp="1513042406204"><title>反射机制</title><extensions><extension provider="org.xmind.ui.map.unbalanced"><content><right-number>-1</right-number></content></extension></extensions><children><topics type="attached"><topic id="75ap3focngkct538ucqm7flpn0" modified-by="" timestamp="1513039339241"><title>为什么要用反射？</title><children><topics type="attached"><topic id="4sdlu9vs868bknpakf5vpma8iv" modified-by="" timestamp="1513039405682"><title svg:width="500">因为Java是静态的强类型语言，在编译阶段就需要确定类型</title><children><topics type="attached"><topic id="2hhourjhfkc9fgknavinhevfsu" modified-by="" timestamp="1513039842426"><title>Java为了实现“动态性“特征，引入了反射机制</title><children><topics type="attached"><topic id="0j6j7m3ida2jhtaj867u2toir1" modified-by="" timestamp="1513039489365"><title svg:width="500">变量可以使用Object声明，然后在运行时确定某个对象的运行时类型</title></topic><topic id="299qhflgqs8p0h6jdsuso98t3u" modified-by="" timestamp="1513039526843"><title svg:width="500">或者在运行时动态的”注入“某个类型的对象，动态的创建某个类型的对象</title><children><topics type="attached"><topic id="0rqdo3o0n1b1ht9vq756ijc4lc" modified-by="" timestamp="1513039540571"><title svg:width="500">例如：用这个类型的Class对象，然后创建它的实例</title></topic></topics></children></topic><topic id="3ba2b56nru91htu1pgp3p2moo1" modified-by="" timestamp="1513039847191"><title>。。。。</title></topic></topics></children></topic></topics></children></topic><topic id="5kb0310eu1487vots4ffu5aici" modified-by="" timestamp="1513039373516"><title svg:width="500">例如：JS等是动态的弱类型的语言，在运行时确定变量的类型，根据赋的值确定变量的类型</title></topic></topics></children></topic><topic id="7c39fhkbkffiien8r2thkfvpci" modified-by="" timestamp="1513040148085"><title>反射的根源</title><children><topics type="attached"><topic id="0pap2qm32f8964e1k2a682ttk9" modified-by="" timestamp="1513039901216"><title>java.lang.Class</title><children><topics type="attached"><topic id="4fk691plab5a9mkj2i050fpjul" modified-by="" timestamp="1513039968687"><title svg:width="500">Class 类的实例表示正在运行的 Java 应用程序中的类和接口。枚举是一种类，注释是一种接口。每个数组属于被映射为 Class 对象的一个类，所有具有相同元素类型和维数的数组都共享该 Class 对象。基本的 Java 类型（boolean、byte、char、short、int、long、float 和 double）和关键字 void 也表示为 Class 对象。 </title><children><topics type="attached"><topic id="6u5rnpu2etvcna9pnc02bt805k" modified-by="" timestamp="1513040025766"><title>示例代码</title><children><topics type="attached"><topic id="14254lghnq3papk9dinbpbqrbc" modified-by="" timestamp="1513040027802"><title svg:width="500">	@Test&#13;
	public void test() {&#13;
		Class c1 = int.class;&#13;
		Class c2 = void.class;&#13;
		Class c3 = String.class;&#13;
		Class c4 = Comparable.class;&#13;
		Class c5 = ElementType.class;&#13;
		Class c6 = Override.class;&#13;
		Class c7 = int[].class;&#13;
		&#13;
		int[] arr1 = new int[5];&#13;
		int[] arr2 = new int[10];&#13;
		&#13;
		System.out.println(arr1.getClass() == arr2.getClass());&#13;
		System.out.println(int[].class == arr2.getClass());&#13;
		&#13;
		int[][] arr3 = new int[5][10];&#13;
		System.out.println(arr1.getClass());&#13;
		System.out.println(arr3.getClass());&#13;
	}</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="0tldv37hoijg0donmd5bm1v9lk" modified-by="" timestamp="1513040293963"><title>四种获取Class对象的方式</title><children><topics type="attached"><topic id="4nuo1ov94ss3skv10uf9253cn2" modified-by="" timestamp="1513040177875"><title>（1）如果类型已知：</title><children><topics type="attached"><topic id="6nv65q8432u5es9abs4ognurph" modified-by="" timestamp="1513040196830"><title>类型名.class</title></topic></topics></children></topic><topic id="06n9d2tnkrshi85uq6n53c3ijd" modified-by="" timestamp="1513040226757"><title>（2）如果对象存在</title><children><topics type="attached"><topic id="37hiqo54hj1auh31qv8g3mme9l" modified-by="" timestamp="1513040233118"><title>对象.getClass()</title></topic></topics></children></topic><topic id="5pqnq8hr0ojruk38rclntepd8v" modified-by="" timestamp="1513040276796"><title svg:width="500">（3）如果在编译阶段未知，但是运行阶段可以获取它的类型全名称</title><children><topics type="attached"><topic id="6vrfjvdhmsq7pn2l3qlvn9qf6o" modified-by="" timestamp="1513040289312"><title>Class.forName("类型全名称")</title></topic></topics></children></topic><topic id="4vevq5f7ctvbp66g57guboe6v4" modified-by="" timestamp="1513040297402"><title svg:width="500">（4）如果在编译阶段未知，但是运行阶段可以获取它的类型全名称</title><children><topics type="attached"><topic id="4b0cigc8le7925k8hlpqgr12v5" modified-by="" timestamp="1513040308123"><title>类加载对象.loadClass("类型全名称")</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="5brc2s5m70clnb00pqml2u3c7j" modified-by="" timestamp="1513069675422"><title>相关的API（了解）</title><children><topics type="attached"><topic id="0di5flmtn0mj5ds0ls36dfnu36" modified-by="" timestamp="1513040460333"><title>java.lang.Class</title><children><topics type="attached"><topic id="52vv6dvrc7avde7fsaig7uljvt" modified-by="" timestamp="1513041184557"><title>方法</title><children><topics type="attached"><topic id="2169d5qkg33q0203o35qe4gdqo" modified-by="" timestamp="1513040482014"><title>（1）获取类型名：</title><children><topics type="attached"><topic id="5pdl6a2a34m79mhmhs4feaar3q" modified-by="" timestamp="1513040485319"><title>getName()</title></topic></topics></children></topic><topic id="121ivu1m3jlf3db0926oajdg9q" modified-by="" timestamp="1513040506621"><title>（2）创建实例对象</title><children><topics type="attached"><topic id="7bvouss179i1l63lgdcu5rd7fa" modified-by="" timestamp="1513041455302"><title>newInstance()</title><children><topics type="attached"><topic id="7s8m5h7n3p3t0amnvdjbnjjfup" modified-by="" timestamp="1513040524158"><title>这个类型必须有无参构造</title></topic><topic id="2kinf7o45mfldjkli3agkoji88" modified-by="" timestamp="1513041467670"><title>Class对象.newInstance()</title></topic></topics></children></topic></topics></children><marker-refs><marker-ref marker-id="star-red"/></marker-refs></topic><topic id="4g5ffurh9v01io4k749flc8f55" modified-by="" timestamp="1513040542752"><title>（3）获取包的信息</title><children><topics type="attached"><topic id="0ak9sfsqpd0akedtoo7mil5m1s" modified-by="" timestamp="1513040553048"><title>getPackage()</title></topic></topics></children></topic><topic id="63mbgfujlp968fsb00t4ti7sgo" modified-by="" timestamp="1513041288435"><title>（4）获取父类</title><children><topics type="attached"><topic id="72ftq5u3026rqdjupnpsbmrpt4" modified-by="" timestamp="1513040624379"><title>Class  getSuperClass()</title><children><topics type="attached"><topic id="5gr5thgvemka3grho3la06vsfv" modified-by="" timestamp="1513040618901"><title>不带泛型</title></topic></topics></children></topic><topic id="2o4c38nler142k42lgevq84tde" modified-by="" timestamp="1513040646607"><title>Type  getGenericSuperClass()</title><children><topics type="attached"><topic id="5onsk80rnlftlaau6hgi4s99l9" modified-by="" timestamp="1513040651852"><title>可以带泛型</title></topic></topics></children></topic></topics></children><marker-refs><marker-ref marker-id="star-red"/></marker-refs></topic><topic id="5qehdlvnv0lfie39igff7lsjuk" modified-by="" timestamp="1513040737847"><title>（5）获取父接口</title><children><topics type="attached"><topic id="19hnlnaunk5erq4eat1723rq8s" modified-by="" timestamp="1513040841717"><title>Class[]  getInterfaces()</title><children><topics type="attached"><topic id="3m68lc01milt9uq520ceul9m92" modified-by="" timestamp="1513040693019"><title>不带泛型</title></topic></topics></children></topic><topic id="4ik1nlmmc2bbsu5gc62d820bk0" modified-by="" timestamp="1513040744642"><title>Type[]  getGenericInterfaces()</title><children><topics type="attached"><topic id="1bopig65rtrouo8ngko30p65m8" modified-by="" timestamp="1513040747358"><title>可以带泛型</title></topic></topics></children></topic></topics></children></topic><topic id="09hosl8h60j7ibr7tm2at8pku1" modified-by="" timestamp="1513040899929"><title>（6）获取该类型的属性</title><children><topics type="attached"><topic id="5rr96966idkdmqarrqlctkt83r" modified-by="" timestamp="1513040801873"><title>获取全部可访问的公共的属性</title><children><topics type="attached"><topic id="3i32d8m78ueebg7b5ldr7jdcqv" modified-by="" timestamp="1513040834117"><title>Field[]   getFields()</title></topic></topics></children></topic><topic id="1ch6i34r7apbj17i8fdg02dlqp" modified-by="" timestamp="1513040816178"><title>获取全部已声明的属性</title><children><topics type="attached"><topic id="0klvf9km2a2um8in1bg05kaccv" modified-by="" timestamp="1513040845389"><title>Field[]  getDeclaredFields()</title></topic></topics></children></topic><topic id="18f4hd6eghsq0dbl1enjbidjk2" modified-by="" timestamp="1513040860015"><title>获取某一个公共的属性</title><children><topics type="attached"><topic id="0s2pmjt07ggu2ajo4a3khn7j6r" modified-by="" timestamp="1513040890117"><title>Field  getField("属性名")</title></topic></topics></children></topic><topic id="3ti755a2doo2oreii1h7vp1ahs" modified-by="" timestamp="1513041295282"><title>获取某一个声明过的属性，可能是私有的等</title><children><topics type="attached"><topic id="114ldrmncqelidn8ssc1qhe17e" modified-by="" timestamp="1513040923105"><title>Field  getDeclaredField("属性名")</title></topic><topic id="77cc5pu3ad1lvjg0u6n7l00mca" modified-by="" timestamp="1513041154549"><title>通过属性名就可以唯一确定一个属性</title></topic></topics></children><marker-refs><marker-ref marker-id="flag-red"/></marker-refs></topic></topics></children></topic><topic id="1bcfn17456el95ecatn8a6994l" modified-by="" timestamp="1513040989200"><title>（7）获取该类的构造器</title><children><topics type="attached"><topic id="20nrbho351kgogdp77n403is5k" modified-by="" timestamp="1513040964494"><title>获取全部的公共的构造器</title></topic><topic id="6ks31gbmpo2d22hg9svghkdra3" modified-by="" timestamp="1513040977284"><title>获取全部已声明的构造器</title></topic><topic id="2o1iln24prr4v2b08qttb17ca8" modified-by="" timestamp="1513040988326"><title>获取某一个公共的构造器</title></topic><topic id="4qcpaburiumkooodav0kb4gnro" modified-by="" timestamp="1513041155417"><title>获取某一个已声明的构造器</title><children><topics type="attached"><topic id="4412kfjj6han6n9rf8e9cfjj08" modified-by="" timestamp="1513041055562"><title svg:width="500">Constructor  getDeclaredConstructor(形参列表的类型Class列表...  )</title></topic><topic id="1m8vc8399ucu83hns871c4e0hk" modified-by="" timestamp="1513041170131"><title>通过构造器的形参列表就可以唯一确定一个构造器</title></topic></topics></children></topic></topics></children></topic><topic id="52k52u66g9fkf802ucvnbkb38o" modified-by="" timestamp="1513041079038"><title>（8）获取该类的方法</title><children><topics type="attached"><topic id="333mkoqbqa0htcrkjc5isnjt6m" modified-by="" timestamp="1513041084102"><title>获取全部的公共的方法</title></topic><topic id="34vhkpdl1g268pkl1u0e07m0b7" modified-by="" timestamp="1513041087367"><title>获取全部已声明的方法</title></topic><topic id="0g7d8010fbhjo8a5pjl5pjbasg" modified-by="" timestamp="1513041090724"><title>获取某一个公共的方法</title></topic><topic id="4ud4mmhk98r8mltp5ejv3dnf7v" modified-by="" timestamp="1513041306457"><title>获取某一个已声明的方法</title><children><topics type="attached"><topic id="5ru183eb5e9suncljqoodsa59k" modified-by="" timestamp="1513041137099"><title svg:width="500">Method getDeclaredMethod("方法名", 形参列表的类型Class列表 ....)</title></topic><topic id="15hqqsipjq0t9g2d7kfbs0kin4" modified-by="" timestamp="1513041180484"><title svg:width="500">通过方法的名称+形参列表才能唯一确定一个方法</title></topic></topics></children><marker-refs><marker-ref marker-id="star-red"/></marker-refs></topic></topics></children></topic><topic id="5d9dtugk1kub0c1um2n751hgen" modified-by="" timestamp="1513041235049"><title>（9）获取类上的注解</title><children><topics type="attached"><topic id="530vnk70ggl6vktintj3poeh1l" modified-by="" timestamp="1513041226901"><title>获取所有的注解/注释</title><children><topics type="attached"><topic id="31grmbg4rs2nfms881n6o70573" modified-by="" timestamp="1513041233776"><title> Annotation[] getAnnotations() </title></topic></topics></children></topic><topic id="56spgfu8hvfv7554971m49sanp" modified-by="" timestamp="1513041309447"><title>获取指定的注解</title><children><topics type="attached"><topic id="5q74vpqassi446934ddn0r23ai" modified-by="" timestamp="1513041276776"><title svg:width="500">&lt;A extends Annotation&gt;  A   getAnnotation(Class&lt;A&gt; annotationClass) </title></topic></topics></children><marker-refs><marker-ref marker-id="star-red"/></marker-refs></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="190p8gf0l2622g3haf0551gfum" modified-by="" timestamp="1513040455894"><title>java.lang.reflect</title><children><topics type="attached"><topic id="13k4rippcvn7l8c46nnnl6ttd1" modified-by="" timestamp="1513041323066"><title>Package</title><children><topics type="attached"><topic id="5uu3ou8mh8d0cta9qeo4l7unue" modified-by="" timestamp="1513041330811"><title>获取包名</title><children><topics type="attached"><topic id="55155lbr6j2a28hombpdqg43re" modified-by="" timestamp="1513041336391"><title>getName()</title></topic></topics></children></topic></topics></children></topic><topic id="3hfivgo3vu0udh9m2uggs2tefk" modified-by="" timestamp="1513041349980"><title>Modifier</title><children><topics type="attached"><topic id="1nob34obshqsnl5j3vct30uola" modified-by="" timestamp="1513041362020"><title>Modifier.toString(mod)</title></topic></topics></children></topic><topic id="5u66ebm1uaq8b1amin055nue6h" modified-by="" timestamp="1513041370454"><title>Constructor</title><children><topics type="attached"><topic id="2thvt7paisu28m6tjrsp2aae5h" modified-by="" timestamp="1513041378725"><title>创建实例对象</title><children><topics type="attached"><topic id="3d7jp6fvleqop9hs17vmdg97kv" modified-by="" timestamp="1513041427654"><title>newInstance(Object ...)</title><children><topics type="attached"><topic id="108u1g9t6f0mde52ek7voejlsm" modified-by="" timestamp="1513041426614"><title svg:width="500">如果无参，那么就直接“构造器对象.newInstance()”</title></topic><topic id="5l8dvsfs7383eh6p7ki5supe2g" modified-by="" timestamp="1513041448578"><title svg:width="500">如果有参：构造器对象.newInstance(给构造器的实参列表)</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="0gtt4bjgqgosp7ad5gp860h68i" modified-by="" timestamp="1513041518349"><title>Field</title><children><topics type="attached"><topic id="4rl2lk5r2itjds55atq3qhspeq" modified-by="" timestamp="1513041508939"><title>（1）setAccessible(true)</title></topic><topic id="15amdst3jjs8252c793cn7bbh4" modified-by="" timestamp="1513041562629"><title>（2）Object  get(实例对象)</title><children><topics type="attached"><topic id="51iuu1mfmvc67tkrb43vfb9g39" modified-by="" timestamp="1513041561777"><title>Object  属性对象.get(实例对象)</title></topic><topic id="4jd74f24ihv8c848knb05pra2d" modified-by="" timestamp="1513041579713"><title>原来是：  实例对象.get属性名();</title></topic></topics></children></topic><topic id="6r54il63nn7vu5lrvqot98hunr" modified-by="" timestamp="1513041634748"><title>（3）set(实例对象， 属性的新值)</title><children><topics type="attached"><topic id="0ge3lcu9ae7cnfpvvkur3nrs7k" modified-by="" timestamp="1513041633679"><title>属性对象.set（实例对象，属性值）</title></topic><topic id="1m3enfh5o259mbbn5a0k8l9ejo" modified-by="" timestamp="1513041646995"><title>原来是：实例对象.set属性名（属性值）</title></topic></topics></children></topic></topics></children></topic><topic id="1c7b917e985mvaks5rs3ia17ul" modified-by="" timestamp="1513041699537"><title>Method</title><children><topics type="attached"><topic id="6v5127n9p7slquk85fdc4guubl" modified-by="" timestamp="1513041689906"><title>（1）setAccessible(true)</title><children><topics type="attached"><topic id="7q8nevv4bvjvd7rnmu895v9el3" modified-by="" timestamp="1513041698203"><title>如果方法不是public才需要</title></topic></topics></children></topic><topic id="1lf9imhqofoba45aik7end2msp" modified-by="" timestamp="1513041797797"><title svg:width="500">（2）Object invoke(实例对象, 传给被调用方法的实参列表)</title><children><topics type="attached"><topic id="3gij4vfcnh9lfcb96j1ubl2224" modified-by="" timestamp="1513041857208"><title svg:width="500">Object  returnValue = 方法对象.invoke(实例对象，实参列表...）</title><children><topics type="attached"><topic id="3hrpg8erbfp1f84lfga0qso31r" modified-by="" timestamp="1513041794376"><title svg:width="500">如果原来的方法对象是没有返回值，即是void，那么returnValue是null</title></topic></topics></children></topic><topic id="0b7m1lh08c6uhaggb5irrp0vdk" modified-by="" timestamp="1513041837919"><title>原来：</title><children><topics type="attached"><topic id="3slqfffgpd0gahvaqj5svd65ac" modified-by="" timestamp="1513041841743"><title>有返回值</title><children><topics type="attached"><topic id="01rlnv5finbhapqmt5704rtifq" modified-by="" timestamp="1513041843265"><title>变量 = 实例对象.方法名(实参列表)</title></topic></topics></children></topic><topic id="0npetnujpn5lfcpep2hp9itj2c" modified-by="" timestamp="1513041847205"><title>无返回值</title><children><topics type="attached"><topic id="4j7a4ss9npr5s5khrrhf9ui61i" modified-by="" timestamp="1513041850601"><title>实例对象.方法名(实参列表);</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="1hb6o3ir780qt52shr9pchgor2" modified-by="" timestamp="1513069682753"><title>示例代码</title><notes><html><xhtml:p>package com.atguigu.reflect;</xhtml:p><xhtml:p/><xhtml:p>import java.lang.reflect.Constructor;</xhtml:p><xhtml:p>import java.lang.reflect.Field;</xhtml:p><xhtml:p>import java.lang.reflect.Method;</xhtml:p><xhtml:p>import java.lang.reflect.Modifier;</xhtml:p><xhtml:p>import java.nio.charset.Charset;</xhtml:p><xhtml:p>import java.util.Arrays;</xhtml:p><xhtml:p/><xhtml:p>/*</xhtml:p><xhtml:p> * 有了Class对象后，都可以做什么事？你想干啥干啥</xhtml:p><xhtml:p> * </xhtml:p><xhtml:p> * 1、获取类的详细信息</xhtml:p><xhtml:p> * 2、创建实例对象</xhtml:p><xhtml:p> * 3、获取属性，设置属性</xhtml:p><xhtml:p> * 4、获取方法，设置方法</xhtml:p><xhtml:p> * ...</xhtml:p><xhtml:p> */</xhtml:p><xhtml:p>public class TestReflectAPI {</xhtml:p><xhtml:p/><xhtml:p>	public static void main(String[] args) throws Exception {</xhtml:p><xhtml:p>		Object obj = "hello";</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		Class clazz = obj.getClass();</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//1、获取类名</xhtml:p><xhtml:p>		System.out.println("类名：" + clazz.getName());</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//2、获取包信息</xhtml:p><xhtml:p>		/*</xhtml:p><xhtml:p>		 * 所有的包有共同点--&gt;Package</xhtml:p><xhtml:p>		 */</xhtml:p><xhtml:p>		Package pack = clazz.getPackage();</xhtml:p><xhtml:p>		System.out.println("包名：" + pack.getName());</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//3、获取类的修饰符</xhtml:p><xhtml:p>		int mod = clazz.getModifiers();</xhtml:p><xhtml:p>		//每一种修饰符，有一个常量表示</xhtml:p><xhtml:p>		//这个常量在Modifier类型声明</xhtml:p><xhtml:p>		System.out.println(Modifier.toString(mod));</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//4、父类</xhtml:p><xhtml:p>		Class superclass = clazz.getSuperclass();</xhtml:p><xhtml:p>		System.out.println("父类：" + superclass);</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//5、接口</xhtml:p><xhtml:p>		Class[] interfaces = clazz.getInterfaces();</xhtml:p><xhtml:p>		System.out.println("接口们：");</xhtml:p><xhtml:p>		for (Class class1 : interfaces) {</xhtml:p><xhtml:p>			System.out.println(class1);</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//6、属性：Field</xhtml:p><xhtml:p>		/*</xhtml:p><xhtml:p>		 * 属性共同点：  修饰符   数据类型   属性名      属性对应set值，get值的操作</xhtml:p><xhtml:p>		 * 任意类型的一个属性对应Field对象</xhtml:p><xhtml:p>		 * </xhtml:p><xhtml:p>		 * 一切皆对象</xhtml:p><xhtml:p>		 */</xhtml:p><xhtml:p>//		Field[] fields = clazz.getFields();//返回公共的属性</xhtml:p><xhtml:p>/*		Field[] fields = clazz.getDeclaredFields();</xhtml:p><xhtml:p>		System.out.println("属性们：");</xhtml:p><xhtml:p>		for (Field field : fields) {</xhtml:p><xhtml:p>			System.out.println("属性的类型："+field.getType());</xhtml:p><xhtml:p>			System.out.println("属性的名称："+field.getName());</xhtml:p><xhtml:p>			System.out.println("属性的所有信息："+field);</xhtml:p><xhtml:p>		}*/</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//单独获取某个属性对象，例如：获取value属性</xhtml:p><xhtml:p>		//假设从配置文件中知晓属性名是value</xhtml:p><xhtml:p>//		Field field = clazz.getField("value");//得到公共的</xhtml:p><xhtml:p>		Field field = clazz.getDeclaredField("value");//得到已声明的</xhtml:p><xhtml:p>		System.out.println(field);</xhtml:p><xhtml:p>		//设置属性值，获取属性值</xhtml:p><xhtml:p>		//先有对象，才能有属性值</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>//		获取"hello"对象的value属性值</xhtml:p><xhtml:p>		field.setAccessible(true);//设置可访问</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		Object object = field.get(obj);</xhtml:p><xhtml:p>		char[] v = (char[]) object;</xhtml:p><xhtml:p>		System.out.println(Arrays.toString(v));</xhtml:p><xhtml:p>		v[0] = 'w';</xhtml:p><xhtml:p>		v[1] = 'o';</xhtml:p><xhtml:p>		v[2] = 'r';</xhtml:p><xhtml:p>		v[3] = 'l';</xhtml:p><xhtml:p>		v[4] = 'd';</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//参数一：哪个对象的field属性，第二个参数：设置为xx新值</xhtml:p><xhtml:p>//		field.set("hello", "world");//因为是final</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		System.out.println(obj);</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//7、创建对象    创建Class对应的类型的对象</xhtml:p><xhtml:p>//		Object obj = clazz.newInstance();</xhtml:p><xhtml:p>//		System.out.println(obj);</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//8、构造器</xhtml:p><xhtml:p>//		clazz.getConstructors()//获取所有公共的构造器</xhtml:p><xhtml:p>//		clazz.getDeclaredConstructors();//获取所有该类拥有的构造器</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		/*</xhtml:p><xhtml:p>		 * 构造器的共同特点：修饰符   构造器名   形参列表      可以创建对象的操作</xhtml:p><xhtml:p>		 */</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		/*</xhtml:p><xhtml:p>		 * 构造器可以重载，构造器的名称都一样</xhtml:p><xhtml:p>		 * 如何在类中唯一确定一个构造器：靠形参列表（个数和类型）</xhtml:p><xhtml:p>		 */</xhtml:p><xhtml:p>//		 Constructor c = clazz.getDeclaredConstructor();//获取无参构造</xhtml:p><xhtml:p>//		 Object newInstance = c.newInstance();//用无参构造创建对象</xhtml:p><xhtml:p>//		 System.out.println("对象："+newInstance);</xhtml:p><xhtml:p>		 </xhtml:p><xhtml:p>		//public String(char value[])</xhtml:p><xhtml:p>		 Constructor c = clazz.getDeclaredConstructor(char[].class);//char[]数组类型</xhtml:p><xhtml:p>		 //用有参构造创建对象，需要实参列表</xhtml:p><xhtml:p>		 char[] params= {'c','h','a','i'};</xhtml:p><xhtml:p>		 Object newInstance = c.newInstance(params);</xhtml:p><xhtml:p>		System.out.println("对象："+newInstance);</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//9、方法</xhtml:p><xhtml:p>		/*</xhtml:p><xhtml:p>		 * 所有方法共同特点：</xhtml:p><xhtml:p>		 * 修饰符  返回值类型  方法名（形参列表）抛出的异常列表</xhtml:p><xhtml:p>		 * 方法可以被调用</xhtml:p><xhtml:p>		 */</xhtml:p><xhtml:p>//		clazz.getMethods()//获取所有公共的方法</xhtml:p><xhtml:p>//		clazz.getDeclaredMethods();//获取所有方法</xhtml:p><xhtml:p>		/*</xhtml:p><xhtml:p>		 * 方法可以重载，如何在一个类中，唯一确定方法：方法名+形参列表（个数和类型）</xhtml:p><xhtml:p>		 * </xhtml:p><xhtml:p>		 * toString()</xhtml:p><xhtml:p>		 */</xhtml:p><xhtml:p>		Method m = clazz.getDeclaredMethod("toString");//获取无参的方法</xhtml:p><xhtml:p>		System.out.println(m);</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//调用方法</xhtml:p><xhtml:p>		//参数一：那个实例对象调用m方法，参数二：传给m方法的实参列表</xhtml:p><xhtml:p>		Object returnValue = m.invoke(obj);</xhtml:p><xhtml:p>		System.out.println(returnValue);</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		// public byte[] getBytes(Charset charset) </xhtml:p><xhtml:p>		Method m2 = clazz.getDeclaredMethod("getBytes", Charset.class);</xhtml:p><xhtml:p>		Object returnValue2 = m2.invoke(obj, Charset.forName("GBK"));</xhtml:p><xhtml:p>		System.out.println(returnValue2);</xhtml:p><xhtml:p>		byte[] data = (byte[]) returnValue2;</xhtml:p><xhtml:p>		System.out.println(Arrays.toString(data));</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p/><xhtml:p>}</xhtml:p><xhtml:p/></html><plain>package com.atguigu.reflect;&#13;
&#13;
import java.lang.reflect.Constructor;&#13;
import java.lang.reflect.Field;&#13;
import java.lang.reflect.Method;&#13;
import java.lang.reflect.Modifier;&#13;
import java.nio.charset.Charset;&#13;
import java.util.Arrays;&#13;
&#13;
/*&#13;
 * 有了Class对象后，都可以做什么事？你想干啥干啥&#13;
 * &#13;
 * 1、获取类的详细信息&#13;
 * 2、创建实例对象&#13;
 * 3、获取属性，设置属性&#13;
 * 4、获取方法，设置方法&#13;
 * ...&#13;
 */&#13;
public class TestReflectAPI {&#13;
&#13;
	public static void main(String[] args) throws Exception {&#13;
		Object obj = "hello";&#13;
		&#13;
		Class clazz = obj.getClass();&#13;
		&#13;
		//1、获取类名&#13;
		System.out.println("类名：" + clazz.getName());&#13;
		&#13;
		//2、获取包信息&#13;
		/*&#13;
		 * 所有的包有共同点--&gt;Package&#13;
		 */&#13;
		Package pack = clazz.getPackage();&#13;
		System.out.println("包名：" + pack.getName());&#13;
		&#13;
		//3、获取类的修饰符&#13;
		int mod = clazz.getModifiers();&#13;
		//每一种修饰符，有一个常量表示&#13;
		//这个常量在Modifier类型声明&#13;
		System.out.println(Modifier.toString(mod));&#13;
		&#13;
		//4、父类&#13;
		Class superclass = clazz.getSuperclass();&#13;
		System.out.println("父类：" + superclass);&#13;
		&#13;
		//5、接口&#13;
		Class[] interfaces = clazz.getInterfaces();&#13;
		System.out.println("接口们：");&#13;
		for (Class class1 : interfaces) {&#13;
			System.out.println(class1);&#13;
		}&#13;
		&#13;
		//6、属性：Field&#13;
		/*&#13;
		 * 属性共同点：  修饰符   数据类型   属性名      属性对应set值，get值的操作&#13;
		 * 任意类型的一个属性对应Field对象&#13;
		 * &#13;
		 * 一切皆对象&#13;
		 */&#13;
//		Field[] fields = clazz.getFields();//返回公共的属性&#13;
/*		Field[] fields = clazz.getDeclaredFields();&#13;
		System.out.println("属性们：");&#13;
		for (Field field : fields) {&#13;
			System.out.println("属性的类型："+field.getType());&#13;
			System.out.println("属性的名称："+field.getName());&#13;
			System.out.println("属性的所有信息："+field);&#13;
		}*/&#13;
		&#13;
		//单独获取某个属性对象，例如：获取value属性&#13;
		//假设从配置文件中知晓属性名是value&#13;
//		Field field = clazz.getField("value");//得到公共的&#13;
		Field field = clazz.getDeclaredField("value");//得到已声明的&#13;
		System.out.println(field);&#13;
		//设置属性值，获取属性值&#13;
		//先有对象，才能有属性值&#13;
		&#13;
//		获取"hello"对象的value属性值&#13;
		field.setAccessible(true);//设置可访问&#13;
		&#13;
		Object object = field.get(obj);&#13;
		char[] v = (char[]) object;&#13;
		System.out.println(Arrays.toString(v));&#13;
		v[0] = 'w';&#13;
		v[1] = 'o';&#13;
		v[2] = 'r';&#13;
		v[3] = 'l';&#13;
		v[4] = 'd';&#13;
		&#13;
		//参数一：哪个对象的field属性，第二个参数：设置为xx新值&#13;
//		field.set("hello", "world");//因为是final&#13;
		&#13;
		System.out.println(obj);&#13;
		&#13;
		//7、创建对象    创建Class对应的类型的对象&#13;
//		Object obj = clazz.newInstance();&#13;
//		System.out.println(obj);&#13;
		&#13;
		//8、构造器&#13;
//		clazz.getConstructors()//获取所有公共的构造器&#13;
//		clazz.getDeclaredConstructors();//获取所有该类拥有的构造器&#13;
		&#13;
		/*&#13;
		 * 构造器的共同特点：修饰符   构造器名   形参列表      可以创建对象的操作&#13;
		 */&#13;
		&#13;
		/*&#13;
		 * 构造器可以重载，构造器的名称都一样&#13;
		 * 如何在类中唯一确定一个构造器：靠形参列表（个数和类型）&#13;
		 */&#13;
//		 Constructor c = clazz.getDeclaredConstructor();//获取无参构造&#13;
//		 Object newInstance = c.newInstance();//用无参构造创建对象&#13;
//		 System.out.println("对象："+newInstance);&#13;
		 &#13;
		//public String(char value[])&#13;
		 Constructor c = clazz.getDeclaredConstructor(char[].class);//char[]数组类型&#13;
		 //用有参构造创建对象，需要实参列表&#13;
		 char[] params= {'c','h','a','i'};&#13;
		 Object newInstance = c.newInstance(params);&#13;
		System.out.println("对象："+newInstance);&#13;
		&#13;
		&#13;
		//9、方法&#13;
		/*&#13;
		 * 所有方法共同特点：&#13;
		 * 修饰符  返回值类型  方法名（形参列表）抛出的异常列表&#13;
		 * 方法可以被调用&#13;
		 */&#13;
//		clazz.getMethods()//获取所有公共的方法&#13;
//		clazz.getDeclaredMethods();//获取所有方法&#13;
		/*&#13;
		 * 方法可以重载，如何在一个类中，唯一确定方法：方法名+形参列表（个数和类型）&#13;
		 * &#13;
		 * toString()&#13;
		 */&#13;
		Method m = clazz.getDeclaredMethod("toString");//获取无参的方法&#13;
		System.out.println(m);&#13;
		&#13;
		//调用方法&#13;
		//参数一：那个实例对象调用m方法，参数二：传给m方法的实参列表&#13;
		Object returnValue = m.invoke(obj);&#13;
		System.out.println(returnValue);&#13;
		&#13;
		// public byte[] getBytes(Charset charset) &#13;
		Method m2 = clazz.getDeclaredMethod("getBytes", Charset.class);&#13;
		Object returnValue2 = m2.invoke(obj, Charset.forName("GBK"));&#13;
		System.out.println(returnValue2);&#13;
		byte[] data = (byte[]) returnValue2;&#13;
		System.out.println(Arrays.toString(data));&#13;
	}&#13;
&#13;
}&#13;
</plain></notes></topic></topics></children></topic><topic id="6rshg0ehu82f2sj7o57tk0fpo6" modified-by="" timestamp="1513069540434"><title>如何获取类上的泛型</title><children><topics type="attached"><topic id="6sf3bd3dcud0us8gaan0quuvtl" modified-by="" timestamp="1513042200507"><title>步骤</title><children><topics type="attached"><topic id="49023vmkfpmsrepo95odouum69" modified-by="" timestamp="1513042087731"><title>（1）先得到类的Class对象</title></topic><topic id="6u6c4pha22d844aig330kj4jgp" modified-by="" timestamp="1513042126194"><title>（2）获取它的父类</title><children><topics type="attached"><topic id="0ok14a57d967jiaea7gpriekud" modified-by="" timestamp="1513042131541"><title>Type  getGenericSuperClass() 可以带泛型</title></topic></topics></children></topic><topic id="37pvjcd0bd6hbsrnspf64sdi45" modified-by="" timestamp="1513042174979"><title>（3）类型转换</title><children><topics type="attached"><topic id="0lda0ssukj2u6uv88b6u6uoke7" modified-by="" timestamp="1513042172410"><title>如果是父类是这样的类型    父类名&lt;泛型实参&gt;</title></topic><topic id="0p3bp0c6tk97p4unc45v768c5s" modified-by="" timestamp="1513042198444"><title svg:width="500">ParameterizedType  p = (ParameterizedType )type;</title></topic></topics></children></topic><topic id="1p1vr8ahteuflspnufslmvsgsk" modified-by="" timestamp="1513042208408"><title>（4）获取泛型实参</title><children><topics type="attached"><topic id="5dsl0ba1hjdh8pvq70th7isp8t" modified-by="" timestamp="1513042223738"><title>Type[] getActualTypeArguments()  </title></topic></topics></children></topic></topics></children></topic><topic id="02qe28775q6uvu8ubcfdc5osu5" modified-by="" timestamp="1513069597925"><title>示例代码</title><notes><html><xhtml:p>package com.atguigu.reflect;</xhtml:p><xhtml:p/><xhtml:p>import java.lang.reflect.ParameterizedType;</xhtml:p><xhtml:p>import java.lang.reflect.Type;</xhtml:p><xhtml:p>import java.util.Date;</xhtml:p><xhtml:p/><xhtml:p>public class TestGenericType {</xhtml:p><xhtml:p/><xhtml:p>	public static void main(String[] args) {</xhtml:p><xhtml:p>		GenericSub g = new GenericSub();</xhtml:p><xhtml:p>		System.out.println(g.getType1());</xhtml:p><xhtml:p>		System.out.println(g.getType2());</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		GenericSub2 g2 = new GenericSub2();</xhtml:p><xhtml:p>		System.out.println(g2.getType1());</xhtml:p><xhtml:p>		System.out.println(g2.getType2());</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p/><xhtml:p>}</xhtml:p><xhtml:p>//T叫做类型形参</xhtml:p><xhtml:p>abstract class GenericSuper&lt;T,U&gt;{</xhtml:p><xhtml:p>	private Class&lt;T&gt; type1;</xhtml:p><xhtml:p>	private Class&lt;U&gt; type2;</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>	public GenericSuper(){</xhtml:p><xhtml:p>		Class clazz = this.getClass();//this是当前对象，在构造器中，就是代表那个正在创建的对象</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//Type是包含Class等的所有类型</xhtml:p><xhtml:p>		Type gs = clazz.getGenericSuperclass();</xhtml:p><xhtml:p>		//GenericSuper&lt;String&gt;：参数化的类型</xhtml:p><xhtml:p>		ParameterizedType p  = (ParameterizedType) gs;</xhtml:p><xhtml:p>		//获取类型实参</xhtml:p><xhtml:p>		Type[] arr = p.getActualTypeArguments();</xhtml:p><xhtml:p>				</xhtml:p><xhtml:p>		type1 = (Class&lt;T&gt;) arr[0];</xhtml:p><xhtml:p>		type2 = (Class&lt;U&gt;) arr[1];</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p/><xhtml:p>	public Class&lt;T&gt; getType1() {</xhtml:p><xhtml:p>		return type1;</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>	public Class&lt;U&gt; getType2() {</xhtml:p><xhtml:p>		return type2;</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p/><xhtml:p>}</xhtml:p><xhtml:p>//String是类型实参</xhtml:p><xhtml:p>class GenericSub extends GenericSuper&lt;String,Integer&gt;{</xhtml:p><xhtml:p/><xhtml:p>}</xhtml:p><xhtml:p/><xhtml:p>class GenericSub2 extends GenericSuper&lt;Date,Double&gt;{</xhtml:p><xhtml:p/><xhtml:p>}</xhtml:p></html><plain>package com.atguigu.reflect;&#13;
&#13;
import java.lang.reflect.ParameterizedType;&#13;
import java.lang.reflect.Type;&#13;
import java.util.Date;&#13;
&#13;
public class TestGenericType {&#13;
&#13;
	public static void main(String[] args) {&#13;
		GenericSub g = new GenericSub();&#13;
		System.out.println(g.getType1());&#13;
		System.out.println(g.getType2());&#13;
		&#13;
		GenericSub2 g2 = new GenericSub2();&#13;
		System.out.println(g2.getType1());&#13;
		System.out.println(g2.getType2());&#13;
	}&#13;
&#13;
}&#13;
//T叫做类型形参&#13;
abstract class GenericSuper&lt;T,U&gt;{&#13;
	private Class&lt;T&gt; type1;&#13;
	private Class&lt;U&gt; type2;&#13;
	&#13;
	public GenericSuper(){&#13;
		Class clazz = this.getClass();//this是当前对象，在构造器中，就是代表那个正在创建的对象&#13;
		&#13;
		//Type是包含Class等的所有类型&#13;
		Type gs = clazz.getGenericSuperclass();&#13;
		//GenericSuper&lt;String&gt;：参数化的类型&#13;
		ParameterizedType p  = (ParameterizedType) gs;&#13;
		//获取类型实参&#13;
		Type[] arr = p.getActualTypeArguments();&#13;
				&#13;
		type1 = (Class&lt;T&gt;) arr[0];&#13;
		type2 = (Class&lt;U&gt;) arr[1];&#13;
	}&#13;
&#13;
	public Class&lt;T&gt; getType1() {&#13;
		return type1;&#13;
	}&#13;
	public Class&lt;U&gt; getType2() {&#13;
		return type2;&#13;
	}&#13;
&#13;
}&#13;
//String是类型实参&#13;
class GenericSub extends GenericSuper&lt;String,Integer&gt;{&#13;
&#13;
}&#13;
&#13;
class GenericSub2 extends GenericSuper&lt;Date,Double&gt;{&#13;
&#13;
}</plain></notes></topic><topic id="10ht6s28p2b3fk40bfqs5sst1d" modified-by="" timestamp="1513069565766"><title>核心代码</title><notes><html><xhtml:p>		Class clazz = GenericSub.class;</xhtml:p><xhtml:p>//		Class sup = clazz.getSuperclass();//得不到泛型的信息</xhtml:p><xhtml:p>//		System.out.println(sup);</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//Type是包含Class等的所有类型</xhtml:p><xhtml:p>		Type gs = clazz.getGenericSuperclass();</xhtml:p><xhtml:p>		//GenericSuper&lt;String&gt;：参数化的类型</xhtml:p><xhtml:p>		ParameterizedType p  = (ParameterizedType) gs;</xhtml:p><xhtml:p>		//获取类型实参</xhtml:p><xhtml:p>		Type[] arr = p.getActualTypeArguments();</xhtml:p><xhtml:p>		System.out.println(arr[0]);</xhtml:p><xhtml:p>		System.out.println(arr[1]);</xhtml:p></html><plain>		Class clazz = GenericSub.class;&#13;
//		Class sup = clazz.getSuperclass();//得不到泛型的信息&#13;
//		System.out.println(sup);&#13;
		&#13;
		//Type是包含Class等的所有类型&#13;
		Type gs = clazz.getGenericSuperclass();&#13;
		//GenericSuper&lt;String&gt;：参数化的类型&#13;
		ParameterizedType p  = (ParameterizedType) gs;&#13;
		//获取类型实参&#13;
		Type[] arr = p.getActualTypeArguments();&#13;
		System.out.println(arr[0]);&#13;
		System.out.println(arr[1]);</plain></notes></topic></topics></children></topic><topic id="217nb63lpmda0lkfha7fc4vnjs" modified-by="" timestamp="1513069510490"><title>获取注解</title><children><topics type="attached"><topic id="2g427s5a8mo4bmc1sfhd2mvtag" modified-by="" timestamp="1513069497014"><title>获取类上的注解</title><children><topics type="attached"><topic id="4nsksd5tbe4465r9t2l4lsffli" modified-by="" timestamp="1513042286670"><title>步骤</title><children><topics type="attached"><topic id="65pqiupmsuuk412fravjop3mfo" modified-by="" timestamp="1513042272296"><title>（1）先得到类的Class对象</title></topic><topic id="3gbufgc2h3lenu5ohn4f4has5s" modified-by="" timestamp="1513042282272"><title>（2）</title><children><topics type="attached"><topic id="04ud19gcgcvlkt478nuedi2cc5" modified-by="" timestamp="1513042301443"><title>获取指定的注解</title><children><topics type="attached"><topic id="1sf9543gkn3gpufsfvfu8covn0" modified-by="" timestamp="1513041276776"><title svg:width="500">&lt;A extends Annotation&gt;  A   getAnnotation(Class&lt;A&gt; annotationClass) </title></topic><topic id="3rs0f04mv8tlkohklfaqbcj61s" modified-by="" timestamp="1513042316638"><title>可以获取到的注解，必须声明周期是RUNTIME</title></topic></topics></children><marker-refs><marker-ref marker-id="star-red"/></marker-refs></topic></topics></children></topic><topic id="5j7rcghvgiac4rkei3lv8modh9" modified-by="" timestamp="1513042296298"><title>（3）获取注解的配置参数的值</title></topic></topics></children></topic><topic id="44rni979jppm1goe3u2amflcbu" modified-by="" timestamp="1513069507368"><title>示例代码</title><notes><html><xhtml:p>package com.atguigu.reflect;</xhtml:p><xhtml:p/><xhtml:p>import java.lang.annotation.Retention;</xhtml:p><xhtml:p>import java.lang.annotation.RetentionPolicy;</xhtml:p><xhtml:p/><xhtml:p>import org.junit.Test;</xhtml:p><xhtml:p/><xhtml:p>@MyAnnoation</xhtml:p><xhtml:p>public class TestAnnotatio {</xhtml:p><xhtml:p/><xhtml:p>	@MyAnnoation(value = "尚硅谷")</xhtml:p><xhtml:p>	private String info;</xhtml:p><xhtml:p/><xhtml:p>	//获取类上的注解信息</xhtml:p><xhtml:p>	@Test</xhtml:p><xhtml:p>	public void test() {</xhtml:p><xhtml:p>		// 1、先得到Class对象</xhtml:p><xhtml:p>		Class clazz = TestAnnotatio.class;</xhtml:p><xhtml:p/><xhtml:p>		// 2、获取类上的注解信息：得到MyAnnoation注解对象</xhtml:p><xhtml:p>		MyAnnoation m = (MyAnnoation) clazz.getAnnotation(MyAnnoation.class);</xhtml:p><xhtml:p/><xhtml:p>		// 3、得到注解的配置参数的值</xhtml:p><xhtml:p>		String value = m.value();</xhtml:p><xhtml:p>		System.out.println(value);</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p/><xhtml:p>@Retention(RetentionPolicy.RUNTIME) // 为了在反射阶段可以读取到该注解的信息，生命周期一定要在RUNTIME</xhtml:p><xhtml:p>@interface MyAnnoation {</xhtml:p><xhtml:p>	String value() default "atguigu";</xhtml:p><xhtml:p>}</xhtml:p></html><plain>package com.atguigu.reflect;&#13;
&#13;
import java.lang.annotation.Retention;&#13;
import java.lang.annotation.RetentionPolicy;&#13;
&#13;
import org.junit.Test;&#13;
&#13;
@MyAnnoation&#13;
public class TestAnnotatio {&#13;
&#13;
	@MyAnnoation(value = "尚硅谷")&#13;
	private String info;&#13;
&#13;
	//获取类上的注解信息&#13;
	@Test&#13;
	public void test() {&#13;
		// 1、先得到Class对象&#13;
		Class clazz = TestAnnotatio.class;&#13;
&#13;
		// 2、获取类上的注解信息：得到MyAnnoation注解对象&#13;
		MyAnnoation m = (MyAnnoation) clazz.getAnnotation(MyAnnoation.class);&#13;
&#13;
		// 3、得到注解的配置参数的值&#13;
		String value = m.value();&#13;
		System.out.println(value);&#13;
	}&#13;
}&#13;
&#13;
@Retention(RetentionPolicy.RUNTIME) // 为了在反射阶段可以读取到该注解的信息，生命周期一定要在RUNTIME&#13;
@interface MyAnnoation {&#13;
	String value() default "atguigu";&#13;
}</plain></notes></topic></topics></children></topic><topic id="32qit3u7bb5bmna6gq5b22kn81" modified-by="" timestamp="1513069510508"><title>获取属性上的注解</title><children><topics type="attached"><topic id="1h12v8d4e3t9sacforgonhqqn8" modified-by="" timestamp="1513042348838"><title>步骤</title><children><topics type="attached"><topic id="4oshv9n0k2kvdfoc6iskirastc" modified-by="" timestamp="1513042272296"><title>（1）先得到类的Class对象</title></topic><topic id="7kbejp1euuvasro4us46tak5d7" modified-by="" timestamp="1513042348820"><title>（2）获取属性对象</title></topic><topic id="6uvdh8oemq38i8rlerqfealrsf" modified-by="" timestamp="1513042353126"><title>（3）</title><children><topics type="attached"><topic id="6gfneim0utaa7nujlav0df7gbf" modified-by="" timestamp="1513042301443"><title>获取指定的注解</title><children><topics type="attached"><topic id="1evsdavjptq99db6k3t3ndlolh" modified-by="" timestamp="1513041276776"><title svg:width="500">&lt;A extends Annotation&gt;  A   getAnnotation(Class&lt;A&gt; annotationClass) </title></topic><topic id="4flpo5mhtdjrev0c5fofhvopbe" modified-by="" timestamp="1513042316638"><title>可以获取到的注解，必须声明周期是RUNTIME</title></topic></topics></children><marker-refs><marker-ref marker-id="star-red"/></marker-refs></topic></topics></children></topic><topic id="41ee7m48rk5tq5gb15ghptbnge" modified-by="" timestamp="1513042357060"><title>（4）获取注解的配置参数的值</title></topic></topics></children></topic><topic id="15e7enpk9ldpvisupk4vkokd3f" modified-by="" timestamp="1513069531410"><title>示例代码</title><notes><html><xhtml:p>package com.atguigu.reflect;</xhtml:p><xhtml:p/><xhtml:p>import java.lang.annotation.Retention;</xhtml:p><xhtml:p>import java.lang.annotation.RetentionPolicy;</xhtml:p><xhtml:p>import java.lang.reflect.Field;</xhtml:p><xhtml:p/><xhtml:p>import org.junit.Test;</xhtml:p><xhtml:p/><xhtml:p>public class TestAnnotatio {</xhtml:p><xhtml:p/><xhtml:p>	@MyAnnoation(value = "尚硅谷")</xhtml:p><xhtml:p>	private String info;</xhtml:p><xhtml:p/><xhtml:p>	//获取属性上的注解信息</xhtml:p><xhtml:p>	@Test</xhtml:p><xhtml:p>	public void test2() throws Exception {</xhtml:p><xhtml:p>		// 1、获取Class对象</xhtml:p><xhtml:p>		Class clazz = TestAnnotatio.class;</xhtml:p><xhtml:p/><xhtml:p>		// 2、先获取属性对象</xhtml:p><xhtml:p>		Field field = clazz.getDeclaredField("info");</xhtml:p><xhtml:p/><xhtml:p>		// 3、得到注解对象</xhtml:p><xhtml:p>		MyAnnoation m = (MyAnnoation) field.getAnnotation(MyAnnoation.class);</xhtml:p><xhtml:p/><xhtml:p>		// 4、得到属性值</xhtml:p><xhtml:p>		System.out.println(m.value());</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p/><xhtml:p>@Retention(RetentionPolicy.RUNTIME) // 为了在反射阶段可以读取到该注解的信息，生命周期一定要在RUNTIME</xhtml:p><xhtml:p>@interface MyAnnoation {</xhtml:p><xhtml:p>	String value() default "atguigu";</xhtml:p><xhtml:p>}</xhtml:p></html><plain>package com.atguigu.reflect;&#13;
&#13;
import java.lang.annotation.Retention;&#13;
import java.lang.annotation.RetentionPolicy;&#13;
import java.lang.reflect.Field;&#13;
&#13;
import org.junit.Test;&#13;
&#13;
public class TestAnnotatio {&#13;
&#13;
	@MyAnnoation(value = "尚硅谷")&#13;
	private String info;&#13;
&#13;
	//获取属性上的注解信息&#13;
	@Test&#13;
	public void test2() throws Exception {&#13;
		// 1、获取Class对象&#13;
		Class clazz = TestAnnotatio.class;&#13;
&#13;
		// 2、先获取属性对象&#13;
		Field field = clazz.getDeclaredField("info");&#13;
&#13;
		// 3、得到注解对象&#13;
		MyAnnoation m = (MyAnnoation) field.getAnnotation(MyAnnoation.class);&#13;
&#13;
		// 4、得到属性值&#13;
		System.out.println(m.value());&#13;
	}&#13;
}&#13;
&#13;
@Retention(RetentionPolicy.RUNTIME) // 为了在反射阶段可以读取到该注解的信息，生命周期一定要在RUNTIME&#13;
@interface MyAnnoation {&#13;
	String value() default "atguigu";&#13;
}</plain></notes></topic></topics></children></topic></topics></children></topic><topic id="6d1v0i6j0rrv1tcpd9r9tniab7" modified-by="" timestamp="1513042864009"><title>类加载器</title><children><topics type="attached"><topic id="56lhe11cjgq7e43ntabmqeop0r" modified-by="" timestamp="1513042430247"><title>类加载的过程（了解）</title><children><topics type="attached"><topic id="14hr2h7sng1u7ajgegebc7tqge" modified-by="" timestamp="1513042900434"><title>双亲委托模式/机制</title><children><topics type="attached"><topic id="1mtnhimg84utv8qio965mmdel5" modified-by="" timestamp="1513042589433"><title svg:width="500">某个类加载器接到加载任务，先把加载任务交给“父”加载器，层层往上，一直到引导类加载器，如果“父”加载器可以加载，那么就由“父”加载器加载，如果不可以，传回它的“子”加载器，“子”加载器尝试加载，如果可以，那么就加载，如果不可以，再往回传，一到回到最初接到任务的那个加载器，如果它可以，也正常加载，如果它也不能加载，报异常：ClassNotFoundException</title></topic><topic id="5gftpotl2nkpr26020q1husio1" modified-by="" timestamp="1513042906951"><title>作用：安全</title></topic></topics></children></topic></topics></children></topic><topic id="7fuo8rdpmaq5ffmcr1t8p2vpug" modified-by="" timestamp="1513042831926"><title>类加载器的体系结构</title><children><topics type="attached"><topic id="39ohr52kk1fgv12fs2qp88t6e1" modified-by="" timestamp="1513042669427"><title>1、引导类加载器BootStrap</title><children><topics type="attached"><topic id="75dgv40ssho13c05n8837sa06t" modified-by="" timestamp="1513042640034"><title>非Java语言实现的</title><children><topics type="attached"><topic id="1niov8aif59s2t6qs3ih5km898" modified-by="" timestamp="1513042650167"><title>获取不到它的对象，只能得到null</title></topic></topics></children></topic><topic id="304ukjle2ehb52v8rv6fjaamjj" modified-by="" timestamp="1513042664085"><title>加载核心类库rt.jar</title></topic><topic id="3s05ip980oi64lp4qvha0bf63t" modified-by="" timestamp="1513042711505"><title>加载sun.boot.class.path路径下的内容</title></topic></topics></children></topic><topic id="6usavbeaglr8rk85natkiubcql" modified-by="" timestamp="1513042776598"><title>2、扩展类加载器ExtClassLoader</title><children><topics type="attached"><topic id="3pr2h7gpdtmgt3ist79f3t5hj0" modified-by="" timestamp="1513042766336"><title>加载jre/ext目录</title></topic><topic id="41s6o3841m956jpp9sg4macts5" modified-by="" timestamp="1513042780704"><title>java.ext.dirs路径下的内容</title></topic></topics></children></topic><topic id="2hl62m9eadob4nng83q0kgb7h9" modified-by="" timestamp="1513042812797"><title svg:width="500">3、应用程序类加载器，系统类加载器AppClassLoader</title><children><topics type="attached"><topic id="4ffet2q1m8q08hm0gejg8473k0" modified-by="" timestamp="1513042807067"><title>加载用户自定义的类型</title></topic><topic id="4dqqms4kkaosr3ged2o1j73pav" modified-by="" timestamp="1513042826938"><title>加载src目录下的内容（bin）</title></topic></topics></children></topic><topic id="7i7tcd4urtek6iic2lpjckeed6" modified-by="" timestamp="1513042853434"><title>4、自定义类加载器</title></topic></topics></children></topic><topic id="5okg9b0cub4v970q3jks23r14c" modified-by="" timestamp="1513042877867"><title>类加载的作用</title><children><topics type="attached"><topic id="24f4v8m39j94bogpap8nncd0b5" modified-by="" timestamp="1513042877287"><title>（1）加载类</title></topic><topic id="4k8uv9phau2bkk0jgii40k456m" modified-by="" timestamp="1513069629725"><title>（2）加载资源文件</title><notes><html><xhtml:p>	@Test</xhtml:p><xhtml:p>	public void test8()throws Exception{</xhtml:p><xhtml:p>		Properties pro = new Properties();</xhtml:p><xhtml:p>		//JavaSE和Web项目</xhtml:p><xhtml:p>		//在web项目中，因为项目部署到tomcat中运行，又因为tomcat用自己的类加载器的</xhtml:p><xhtml:p>		//把配置文件放在了src中，最终代码在WEB-INFO的classes目录</xhtml:p><xhtml:p>		//可以用类加载器加载这个配置文件，但是不是系统类加载器</xhtml:p><xhtml:p>		//this.getClass().getClassLoader()目的是得到tomcat的自定义类加载器对象</xhtml:p><xhtml:p>		pro.load(this.getClass().getClassLoader().getResourceAsStream("3.properties"));</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>		System.out.println(pro.getProperty("user3"));</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>	@Test</xhtml:p><xhtml:p>	public void test7()throws Exception{</xhtml:p><xhtml:p>		Properties pro = new Properties();</xhtml:p><xhtml:p>		//JavaSE和Web都可以</xhtml:p><xhtml:p>		//把配置文件放在了项目根目录下，在src外面</xhtml:p><xhtml:p>		//不可以用类加载器加载这个配置文件</xhtml:p><xhtml:p>		//可以使用FileInputStream获取</xhtml:p><xhtml:p>		pro.load(new FileInputStream("2.properties"));</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>		System.out.println(pro.getProperty("user2"));</xhtml:p><xhtml:p>	}</xhtml:p></html><plain>	@Test&#13;
	public void test8()throws Exception{&#13;
		Properties pro = new Properties();&#13;
		//JavaSE和Web项目&#13;
		//在web项目中，因为项目部署到tomcat中运行，又因为tomcat用自己的类加载器的&#13;
		//把配置文件放在了src中，最终代码在WEB-INFO的classes目录&#13;
		//可以用类加载器加载这个配置文件，但是不是系统类加载器&#13;
		//this.getClass().getClassLoader()目的是得到tomcat的自定义类加载器对象&#13;
		pro.load(this.getClass().getClassLoader().getResourceAsStream("3.properties"));&#13;
	&#13;
		System.out.println(pro.getProperty("user3"));&#13;
	}&#13;
	&#13;
	@Test&#13;
	public void test7()throws Exception{&#13;
		Properties pro = new Properties();&#13;
		//JavaSE和Web都可以&#13;
		//把配置文件放在了项目根目录下，在src外面&#13;
		//不可以用类加载器加载这个配置文件&#13;
		//可以使用FileInputStream获取&#13;
		pro.load(new FileInputStream("2.properties"));&#13;
	&#13;
		System.out.println(pro.getProperty("user2"));&#13;
	}</plain></notes></topic></topics></children></topic></topics></children></topic></topics></children></topic><title>反射</title></sheet><sheet id="0ueglmqr6dn1n0tviquelns49n" modified-by="" style-id="21qrlcven7bqj5m8c9moe6ceo2" theme="xminddefaultthemeid" timestamp="1513156953233"><topic id="1c010d86hfph99amsfrkeiqd7h" modified-by="" structure-class="org.xmind.ui.logic.right" timestamp="1513126675220"><title>网络编程</title><extensions><extension provider="org.xmind.ui.map.unbalanced"><content><right-number>-1</right-number></content></extension></extensions><children><topics type="attached"><topic id="6nf4tgasm02epefq4vujhl8vk4" modified-by="" timestamp="1513126663978"><title>网络编程的三个要素</title><children><topics type="attached"><topic id="1697o2nsp2npr35t6c6m7dv8ad" modified-by="" timestamp="1513125833728"><title>1、IP地址或主机名</title><children><topics type="attached"><topic id="7171sv2jglc3u3sqqbu5gg68r2" modified-by="" timestamp="1513125773630"><title>InetAddress</title></topic><topic id="2mb2re9od0adbeibgp30rfsa9i" modified-by="" timestamp="1513125798673"><title>String：192.168.24.71</title><children><topics type="attached"><topic id="49238c2c55nodveo9gho55bacm" modified-by="" timestamp="1513125816264"><title>每一个整数是1~255</title></topic></topics></children></topic><topic id="1legip3lk7o2l2ku38s03j22ed" modified-by="" timestamp="1513125854325"><title>域名：www.baidu.com</title><children><topics type="attached"><topic id="0i0mqf6b2uh710kmi2p4e5tnqi" modified-by="" timestamp="1513125869082"><title>通过域名解析器，找对对应的ip地址</title></topic></topics></children></topic></topics></children></topic><topic id="1a8puhf1t0lgq228pv6jdc7t80" modified-by="" timestamp="1513125882881"><title>2、端口号</title><children><topics type="attached"><topic id="3qvmgnm8l0ii7iq081qrnemvik" modified-by="" timestamp="1513125881945"><title>0~65535</title></topic><topic id="2g23os4klkbe6bg57puo8mkb37" modified-by="" timestamp="1513126043763"><title>建议不要使用</title><children><topics type="attached"><topic id="0tof13ikl9jg72aikvs9p37ned" modified-by="" timestamp="1513125902046"><title>0~1023</title><children><topics type="attached"><topic id="3roq2n0idg8b74d3glnkc7rmva" modified-by="" timestamp="1513125913026"><title>用于基础服务</title></topic></topics></children></topic><topic id="5mu3qobh1cofuogejjgc5ho470" modified-by="" timestamp="1513125932211"><title>tomcat/jboss</title><children><topics type="attached"><topic id="5fnp7c7ijdjeqnpmg4ne9jcjg6" modified-by="" timestamp="1513125934598"><title>8080</title></topic></topics></children></topic><topic id="03fuldobb4p3d96hc41mil834h" modified-by="" timestamp="1513125939222"><title>mysql</title><children><topics type="attached"><topic id="3dhe3as8naq8tii48i0id87eeq" modified-by="" timestamp="1513125942402"><title>3306</title></topic></topics></children></topic><topic id="386g3js53gk0jc97m5esh8356t" modified-by="" timestamp="1513125946718"><title>oracle</title><children><topics type="attached"><topic id="0o8ceatd12s45poihpi1ri3ln0" modified-by="" timestamp="1513125949609"><title>1521</title></topic></topics></children></topic><topic id="3a6l8m4l6uu485svmc1bam8nrh" modified-by="" timestamp="1513125981336"><title>sql server</title><children><topics type="attached"><topic id="3pj0haetc3j5ripb5dq0kf0bgr" modified-by="" timestamp="1513125983795"><title>1433</title></topic></topics></children></topic><topic id="1j4li937k0docugtaqk83trq5s" modified-by="" timestamp="1513126001525"><title>浏览器：http</title><children><topics type="attached"><topic id="1sgfcu0rl55a2b5134cngh9tt3" modified-by="" timestamp="1513126003480"><title>80</title></topic></topics></children></topic><topic id="0iqrejft4i025atl1do5qqmtq5" modified-by="" timestamp="1513126046400"><title>....</title></topic></topics></children></topic></topics></children></topic><topic id="0basbhi32vaeavltr31hmq8hq6" modified-by="" timestamp="1513126296543"><title>3、网络协议</title><children><topics type="attached"><topic id="3hf0afifitcvj0ku9nh63up4bh" modified-by="" timestamp="1513126145147"><title>OSI理想参考模型</title><children><topics type="attached"><topic id="0b6fvop58pme09dg3f58qssdl8" modified-by="" timestamp="1513126157396"><title/><xhtml:img svg:height="270" svg:width="400" xhtml:src="xap:attachments/7roa36aup22ncer11a4cu3fmof.png"/></topic></topics></children></topic><topic id="7oh7fkcbpi0p93u76aif8108ij" modified-by="" timestamp="1513126074331"><title>TCP/IP的四层实现模式</title></topic><topic id="341i1qrekhlearksecpmtpqmji" modified-by="" timestamp="1513126175639"><title>传输层</title><children><topics type="attached"><topic id="6mkdvvrln5036l14kgcj8mpku1" modified-by="" timestamp="1513126182566"><title>TCP</title><children><topics type="attached"><topic id="37s193d5123nkc7dv0gseitd8a" modified-by="" timestamp="1513126255206"><title svg:width="500">面向连接的，可靠的，适用于大数据传输，速率相对低，在传输之前会先“三次握手”，在断开之前会“四次挥手”</title></topic></topics></children></topic><topic id="5nsj71o1m4t5lm3nil98d2ti94" modified-by="" timestamp="1513126257015"><title>UDP</title><children><topics type="attached"><topic id="55jf1s0pq4ei87c04g4g4n9636" modified-by="" timestamp="1513126290273"><title svg:width="500">非面向连接的，不可靠的，适用于数据比较小的，&lt;=64kb，相对速率高</title></topic></topics></children></topic></topics></children></topic><topic id="1g7p8gbnipuqsuc31vsagg12fs" modified-by="" timestamp="1513126337306"><title>应用层</title><children><topics type="attached"><topic id="5h313qpnmqngv6ptmtptpognpg" modified-by="" timestamp="1513126313223"><title>http/https</title></topic><topic id="6okgv94bnev9nhk4mu2p7hqij4" modified-by="" timestamp="1513126327807"><title>ftp</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="0r60u8fdag6oj17f3a9ja15kf6" modified-by="" timestamp="1513127349905"><title>网络编程的API</title><children><topics type="attached"><topic id="2lt26rs3ujlanpaehn3iruvjcv" modified-by="" timestamp="1513126436711"><title>Socket</title><children><topics type="attached"><topic id="7s1g58c47o5eiujkb3uifnm0gs" modified-by="" timestamp="1513126435615"><title>套接字</title><children><topics type="attached"><topic id="5ck80pu7a8j6e1ftemj35ifo98" modified-by="" timestamp="1513126427049"><title>表示通信的两个端点，两边各一个</title></topic></topics></children></topic><topic id="0enbou8bpr1ee855qopi7l82mc" modified-by="" timestamp="1513126463356"><title>分类</title><children><topics type="attached"><topic id="3ufbobl8go02o2jshlo93mfskr" modified-by="" timestamp="1513126448255"><title>流套接字</title><children><topics type="attached"><topic id="7em86tej40qq7ijm85ui4snvjm" modified-by="" timestamp="1513126460510"><title>用于TCP的通信</title><children><topics type="attached"><topic id="092monpkfg7rf8cp8u7qcl7leg" modified-by="" timestamp="1513126488875"><title>ServerSocket</title><children><topics type="attached"><topic id="4qfrv3kdmv1qq2ltokmsgqon69" modified-by="" timestamp="1513126507749"><title>转门用于服务器用来监听和接收客户端的连接</title></topic></topics></children></topic><topic id="1funle3cpjek3ipktdmggtf8rd" modified-by="" timestamp="1513126509044"><title>Socket</title><children><topics type="attached"><topic id="7p6spgtj1v740ldohgrcie5kbr" modified-by="" timestamp="1513126521304"><title>用于服务器和客户端的通信</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="7m1c7g98k1lade2krdlupkn7mn" modified-by="" timestamp="1513126471210"><title>数据报套接字</title><children><topics type="attached"><topic id="2hkq5911m8f2p84a0en07cppaf" modified-by="" timestamp="1513126477642"><title>用于UDP的通信</title><children><topics type="attached"><topic id="08r4gv9jke26tajqbtqgcnbtgu" modified-by="" timestamp="1513126527397"><title>DatagramSocket</title><children><topics type="attached"><topic id="6fsn7f9r4sj3cge4dojqa5qqcp" modified-by="" timestamp="1513126535914"><title>用于UDP的两端的通信</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="1k3dsspeq9bvll3p2aoq7km3pa" modified-by="" timestamp="1513156923512"><title>TCP编程步骤</title><children><topics type="attached"><topic id="03k36sg77c3q549idklke15m8n" modified-by="" timestamp="1513126939219"><title>服务器</title><children><topics type="attached"><topic id="31qg71ci2f8fahf8eiht0au6iu" modified-by="" timestamp="1513126710409"><title>1、先创建ServerSocket</title><children><topics type="attached"><topic id="63916l72ttmo8k15v3hrglahb1" modified-by="" timestamp="1513126760223"><title svg:width="500">ServerSocket server = new ServerSocket(端口号);</title><children><topics type="attached"><topic id="6161m9kdjos9omgltgpd7teg5a" modified-by="" timestamp="1513126789492"><title svg:width="500">指定端口号进行监听，客户端通过这个端口号与它进行连接和通信</title></topic></topics></children></topic></topics></children></topic><topic id="7o05onj69h59kn3n1rj3tfsht5" modified-by="" timestamp="1513126808694"><title>2、接收客户端的连接</title><children><topics type="attached"><topic id="6vv455tfhfp5q9utii7b66mfmq" modified-by="" timestamp="1513126835008"><title>Socket socket = server.accept();</title><children><topics type="attached"><topic id="763jlk3fi6mjslfm8o16f899th" modified-by="" timestamp="1513126834085"><title>每一个客户端就要有自己的一个Socket</title></topic><topic id="6rgdt5kk54u3n2jganufmrvcot" modified-by="" timestamp="1513126873847"><title svg:width="500">如果希望不同的客户端通信“同时”进行，需要每一个socket用一个线程进行维护</title></topic></topics></children></topic></topics></children></topic><topic id="4gjfej78i0acm0utmds76j5bm0" modified-by="" timestamp="1513126906948"><title>3、通过socket进行收或发消息</title><children><topics type="attached"><topic id="5r7bstoqo8gqgfdbcufkepmfp0" modified-by="" timestamp="1513126893403"><title>收消息</title><children><topics type="attached"><topic id="0sm8c7cg8kdlcnt4skhjtlh6uq" modified-by="" timestamp="1513126956977"><title>InputStream is = socket.getInputStream();</title><children><topics type="attached"><topic id="5dfnm6bee8drea2s92s2ue9fnu" modified-by="" timestamp="1513126986385"><title svg:width="500">可以在此基础上，包装缓冲流，转换流，对象流，打印流，数据流等</title></topic></topics></children></topic></topics></children></topic><topic id="7578hco9s1qsoftt3dbdt0nvla" modified-by="" timestamp="1513126910624"><title>发消息</title><children><topics type="attached"><topic id="2lcssp2qlu1jlclnr5rq9c8b2d" modified-by="" timestamp="1513126988330"><title svg:width="500">OutputStream out = socket.getOutputStream();</title><children><topics type="attached"><topic id="251aobqgleiih0lliliirr3ubc" modified-by="" timestamp="1513126988313"><title svg:width="500">可以在此基础上，包装缓冲流，转换流，对象流，打印流，数据流等</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="55f62vvb34g22beari35bgg7p7" modified-by="" timestamp="1513126948577"><title>4、与客户端断开连接</title><children><topics type="attached"><topic id="18on5iqg7a0etdven0j1n0nrdb" modified-by="" timestamp="1513126953881"><title>socket.close();</title></topic></topics></children></topic></topics></children></topic><topic id="7b217srgahe02eglbkph2pdutb" modified-by="" timestamp="1513127050519"><title>客户端</title><children><topics type="attached"><topic id="183vgbbae6tplfkj2em24niiu9" modified-by="" timestamp="1513127017947"><title svg:width="500">1、先与服务器建立连接，通过创建一个Socket，要指定服务器的IP和端口号</title><children><topics type="attached"><topic id="5aqe0vt7br498hjlgg79fnja1i" modified-by="" timestamp="1513127040523"><title svg:width="500">Socket socket = new Socket(服务器的IP，服务器的监听端口号);</title></topic></topics></children></topic><topic id="2puks23ipt38n6kmp0i7pd68mj" modified-by="" timestamp="1513127055313"><title>2、通过socket进行收或发消息</title><children><topics type="attached"><topic id="2a66jgsgh0en6tt0u0jd2bro2s" modified-by="" timestamp="1513126893403"><title>收消息</title><children><topics type="attached"><topic id="69v8jm7k9c4uc158s9b30l8mme" modified-by="" timestamp="1513126956977"><title>InputStream is = socket.getInputStream();</title><children><topics type="attached"><topic id="5thut9qespp0k3n94k29jrs1me" modified-by="" timestamp="1513126986385"><title svg:width="500">可以在此基础上，包装缓冲流，转换流，对象流，打印流，数据流等</title></topic></topics></children></topic></topics></children></topic><topic id="6s0b0gd4s4rbmqji9bbk2vqud5" modified-by="" timestamp="1513126910624"><title>发消息</title><children><topics type="attached"><topic id="2e29cic4ljk5qg87gtsgp49sj8" modified-by="" timestamp="1513126988330"><title svg:width="500">OutputStream out = socket.getOutputStream();</title><children><topics type="attached"><topic id="4g8gcrgaljq1rtedfcti0va4sb" modified-by="" timestamp="1513126988313"><title svg:width="500">可以在此基础上，包装缓冲流，转换流，对象流，打印流，数据流等</title></topic></topics></children></topic></topics></children></topic><topic id="5hlnbqs36uskgmp23n58qob1ns" modified-by="" timestamp="1513127064158"><title>收和发可以用不同的线程进行维护</title></topic></topics></children></topic><topic id="4kun58ecmvjb1s27m6u72mv8ge" modified-by="" timestamp="1513127053573"><title>3、与客户端断开连接</title><children><topics type="attached"><topic id="13lcou76d7db1sl6bpjtjrhkdj" modified-by="" timestamp="1513126953881"><title>socket.close();</title></topic></topics></children></topic></topics></children></topic><topic id="45mfki2n32ddjg9rp64c7bvufm" modified-by="" timestamp="1513156910471"><title>示例一</title><notes><html><xhtml:p>package com.atguigu.tcp1;</xhtml:p><xhtml:p/><xhtml:p>import java.io.InputStream;</xhtml:p><xhtml:p>import java.io.OutputStream;</xhtml:p><xhtml:p>import java.net.ServerSocket;</xhtml:p><xhtml:p>import java.net.Socket;</xhtml:p><xhtml:p/><xhtml:p>import org.junit.Test;</xhtml:p><xhtml:p/><xhtml:p>/*</xhtml:p><xhtml:p> * TCP:面向连接</xhtml:p><xhtml:p> * 通信的两端分角色：服务器端和客户端</xhtml:p><xhtml:p> * </xhtml:p><xhtml:p> * 服务器端等着被连接，客户端主动连接</xhtml:p><xhtml:p> * </xhtml:p><xhtml:p> * 服务器端：</xhtml:p><xhtml:p> * 1、ServerSocket：用来接收客户端的连接信息</xhtml:p><xhtml:p> * 2、Socket：用来与某个客户端进行通信</xhtml:p><xhtml:p> * </xhtml:p><xhtml:p> * 客户端：</xhtml:p><xhtml:p> * 1、Socket：用来与服务器进行通信</xhtml:p><xhtml:p> * </xhtml:p><xhtml:p> */</xhtml:p><xhtml:p>public class TestTCP1 {</xhtml:p><xhtml:p>	@Test</xhtml:p><xhtml:p>	public void server()throws Exception{</xhtml:p><xhtml:p>		//1、创建ServerSocket，看成：开启服务器 ，需要指定一个端口号，监听是否有客户端来连接</xhtml:p><xhtml:p>		ServerSocket ss = new ServerSocket(9090);</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		while(true){</xhtml:p><xhtml:p>			System.out.println("等待您的链接....");</xhtml:p><xhtml:p>			//2、等待客户端的连接，接收客户端的连接（如果没有人连接，那么这句代码会阻塞）</xhtml:p><xhtml:p>			//一旦有客户端连接成功，那么就会产生一个Socket对象，专门负责和这个客户端通信</xhtml:p><xhtml:p>			Socket socket = ss.accept();</xhtml:p><xhtml:p>			</xhtml:p><xhtml:p>			System.out.println(socket.getInetAddress().getHostAddress()+"连接成功");</xhtml:p><xhtml:p>			</xhtml:p><xhtml:p>			//3、可以接收消息，或发生消息</xhtml:p><xhtml:p>			//例如：先发：“欢迎登陆”</xhtml:p><xhtml:p>			//在接收消息</xhtml:p><xhtml:p>			</xhtml:p><xhtml:p>			//发消息：输出流，OutputStream</xhtml:p><xhtml:p>			OutputStream output = socket.getOutputStream();</xhtml:p><xhtml:p>			output.write("欢迎登陆".getBytes());</xhtml:p><xhtml:p>			socket.shutdownOutput();</xhtml:p><xhtml:p>			</xhtml:p><xhtml:p>			//收消息</xhtml:p><xhtml:p>			InputStream is = socket.getInputStream();</xhtml:p><xhtml:p>			</xhtml:p><xhtml:p>			byte[] data = new byte[1024];</xhtml:p><xhtml:p>			int len;</xhtml:p><xhtml:p>			StringBuilder sb = new StringBuilder();</xhtml:p><xhtml:p>			while((len= is.read(data)) !=-1){</xhtml:p><xhtml:p>				sb.append(new String(data,0,len));</xhtml:p><xhtml:p>			}</xhtml:p><xhtml:p>			System.out.println("服务器收到的消息：" + sb);</xhtml:p><xhtml:p>			</xhtml:p><xhtml:p>			//4、关闭连接</xhtml:p><xhtml:p>			socket.close();//只是与某个客户端断开</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//5、服务器关闭</xhtml:p><xhtml:p>//		ss.close();</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>	@Test</xhtml:p><xhtml:p>	public void client()throws Exception{</xhtml:p><xhtml:p>		//1、创建一个Socket，要指定服务器的IP和端口号</xhtml:p><xhtml:p>		Socket socket = new Socket("192.168.24.71",9090);</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//2、接收消息</xhtml:p><xhtml:p>		InputStream is = socket.getInputStream();</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		byte[] data = new byte[1024];</xhtml:p><xhtml:p>		int len;</xhtml:p><xhtml:p>		StringBuilder sb = new StringBuilder();</xhtml:p><xhtml:p>		while((len= is.read(data)) !=-1){</xhtml:p><xhtml:p>			sb.append(new String(data,0,len));</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>		System.out.println("客户端收到的消息：" + sb);</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//3、发送消息</xhtml:p><xhtml:p>		String info = "马上吃饭了";</xhtml:p><xhtml:p>		OutputStream out = socket.getOutputStream();</xhtml:p><xhtml:p>		out.write(info.getBytes());</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//3、关闭连接</xhtml:p><xhtml:p>		socket.close();</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p/></html><plain>package com.atguigu.tcp1;&#13;
&#13;
import java.io.InputStream;&#13;
import java.io.OutputStream;&#13;
import java.net.ServerSocket;&#13;
import java.net.Socket;&#13;
&#13;
import org.junit.Test;&#13;
&#13;
/*&#13;
 * TCP:面向连接&#13;
 * 通信的两端分角色：服务器端和客户端&#13;
 * &#13;
 * 服务器端等着被连接，客户端主动连接&#13;
 * &#13;
 * 服务器端：&#13;
 * 1、ServerSocket：用来接收客户端的连接信息&#13;
 * 2、Socket：用来与某个客户端进行通信&#13;
 * &#13;
 * 客户端：&#13;
 * 1、Socket：用来与服务器进行通信&#13;
 * &#13;
 */&#13;
public class TestTCP1 {&#13;
	@Test&#13;
	public void server()throws Exception{&#13;
		//1、创建ServerSocket，看成：开启服务器 ，需要指定一个端口号，监听是否有客户端来连接&#13;
		ServerSocket ss = new ServerSocket(9090);&#13;
		&#13;
		while(true){&#13;
			System.out.println("等待您的链接....");&#13;
			//2、等待客户端的连接，接收客户端的连接（如果没有人连接，那么这句代码会阻塞）&#13;
			//一旦有客户端连接成功，那么就会产生一个Socket对象，专门负责和这个客户端通信&#13;
			Socket socket = ss.accept();&#13;
			&#13;
			System.out.println(socket.getInetAddress().getHostAddress()+"连接成功");&#13;
			&#13;
			//3、可以接收消息，或发生消息&#13;
			//例如：先发：“欢迎登陆”&#13;
			//在接收消息&#13;
			&#13;
			//发消息：输出流，OutputStream&#13;
			OutputStream output = socket.getOutputStream();&#13;
			output.write("欢迎登陆".getBytes());&#13;
			socket.shutdownOutput();&#13;
			&#13;
			//收消息&#13;
			InputStream is = socket.getInputStream();&#13;
			&#13;
			byte[] data = new byte[1024];&#13;
			int len;&#13;
			StringBuilder sb = new StringBuilder();&#13;
			while((len= is.read(data)) !=-1){&#13;
				sb.append(new String(data,0,len));&#13;
			}&#13;
			System.out.println("服务器收到的消息：" + sb);&#13;
			&#13;
			//4、关闭连接&#13;
			socket.close();//只是与某个客户端断开&#13;
		}&#13;
		&#13;
		//5、服务器关闭&#13;
//		ss.close();&#13;
	}&#13;
	&#13;
	@Test&#13;
	public void client()throws Exception{&#13;
		//1、创建一个Socket，要指定服务器的IP和端口号&#13;
		Socket socket = new Socket("192.168.24.71",9090);&#13;
		&#13;
		//2、接收消息&#13;
		InputStream is = socket.getInputStream();&#13;
		&#13;
		byte[] data = new byte[1024];&#13;
		int len;&#13;
		StringBuilder sb = new StringBuilder();&#13;
		while((len= is.read(data)) !=-1){&#13;
			sb.append(new String(data,0,len));&#13;
		}&#13;
		System.out.println("客户端收到的消息：" + sb);&#13;
		&#13;
		//3、发送消息&#13;
		String info = "马上吃饭了";&#13;
		OutputStream out = socket.getOutputStream();&#13;
		out.write(info.getBytes());&#13;
		&#13;
		//3、关闭连接&#13;
		socket.close();&#13;
	}&#13;
}&#13;
</plain></notes></topic><topic id="7d2qku46k8n0spad6i8r2t88mi" modified-by="" timestamp="1513156922632"><title>示例二</title><notes><html><xhtml:p>package com.atguigu.tcp2;</xhtml:p><xhtml:p/><xhtml:p>import java.io.BufferedReader;</xhtml:p><xhtml:p>import java.io.IOException;</xhtml:p><xhtml:p>import java.io.InputStream;</xhtml:p><xhtml:p>import java.io.InputStreamReader;</xhtml:p><xhtml:p>import java.io.OutputStream;</xhtml:p><xhtml:p>import java.net.ServerSocket;</xhtml:p><xhtml:p>import java.net.Socket;</xhtml:p><xhtml:p>import java.util.Scanner;</xhtml:p><xhtml:p/><xhtml:p>import org.junit.Test;</xhtml:p><xhtml:p/><xhtml:p>public class TestTCP2 {</xhtml:p><xhtml:p>	@Test</xhtml:p><xhtml:p>	public void server()throws Exception{</xhtml:p><xhtml:p>		//1、创建ServerSocket</xhtml:p><xhtml:p>		ServerSocket server = new ServerSocket(9999);</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		while(true){</xhtml:p><xhtml:p>			//2、等待客户端的连接，接收客户端的连接</xhtml:p><xhtml:p>			Socket socket = server.accept();</xhtml:p><xhtml:p>			String clientIp = socket.getInetAddress().getHostAddress();</xhtml:p><xhtml:p>			</xhtml:p><xhtml:p>			System.out.println(clientIp+"上线了");</xhtml:p><xhtml:p>			</xhtml:p><xhtml:p>			//每一个客户端需要一个线程单独维护它的通信，“同时”与服务器通信的效果</xhtml:p><xhtml:p>			new MessageHandler(socket).start();</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>	//和服务器连接上以后，从键盘输入消息，给服务器发送，一直到从键盘输入byebye，在与服务端口连接</xhtml:p><xhtml:p>	@Test</xhtml:p><xhtml:p>	public void client()throws Exception{</xhtml:p><xhtml:p>		//1、连接服务器</xhtml:p><xhtml:p>		Socket socket = new Socket("192.168.24.71",9999);</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		OutputStream out = socket.getOutputStream();</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//2，从键盘输入给服务器发送</xhtml:p><xhtml:p>		Scanner input = new Scanner(System.in);</xhtml:p><xhtml:p>		while(true){</xhtml:p><xhtml:p>			System.out.println("输入要发送的内容：");</xhtml:p><xhtml:p>			String info = input.nextLine();</xhtml:p><xhtml:p>			</xhtml:p><xhtml:p>			if("byebye".equals(info)){</xhtml:p><xhtml:p>				break;</xhtml:p><xhtml:p>			}</xhtml:p><xhtml:p>			</xhtml:p><xhtml:p>			//给服务器发送</xhtml:p><xhtml:p>			out.write((info+"\n").getBytes());</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//3、断开</xhtml:p><xhtml:p>		socket.close();</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p/><xhtml:p/><xhtml:p>class MessageHandler extends Thread{</xhtml:p><xhtml:p>	private Socket socket;</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>	public MessageHandler(Socket socket) {</xhtml:p><xhtml:p>		super();</xhtml:p><xhtml:p>		this.socket = socket;</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p/><xhtml:p>	public void run(){</xhtml:p><xhtml:p>		try {</xhtml:p><xhtml:p>			//3、和一个客户端多次通信，接收到消息后，在控制台打印</xhtml:p><xhtml:p>			InputStream input = socket.getInputStream();</xhtml:p><xhtml:p>			InputStreamReader isr = new InputStreamReader(input);</xhtml:p><xhtml:p>			BufferedReader br = new BufferedReader(isr);</xhtml:p><xhtml:p>			</xhtml:p><xhtml:p>			String str;</xhtml:p><xhtml:p>			while((str = br.readLine())!=null){</xhtml:p><xhtml:p>				System.out.println(socket.getInetAddress().getHostAddress() +"说："+ str);</xhtml:p><xhtml:p>			}</xhtml:p><xhtml:p>			</xhtml:p><xhtml:p>			//4、断开</xhtml:p><xhtml:p>			socket.close();</xhtml:p><xhtml:p>		} catch (IOException e) {</xhtml:p><xhtml:p>			e.printStackTrace();</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p></html><plain>package com.atguigu.tcp2;&#13;
&#13;
import java.io.BufferedReader;&#13;
import java.io.IOException;&#13;
import java.io.InputStream;&#13;
import java.io.InputStreamReader;&#13;
import java.io.OutputStream;&#13;
import java.net.ServerSocket;&#13;
import java.net.Socket;&#13;
import java.util.Scanner;&#13;
&#13;
import org.junit.Test;&#13;
&#13;
public class TestTCP2 {&#13;
	@Test&#13;
	public void server()throws Exception{&#13;
		//1、创建ServerSocket&#13;
		ServerSocket server = new ServerSocket(9999);&#13;
		&#13;
		while(true){&#13;
			//2、等待客户端的连接，接收客户端的连接&#13;
			Socket socket = server.accept();&#13;
			String clientIp = socket.getInetAddress().getHostAddress();&#13;
			&#13;
			System.out.println(clientIp+"上线了");&#13;
			&#13;
			//每一个客户端需要一个线程单独维护它的通信，“同时”与服务器通信的效果&#13;
			new MessageHandler(socket).start();&#13;
		}&#13;
	}&#13;
	&#13;
	//和服务器连接上以后，从键盘输入消息，给服务器发送，一直到从键盘输入byebye，在与服务端口连接&#13;
	@Test&#13;
	public void client()throws Exception{&#13;
		//1、连接服务器&#13;
		Socket socket = new Socket("192.168.24.71",9999);&#13;
		&#13;
		OutputStream out = socket.getOutputStream();&#13;
		&#13;
		//2，从键盘输入给服务器发送&#13;
		Scanner input = new Scanner(System.in);&#13;
		while(true){&#13;
			System.out.println("输入要发送的内容：");&#13;
			String info = input.nextLine();&#13;
			&#13;
			if("byebye".equals(info)){&#13;
				break;&#13;
			}&#13;
			&#13;
			//给服务器发送&#13;
			out.write((info+"\n").getBytes());&#13;
		}&#13;
		&#13;
		//3、断开&#13;
		socket.close();&#13;
	}&#13;
}&#13;
&#13;
&#13;
class MessageHandler extends Thread{&#13;
	private Socket socket;&#13;
	&#13;
	public MessageHandler(Socket socket) {&#13;
		super();&#13;
		this.socket = socket;&#13;
	}&#13;
&#13;
	public void run(){&#13;
		try {&#13;
			//3、和一个客户端多次通信，接收到消息后，在控制台打印&#13;
			InputStream input = socket.getInputStream();&#13;
			InputStreamReader isr = new InputStreamReader(input);&#13;
			BufferedReader br = new BufferedReader(isr);&#13;
			&#13;
			String str;&#13;
			while((str = br.readLine())!=null){&#13;
				System.out.println(socket.getInetAddress().getHostAddress() +"说："+ str);&#13;
			}&#13;
			&#13;
			//4、断开&#13;
			socket.close();&#13;
		} catch (IOException e) {&#13;
			e.printStackTrace();&#13;
		}&#13;
	}&#13;
}</plain></notes></topic><topic id="7rkp1h9a23p31240cligdd72gl" modified-by="" timestamp="1513156940212"><title>示例三：群聊</title><children><topics type="attached"><topic id="44s5ofj1d5dgmi9h8v5mdfbv4q" modified-by="" timestamp="1513156945834"><title>服务器</title><notes><html><xhtml:p>package com.atguigu.tcp2;</xhtml:p><xhtml:p/><xhtml:p>import java.io.BufferedReader;</xhtml:p><xhtml:p>import java.io.IOException;</xhtml:p><xhtml:p>import java.io.InputStream;</xhtml:p><xhtml:p>import java.io.InputStreamReader;</xhtml:p><xhtml:p>import java.io.OutputStream;</xhtml:p><xhtml:p>import java.net.ServerSocket;</xhtml:p><xhtml:p>import java.net.Socket;</xhtml:p><xhtml:p>import java.util.Scanner;</xhtml:p><xhtml:p/><xhtml:p>import org.junit.Test;</xhtml:p><xhtml:p/><xhtml:p>public class TestTCP2 {</xhtml:p><xhtml:p>	@Test</xhtml:p><xhtml:p>	public void server()throws Exception{</xhtml:p><xhtml:p>		//1、创建ServerSocket</xhtml:p><xhtml:p>		ServerSocket server = new ServerSocket(9999);</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		while(true){</xhtml:p><xhtml:p>			//2、等待客户端的连接，接收客户端的连接</xhtml:p><xhtml:p>			Socket socket = server.accept();</xhtml:p><xhtml:p>			String clientIp = socket.getInetAddress().getHostAddress();</xhtml:p><xhtml:p>			</xhtml:p><xhtml:p>			System.out.println(clientIp+"上线了");</xhtml:p><xhtml:p>			</xhtml:p><xhtml:p>			//每一个客户端需要一个线程单独维护它的通信，“同时”与服务器通信的效果</xhtml:p><xhtml:p>			new MessageHandler(socket).start();</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>	//和服务器连接上以后，从键盘输入消息，给服务器发送，一直到从键盘输入byebye，在与服务端口连接</xhtml:p><xhtml:p>	@Test</xhtml:p><xhtml:p>	public void client()throws Exception{</xhtml:p><xhtml:p>		//1、连接服务器</xhtml:p><xhtml:p>		Socket socket = new Socket("192.168.24.71",9999);</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		OutputStream out = socket.getOutputStream();</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//2，从键盘输入给服务器发送</xhtml:p><xhtml:p>		Scanner input = new Scanner(System.in);</xhtml:p><xhtml:p>		while(true){</xhtml:p><xhtml:p>			System.out.println("输入要发送的内容：");</xhtml:p><xhtml:p>			String info = input.nextLine();</xhtml:p><xhtml:p>			</xhtml:p><xhtml:p>			if("byebye".equals(info)){</xhtml:p><xhtml:p>				break;</xhtml:p><xhtml:p>			}</xhtml:p><xhtml:p>			</xhtml:p><xhtml:p>			//给服务器发送</xhtml:p><xhtml:p>			out.write((info+"\n").getBytes());</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//3、断开</xhtml:p><xhtml:p>		socket.close();</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p/><xhtml:p/><xhtml:p>class MessageHandler extends Thread{</xhtml:p><xhtml:p>	private Socket socket;</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>	public MessageHandler(Socket socket) {</xhtml:p><xhtml:p>		super();</xhtml:p><xhtml:p>		this.socket = socket;</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p/><xhtml:p>	public void run(){</xhtml:p><xhtml:p>		try {</xhtml:p><xhtml:p>			//3、和一个客户端多次通信，接收到消息后，在控制台打印</xhtml:p><xhtml:p>			InputStream input = socket.getInputStream();</xhtml:p><xhtml:p>			InputStreamReader isr = new InputStreamReader(input);</xhtml:p><xhtml:p>			BufferedReader br = new BufferedReader(isr);</xhtml:p><xhtml:p>			</xhtml:p><xhtml:p>			String str;</xhtml:p><xhtml:p>			while((str = br.readLine())!=null){</xhtml:p><xhtml:p>				System.out.println(socket.getInetAddress().getHostAddress() +"说："+ str);</xhtml:p><xhtml:p>			}</xhtml:p><xhtml:p>			</xhtml:p><xhtml:p>			//4、断开</xhtml:p><xhtml:p>			socket.close();</xhtml:p><xhtml:p>		} catch (IOException e) {</xhtml:p><xhtml:p>			e.printStackTrace();</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p></html><plain>package com.atguigu.tcp2;&#13;
&#13;
import java.io.BufferedReader;&#13;
import java.io.IOException;&#13;
import java.io.InputStream;&#13;
import java.io.InputStreamReader;&#13;
import java.io.OutputStream;&#13;
import java.net.ServerSocket;&#13;
import java.net.Socket;&#13;
import java.util.Scanner;&#13;
&#13;
import org.junit.Test;&#13;
&#13;
public class TestTCP2 {&#13;
	@Test&#13;
	public void server()throws Exception{&#13;
		//1、创建ServerSocket&#13;
		ServerSocket server = new ServerSocket(9999);&#13;
		&#13;
		while(true){&#13;
			//2、等待客户端的连接，接收客户端的连接&#13;
			Socket socket = server.accept();&#13;
			String clientIp = socket.getInetAddress().getHostAddress();&#13;
			&#13;
			System.out.println(clientIp+"上线了");&#13;
			&#13;
			//每一个客户端需要一个线程单独维护它的通信，“同时”与服务器通信的效果&#13;
			new MessageHandler(socket).start();&#13;
		}&#13;
	}&#13;
	&#13;
	//和服务器连接上以后，从键盘输入消息，给服务器发送，一直到从键盘输入byebye，在与服务端口连接&#13;
	@Test&#13;
	public void client()throws Exception{&#13;
		//1、连接服务器&#13;
		Socket socket = new Socket("192.168.24.71",9999);&#13;
		&#13;
		OutputStream out = socket.getOutputStream();&#13;
		&#13;
		//2，从键盘输入给服务器发送&#13;
		Scanner input = new Scanner(System.in);&#13;
		while(true){&#13;
			System.out.println("输入要发送的内容：");&#13;
			String info = input.nextLine();&#13;
			&#13;
			if("byebye".equals(info)){&#13;
				break;&#13;
			}&#13;
			&#13;
			//给服务器发送&#13;
			out.write((info+"\n").getBytes());&#13;
		}&#13;
		&#13;
		//3、断开&#13;
		socket.close();&#13;
	}&#13;
}&#13;
&#13;
&#13;
class MessageHandler extends Thread{&#13;
	private Socket socket;&#13;
	&#13;
	public MessageHandler(Socket socket) {&#13;
		super();&#13;
		this.socket = socket;&#13;
	}&#13;
&#13;
	public void run(){&#13;
		try {&#13;
			//3、和一个客户端多次通信，接收到消息后，在控制台打印&#13;
			InputStream input = socket.getInputStream();&#13;
			InputStreamReader isr = new InputStreamReader(input);&#13;
			BufferedReader br = new BufferedReader(isr);&#13;
			&#13;
			String str;&#13;
			while((str = br.readLine())!=null){&#13;
				System.out.println(socket.getInetAddress().getHostAddress() +"说："+ str);&#13;
			}&#13;
			&#13;
			//4、断开&#13;
			socket.close();&#13;
		} catch (IOException e) {&#13;
			e.printStackTrace();&#13;
		}&#13;
	}&#13;
}</plain></notes></topic><topic id="7u5vhouvp49p0ujjfp0dlnp2qi" modified-by="" timestamp="1513156953233"><title>客户端</title><notes><html><xhtml:p>package com.atguigu.tcp3;</xhtml:p><xhtml:p/><xhtml:p>import java.io.BufferedReader;</xhtml:p><xhtml:p>import java.io.IOException;</xhtml:p><xhtml:p>import java.io.InputStream;</xhtml:p><xhtml:p>import java.io.InputStreamReader;</xhtml:p><xhtml:p>import java.io.OutputStream;</xhtml:p><xhtml:p>import java.io.PrintStream;</xhtml:p><xhtml:p>import java.net.Socket;</xhtml:p><xhtml:p>import java.net.SocketException;</xhtml:p><xhtml:p>import java.util.Scanner;</xhtml:p><xhtml:p/><xhtml:p>/*</xhtml:p><xhtml:p> * </xhtml:p><xhtml:p> */</xhtml:p><xhtml:p>public class TestTCPClient{</xhtml:p><xhtml:p>	public static void main(String[] args) throws Exception{</xhtml:p><xhtml:p>		//1、连接服务器</xhtml:p><xhtml:p>		Socket socket = new Socket("192.168.24.71",9090);</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//2、创建两个线程，一个收，一个发</xhtml:p><xhtml:p>		SendThread send = new SendThread(socket);</xhtml:p><xhtml:p>		send.start();</xhtml:p><xhtml:p>		RecevierThread r = new RecevierThread(socket);</xhtml:p><xhtml:p>		r.start();</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		send.join();</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		r.setExit(true);</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//3、关闭</xhtml:p><xhtml:p>		socket.close();</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p>class SendThread extends Thread{</xhtml:p><xhtml:p>	private Socket socket;</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>	public SendThread(Socket socket) {</xhtml:p><xhtml:p>		super();</xhtml:p><xhtml:p>		this.socket = socket;</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p/><xhtml:p>	@Override</xhtml:p><xhtml:p>	public void run() {</xhtml:p><xhtml:p>		try {</xhtml:p><xhtml:p>			OutputStream output = socket.getOutputStream();</xhtml:p><xhtml:p>			PrintStream ps = new PrintStream(output);</xhtml:p><xhtml:p>			</xhtml:p><xhtml:p>			Scanner input = new Scanner(System.in);</xhtml:p><xhtml:p>			while(true){</xhtml:p><xhtml:p>				System.out.println("请输入要发送的内容：");</xhtml:p><xhtml:p>				String info = input.nextLine();</xhtml:p><xhtml:p>				if("bye".equals(info)){</xhtml:p><xhtml:p>					break;</xhtml:p><xhtml:p>				}</xhtml:p><xhtml:p>				//给服务器发送</xhtml:p><xhtml:p>				ps.println(info);</xhtml:p><xhtml:p>			}</xhtml:p><xhtml:p>			</xhtml:p><xhtml:p>		} catch (IOException e) {</xhtml:p><xhtml:p>			e.printStackTrace();</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p>class RecevierThread extends Thread{</xhtml:p><xhtml:p>	private Socket socket;</xhtml:p><xhtml:p>	private boolean exit = false;</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>	public RecevierThread(Socket socket) {</xhtml:p><xhtml:p>		super();</xhtml:p><xhtml:p>		this.socket = socket;</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>	@Override</xhtml:p><xhtml:p>	public void run() {</xhtml:p><xhtml:p>		try {</xhtml:p><xhtml:p>			InputStream is = socket.getInputStream();</xhtml:p><xhtml:p>			InputStreamReader isr = new InputStreamReader(is);</xhtml:p><xhtml:p>			BufferedReader br = new BufferedReader(isr);</xhtml:p><xhtml:p>			</xhtml:p><xhtml:p>			String str;</xhtml:p><xhtml:p>			while(exit==false){</xhtml:p><xhtml:p>				try {</xhtml:p><xhtml:p>					str = br.readLine();</xhtml:p><xhtml:p>				} catch (SocketException e) {</xhtml:p><xhtml:p>					break;</xhtml:p><xhtml:p>				}</xhtml:p><xhtml:p>				if(str==null){</xhtml:p><xhtml:p>					break;</xhtml:p><xhtml:p>				}</xhtml:p><xhtml:p>				System.out.println("收到的消息：" + str);</xhtml:p><xhtml:p>			}</xhtml:p><xhtml:p>			</xhtml:p><xhtml:p>		} catch (IOException e) {</xhtml:p><xhtml:p>			e.printStackTrace();</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>	public void setExit(boolean exit) {</xhtml:p><xhtml:p>		this.exit = exit;</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>}</xhtml:p></html><plain>package com.atguigu.tcp3;&#13;
&#13;
import java.io.BufferedReader;&#13;
import java.io.IOException;&#13;
import java.io.InputStream;&#13;
import java.io.InputStreamReader;&#13;
import java.io.OutputStream;&#13;
import java.io.PrintStream;&#13;
import java.net.Socket;&#13;
import java.net.SocketException;&#13;
import java.util.Scanner;&#13;
&#13;
/*&#13;
 * &#13;
 */&#13;
public class TestTCPClient{&#13;
	public static void main(String[] args) throws Exception{&#13;
		//1、连接服务器&#13;
		Socket socket = new Socket("192.168.24.71",9090);&#13;
		&#13;
		//2、创建两个线程，一个收，一个发&#13;
		SendThread send = new SendThread(socket);&#13;
		send.start();&#13;
		RecevierThread r = new RecevierThread(socket);&#13;
		r.start();&#13;
		&#13;
		send.join();&#13;
		&#13;
		r.setExit(true);&#13;
		&#13;
		//3、关闭&#13;
		socket.close();&#13;
	}&#13;
}&#13;
class SendThread extends Thread{&#13;
	private Socket socket;&#13;
	&#13;
	public SendThread(Socket socket) {&#13;
		super();&#13;
		this.socket = socket;&#13;
	}&#13;
&#13;
	@Override&#13;
	public void run() {&#13;
		try {&#13;
			OutputStream output = socket.getOutputStream();&#13;
			PrintStream ps = new PrintStream(output);&#13;
			&#13;
			Scanner input = new Scanner(System.in);&#13;
			while(true){&#13;
				System.out.println("请输入要发送的内容：");&#13;
				String info = input.nextLine();&#13;
				if("bye".equals(info)){&#13;
					break;&#13;
				}&#13;
				//给服务器发送&#13;
				ps.println(info);&#13;
			}&#13;
			&#13;
		} catch (IOException e) {&#13;
			e.printStackTrace();&#13;
		}&#13;
	}&#13;
}&#13;
class RecevierThread extends Thread{&#13;
	private Socket socket;&#13;
	private boolean exit = false;&#13;
	&#13;
	public RecevierThread(Socket socket) {&#13;
		super();&#13;
		this.socket = socket;&#13;
	}&#13;
	@Override&#13;
	public void run() {&#13;
		try {&#13;
			InputStream is = socket.getInputStream();&#13;
			InputStreamReader isr = new InputStreamReader(is);&#13;
			BufferedReader br = new BufferedReader(isr);&#13;
			&#13;
			String str;&#13;
			while(exit==false){&#13;
				try {&#13;
					str = br.readLine();&#13;
				} catch (SocketException e) {&#13;
					break;&#13;
				}&#13;
				if(str==null){&#13;
					break;&#13;
				}&#13;
				System.out.println("收到的消息：" + str);&#13;
			}&#13;
			&#13;
		} catch (IOException e) {&#13;
			e.printStackTrace();&#13;
		}&#13;
	}&#13;
	public void setExit(boolean exit) {&#13;
		this.exit = exit;&#13;
	}&#13;
	&#13;
}</plain></notes></topic></topics></children></topic></topics></children></topic><topic id="41li6695dnhevc9igcpblp15re" modified-by="" timestamp="1513156782822"><title>UDP编程步骤</title><children><topics type="attached"><topic id="3b60dkmrl5rmub51u1kdagi67d" modified-by="" timestamp="1513127192721"><title>发送端</title><children><topics type="attached"><topic id="2cg8mrv8fh0jc5qsiga8gmi18l" modified-by="" timestamp="1513127115477"><title>1、创建一个DatagramSocket</title></topic><topic id="0vc7jrbvd52fmorstkipbk6rva" modified-by="" timestamp="1513127136494"><title>2、准备发送的数据，并且打包</title><children><topics type="attached"><topic id="652pclqqf2gkgo6a2l1lth5ol9" modified-by="" timestamp="1513127145784"><title>DatagramPacket</title><children><topics type="attached"><topic id="5abf8kq50i0iccqqasj4rgp0ak" modified-by="" timestamp="1513127169195"><title svg:width="500">要指定：发送的数据，长度，接收方的IP，接收方的端口号</title></topic></topics></children></topic></topics></children></topic><topic id="6gi2r258r5ofthk54o5hp22mtr" modified-by="" timestamp="1513127191117"><title>3、通过DatagramSocket的send(数据报)</title></topic><topic id="7i18i0b2h965afpgba8j0qt43h" modified-by="" timestamp="1513127202430"><title>4、关闭</title></topic></topics></children></topic><topic id="28efsjd4n2bqstur6bq406ic4o" modified-by="" timestamp="1513127335433"><title>接收端</title><children><topics type="attached"><topic id="360dgna17u66jef3kosr307bo7" modified-by="" timestamp="1513127208563"><title>1、创建一个DatagramSocket</title><children><topics type="attached"><topic id="21cpcnd4o42pdmsrspgvg510qu" modified-by="" timestamp="1513127217826"><title>要指定 监听的端口号</title></topic></topics></children></topic><topic id="06qirj0fb1brqa2iv4dcuf2nmd" modified-by="" timestamp="1513127245410"><title>2、准备一个DatagramPacket，用来接收数据</title><children><topics type="attached"><topic id="1qg91ab5q60munhgh6inen27ps" modified-by="" timestamp="1513127258840"><title>要指定装数据一个字节数组，以及长度</title></topic></topics></children></topic><topic id="5pkdd0qjke0dmk3j1gs4imrnlp" modified-by="" timestamp="1513127288249"><title>3、通过DatagramSocket的receive(数据报)</title></topic><topic id="22iaokdpv5eg0paagfbpnr8f3e" modified-by="" timestamp="1513127295868"><title>4、拆解数据</title><children><topics type="attached"><topic id="2q69e73jpep12dqi36ksvo0ujg" modified-by="" timestamp="1513127333031"><title svg:width="500">通过DatagramPacket对象.getData()数据，DatagramPacket对象.getLength()实际接收的数据长度</title></topic></topics></children></topic><topic id="3g65fchc2b1mehe8bsomtevpbu" modified-by="" timestamp="1513127338226"><title>5、关闭</title></topic></topics></children></topic><topic id="4bdungr7t8un7pci27srsuqngh" modified-by="" timestamp="1513156789673"><title>示例代码</title><notes><html><xhtml:p>package com.atguigu.udp;</xhtml:p><xhtml:p/><xhtml:p>import java.net.DatagramPacket;</xhtml:p><xhtml:p>import java.net.DatagramSocket;</xhtml:p><xhtml:p>import java.net.InetAddress;</xhtml:p><xhtml:p/><xhtml:p>import org.junit.Test;</xhtml:p><xhtml:p/><xhtml:p>/*</xhtml:p><xhtml:p> * UDP:非面向连接的</xhtml:p><xhtml:p> * </xhtml:p><xhtml:p> * 有发送端和接收端两个应用程序</xhtml:p><xhtml:p> */</xhtml:p><xhtml:p>public class TestUDP {</xhtml:p><xhtml:p>	@Test</xhtml:p><xhtml:p>	public void send()throws Exception{</xhtml:p><xhtml:p>		//1、创建Socket</xhtml:p><xhtml:p>		DatagramSocket ds = new DatagramSocket();</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//2、把数据打包成一个数据报，包</xhtml:p><xhtml:p>		String str = "双十二购物快乐";</xhtml:p><xhtml:p>		byte[] bytes = str.getBytes();</xhtml:p><xhtml:p>		InetAddress ip = InetAddress.getByName("192.168.24.71");</xhtml:p><xhtml:p>		DatagramPacket dp = new DatagramPacket(bytes, bytes.length, ip,8989);</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//3、通过socket发送出去</xhtml:p><xhtml:p>		ds.send(dp);</xhtml:p><xhtml:p>		System.out.println("发送完毕");</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//4、释放资源</xhtml:p><xhtml:p>		ds.close();</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>	@Test</xhtml:p><xhtml:p>	public void reveive()throws Exception{</xhtml:p><xhtml:p>		//1、创建Socket</xhtml:p><xhtml:p>		DatagramSocket ds = new DatagramSocket(8989);//为它指定一个端口号，在端口号一直监听着</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//2、先创建一个数据报等着</xhtml:p><xhtml:p>		byte[] data = new byte[1024];</xhtml:p><xhtml:p>		DatagramPacket dp  = new DatagramPacket(data, data.length);</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//3、准备接受数据，从socket中接收数据，如果此时没有数据，这句代码会阻塞</xhtml:p><xhtml:p>		ds.receive(dp);</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//4、拆出数据</xhtml:p><xhtml:p>		String str = new String(dp.getData(),0,dp.getLength());</xhtml:p><xhtml:p>		System.out.println("收到的数据是：" + str);</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//5、关闭</xhtml:p><xhtml:p>		ds.close();</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p/></html><plain>package com.atguigu.udp;&#13;
&#13;
import java.net.DatagramPacket;&#13;
import java.net.DatagramSocket;&#13;
import java.net.InetAddress;&#13;
&#13;
import org.junit.Test;&#13;
&#13;
/*&#13;
 * UDP:非面向连接的&#13;
 * &#13;
 * 有发送端和接收端两个应用程序&#13;
 */&#13;
public class TestUDP {&#13;
	@Test&#13;
	public void send()throws Exception{&#13;
		//1、创建Socket&#13;
		DatagramSocket ds = new DatagramSocket();&#13;
		&#13;
		//2、把数据打包成一个数据报，包&#13;
		String str = "双十二购物快乐";&#13;
		byte[] bytes = str.getBytes();&#13;
		InetAddress ip = InetAddress.getByName("192.168.24.71");&#13;
		DatagramPacket dp = new DatagramPacket(bytes, bytes.length, ip,8989);&#13;
		&#13;
		//3、通过socket发送出去&#13;
		ds.send(dp);&#13;
		System.out.println("发送完毕");&#13;
		&#13;
		//4、释放资源&#13;
		ds.close();&#13;
	}&#13;
	&#13;
	@Test&#13;
	public void reveive()throws Exception{&#13;
		//1、创建Socket&#13;
		DatagramSocket ds = new DatagramSocket(8989);//为它指定一个端口号，在端口号一直监听着&#13;
		&#13;
		//2、先创建一个数据报等着&#13;
		byte[] data = new byte[1024];&#13;
		DatagramPacket dp  = new DatagramPacket(data, data.length);&#13;
		&#13;
		//3、准备接受数据，从socket中接收数据，如果此时没有数据，这句代码会阻塞&#13;
		ds.receive(dp);&#13;
		&#13;
		//4、拆出数据&#13;
		String str = new String(dp.getData(),0,dp.getLength());&#13;
		System.out.println("收到的数据是：" + str);&#13;
		&#13;
		//5、关闭&#13;
		ds.close();&#13;
	}&#13;
}&#13;
</plain></notes></topic></topics></children></topic><topic id="21g8k1i1ffo7qdka3l2pc8mr82" modified-by="" timestamp="1513156793326"><title>URL编程</title><children><topics type="attached"><topic id="3tndc81s1ughv9f2g403brtiuc" modified-by="" timestamp="1513127373355"><title>在TCP的基础上</title><children><topics type="attached"><topic id="297lu8nv2a6fcmsmuded9ontfi" modified-by="" timestamp="1513127380711"><title>服务器端</title><children><topics type="attached"><topic id="2kunuo1ujlkju3qj3a56mmf690" modified-by="" timestamp="1513127386246"><title>Web服务器</title></topic></topics></children></topic><topic id="1m59t9b32hdbapvpn2bl2gmecg" modified-by="" timestamp="1513127712729"><title>客户端</title><children><topics type="attached"><topic id="387dcdrjap44rca7jpsutaedg6" modified-by="" timestamp="1513127399857"><title>1、创建URL的对象</title><children><topics type="attached"><topic id="25cgucmq27hthmd7jgfvdri94h" modified-by="" timestamp="1513127475230"><title>URL url = new URL(网址);</title><children><topics type="attached"><topic id="19474ib8eqcqrggu79hlom06a7" modified-by="" timestamp="1513127450826"><title svg:width="500">网址：协议://主机名:端口号/文件路径名?参数名=参数值&amp;参数名=参数值...</title></topic><topic id="25en0otcpkfch6404l5ku7mav6" modified-by="" timestamp="1513127472261"><title svg:width="500">例如：http://localhost:8080/1108web/index.html</title></topic><topic id="1i7tg6l6l3mist253nc1eonupc" modified-by="" timestamp="1513127490007"><title svg:width="500">例如：http://localhost:8080/1108web/login?username=xx&amp;password=xx</title></topic></topics></children></topic></topics></children></topic><topic id="7e73p7557t5m5hlftumb8ogkib" modified-by="" timestamp="1513127585907"><title>2、与服务器建立连接</title><children><topics type="attached"><topic id="0669cifpekfk1a26kii19oite4" modified-by="" timestamp="1513127524497"><title>InputStream is = url.openStream();</title><children><topics type="attached"><topic id="2v1h7tanlon9t2p1eokr1cqta3" modified-by="" timestamp="1513127561844"><title>这种方式只能使用get方法与服务器进行通信</title><children><topics type="attached"><topic id="6tpqhc8rn7h3peisv5gnkefnce" modified-by="" timestamp="1513127582383"><title svg:width="500">如果要给服务器传参数只能在网址后面通过?参数名=参数值&amp;参数名=参数值...</title></topic></topics></children></topic></topics></children></topic><topic id="32ak2sikcn5tmpmrgf1lionfml" modified-by="" timestamp="1513127629267"><title svg:width="500">HttpURLConnection tc = (HttpURLConnection)url.openConnection();</title><children><topics type="attached"><topic id="0kdkpmdtprc2tb31unqmojg9pq" modified-by="" timestamp="1513127688429"><title>这种方式可以使用post方法与服务器进行通信</title><children><topics type="attached"><topic id="1ufpfk47lm0ppcnsj28t8enlci" modified-by="" timestamp="1513127687330"><title svg:width="500">如果要给服务器传数据，那么需要hc.setDoOutput(true);</title></topic><topic id="3je1oi976ekkinpvoo7d1vetkm" modified-by="" timestamp="1513127697645"><title>然后用OutputStream进行发送数据</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="7o5gf7tv4ilsrl2v6vo30si03a" modified-by="" timestamp="1513127718848"><title>3、处理接收到数据</title></topic></topics></children></topic></topics></children></topic><topic id="13607oupkh2a9k9656rgq2ch9u" modified-by="" timestamp="1513156872687"><title>示例代码</title><children><topics type="attached"><topic id="3h5d3gmasptu850hhbj9jdetpf" modified-by="" timestamp="1513156858318"><title>示例一</title><notes><html><xhtml:p>package com.atguigu.url;</xhtml:p><xhtml:p/><xhtml:p>import java.io.BufferedReader;</xhtml:p><xhtml:p>import java.io.InputStream;</xhtml:p><xhtml:p>import java.io.InputStreamReader;</xhtml:p><xhtml:p>import java.net.URL;</xhtml:p><xhtml:p/><xhtml:p>/*</xhtml:p><xhtml:p> * tomcat：是一个服务器</xhtml:p><xhtml:p> * 浏览器：客户端</xhtml:p><xhtml:p> */</xhtml:p><xhtml:p>public class TestURL {</xhtml:p><xhtml:p/><xhtml:p>	public static void main(String[] args) throws Exception{</xhtml:p><xhtml:p>		//自定义客户端</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		URL url = new URL("http://192.168.24.71:8080/1108JavaWeb/index.html");</xhtml:p><xhtml:p>		/*System.out.println("协议：" + url.getProtocol());</xhtml:p><xhtml:p>		System.out.println("主机名：" + url.getHost());</xhtml:p><xhtml:p>		System.out.println("端口号：" + url.getPort());</xhtml:p><xhtml:p>		System.out.println("路径名：" + url.getPath());*/</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		InputStream input = url.openStream();</xhtml:p><xhtml:p>		InputStreamReader isr = new InputStreamReader(input);</xhtml:p><xhtml:p>		BufferedReader br  = new BufferedReader(isr);	</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		String str ;</xhtml:p><xhtml:p>		while((str=br.readLine())!=null){</xhtml:p><xhtml:p>			System.out.println(str);</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p/><xhtml:p>}</xhtml:p><xhtml:p/></html><plain>package com.atguigu.url;&#13;
&#13;
import java.io.BufferedReader;&#13;
import java.io.InputStream;&#13;
import java.io.InputStreamReader;&#13;
import java.net.URL;&#13;
&#13;
/*&#13;
 * tomcat：是一个服务器&#13;
 * 浏览器：客户端&#13;
 */&#13;
public class TestURL {&#13;
&#13;
	public static void main(String[] args) throws Exception{&#13;
		//自定义客户端&#13;
		&#13;
		URL url = new URL("http://192.168.24.71:8080/1108JavaWeb/index.html");&#13;
		/*System.out.println("协议：" + url.getProtocol());&#13;
		System.out.println("主机名：" + url.getHost());&#13;
		System.out.println("端口号：" + url.getPort());&#13;
		System.out.println("路径名：" + url.getPath());*/&#13;
		&#13;
		InputStream input = url.openStream();&#13;
		InputStreamReader isr = new InputStreamReader(input);&#13;
		BufferedReader br  = new BufferedReader(isr);	&#13;
		&#13;
		String str ;&#13;
		while((str=br.readLine())!=null){&#13;
			System.out.println(str);&#13;
		}&#13;
	}&#13;
&#13;
}&#13;
</plain></notes></topic><topic id="7ogs1ibgk9jl4snk2tvpgp109v" modified-by="" timestamp="1513156872367"><title>示例二：get</title><notes><html><xhtml:p>package com.atguigu.url;</xhtml:p><xhtml:p/><xhtml:p>import java.io.BufferedReader;</xhtml:p><xhtml:p>import java.io.InputStream;</xhtml:p><xhtml:p>import java.io.InputStreamReader;</xhtml:p><xhtml:p>import java.net.URL;</xhtml:p><xhtml:p/><xhtml:p>public class TestURL2 {</xhtml:p><xhtml:p/><xhtml:p>	public static void main(String[] args) throws Exception{</xhtml:p><xhtml:p>		URL url = new URL("http://192.168.24.71:8080/myweb/login?username=admin&amp;pass=123");</xhtml:p><xhtml:p>		InputStream input = url.openStream();</xhtml:p><xhtml:p>		InputStreamReader isr = new InputStreamReader(input);</xhtml:p><xhtml:p>		BufferedReader br  = new BufferedReader(isr);	</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		String str ;</xhtml:p><xhtml:p>		while((str=br.readLine())!=null){</xhtml:p><xhtml:p>			System.out.println(str);</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p/><xhtml:p>}</xhtml:p><xhtml:p/></html><plain>package com.atguigu.url;&#13;
&#13;
import java.io.BufferedReader;&#13;
import java.io.InputStream;&#13;
import java.io.InputStreamReader;&#13;
import java.net.URL;&#13;
&#13;
public class TestURL2 {&#13;
&#13;
	public static void main(String[] args) throws Exception{&#13;
		URL url = new URL("http://192.168.24.71:8080/myweb/login?username=admin&amp;pass=123");&#13;
		InputStream input = url.openStream();&#13;
		InputStreamReader isr = new InputStreamReader(input);&#13;
		BufferedReader br  = new BufferedReader(isr);	&#13;
		&#13;
		String str ;&#13;
		while((str=br.readLine())!=null){&#13;
			System.out.println(str);&#13;
		}&#13;
	}&#13;
&#13;
}&#13;
</plain></notes></topic><topic id="0q3d2f9mcrgrq35vh513tdrhs1" modified-by="" timestamp="1513156887002"><title>示例三：post</title><notes><html><xhtml:p>package com.atguigu.url;</xhtml:p><xhtml:p/><xhtml:p>import java.io.BufferedReader;</xhtml:p><xhtml:p>import java.io.InputStream;</xhtml:p><xhtml:p>import java.io.InputStreamReader;</xhtml:p><xhtml:p>import java.io.OutputStream;</xhtml:p><xhtml:p>import java.io.PrintStream;</xhtml:p><xhtml:p>import java.net.HttpURLConnection;</xhtml:p><xhtml:p>import java.net.URL;</xhtml:p><xhtml:p/><xhtml:p>public class TestURL3 {</xhtml:p><xhtml:p/><xhtml:p>	public static void main(String[] args) throws Exception{</xhtml:p><xhtml:p>		URL url = new URL("http://192.168.24.71:8080/myweb/login");</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		HttpURLConnection hc = (HttpURLConnection) url.openConnection();</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		hc.setDoOutput(true);</xhtml:p><xhtml:p>		OutputStream output = hc.getOutputStream();</xhtml:p><xhtml:p>		PrintStream ps = new PrintStream(output);</xhtml:p><xhtml:p>//		output.write("username=chai&amp;pass=123".getBytes());</xhtml:p><xhtml:p>		ps.println("username=chai&amp;pass=123");</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		InputStream input = hc.getInputStream();</xhtml:p><xhtml:p>		InputStreamReader isr = new InputStreamReader(input);</xhtml:p><xhtml:p>		BufferedReader br  = new BufferedReader(isr);	</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		String str ;</xhtml:p><xhtml:p>		while((str=br.readLine())!=null){</xhtml:p><xhtml:p>			System.out.println(str);</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p/><xhtml:p>}</xhtml:p><xhtml:p/></html><plain>package com.atguigu.url;&#13;
&#13;
import java.io.BufferedReader;&#13;
import java.io.InputStream;&#13;
import java.io.InputStreamReader;&#13;
import java.io.OutputStream;&#13;
import java.io.PrintStream;&#13;
import java.net.HttpURLConnection;&#13;
import java.net.URL;&#13;
&#13;
public class TestURL3 {&#13;
&#13;
	public static void main(String[] args) throws Exception{&#13;
		URL url = new URL("http://192.168.24.71:8080/myweb/login");&#13;
		&#13;
		HttpURLConnection hc = (HttpURLConnection) url.openConnection();&#13;
		&#13;
		hc.setDoOutput(true);&#13;
		OutputStream output = hc.getOutputStream();&#13;
		PrintStream ps = new PrintStream(output);&#13;
//		output.write("username=chai&amp;pass=123".getBytes());&#13;
		ps.println("username=chai&amp;pass=123");&#13;
		&#13;
		InputStream input = hc.getInputStream();&#13;
		InputStreamReader isr = new InputStreamReader(input);&#13;
		BufferedReader br  = new BufferedReader(isr);	&#13;
		&#13;
		String str ;&#13;
		while((str=br.readLine())!=null){&#13;
			System.out.println(str);&#13;
		}&#13;
	}&#13;
&#13;
}&#13;
</plain></notes></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><title>网络编程</title></sheet><sheet id="7r1c43751j0jvih8ej0parnkvc" modified-by="" theme="xminddefaultthemeid" timestamp="1513299198554"><topic id="0v8j0co7s9rj1ln4e94743rl1d" modified-by="" structure-class="org.xmind.ui.logic.right" timestamp="1508468416715"><title svg:width="500">Lambda表达式与StreamAPI</title><extensions><extension provider="org.xmind.ui.map.unbalanced"><content><right-number>-1</right-number></content></extension></extensions><children><topics type="attached"><topic id="4mn0bj08kblqvtudkfs1n87qpd" modified-by="" timestamp="1508465755519"><title>JDK1.8</title></topic><topic id="1b4rqjv8t99gptsqtr55k435v9" modified-by="" timestamp="1508465789493"><title svg:width="500">这两个的目的都是想要使得Java能够实现函数式编程</title></topic><topic id="0v7supds7rk9juuo2tocj8feuf" modified-by="" timestamp="1508465860430"><title svg:width="500">Lambada表达式主要针对接口，函数式接口进行的优化，简化代码</title></topic><topic id="318c493fu66ve684jaf4nim5rn" modified-by="" timestamp="1508465855039"><title svg:width="500">StreamAPI主要是针对集合的处理操作进行的优化，简化代码</title></topic><topic id="7scue6n5m0lfctufnrfsgc02td" modified-by="" timestamp="1508467717878"><title>Lambda表达式</title><children><topics type="attached"><topic id="6go5h8erdops12ncregjqlb0ct" modified-by="" timestamp="1508465896339"><title svg:width="500">是一个匿名的函数，为了把方法体的实现代码当做数据一样进行传递</title></topic><topic id="44kspil4c23fg4hvod0a3omrmh" modified-by="" timestamp="1508466007426"><title>JDK1.8之前，用匿名内部类完成</title><children><topics type="attached"><topic id="5qnqpbniifljrsfq6jh1ar84fj" modified-by="" timestamp="1508465959207"><title>Runnable r = new Runnable(){&#13;
	public void run(){&#13;
		......&#13;
	}&#13;
}</title><children><topics type="attached"><topic id="4451175g6ilpulgbj6d231cs54" modified-by="" timestamp="1508465974143"><title>目的就是传递run()方法的实现代码</title></topic></topics></children></topic><topic id="0ng6bpp6mnfdca2s5f4cn8av3q" modified-by="" timestamp="1508466038181"><title>new Thread(new Runnable(){&#13;
	public void run(){&#13;
		......&#13;
	}&#13;
}).start();</title></topic></topics></children></topic><topic id="5ukpq6tpphuh750l7epf8dl5gt" modified-by="" timestamp="1508466040021"><title>使用Lambda表达式</title><children><topics type="attached"><topic id="0hfioshg942ccn6cecq4hhgahb" modified-by="" timestamp="1508465999474"><title>Runnable r = () -&gt; {....};</title></topic><topic id="3637hqqbt9fho0dp2ug4cimhq4" modified-by="" timestamp="1508466054678"><title>new Thread(() -&gt; {....}).start();</title></topic></topics></children></topic><topic id="464707hipm7u5sr48ui0ea4tk6" modified-by="" timestamp="1508466066317"><title>语法</title><children><topics type="attached"><topic id="535kkuv97iari68u8h9edcvmue" modified-by="" timestamp="1513298699338"><title>格式： (形参列表) -&gt;  {Lambda体}</title></topic></topics></children></topic><topic id="49girpupb8v92p87ntpj1i2q5g" modified-by="" timestamp="1508466114117"><title>四种形式</title><children><topics type="attached"><topic id="0ki4hrfdhhitvuepsdg68r518c" modified-by="" timestamp="1508466473343"><title>（1）无参无返回值</title><children><topics type="attached"><topic id="71pfrnjo9fstv7r0an8045930u" modified-by="" timestamp="1508466126596"><title>格式</title><children><topics type="attached"><topic id="281ge9be9rtnv216d7mavpph35" modified-by="" timestamp="1508466137769"><title>() -&gt; {Lambda体}</title></topic></topics></children></topic><topic id="49eg881drf68hpdhr51qfbhs6j" modified-by="" timestamp="1513156165465"><title>说明：</title><children><topics type="attached"><topic id="3gm9e1phre0q5l98ubqrdg4ol8" modified-by="" timestamp="1513156154204"><title>（1）无参，()</title></topic><topic id="6q9m3a87b3pah2r0veqvr1gspk" modified-by="" timestamp="1513156156212"><title svg:width="500">（2）如果Lambda体是多句语句，那么{}是不可以省略</title></topic><topic id="6kvqr91dntb672j70tobm53120" modified-by="" timestamp="1513156158621"><title svg:width="500">（3）如果Lambda体是1句语句，那么{}如果不省略，那么语句后面要加; ，即{;}</title></topic><topic id="260373t148eaqv36a8jelfoqck" modified-by="" timestamp="1513156161976"><title svg:width="500">（4）如果Lambda体是1句语句，那么{;}可以省略</title></topic></topics></children></topic><topic id="5kpflt1tuhno72huatkle711dl" modified-by="" timestamp="1508466502099"><title>代表</title><children><topics type="attached"><topic id="7ccaipd34fsesn7a1av1bps2fn" modified-by="" timestamp="1508466518824"><title svg:width="500">Runnable r = ()  -&gt; {System.out.println("hello");};</title></topic><topic id="5ir52090sa2jgtpi97o8v9i75k" modified-by="" timestamp="1508466516988"><title>Runnable r = ()  -&gt; System.out.println("hello");</title></topic></topics></children></topic></topics></children></topic><topic id="359m5jprb9vjf4ha9rpet29a9m" modified-by="" timestamp="1508466525566"><title>（2）有参无返回值</title><children><topics type="attached"><topic id="7h7gedn9ro5fc3c19eonj1g21h" modified-by="" timestamp="1508466224272"><title>格式</title><children><topics type="attached"><topic id="209q2s7fvfnhtlh4oe3tbcqcrc" modified-by="" timestamp="1508466231303"><title>(形参列表) -&gt; {Lambda体}</title></topic></topics></children></topic><topic id="7gers9s3o33hl6bel6ltdr165e" modified-by="" timestamp="1513156234910"><title>说明：</title><children><topics type="attached"><topic id="3j7gph3jmab6qaf7g8p14v7scp" modified-by="" timestamp="1513156219729"><title> （1）如果Lambda体是多句语句，那么{}是不可以省略</title></topic><topic id="11elnc67svlrc44fjsn2ilu29b" modified-by="" timestamp="1513156219729"><title> （2）如果Lambda体是1句语句，那么{}如果不省略，那么语句后面要加; ，即{;}</title></topic><topic id="2hoilq2ld03d66qrkadc50ren3" modified-by="" timestamp="1513156219729"><title> （3）如果Lambda体是1句语句，那么{;}可以省略</title></topic><topic id="47ud408r1itg4mcspltre3vnbp" modified-by="" timestamp="1513156255273"><title svg:width="500">（4）如果参数列表的参数类型是可以确定的，那么类型可以省略，如果形参个数是多个，那么()不可以省略</title></topic><topic id="01tkqhb5n459gbgjnesrk3qf9m" modified-by="" timestamp="1513156268623"><title svg:width="500"> （5）如果参数列表的个数只有1个，类型可以确定，()可以省略,形参名不可以省略，但是形参名可以和接口的抽象方法的形参名不一样</title></topic></topics></children></topic><topic id="5s7fh682vhta4qu4n83u5ktm1r" modified-by="" timestamp="1508466557468"><title>代表</title><children><topics type="attached"><topic id="3h36fsn71k75krkrm4mt2gica4" modified-by="" timestamp="1508466538670"><title>消费型</title></topic><topic id="013f0n9hb497g57jpl7km1lek1" modified-by="" timestamp="1508466556556"><title>Consumer&lt;T&gt;   void  accept(T t)</title></topic><topic id="7kvam981m9ori2n0q9v8153b3n" modified-by="" timestamp="1508466588644"><title>java.lang.Iterable&lt;T&gt;</title><children><topics type="attached"><topic id="0rd156fddeom0qnkg53vl41pj0" modified-by="" timestamp="1508466585664"><title>forEach(Consumer&lt;T&gt;)</title></topic><topic id="5unbc1m8i82604mmhs9olis520" modified-by="" timestamp="1508466618725"><title>集合对象.forEach(t  -&gt; System.out.println(t));</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="0n94urtuupam7i6djnj4q98glt" modified-by="" timestamp="1508466625047"><title>（3）无参有返回值</title><children><topics type="attached"><topic id="041tv3dsmqunos3kikh3foe111" modified-by="" timestamp="1508466332157"><title>格式</title><children><topics type="attached"><topic id="7njg9477793qkjqtsf33sni9u0" modified-by="" timestamp="1508466338884"><title>() -&gt; {Lambda体}</title><children><topics type="attached"><topic id="1ggbg9t75sjlk8nn1ai811t0l2" modified-by="" timestamp="1508466355398"><title>Lambda体中，肯定有return语句</title></topic></topics></children></topic></topics></children></topic><topic id="1ekpbpu03h7po10pgjj0o7i114" modified-by="" timestamp="1513156423343"><title>说明：</title><children><topics type="attached"><topic id="2qa7efddeooejss8smkggp42bv" modified-by="" timestamp="1513156423275"><title> （1）无参，()不可以省略</title></topic><topic id="5iqi1cru6cv2dq1n8n3ovid4sb" modified-by="" timestamp="1513156423275"><title> （2）如果Lambda体是多句语句，那么{}是不可以省略，，每一个语句后面要;，并且必须有return 返回值;的语句</title></topic><topic id="37ai6nftljtn4krtt2katn42ch" modified-by="" timestamp="1513156423275"><title> （3）如果Lambda体是1句语句，那么{}如果不省略，那么一定是{return 返回值;}的语句</title></topic><topic id="1dl8c4vp42jgo8sco9sm8om6rt" modified-by="" timestamp="1513156423275"><title> （4）如果Lambda体是1句语句，那么{;}可以省略，而且return要省略</title></topic></topics></children></topic><topic id="6lc0hljk5k8ifhe3ibfjd5nj1o" modified-by="" timestamp="1508466651817"><title>代表</title><children><topics type="attached"><topic id="5s5blf8a2grmcdn36jmr68lft0" modified-by="" timestamp="1508466634323"><title>供给型</title></topic><topic id="2n4d7qhc2d0go10urvhpiav6a6" modified-by="" timestamp="1508466649772"><title>Supplier&lt;T&gt;   T get()</title></topic><topic id="3g6pigtu0p07gnbog270m7veau" modified-by="" timestamp="1508466708186"><title>java.util.Optional&lt;T&gt;   orElseGet(Supplier)</title><children><topics type="attached"><topic id="32bt6qjh0ealsb3s59j74uumsg" modified-by="" timestamp="1508466706706"><title svg:width="500">Optional&lt;String&gt; opt = Optional.ofNullable(address);</title></topic><topic id="0f8vn6lrvbo9qm0i2kaq1b9pc3" modified-by="" timestamp="1508466753954"><title svg:width="500">String address = opt.orElseGet(() -&gt; new String("北京"));</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="0n9mpnt2rqr8k6tjtb0o1p024a" modified-by="" timestamp="1508466759241"><title>（4）有参有返回值</title><children><topics type="attached"><topic id="25e2b58jduv0mqh3m9rpenshdo" modified-by="" timestamp="1508466435124"><title>格式</title><children><topics type="attached"><topic id="2dpbtuia2ppv390tkg2p8fnm1f" modified-by="" timestamp="1508466231303"><title>(形参列表) -&gt; {Lambda体}</title></topic></topics></children></topic><topic id="5ki8e04do5hhan079fsv6ugbhh" modified-by="" timestamp="1513156501384"><title>说明：</title><children><topics type="attached"><topic id="54bdcptlritr7m52e7tjnmn7fq" modified-by="" timestamp="1513156501284"><title> （1）如果Lambda体是多句语句，那么{}是不可以省略，并且必须有return 返回值;的语句</title></topic><topic id="6cdahp9bouppbp7k9e33llfc95" modified-by="" timestamp="1513156501284"><title> （2）如果Lambda体是1句语句，那么{}如果不省略，那么一定是{return 返回值;}的语句</title></topic><topic id="4mriolb8u0mv37n6u1njqph2h2" modified-by="" timestamp="1513156501284"><title> （3）如果Lambda体是1句语句，那么{;}可以省略，而且return也可以省略</title></topic><topic id="5t4e4utpuvr7bbdg315bekcl5v" modified-by="" timestamp="1513156501284"><title> （4）参数列表，如果类型可以确定，那么类型可以省略,()不可以省略</title></topic><topic id="3i2v5q1und31ckju13u72kslbl" modified-by="" timestamp="1513156501284"><title> （5）参数列表，如果类型可以确定，并且参数个数只有一个，那么类型和()都可以省略</title></topic></topics></children></topic><topic id="32ope7kvijskjbvdrh961alttg" modified-by="" timestamp="1508466804733"><title>代表</title><children><topics type="attached"><topic id="4ik86pm0ekero94mp6da5qbs5e" modified-by="" timestamp="1508466842660"><title svg:width="500">java.util.Comparator&lt;T&gt;： int compare(T t1, T t2)</title><children><topics type="attached"><topic id="47ep6ikjuducou81ggcv17uusg" modified-by="" timestamp="1508466878760"><title svg:width="500">Comparator&lt;Student&gt; com = (t1,t2) -&gt; t1.getId() - t2.getId();</title></topic></topics></children></topic><topic id="3uocn9achjrortd7qlmku7qq5q" modified-by="" timestamp="1508466882548"><title>Predicate&lt;T&gt;  : boolean  test(T t)</title><children><topics type="attached"><topic id="6joi95qfac8jadr6v558kefaf5" modified-by="" timestamp="1508466905240"><title svg:width="500">Predicate&lt;Employee&gt;  p = t -&gt; t.getSalary() &gt; 10000;</title></topic></topics></children></topic><topic id="5ml92m4u38eeip06ul7s85qgv7" modified-by="" timestamp="1508466976085"><title>Function&lt;T,R&gt; :  R apply(T t)</title><children><topics type="attached"><topic id="0v9ibuagmupiss4rrk0lfnc1iq" modified-by="" timestamp="1508466992162"><title svg:width="500">如果Employee对象的薪资低于10000，涨薪10%，并且返回新工作</title></topic><topic id="7ugdsaisrhufmt6mruash7he82" modified-by="" timestamp="1508467119926"><title svg:width="500">Function&lt;Employee, Double&gt;  f = e -&gt; {&#13;
		if(e.getSalary()&lt;10000){&#13;
			e.setSalary(e.getSalary()*1.1;&#13;
		}&#13;
		return e.getSalary();	&#13;
}</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="5nlnqe7g488luk7aa83g927j9d" modified-by="" timestamp="1508467335102"><title>使用的形式</title><children><topics type="attached"><topic id="6duhgu0oulvae8fo1hn39dr4l4" modified-by="" timestamp="1508467328798"><title>1、给函数式接口的变量赋值：多态引用</title><children><topics type="attached"><topic id="6sdcd01uqggbb1uevhntqbud7f" modified-by="" timestamp="1508467328761"><title svg:width="500">Comparator&lt;Student&gt; com = (t1,t2) -&gt; t1.getId() - t2.getId();</title></topic></topics></children></topic><topic id="6c3ott9c5l4u4eg8hbc90jthfc" modified-by="" timestamp="1508467349534"><title>2、给函数式接口的形参赋值：多态参数</title><children><topics type="attached"><topic id="23ig2gh6mkqksqtknteesodl73" modified-by="" timestamp="1508467363463"><title>new TreeSet( (t1,t2) -&gt; t1.getId() - t2.getId());</title></topic></topics></children></topic></topics></children></topic><topic id="2re99koore7mogbr2urfcbsleo" modified-by="" timestamp="1508467372730"><title>函数式接口</title><children><topics type="attached"><topic id="4l799tuajivol5g5iskqdbivjv" modified-by="" timestamp="1508467161051"><title svg:width="500">函数式接口也是接口，是个特殊的接口，SAM型接口</title><children><topics type="attached"><topic id="0ca7057am6tcvk5uut6j0tts5b" modified-by="" timestamp="1513299110542"><title>SAM：Single  Abstract  Method</title><children><topics type="attached"><topic id="0c348j3ee69ateebhpsvd9frhh" modified-by="" timestamp="1513299121234"><title>使用注解声明@FunctionInterface</title></topic></topics></children></topic></topics></children></topic><topic id="7do8rvv6o1c2a1od5eojakk8ks" modified-by="" timestamp="1508467208313"><title svg:width="500">在这个类接口中只有一个抽象方法，但是可以有静态方法和默认方法以及Object中的方法</title></topic><topic id="16g1ncmm5h3fnddv3li9m6nqke" modified-by="" timestamp="1508467240158"><title svg:width="500">只有函数式接口的变量或形参才能用Lambda表达式赋值</title></topic><topic id="2tvgid3g8shg4glg3kqulpn1a6" modified-by="" timestamp="1508467656070"><title>四个核心的函数式</title><children><topics type="attached"><topic id="13dfvi0oktsftktk0ao068b5ql" modified-by="" timestamp="1508467442849"><title>1、消费型</title><children><topics type="attached"><topic id="391cktrl7nbbtcjoh55hgkhr6r" modified-by="" timestamp="1508467403233"><title>Consumer&lt;T&gt;   void  accept(T t)</title></topic><topic id="1i6oe6koqmgm10g7r2ikcb6d56" modified-by="" timestamp="1508467471803"><title>还有延伸版</title><children><topics type="attached"><topic id="4a4h81ps692q115m4bs2vg9un4" modified-by="" timestamp="1508467467838"><title>BiConsumer&lt;T,U&gt;: void  accept(T t,U u)</title></topic><topic id="5mk0kau6bl2v4bigirgr50hign" modified-by="" timestamp="1508467474112"><title>。。。。</title></topic></topics></children></topic></topics></children></topic><topic id="5c2q9rt5m5fem35f84aea8gp4i" modified-by="" timestamp="1508467530674"><title>2、供给型</title><children><topics type="attached"><topic id="65mtvu7pavng3uguudoahljft6" modified-by="" timestamp="1508467488518"><title>Supplier&lt;T&gt;   T get()</title></topic><topic id="5gkke5mad1hr08pbrtigo8ohg0" modified-by="" timestamp="1508467530054"><title>DoubleSupplier   Double get()</title></topic><topic id="59b2ie8jurh3u70u46mrinq4mv" modified-by="" timestamp="1508467532472"><title>....</title></topic></topics></children></topic><topic id="7bmjnt0slfhdfhaeq3vbkd89bd" modified-by="" timestamp="1508467581878"><title>3、功能型</title><children><topics type="attached"><topic id="33gc7tr01afhfg4ah3hscaeob8" modified-by="" timestamp="1508467572887"><title>Function&lt;T,R&gt;  R  apply(T t)</title></topic><topic id="5584s1a7c8e06de601qual3vj1" modified-by="" timestamp="1508467653288"><title>延伸版</title><children><topics type="attached"><topic id="13fm395htv5dpq3r5sla2s8epk" modified-by="" timestamp="1508467652237"><title>BiFunction&lt;T,U,R&gt;  R apply(T t,U u)</title></topic><topic id="4r5n8smei0sbv6sfcb6cakfp30" modified-by="" timestamp="1508467640303"><title>BinaryOperator&lt;T&gt;  T apply(T t2, T t2)</title></topic><topic id="6ho8h7m5bt0il29vd4euvfeq3b" modified-by="" timestamp="1508467655273"><title>....</title></topic></topics></children></topic></topics></children></topic><topic id="3ur74crf9iebt8sdqa374oo3og" modified-by="" timestamp="1508467686200"><title>4、断定型</title><children><topics type="attached"><topic id="48pdquv0448dnbeft8b8a1i7ar" modified-by="" timestamp="1508467670100"><title>Predicate&lt;T&gt;  : boolean  test(T t)</title></topic><topic id="3ihvnb1vaogd0nnnj4k4bdiofv" modified-by="" timestamp="1508467705570"><title>延伸版</title><children><topics type="attached"><topic id="0ljdp77h4o10alklklkofkohgf" modified-by="" timestamp="1508467902347"><title>BiPredicate&lt;T,U&gt;  boolean test(T t ,U u)</title></topic><topic id="4gnmpfke9jaagouk01gni1regm" modified-by="" timestamp="1508467707663"><title>....</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="3s4g3tnf8d4g8601vvhgtq8qfr" modified-by="" timestamp="1513299198554"><title>再简化版</title><children><topics type="attached"><topic id="3403iee3i1s41beg9nbghfb9jj" modified-by="" timestamp="1508467804328"><title>方法引用</title><children><topics type="attached"><topic id="3jfi7g5ri8ga2f5srk6k2tjfof" modified-by="" timestamp="1508467781736"><title>条件</title><children><topics type="attached"><topic id="3fvk99k0gapjhfd6cd2901qint" modified-by="" timestamp="1508467778757"><title>（1）Lambda体通过调用一个现成的方法来完成</title></topic><topic id="76re6etvehaq2ol7lcqnggl16s" modified-by="" timestamp="1508467802908"><title svg:width="500">（2）Lambda的形参列表刚好是用于这个方法的实参</title></topic></topics></children></topic><topic id="561mjglvdl8a8e2ootb6pgavpt" modified-by="" timestamp="1508468033898"><title>形式有三种</title><children><topics type="attached"><topic id="3he956id7jd1b7hgakn9rpf9nh" modified-by="" timestamp="1508467907759"><title>（1）实例对象::实例方法名</title><children><topics type="attached"><topic id="7hmvmlliplm0ci42tk0tq6n5gu" modified-by="" timestamp="1508467885270"><title>集合对象.forEach(t -&gt; System.out.println(t));</title></topic><topic id="7911da00na4d161tcclkpfslbt" modified-by="" timestamp="1508467905788"><title>集合对象.forEach(System.out::println)</title></topic></topics></children></topic><topic id="5dvenff6vrphdvdqkedu0gae85" modified-by="" timestamp="1508467977924"><title>（2）类名::静态方法名</title><children><topics type="attached"><topic id="6jec9deu579j1bl9pr1n0d83q8" modified-by="" timestamp="1508467962096"><title>Supplier&lt;Double&gt;  s = () -&gt; Math.random();</title><children><topics type="attached"><topic id="1bdc88t0i342vaub4ajddk2gqu" modified-by="" timestamp="1508467974418"><title>Supplier&lt;Double&gt;  s = Math::random;</title></topic></topics></children></topic><topic id="7bqlsvtj90fvq52ods62asmash" modified-by="" timestamp="1508468020138"><title svg:width="500">BiFunction&lt;Integer,Integer,Integer&gt; b = (a,b) -&gt; Math.max(a,b);</title><children><topics type="attached"><topic id="1e2r8vtufb67335tmsba3gvb10" modified-by="" timestamp="1508468028744"><title svg:width="500">BiFunction&lt;Integer,Integer,Integer&gt; b = Math::max;</title></topic></topics></children></topic></topics></children></topic><topic id="4vm92udmpfqmasan50e9js44nr" modified-by="" timestamp="1508468050000"><title>（3）类名::实例方法名</title><children><topics type="attached"><topic id="3h8gk58muutr87jq5sng6s1i7j" modified-by="" timestamp="1508468150077"><title svg:width="500">Comparator&lt;String&gt;  c = (t1,t2)  -&gt;  t1.compareTo(t2);</title><children><topics type="attached"><topic id="4iq3dcb7o3b45girbra2pup4ta" modified-by="" timestamp="1508468144887"><title svg:width="500">Lambda表达式的形参的第一个作为调用方法的对象，第二个，作为这个实例方法的实参</title></topic><topic id="0v038jqq070bo15rk2ajuesvt2" modified-by="" timestamp="1508468164276"><title>Comparator&lt;String&gt;  c = String::compareTo;</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="0pthr0vf104l7uacvnisrgc2np" modified-by="" timestamp="1508468233031"><title>构造器引用</title><children><topics type="attached"><topic id="2pe06bthev4cfpsm9b6vi80fa4" modified-by="" timestamp="1508468224099"><title>条件</title><children><topics type="attached"><topic id="6177ndlufhafq7ba56glr9egkt" modified-by="" timestamp="1508468222159"><title svg:width="500">（1）Lambda体通过调用一个构造器完成，返回这个新建的对象</title></topic><topic id="5k0eio2uk4kb1l6l2b4hdave8c" modified-by="" timestamp="1508468230496"><title svg:width="500">（2）Lambda的形参列表刚好是用于这个构造器的实参</title></topic></topics></children></topic><topic id="67n2jbhfn843bahraj1srkkmfr" modified-by="" timestamp="1508468302855"><title>示例</title><children><topics type="attached"><topic id="5od8ud8sivkin7n76lmlribp83" modified-by="" timestamp="1508468301651"><title svg:width="500">Fuction&lt;String ,Employee&gt;  f = name -&gt; new Employee(name);</title></topic><topic id="4uamtmh6pdrloc4u62a034tuav" modified-by="" timestamp="1508468312971"><title svg:width="500">Fuction&lt;String ,Employee&gt;  f = Employee::new;</title></topic></topics></children></topic></topics></children></topic><topic id="32c9n43vivsukf74q8odd2p37v" modified-by="" timestamp="1508468353109"><title>数组构造引用</title><children><topics type="attached"><topic id="3drhocbgn0j5atl1ov6upcpdi7" modified-by="" timestamp="1508468324920"><title>条件</title><children><topics type="attached"><topic id="529q9bkku3vriar7gvbqguf0go" modified-by="" timestamp="1508468338974"><title svg:width="500">（1）Lambda体通过创建一个数组对象完成，返回这个新建的数组对象</title></topic><topic id="4endj2n27al6hlrq4q2j6mssjn" modified-by="" timestamp="1508468350198"><title svg:width="500">（2）Lambda的形参列表刚好是用于这个数组对象的创建的长度</title></topic></topics></children></topic><topic id="6ukgiog1rda69itkd1trqa2r3t" modified-by="" timestamp="1508468382478"><title>示例</title><children><topics type="attached"><topic id="0hiomsrq2rbnqoi3f2n8of1u4m" modified-by="" timestamp="1508468379915"><title svg:width="500">Fuction&lt;Integer ,Employee[]&gt;  f = len -&gt; new Employee[len];</title></topic><topic id="3e4okmb66fb8sh1rr705tiis7l" modified-by="" timestamp="1508468391604"><title svg:width="500">Fuction&lt;Integer ,Employee[]&gt;  f = Employee[]::new;</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="1nkomqnvquj2rv6tjn31qc8k1j" modified-by="" timestamp="1508469143013"><title>StreamAPI</title><children><topics type="attached"><topic id="0ttfte3pb4u1do3e9j8th3oqst" modified-by="" timestamp="1508469114890"><title>作用</title><children><topics type="attached"><topic id="7nts35p4dn4tr02pp039ssmpsa" modified-by="" timestamp="1508469116150"><title svg:width="500">Stream API ( java.util.stream) 把真正的函数式编程风格引入到Java中。这是目前为止对Java类库最好的补充，因为Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。&#13;
Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。 使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。也可以使用 Stream API 来并行执行操作。简言之，Stream API 提供了一种高效且易于使用的处理数据的方式。</title></topic></topics></children></topic><topic id="5e7drp7ctmhm1c73fi45e0atra" modified-by="" timestamp="1508469162007"><title>特点</title><children><topics type="attached"><topic id="3s8famp0ujuh073qf2nrhha4q6" modified-by="" timestamp="1508469142778"><title>1、Stream不负责存储数据</title></topic><topic id="2l7hla4afnt2bqkko5rceqhju4" modified-by="" timestamp="1508469176242"><title svg:width="500">2、Stream的操作不影响数据源，每次操作返回一个新的Stream</title></topic><topic id="541s1e8nrbffod0aaesacbj4io" modified-by="" timestamp="1508469219610"><title svg:width="500">3、Stream的中间操作是一个“懒惰求值”，一直要到终结操作，才会一口气完成</title></topic></topics></children></topic><topic id="1qcue0cl19a8p23f1793ftqs0u" modified-by="" timestamp="1508469339413"><title>步骤</title><children><topics type="attached"><topic id="430i75pkti4at086g77p1rc2s1" modified-by="" timestamp="1508469230925"><title>1、创建Stream</title><children><topics type="attached"><topic id="7qqo1hh96pjpeabjsg6nfa3ue0" modified-by="" timestamp="1508490203813"><title>四种方式</title><children><topics type="attached"><topic id="6ugnu44cgpbgrs6q6jh3aejacq" modified-by="" timestamp="1508490051760"><title>1、Collection集合对象.stream()</title><children><topics type="attached"><topic id="15c7i2erb6kg7chj16cneera1e" modified-by="" timestamp="1508490094872"><title svg:width="500">ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();&#13;
。。。	&#13;
//创建stream&#13;
Stream&lt;String&gt; stream = list.stream();</title></topic></topics></children></topic><topic id="5htl5fhscpl6u1ji4scrv18n5t" modified-by="" timestamp="1508490107168"><title>2、Arrays.stream(数组对象)</title><children><topics type="attached"><topic id="61g3k84puogahauln0aef8d1aq" modified-by="" timestamp="1508490110143"><title svg:width="500">String[] arr = {"hello","world","java","lambda","stream"};&#13;
Stream&lt;String&gt; stream = Arrays.stream(arr);</title></topic></topics></children></topic><topic id="5ajqeg4asttmfud0p62aseumr3" modified-by="" timestamp="1508490111986"><title>3、Stream.of(T...)</title><children><topics type="attached"><topic id="6521up8bqb88t9bstc7tmdg0lc" modified-by="" timestamp="1508490120008"><title svg:width="500">Stream&lt;String&gt; stream = Stream.of("hello","world","java","lambda","stream");</title></topic></topics></children></topic><topic id="5bsq6fs7j8krblsq3f8qukrt1q" modified-by="" timestamp="1508490168393"><title>4、无限流</title><children><topics type="attached"><topic id="4vqrsu5h75ggrkdmru36au7d1q" modified-by="" timestamp="1508490157907"><title>Stream.iterator(..)</title><children><topics type="attached"><topic id="2bm4trfb0tusn8fu7pu8656do8" modified-by="" timestamp="1508490197149"><title>示例</title><notes><html><xhtml:p>	@Test</xhtml:p><xhtml:p>	public void test4(){</xhtml:p><xhtml:p>		//Interface UnaryOperator&lt;T&gt;是特殊的Function&lt;T,T&gt;： T apply(T t)</xhtml:p><xhtml:p>		Stream&lt;Integer&gt; stream = Stream.iterate(1, x -&gt; x+2);</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//中间操作</xhtml:p><xhtml:p>		stream = stream.limit(10);//取前面的10个</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		stream.forEach(System.out::println);</xhtml:p><xhtml:p>	}</xhtml:p></html><plain>	@Test&#13;
	public void test4(){&#13;
		//Interface UnaryOperator&lt;T&gt;是特殊的Function&lt;T,T&gt;： T apply(T t)&#13;
		Stream&lt;Integer&gt; stream = Stream.iterate(1, x -&gt; x+2);&#13;
		&#13;
		//中间操作&#13;
		stream = stream.limit(10);//取前面的10个&#13;
		&#13;
		stream.forEach(System.out::println);&#13;
	}</plain></notes></topic></topics></children></topic><topic id="5frhg462j39ueq85ag53kjhpfe" modified-by="" timestamp="1508490189549"><title>Stream.generate(xx)</title><children><topics type="attached"><topic id="2m1ahadmqek0ibtt3kmdkbh5nu" modified-by="" timestamp="1508490200395"><title>示例</title><notes><html><xhtml:p>	@Test</xhtml:p><xhtml:p>	public void test5(){</xhtml:p><xhtml:p>		//Supplier&lt;T&gt; ：T  apply()</xhtml:p><xhtml:p>//		Stream&lt;Double&gt; generate = Stream.generate(() -&gt; Math.random());</xhtml:p><xhtml:p>		Stream&lt;Double&gt; stream = Stream.generate(Math::random);</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>//		stream = stream.limit(5);</xhtml:p><xhtml:p>//		stream.forEach(System.out::println);</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		stream.limit(5).forEach(System.out::println);</xhtml:p><xhtml:p>	}</xhtml:p></html><plain>	@Test&#13;
	public void test5(){&#13;
		//Supplier&lt;T&gt; ：T  apply()&#13;
//		Stream&lt;Double&gt; generate = Stream.generate(() -&gt; Math.random());&#13;
		Stream&lt;Double&gt; stream = Stream.generate(Math::random);&#13;
		&#13;
//		stream = stream.limit(5);&#13;
//		stream.forEach(System.out::println);&#13;
		&#13;
		stream.limit(5).forEach(System.out::println);&#13;
	}</plain></notes></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="6ajivf4iha59p2dq9s4cugc6ps" modified-by="" timestamp="1508469317246"><title>2、中间操作</title><children><topics type="attached"><topic id="29e2qi4l8r99mj6cbur3c1v426" modified-by="" timestamp="1508469290295"><title>（1筛选与切片</title><children><topics type="attached"><topic id="5ov9q3lc7n3jvl968deblj5q7q" modified-by="" timestamp="1513156579654"><title>（1）筛选与切片&#13;
A：过滤：filter&#13;
B：去重：distinct&#13;
C：取前面的几个：limit&#13;
D：跳过前面几个：skip&#13;
 *   要取中间几个：skip + limit</title></topic></topics></children></topic><topic id="6nupcafqf1o7tmhf3p1gk7jnvn" modified-by="" timestamp="1508469326608"><title>（2）映射</title><children><topics type="attached"><topic id="5l1rtu7j0k8sb4ote92h7op3bv" modified-by="" timestamp="1513156602129"><title svg:width="500"> A：map(Function)：对Stream中的每一个元素执行某个操作，返回值组成一个新的Stream&#13;
 B：返回值是特殊类型&#13;
 *   mapToInt()&#13;
 *   mapToLong()&#13;
 *   mapToDouble()&#13;
 C：flatMap(Function)：对stream的每一个元素执行某个操作，返回值是一个stream，这些个stream再合成一个大的stream</title></topic></topics></children></topic><topic id="3674vg02411libaldn8hjndqdc" modified-by="" timestamp="1508469334346"><title>（3）排序</title><children><topics type="attached"><topic id="7knvdge4h12ph40dhddh5g4i3b" modified-by="" timestamp="1513156614922"><title>A：sorted()：自然排序&#13;
B：sorted(Comparator)：定制排序</title></topic></topics></children></topic></topics></children></topic><topic id="4i3kk92i97epkcecr0nhjh0k7o" modified-by="" timestamp="1508469414026"><title>3、终结操作</title><children><topics type="attached"><topic id="0n5vur4mjabkefdb8unr1v6m6u" modified-by="" timestamp="1508469362421"><title>（1）遍历</title><children><topics type="attached"><topic id="5acki9tpdjti0hq6v75d0hnorh" modified-by="" timestamp="1508469363560"><title>forEach(Consumer)</title></topic></topics></children></topic><topic id="5pu1t78o6lptp4fhbnr8h8m6t1" modified-by="" timestamp="1508469382603"><title>（2）匹配与查找</title><children><topics type="attached"><topic id="1e2f4k0et7d4volh7k9j7eknm4" modified-by="" timestamp="1513156644492"><title svg:width="500">A：allMatch(Predicate p)：每一个元素是否都满足某个条件&#13;
B：anyMatch(Predicate p)：是否有一个元素满足条件&#13;
C：noneMatch(Predicate p)：是否所有元素都不满足&#13;
 * &#13;
D：findFirst（）:返回第一个&#13;
E：findAny()：如果是并行流，返回的结果是任意一个，如果是一个稳定的流，返回的结果是和findFirst()一样&#13;
 * &#13;
 F：count()：统计&#13;
G：max(Comparator)&#13;
H:min(Comparator)</title></topic></topics></children></topic><topic id="742ueiahamjp6a1im2mna2leci" modified-by="" timestamp="1508469409742"><title>（3）规约</title><children><topics type="attached"><topic id="2nj5uakjd359lbd4oa00n0fap1" modified-by="" timestamp="1513156652861"><title svg:width="500">A:Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator)&#13;
 		BinaryOperator&lt;T&gt;是一个BiFunction&lt;T,T,T&gt;接口：  T apply(T t1, T t2)&#13;
B:T reduce(T identity,BinaryOperator&lt;T&gt; accumulator)</title></topic></topics></children></topic><topic id="4r22r2837p7gdo8462535eijhc" modified-by="" timestamp="1508469428413"><title>（4）收集</title><children><topics type="attached"><topic id="4frt3mugjstvr9r7al2p2v32m7" modified-by="" timestamp="1513156668042"><title svg:width="500">&lt;R,A&gt; R collect(Collector&lt;? super T,A,R&gt; collector)</title><children><topics type="attached"><topic id="6vqesedet2qnrhcmd4md9pvk57" modified-by="" timestamp="1513156669691"><title svg:width="500">Collector 接口中方法的实现决定了如何对流执行收集的操作&#13;
Collectors 实用类提供了很多静态方法，可以方便地创建常见收集器实例，例如、List，Set,Map</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><title>Lambda表达式与StreamAPI</title></sheet><sheet id="5uu5nue742a7v0r2ph9sv2dbot" modified-by="" style-id="7fkp7h7d2rra9h00spf20rci7u" theme="xminddefaultthemeid" timestamp="1513156755567"><topic id="1frhv5htcvi53b1l324cdbb32m" modified-by="" structure-class="org.xmind.ui.map.unbalanced" timestamp="1513156755567"><title>Optional类</title><extensions><extension provider="org.xmind.ui.map.unbalanced"><content><right-number>1</right-number></content></extension></extensions><children><topics type="attached"><topic id="27kc34cq231p0qd2ki264fupga" modified-by="" timestamp="1513156730039"><title>java.util.Optional&lt;T&gt;</title><children><topics type="attached"><topic id="3msi6tccrg40eajtb61io5vc70" modified-by="" timestamp="1508464714537"><title>尽量避免空指针</title></topic><topic id="2hkjpjc87o4dvifeep87ns7mn9" modified-by="" timestamp="1508464810440"><title>1、创建Optional对象</title><children><topics type="attached"><topic id="34u963qshd78knkh0dkmg1798q" modified-by="" timestamp="1508464761061"><title>（1）创建一个空Optional</title><children><topics type="attached"><topic id="3ehhh78300ic2u2k2sqq30kjbc" modified-by="" timestamp="1508464768725"><title>Optional.empty()</title></topic></topics></children></topic><topic id="0f99nbm4khouvko5m00482vunc" modified-by="" timestamp="1508464787000"><title>（2）创建一个包装了对象的Optional</title><children><topics type="attached"><topic id="5v1ublnjusqvb7cud467f6hqrn" modified-by="" timestamp="1508464799535"><title>Optional.of(obj)</title><children><topics type="attached"><topic id="02fl2a5m4u7oojj1s8oe1vm20m" modified-by="" timestamp="1508464809658"><title>obj必须是非空，否则异常</title></topic></topics></children></topic></topics></children></topic><topic id="6pp514msmk3h31rkequa6eil69" modified-by="" timestamp="1508464826256"><title>（3）创建一个包装对象可能为空的Optional</title><children><topics type="attached"><topic id="3rgt1dgc41m3hj2vr6hn0g7k54" modified-by="" timestamp="1508464836512"><title>Optional.ofNullable(obj)</title><children><topics type="attached"><topic id="25733p7o4pc1s1sasv0il2g2kv" modified-by="" timestamp="1508464840731"><title>obj可能为空</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="7eu99df9ppsapnhm36lla7hu2r" modified-by="" timestamp="1508465040138"><title>2、获取包装的对象</title><children><topics type="attached"><topic id="7ugj61sqs5j7jlf7ma5lao050j" modified-by="" timestamp="1508464857483"><title>（1）get()</title><children><topics type="attached"><topic id="40p0012s71jbp2dln7n86a8sul" modified-by="" timestamp="1508464880897"><title svg:width="500">如果Optional包装的对象不为空，正常返回，如果为空，报异常</title></topic></topics></children></topic><topic id="7m43rnahatqvablovkr4mkbdjc" modified-by="" timestamp="1508464951940"><title>（2）orElse(T other)</title><children><topics type="attached"><topic id="4cafed5obp95sadqk54du718hr" modified-by="" timestamp="1508464956728"><title svg:width="500">如果Optional包装的对象不为空，正常返回，如果为空，返回other对象</title></topic></topics></children></topic><topic id="4h5r33u25eklqco16nu3c14dis" modified-by="" timestamp="1508464991513"><title>（3）orElseGet(Supplier)</title><children><topics type="attached"><topic id="12mj2uhsqccj63fjjailtfke2p" modified-by="" timestamp="1508464990641"><title svg:width="500">如果Optional包装的对象不为空，正常返回，如果为空，返回由供给型接口提供的对象</title></topic><topic id="17nji60btj603igmn5jhv2g5s3" modified-by="" timestamp="1508465016127"><title>Supplier接口：T  get()</title></topic></topics></children></topic><topic id="43843odhet4fk6tpfoiahjck7l" modified-by="" timestamp="1508465050285"><title svg:width="500">（4）orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)</title><children><topics type="attached"><topic id="47pprqv6mftrtvlmdqq97dak73" modified-by="" timestamp="1508465068871"><title svg:width="500">如果Optional包装的对象不为空，正常返回，如果为空，报异常，报的异常是由Supplier提供的异常对象</title></topic></topics></children></topic></topics></children></topic><topic id="56nhkn2639fenb5toc87aaalvd" modified-by="" timestamp="1508465144982"><title>3、是否存在</title><children><topics type="attached"><topic id="3f7cpoq3kmq2r8bdhf8jsf8lmg" modified-by="" timestamp="1508465121806"><title>（1）boolean isPresent()</title><children><topics type="attached"><topic id="5naam0nl7le36rudaglqp1jma2" modified-by="" timestamp="1508465143899"><title svg:width="500">表示判断Optional中的包装的对象是否存在，如果存在就返回true，否则就是false</title></topic></topics></children></topic><topic id="0lagvspcr1765pqj1l5cp7o1e5" modified-by="" timestamp="1508465202374"><title svg:width="500">（2）ifPresent(Consumer&lt;? super T&gt; consumer) </title><children><topics type="attached"><topic id="4ids58n0vl6pfi942kcshoig2v" modified-by="" timestamp="1508465189403"><title svg:width="500">如果存在，就执行Consoumer指定的操作，如果不存在就不做</title></topic><topic id="51bssvl53u883isomh04q1bg8h" modified-by="" timestamp="1508465218791"><title>Consumer： void accept(T t)</title></topic></topics></children></topic></topics></children></topic><topic id="2cc2sr3kbkl55sanbl539v8694" modified-by="" timestamp="1508465244787"><title>4、过滤</title><children><topics type="attached"><topic id="5gsnc8m8n21asb7d6ipktsonle" modified-by="" timestamp="1508465249451"><title svg:width="500">Optional&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)  </title><children><topics type="attached"><topic id="5bom3lg4ms20eliklmseolmtvq" modified-by="" timestamp="1508465287891"><title svg:width="500">对Optional中包装的对象进行过滤，按照Predicate的条件进行判断，如果满足，返回它，如果不满足，返回empty的Optional</title></topic></topics></children></topic></topics></children></topic><topic id="6jp01mncjj2kjbvloo404sp94r" modified-by="" timestamp="1508465332257"><title>5、映射</title><children><topics type="attached"><topic id="59qo465f1v9iquph0q3pnrus7o" modified-by="" timestamp="1508465337674"><title svg:width="500">&lt;U&gt; Optional&lt;U&gt; map(Function&lt;? super T,? extends U&gt; mapper) </title><children><topics type="attached"><topic id="0e65dhhun4uvj7gos991hikth8" modified-by="" timestamp="1508465683326"><title svg:width="500">对Optional包装对象，执行Function中的apply方法，apply方法返回的结果可以是任意结果，map方法的结果，把apply方法的结果包装成一个Optional对象</title></topic></topics></children></topic><topic id="7lebqgrq20ok95uhhfrk2jjs2v" modified-by="" timestamp="1508465685341"><title svg:width="500">&lt;U&gt; Optional&lt;U&gt; flatMap(Function&lt;? super T,Optional&lt;U&gt;&gt; mapper)  </title><children><topics type="attached"><topic id="2p8q5uh60qrh3hesoch69c9uou" modified-by="" timestamp="1508465706722"><title svg:width="500">对Optional包装对象，执行Function中的apply方法，apply方法返回的结果是一个Optional，map方法的结果，把apply方法的结果直接返回</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><title>Optional</title></sheet></xmap-content>