<?xml version="1.0" encoding="UTF-8" standalone="no"?><xmap-revision-content xmlns="urn:xmind:xmap:xmlns:revision:1.0" xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:svg="http://www.w3.org/2000/svg" xmlns:xhtml="http://www.w3.org/1999/xhtml" xmlns:xlink="http://www.w3.org/1999/xlink"><sheet id="49h3dmkalf1lbsn2ate9jopuba" modified-by="" style-id="487gi5ovjek2lvp9sjqneegdtc" theme="xminddefaultthemeid" timestamp="1511832908346" xmlns="urn:xmind:xmap:xmlns:content:2.0"><topic id="17mrtu3l8chvr316vtlolrv07t" modified-by="" structure-class="org.xmind.ui.logic.right" timestamp="1511832294246"><title>面向对象高级特性</title><extensions><extension provider="org.xmind.ui.map.unbalanced"><content><right-number>-1</right-number></content></extension></extensions><children><topics type="attached"><topic id="1paeq8kqq69qcoreld5icu5r7e" modified-by="" timestamp="1511746221190"><title>抽象</title><children><topics type="attached"><topic id="26lq6ojq91drvctqd194cmlj19" modified-by="" timestamp="1511746062378"><title>为什么会有抽象类</title><children><topics type="attached"><topic id="3flq27ks2u6m029ei8m064pjf1" modified-by="" timestamp="1511746060709"><title svg:width="500">当子类中都有一个共同的方法，每一个子类都有不同的实现，在父类中又要体现所有子类的共同的特点，所以要体现有这个方法，但是在父类中又无法给出具体的实现，那么这个时候就需要把这个方法声明为抽象的，而包含抽象方法的类，必须是抽象类</title></topic><topic id="56fh3u1p97qapvi46m1dek242b" modified-by="" timestamp="1511746062367"><title svg:width="500">某个父类仅仅是表示一个抽象的概念，不希望它被实例化，这个时候父类中可能没有抽象方法，但是我们也把它声明为抽象类</title></topic></topics></children></topic><topic id="123ijf5ufk02e9tkmv621643i8" modified-by="" timestamp="1511746077195"><title>如何声明抽象类</title><children><topics type="attached"><topic id="4nte0l0akjtd9l457l1gdoi2q1" modified-by="" timestamp="1511746081151"><title>语法格式</title><children><topics type="attached"><topic id="78sclc0ffelqj69gv8luujj2bl" modified-by="" timestamp="1511746082334"><title>[public/缺省] abstract class 类名{&#13;
}</title></topic></topics></children></topic></topics></children></topic><topic id="2s6ln2a41ik1mi005guu7p765b" modified-by="" timestamp="1511746096316"><title>如何声明抽象方法</title><children><topics type="attached"><topic id="7tinf1bmpm2jn2micln2jve6tt" modified-by="" timestamp="1511746101722"><title>语法格式</title><children><topics type="attached"><topic id="2mumclp913nt2ejnmknedj5mep" modified-by="" timestamp="1511746171478"><title svg:width="500">[public/protected/缺省]  abstract   返回值类型   方法名([形参列表]);</title><children><topics type="attached"><topic id="3u5381ju238ve24u8h89c2n34p" modified-by="" timestamp="1511746185994"><title>抽象方法是不能private,static,final修饰的</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="0d1jfqfrqcsnua5k2kngt17uvc" modified-by="" timestamp="1511746211072"><title>抽象类的特点</title><children><topics type="attached"><topic id="7ci60vi3d439aabh6la3bh5apt" modified-by="" timestamp="1511746212456"><title svg:width="500">（1）抽象类不能实例化&#13;
（2）抽象类可以包含抽象方法，也可以没有抽象方法。&#13;
如果一个类有抽象方法，那么这个类必须是抽象类，&#13;
如果一个抽象类没有抽象方法，那么它的用意是不想实例化，用它仅仅表示一个抽象的概念。&#13;
（3）抽象类生来就是用来被继承的，那么子类在继承它的时候，必须重写（实现）抽象父类的抽象方法，&#13;
否则该子类也得是抽象类。&#13;
（4）抽象类的变量与子类的对象构成多态引用。&#13;
（5）抽象类除了不能实例化，可以包含抽象方法，其他的和非抽象类是一样的，&#13;
可以有成员变量（类变量、实例变量）、构造器、代码块（静态代码块和非静态代码块）&#13;
方法（静态方法、非静态方法）</title></topic></topics></children></topic><topic id="2ff3r3hk6t1gva75bht27r6p31" modified-by="" timestamp="1511746228241"><title>抽象类不能实例化，为什么要有构造器呢？</title><children><topics type="attached"><topic id="7hljroh7pr5a9an2qtk8iks6jd" modified-by="" timestamp="1511746233915"><title svg:width="500">子类在继承该类时，一定要调用它的构造器，为属性初始化。</title><children><topics type="attached"><topic id="3dp2qh9n1p52f49hpvfbkjous8" modified-by="" timestamp="1511746262782"><title>因为构造器的作用有两点</title><children><topics type="attached"><topic id="01ujrfombs96jta9iln15lunna" modified-by="" timestamp="1511746262111"><title>（1）和new一起创建对象</title></topic><topic id="4kssbig2sem414f7i5bmoc464c" modified-by="" timestamp="1511746274933"><title>（2）为属性初始化</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="689idmgjbepi4ep6e5c9ktn66i" modified-by="" timestamp="1511747076644"><title>接口</title><children><topics type="attached"><topic id="5ucmhu24dj50qkppneuq5g68o9" modified-by="" timestamp="1511746785541"><title>接口即代表行为标准，功能标准</title></topic><topic id="4da2cknbt8vhqhjhfp1g7q2t2u" modified-by="" timestamp="1511746986735"><title>如何声明一个接口？</title><children><topics type="attached"><topic id="4tgoe6vuqilq7bo70n04hmjt79" modified-by="" timestamp="1511746992062"><title>语法结构</title><children><topics type="attached"><topic id="5igv1qs304u3fcf2e8857m5hkq" modified-by="" timestamp="1511746993186"><title>[public/缺省] interface 接口名{&#13;
}</title></topic></topics></children></topic></topics></children></topic><topic id="12mht89p2484t7apl6pkckl5v4" modified-by="" timestamp="1511747006749"><title>如何实现接口？</title><children><topics type="attached"><topic id="4nrn13nokgabbgvkpg4adfullg" modified-by="" timestamp="1511747023551"><title>语法结构</title><children><topics type="attached"><topic id="0jk10oauuk4he90o7uip7875l3" modified-by="" timestamp="1511747024980"><title svg:width="500">[public/缺省] class 子类名 [extends 父类名] implements  接口名1，接口名2。。。{&#13;
	//要实现接口的所有抽象方法&#13;
}</title></topic></topics></children></topic></topics></children></topic><topic id="5o8cp338iokj94q9feebr93e9i" modified-by="" timestamp="1511747134822"><title>接口的特点</title><children><topics type="attached"><topic id="24eln82jcppeijs8aaqj8jo9sa" modified-by="" timestamp="1511747112136"><title>JDK1.7</title><children><topics type="attached"><topic id="30php8rsf5hlg8oj2f6ccckk16" modified-by="" timestamp="1511747114072"><title svg:width="500">JDK1.7：&#13;
（1）接口不能实例化&#13;
（2）接口只能有全局静态的常量和公共的抽象方法&#13;
（3）接口中不能有构造器，因为它没有属性需要初始化，又不能创建对象&#13;
（4）接口生来用来被实现的，那么实现类（像子类）在实现它时，必须实现（和重写要求一样）接口的&#13;
所有抽象方法，否则该实现类也得是抽象类&#13;
（5）一个类可以同时实现多个接口&#13;
（6）一个类还可以继承父类又实现接口，但是必须先继承后实现&#13;
（7）接口与接口之间是继承关系，一个接口可以继承多个接口&#13;
（8）接口与实现类的对象之间构成多态引用</title></topic></topics></children></topic><topic id="6611cktbpm1cpgjskjvlmbt3o7" modified-by="" timestamp="1511747145811"><title>JDK1.8</title><children><topics type="attached"><topic id="6sisbmqcmhc2k58v0ie07tqob2" modified-by="" timestamp="1511747209402"><title svg:width="500">其他的和JDK1.7一样，不一样的是：&#13;
JDK1.8之后，接口中除了全局静态的常量和公共的抽象方法以外，可以有静态方法和默认方法</title><children><topics type="attached"><topic id="3tqv5qo96euci3f05qttp6pc7g" modified-by="" timestamp="1511747196151"><title>接口中的静态方法</title><children><topics type="attached"><topic id="7v80fhtoo1rb64v28t0c6b0riv" modified-by="" timestamp="1511747194942"><title svg:width="500">当接口的所有实现类，对这个方法的实现是一样的，这个方法就设计在接口中，设计为静态方法</title></topic><topic id="3ho2il8t1s3hlf5309dtmanhf1" modified-by="" timestamp="1511747200572"><title>如何调用</title><children><topics type="attached"><topic id="14ngpp1dokp2r4o9st528o5k07" modified-by="" timestamp="1511747205688"><title>接口名.方法</title></topic></topics></children></topic></topics></children></topic><topic id="3ci070vn5iertsm1k055sgmjk3" modified-by="" timestamp="1511747466454"><title>接口中的默认方法</title><children><topics type="attached"><topic id="57gf1e45aea59rqadcd3rm9ofd" modified-by="" timestamp="1511747261595"><title svg:width="500">当接口的大多数实现类，对这个方法的实现是一样，那么这个方法的实现就可以在接口中提供默认实现，如果某个实现类觉得他不合适，只需要重写它即可</title></topic><topic id="3ueqak93ahucgjdkmqs74qdh33" modified-by="" timestamp="1511747302860"><title>如何调用</title><children><topics type="attached"><topic id="3qh3souakitd10m8g054ht1m7h" modified-by="" timestamp="1511747302037"><title>实现类外</title><children><topics type="attached"><topic id="3aqguqh5qs2mcjcl3id7kvsrd8" modified-by="" timestamp="1511747302018"><title>实现类对象.方法</title></topic></topics></children></topic><topic id="3mav7dkjk2k3ageo2d7dg12v8b" modified-by="" timestamp="1511747329806"><title>实现类中</title><children><topics type="attached"><topic id="68lh8jqu05h48l9cqh772c67hm" modified-by="" timestamp="1511747328308"><title svg:width="500">如果实现类要重写该默认方法，但是又想调用接口中的默认实现</title></topic><topic id="2fihn3q16ealhkj9c90nmnipo7" modified-by="" timestamp="1511747339312"><title>接口名.super.方法</title></topic></topics></children></topic></topics></children></topic><topic id="1pfec4j3q62g3lel02u0koqlag" modified-by="" timestamp="1511747376830"><title>什么情况下需要重写</title><children><topics type="attached"><topic id="13ojndejcqqdddbgju9d6jrnbn" modified-by="" timestamp="1511747373525"><title>接口中的默认实现不适合该实现类</title></topic><topic id="4m95lf2fevuv6ib1tr1c80gaq7" modified-by="" timestamp="1511747383155"><title>必须重写</title><children><topics type="attached"><topic id="6l0g11t7hfb47h9mjqd2aq3op6" modified-by="" timestamp="1511747454317"><title svg:width="500">一个类同时实现了多个接口，而多个接口中都相同的默认方法（方法名和形参列表都相同），这个时候实现类必须做出选择，要重写，如果需要保留其中一个的话，通过接口名.super.方法，保留它的默认实现</title></topic></topics></children></topic></topics></children></topic><topic id="6lrim758b6mrpod9uo3t4m44jj" modified-by="" timestamp="1511747475302"><title>类优先原则</title><children><topics type="attached"><topic id="4cs419onrk99p5519s53njqc7l" modified-by="" timestamp="1511747524680"><title svg:width="500">当一个类继承了父类，又实现了接口，而且父类中的某个方法与接口中的默认方法一样（方法名和形参列表），默认保留的是父类中的方法实现</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="7ia5a5520b8e8d8ei531imdsac" modified-by="" timestamp="1511832345324"><title>枚举</title><children><topics type="attached"><topic id="1j0vdmir49eefkm55jcufsklvg" modified-by="" timestamp="1511832334881"><title svg:width="500">枚举是指某个类型的对象是有限个，在类型中一一创建并列举它的对象</title></topic><topic id="65t48r4dd5sndlsfam6rkp9j0u" modified-by="" timestamp="1511832383251"><title>JDK1.5之前，如何解决</title><children><topics type="attached"><topic id="3omaj95f2kgf76kof7qje1fave" modified-by="" timestamp="1511832369927"><title>（1）构造器私有化</title></topic><topic id="16v4k852661sm5j02hmji73qpo" modified-by="" timestamp="1511832381966"><title>（2）通过常量的方式创建好所有对象</title></topic><topic id="48domp1vd060almp5nb2ggfu8b" modified-by="" timestamp="1511832417126"><title>示例</title><notes><html><xhtml:p>class Week{</xhtml:p><xhtml:p>	public static final Week MONDAY = new Week();</xhtml:p><xhtml:p>	public static final Week TUESDAY = new Week();</xhtml:p><xhtml:p>	public static final Week WEDNESDAY = new Week();</xhtml:p><xhtml:p>	public static final Week THURSDAY = new Week();</xhtml:p><xhtml:p>	public static final Week FRIDAY = new Week();</xhtml:p><xhtml:p>	public static final Week SATURDAY = new Week();</xhtml:p><xhtml:p>	public static final Week SUNDAY = new Week();</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>	private Week(){</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p/><xhtml:p/><xhtml:p>Week w = Week.MONDAY;</xhtml:p></html><plain>class Week{&#13;
	public static final Week MONDAY = new Week();&#13;
	public static final Week TUESDAY = new Week();&#13;
	public static final Week WEDNESDAY = new Week();&#13;
	public static final Week THURSDAY = new Week();&#13;
	public static final Week FRIDAY = new Week();&#13;
	public static final Week SATURDAY = new Week();&#13;
	public static final Week SUNDAY = new Week();&#13;
	&#13;
	private Week(){&#13;
		&#13;
	}&#13;
}&#13;
&#13;
&#13;
Week w = Week.MONDAY;</plain></notes></topic></topics></children></topic><topic id="0mtbis72dor198m903rlr8hbtr" modified-by="" timestamp="1511832491652"><title>JDK1.5之后，如何解决</title><children><topics type="attached"><topic id="5lpd8tddk3fr03qot6rr1tur1t" modified-by="" timestamp="1511832486061"><title>如何声明</title><children><topics type="attached"><topic id="1qokinkjcg5v0vkvqmokm4mhnv" modified-by="" timestamp="1511832472742"><title>[修饰符] enum  枚举类型名{&#13;
	常量对象列表&#13;
}</title></topic><topic id="0pspajk423pg160pqcef1ss3g1" modified-by="" timestamp="1511832487609"><title>[修饰符] enum  枚举类型名{&#13;
	常量对象列表;&#13;
	其他成员;&#13;
}</title></topic></topics></children></topic><topic id="0kitt3dt52hi3v44gcpa45cslj" modified-by="" timestamp="1511832830624"><title>特点</title><children><topics type="attached"><topic id="1aqosu7ifs8d5h0dko7bkgbfqj" modified-by="" timestamp="1511832519457"><title>（1）枚举类型中的构造器都是私有化</title></topic><topic id="32c97albste0k5bmcot59ji8fo" modified-by="" timestamp="1511832546476"><title svg:width="500">（2）常量对象列表必须在首行，如果常量对象列表后面还有其他的代码，那么要用;结束</title></topic><topic id="66bvntbi20d3e41i65j85or9dl" modified-by="" timestamp="1511832762090"><title svg:width="500">（3）枚举类型不能继承别的类型，因为它默认继承java.lang.Enum</title><children><topics type="attached"><topic id="5imsvrabh4u58hbdenskuvqksv" modified-by="" timestamp="1511832741911"><title>它有一些方法</title><children><topics type="attached"><topic id="2en4e889vp49l0adodbpan6l4n" modified-by="" timestamp="1511832610160"><title>name()</title><children><topics type="attached"><topic id="2onobn15p3d90oo1jvuq6l8fgp" modified-by="" timestamp="1511832619099"><title>返回常量对象名</title></topic></topics></children></topic><topic id="16r3fftdfs7b6hk72hpf3ebebs" modified-by="" timestamp="1511832624528"><title>ordinal()</title><children><topics type="attached"><topic id="7bp0a4o08dlbuvb54472dphcvq" modified-by="" timestamp="1511832636602"><title>返回常量对象的序号，从0开始</title></topic></topics></children></topic><topic id="1opncbqtbhv7blr0g8imppbjkq" modified-by="" timestamp="1511832670253"><title svg:width="500">实现了java.lang.Comparable接口，重写compareTo()，按照常量对象的顺序排序</title><children><topics type="attached"><topic id="66v5169umvf91v01n665bhhhab" modified-by="" timestamp="1511832684812"><title>如果自己的枚举类中不适合，可以重写</title></topic></topics></children></topic><topic id="3i64hb27fv50q4upi66h26uemd" modified-by="" timestamp="1511832748662"><title>toString()</title><children><topics type="attached"><topic id="4i6iadg1m3007utrc9b05aeehg" modified-by="" timestamp="1511832750046"><title>返回常量对象名</title><children><topics type="attached"><topic id="07i5bubda8p6nnil79ngvlke4t" modified-by="" timestamp="1511832752852"><title>可以重写</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="7chqneahq8uauc9nfghf89adrg" modified-by="" timestamp="1511832793557"><title>API中没有的方法</title><children><topics type="attached"><topic id="7gk0ondc2g2slp3vmjtnrhvbt3" modified-by="" timestamp="1511832783117"><title>枚举类型名.values()</title><children><topics type="attached"><topic branch="folded" id="2ionc3k8atllnajog1noa4kdce" modified-by="" timestamp="1511832792630"><title>返回枚举常量对象组成的数组</title></topic></topics></children></topic><topic id="2u9acbec8p04ovubkv0g2v5spg" modified-by="" timestamp="1511832811881"><title>枚举类型名.valueOf（常量对象的名称）</title><children><topics type="attached"><topic id="1mqtj04mdkb2ahagmna2tc8im0" modified-by="" timestamp="1511832822714"><title>返回某一个指定的对象</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="6lnia719nojagpv5imdg3pdeha" modified-by="" timestamp="1511832907003"><title>（4）switch对枚举加入支持</title><children><topics type="attached"><topic id="2hqdc4jacooj2mab1ms6ue3388" modified-by="" timestamp="1511832908346"><title>switch(枚举类型表达式){&#13;
	case 常量对象名1:&#13;
		语句;&#13;
		[break;]&#13;
	case 常量对象名2:&#13;
		语句;&#13;
		[break;]&#13;
	case 常量对象名3:&#13;
		语句;&#13;
		[break;]	&#13;
	default:&#13;
		语句;&#13;
		[break;]		&#13;
}</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><title>面向对象高级特性</title></sheet></xmap-revision-content>