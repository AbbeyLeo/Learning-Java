<?xml version="1.0" encoding="UTF-8" standalone="no"?><xmap-revision-content xmlns="urn:xmind:xmap:xmlns:revision:1.0" xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:svg="http://www.w3.org/2000/svg" xmlns:xhtml="http://www.w3.org/1999/xhtml" xmlns:xlink="http://www.w3.org/1999/xlink"><sheet id="0ueglmqr6dn1n0tviquelns49n" modified-by="" style-id="21qrlcven7bqj5m8c9moe6ceo2" theme="xminddefaultthemeid" timestamp="1513156953233" xmlns="urn:xmind:xmap:xmlns:content:2.0"><topic id="1c010d86hfph99amsfrkeiqd7h" modified-by="" structure-class="org.xmind.ui.logic.right" timestamp="1513126675220"><title>网络编程</title><extensions><extension provider="org.xmind.ui.map.unbalanced"><content><right-number>-1</right-number></content></extension></extensions><children><topics type="attached"><topic id="6nf4tgasm02epefq4vujhl8vk4" modified-by="" timestamp="1513126663978"><title>网络编程的三个要素</title><children><topics type="attached"><topic id="1697o2nsp2npr35t6c6m7dv8ad" modified-by="" timestamp="1513125833728"><title>1、IP地址或主机名</title><children><topics type="attached"><topic id="7171sv2jglc3u3sqqbu5gg68r2" modified-by="" timestamp="1513125773630"><title>InetAddress</title></topic><topic id="2mb2re9od0adbeibgp30rfsa9i" modified-by="" timestamp="1513125798673"><title>String：192.168.24.71</title><children><topics type="attached"><topic id="49238c2c55nodveo9gho55bacm" modified-by="" timestamp="1513125816264"><title>每一个整数是1~255</title></topic></topics></children></topic><topic id="1legip3lk7o2l2ku38s03j22ed" modified-by="" timestamp="1513125854325"><title>域名：www.baidu.com</title><children><topics type="attached"><topic id="0i0mqf6b2uh710kmi2p4e5tnqi" modified-by="" timestamp="1513125869082"><title>通过域名解析器，找对对应的ip地址</title></topic></topics></children></topic></topics></children></topic><topic id="1a8puhf1t0lgq228pv6jdc7t80" modified-by="" timestamp="1513125882881"><title>2、端口号</title><children><topics type="attached"><topic id="3qvmgnm8l0ii7iq081qrnemvik" modified-by="" timestamp="1513125881945"><title>0~65535</title></topic><topic id="2g23os4klkbe6bg57puo8mkb37" modified-by="" timestamp="1513126043763"><title>建议不要使用</title><children><topics type="attached"><topic id="0tof13ikl9jg72aikvs9p37ned" modified-by="" timestamp="1513125902046"><title>0~1023</title><children><topics type="attached"><topic id="3roq2n0idg8b74d3glnkc7rmva" modified-by="" timestamp="1513125913026"><title>用于基础服务</title></topic></topics></children></topic><topic id="5mu3qobh1cofuogejjgc5ho470" modified-by="" timestamp="1513125932211"><title>tomcat/jboss</title><children><topics type="attached"><topic id="5fnp7c7ijdjeqnpmg4ne9jcjg6" modified-by="" timestamp="1513125934598"><title>8080</title></topic></topics></children></topic><topic id="03fuldobb4p3d96hc41mil834h" modified-by="" timestamp="1513125939222"><title>mysql</title><children><topics type="attached"><topic id="3dhe3as8naq8tii48i0id87eeq" modified-by="" timestamp="1513125942402"><title>3306</title></topic></topics></children></topic><topic id="386g3js53gk0jc97m5esh8356t" modified-by="" timestamp="1513125946718"><title>oracle</title><children><topics type="attached"><topic id="0o8ceatd12s45poihpi1ri3ln0" modified-by="" timestamp="1513125949609"><title>1521</title></topic></topics></children></topic><topic id="3a6l8m4l6uu485svmc1bam8nrh" modified-by="" timestamp="1513125981336"><title>sql server</title><children><topics type="attached"><topic id="3pj0haetc3j5ripb5dq0kf0bgr" modified-by="" timestamp="1513125983795"><title>1433</title></topic></topics></children></topic><topic id="1j4li937k0docugtaqk83trq5s" modified-by="" timestamp="1513126001525"><title>浏览器：http</title><children><topics type="attached"><topic id="1sgfcu0rl55a2b5134cngh9tt3" modified-by="" timestamp="1513126003480"><title>80</title></topic></topics></children></topic><topic id="0iqrejft4i025atl1do5qqmtq5" modified-by="" timestamp="1513126046400"><title>....</title></topic></topics></children></topic></topics></children></topic><topic id="0basbhi32vaeavltr31hmq8hq6" modified-by="" timestamp="1513126296543"><title>3、网络协议</title><children><topics type="attached"><topic id="3hf0afifitcvj0ku9nh63up4bh" modified-by="" timestamp="1513126145147"><title>OSI理想参考模型</title><children><topics type="attached"><topic id="0b6fvop58pme09dg3f58qssdl8" modified-by="" timestamp="1513126157396"><title/><xhtml:img svg:height="270" svg:width="400" xhtml:src="xap:attachments/7roa36aup22ncer11a4cu3fmof.png"/></topic></topics></children></topic><topic id="7oh7fkcbpi0p93u76aif8108ij" modified-by="" timestamp="1513126074331"><title>TCP/IP的四层实现模式</title></topic><topic id="341i1qrekhlearksecpmtpqmji" modified-by="" timestamp="1513126175639"><title>传输层</title><children><topics type="attached"><topic id="6mkdvvrln5036l14kgcj8mpku1" modified-by="" timestamp="1513126182566"><title>TCP</title><children><topics type="attached"><topic id="37s193d5123nkc7dv0gseitd8a" modified-by="" timestamp="1513126255206"><title svg:width="500">面向连接的，可靠的，适用于大数据传输，速率相对低，在传输之前会先“三次握手”，在断开之前会“四次挥手”</title></topic></topics></children></topic><topic id="5nsj71o1m4t5lm3nil98d2ti94" modified-by="" timestamp="1513126257015"><title>UDP</title><children><topics type="attached"><topic id="55jf1s0pq4ei87c04g4g4n9636" modified-by="" timestamp="1513126290273"><title svg:width="500">非面向连接的，不可靠的，适用于数据比较小的，&lt;=64kb，相对速率高</title></topic></topics></children></topic></topics></children></topic><topic id="1g7p8gbnipuqsuc31vsagg12fs" modified-by="" timestamp="1513126337306"><title>应用层</title><children><topics type="attached"><topic id="5h313qpnmqngv6ptmtptpognpg" modified-by="" timestamp="1513126313223"><title>http/https</title></topic><topic id="6okgv94bnev9nhk4mu2p7hqij4" modified-by="" timestamp="1513126327807"><title>ftp</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="0r60u8fdag6oj17f3a9ja15kf6" modified-by="" timestamp="1513127349905"><title>网络编程的API</title><children><topics type="attached"><topic id="2lt26rs3ujlanpaehn3iruvjcv" modified-by="" timestamp="1513126436711"><title>Socket</title><children><topics type="attached"><topic id="7s1g58c47o5eiujkb3uifnm0gs" modified-by="" timestamp="1513126435615"><title>套接字</title><children><topics type="attached"><topic id="5ck80pu7a8j6e1ftemj35ifo98" modified-by="" timestamp="1513126427049"><title>表示通信的两个端点，两边各一个</title></topic></topics></children></topic><topic id="0enbou8bpr1ee855qopi7l82mc" modified-by="" timestamp="1513126463356"><title>分类</title><children><topics type="attached"><topic id="3ufbobl8go02o2jshlo93mfskr" modified-by="" timestamp="1513126448255"><title>流套接字</title><children><topics type="attached"><topic id="7em86tej40qq7ijm85ui4snvjm" modified-by="" timestamp="1513126460510"><title>用于TCP的通信</title><children><topics type="attached"><topic id="092monpkfg7rf8cp8u7qcl7leg" modified-by="" timestamp="1513126488875"><title>ServerSocket</title><children><topics type="attached"><topic id="4qfrv3kdmv1qq2ltokmsgqon69" modified-by="" timestamp="1513126507749"><title>转门用于服务器用来监听和接收客户端的连接</title></topic></topics></children></topic><topic id="1funle3cpjek3ipktdmggtf8rd" modified-by="" timestamp="1513126509044"><title>Socket</title><children><topics type="attached"><topic id="7p6spgtj1v740ldohgrcie5kbr" modified-by="" timestamp="1513126521304"><title>用于服务器和客户端的通信</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="7m1c7g98k1lade2krdlupkn7mn" modified-by="" timestamp="1513126471210"><title>数据报套接字</title><children><topics type="attached"><topic id="2hkq5911m8f2p84a0en07cppaf" modified-by="" timestamp="1513126477642"><title>用于UDP的通信</title><children><topics type="attached"><topic id="08r4gv9jke26tajqbtqgcnbtgu" modified-by="" timestamp="1513126527397"><title>DatagramSocket</title><children><topics type="attached"><topic id="6fsn7f9r4sj3cge4dojqa5qqcp" modified-by="" timestamp="1513126535914"><title>用于UDP的两端的通信</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="1k3dsspeq9bvll3p2aoq7km3pa" modified-by="" timestamp="1513156923512"><title>TCP编程步骤</title><children><topics type="attached"><topic id="03k36sg77c3q549idklke15m8n" modified-by="" timestamp="1513126939219"><title>服务器</title><children><topics type="attached"><topic id="31qg71ci2f8fahf8eiht0au6iu" modified-by="" timestamp="1513126710409"><title>1、先创建ServerSocket</title><children><topics type="attached"><topic id="63916l72ttmo8k15v3hrglahb1" modified-by="" timestamp="1513126760223"><title svg:width="500">ServerSocket server = new ServerSocket(端口号);</title><children><topics type="attached"><topic id="6161m9kdjos9omgltgpd7teg5a" modified-by="" timestamp="1513126789492"><title svg:width="500">指定端口号进行监听，客户端通过这个端口号与它进行连接和通信</title></topic></topics></children></topic></topics></children></topic><topic id="7o05onj69h59kn3n1rj3tfsht5" modified-by="" timestamp="1513126808694"><title>2、接收客户端的连接</title><children><topics type="attached"><topic id="6vv455tfhfp5q9utii7b66mfmq" modified-by="" timestamp="1513126835008"><title>Socket socket = server.accept();</title><children><topics type="attached"><topic id="763jlk3fi6mjslfm8o16f899th" modified-by="" timestamp="1513126834085"><title>每一个客户端就要有自己的一个Socket</title></topic><topic id="6rgdt5kk54u3n2jganufmrvcot" modified-by="" timestamp="1513126873847"><title svg:width="500">如果希望不同的客户端通信“同时”进行，需要每一个socket用一个线程进行维护</title></topic></topics></children></topic></topics></children></topic><topic id="4gjfej78i0acm0utmds76j5bm0" modified-by="" timestamp="1513126906948"><title>3、通过socket进行收或发消息</title><children><topics type="attached"><topic id="5r7bstoqo8gqgfdbcufkepmfp0" modified-by="" timestamp="1513126893403"><title>收消息</title><children><topics type="attached"><topic id="0sm8c7cg8kdlcnt4skhjtlh6uq" modified-by="" timestamp="1513126956977"><title>InputStream is = socket.getInputStream();</title><children><topics type="attached"><topic id="5dfnm6bee8drea2s92s2ue9fnu" modified-by="" timestamp="1513126986385"><title svg:width="500">可以在此基础上，包装缓冲流，转换流，对象流，打印流，数据流等</title></topic></topics></children></topic></topics></children></topic><topic id="7578hco9s1qsoftt3dbdt0nvla" modified-by="" timestamp="1513126910624"><title>发消息</title><children><topics type="attached"><topic id="2lcssp2qlu1jlclnr5rq9c8b2d" modified-by="" timestamp="1513126988330"><title svg:width="500">OutputStream out = socket.getOutputStream();</title><children><topics type="attached"><topic id="251aobqgleiih0lliliirr3ubc" modified-by="" timestamp="1513126988313"><title svg:width="500">可以在此基础上，包装缓冲流，转换流，对象流，打印流，数据流等</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="55f62vvb34g22beari35bgg7p7" modified-by="" timestamp="1513126948577"><title>4、与客户端断开连接</title><children><topics type="attached"><topic id="18on5iqg7a0etdven0j1n0nrdb" modified-by="" timestamp="1513126953881"><title>socket.close();</title></topic></topics></children></topic></topics></children></topic><topic id="7b217srgahe02eglbkph2pdutb" modified-by="" timestamp="1513127050519"><title>客户端</title><children><topics type="attached"><topic id="183vgbbae6tplfkj2em24niiu9" modified-by="" timestamp="1513127017947"><title svg:width="500">1、先与服务器建立连接，通过创建一个Socket，要指定服务器的IP和端口号</title><children><topics type="attached"><topic id="5aqe0vt7br498hjlgg79fnja1i" modified-by="" timestamp="1513127040523"><title svg:width="500">Socket socket = new Socket(服务器的IP，服务器的监听端口号);</title></topic></topics></children></topic><topic id="2puks23ipt38n6kmp0i7pd68mj" modified-by="" timestamp="1513127055313"><title>2、通过socket进行收或发消息</title><children><topics type="attached"><topic id="2a66jgsgh0en6tt0u0jd2bro2s" modified-by="" timestamp="1513126893403"><title>收消息</title><children><topics type="attached"><topic id="69v8jm7k9c4uc158s9b30l8mme" modified-by="" timestamp="1513126956977"><title>InputStream is = socket.getInputStream();</title><children><topics type="attached"><topic id="5thut9qespp0k3n94k29jrs1me" modified-by="" timestamp="1513126986385"><title svg:width="500">可以在此基础上，包装缓冲流，转换流，对象流，打印流，数据流等</title></topic></topics></children></topic></topics></children></topic><topic id="6s0b0gd4s4rbmqji9bbk2vqud5" modified-by="" timestamp="1513126910624"><title>发消息</title><children><topics type="attached"><topic id="2e29cic4ljk5qg87gtsgp49sj8" modified-by="" timestamp="1513126988330"><title svg:width="500">OutputStream out = socket.getOutputStream();</title><children><topics type="attached"><topic id="4g8gcrgaljq1rtedfcti0va4sb" modified-by="" timestamp="1513126988313"><title svg:width="500">可以在此基础上，包装缓冲流，转换流，对象流，打印流，数据流等</title></topic></topics></children></topic></topics></children></topic><topic id="5hlnbqs36uskgmp23n58qob1ns" modified-by="" timestamp="1513127064158"><title>收和发可以用不同的线程进行维护</title></topic></topics></children></topic><topic id="4kun58ecmvjb1s27m6u72mv8ge" modified-by="" timestamp="1513127053573"><title>3、与客户端断开连接</title><children><topics type="attached"><topic id="13lcou76d7db1sl6bpjtjrhkdj" modified-by="" timestamp="1513126953881"><title>socket.close();</title></topic></topics></children></topic></topics></children></topic><topic id="45mfki2n32ddjg9rp64c7bvufm" modified-by="" timestamp="1513156910471"><title>示例一</title><notes><html><xhtml:p>package com.atguigu.tcp1;</xhtml:p><xhtml:p/><xhtml:p>import java.io.InputStream;</xhtml:p><xhtml:p>import java.io.OutputStream;</xhtml:p><xhtml:p>import java.net.ServerSocket;</xhtml:p><xhtml:p>import java.net.Socket;</xhtml:p><xhtml:p/><xhtml:p>import org.junit.Test;</xhtml:p><xhtml:p/><xhtml:p>/*</xhtml:p><xhtml:p> * TCP:面向连接</xhtml:p><xhtml:p> * 通信的两端分角色：服务器端和客户端</xhtml:p><xhtml:p> * </xhtml:p><xhtml:p> * 服务器端等着被连接，客户端主动连接</xhtml:p><xhtml:p> * </xhtml:p><xhtml:p> * 服务器端：</xhtml:p><xhtml:p> * 1、ServerSocket：用来接收客户端的连接信息</xhtml:p><xhtml:p> * 2、Socket：用来与某个客户端进行通信</xhtml:p><xhtml:p> * </xhtml:p><xhtml:p> * 客户端：</xhtml:p><xhtml:p> * 1、Socket：用来与服务器进行通信</xhtml:p><xhtml:p> * </xhtml:p><xhtml:p> */</xhtml:p><xhtml:p>public class TestTCP1 {</xhtml:p><xhtml:p>	@Test</xhtml:p><xhtml:p>	public void server()throws Exception{</xhtml:p><xhtml:p>		//1、创建ServerSocket，看成：开启服务器 ，需要指定一个端口号，监听是否有客户端来连接</xhtml:p><xhtml:p>		ServerSocket ss = new ServerSocket(9090);</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		while(true){</xhtml:p><xhtml:p>			System.out.println("等待您的链接....");</xhtml:p><xhtml:p>			//2、等待客户端的连接，接收客户端的连接（如果没有人连接，那么这句代码会阻塞）</xhtml:p><xhtml:p>			//一旦有客户端连接成功，那么就会产生一个Socket对象，专门负责和这个客户端通信</xhtml:p><xhtml:p>			Socket socket = ss.accept();</xhtml:p><xhtml:p>			</xhtml:p><xhtml:p>			System.out.println(socket.getInetAddress().getHostAddress()+"连接成功");</xhtml:p><xhtml:p>			</xhtml:p><xhtml:p>			//3、可以接收消息，或发生消息</xhtml:p><xhtml:p>			//例如：先发：“欢迎登陆”</xhtml:p><xhtml:p>			//在接收消息</xhtml:p><xhtml:p>			</xhtml:p><xhtml:p>			//发消息：输出流，OutputStream</xhtml:p><xhtml:p>			OutputStream output = socket.getOutputStream();</xhtml:p><xhtml:p>			output.write("欢迎登陆".getBytes());</xhtml:p><xhtml:p>			socket.shutdownOutput();</xhtml:p><xhtml:p>			</xhtml:p><xhtml:p>			//收消息</xhtml:p><xhtml:p>			InputStream is = socket.getInputStream();</xhtml:p><xhtml:p>			</xhtml:p><xhtml:p>			byte[] data = new byte[1024];</xhtml:p><xhtml:p>			int len;</xhtml:p><xhtml:p>			StringBuilder sb = new StringBuilder();</xhtml:p><xhtml:p>			while((len= is.read(data)) !=-1){</xhtml:p><xhtml:p>				sb.append(new String(data,0,len));</xhtml:p><xhtml:p>			}</xhtml:p><xhtml:p>			System.out.println("服务器收到的消息：" + sb);</xhtml:p><xhtml:p>			</xhtml:p><xhtml:p>			//4、关闭连接</xhtml:p><xhtml:p>			socket.close();//只是与某个客户端断开</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//5、服务器关闭</xhtml:p><xhtml:p>//		ss.close();</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>	@Test</xhtml:p><xhtml:p>	public void client()throws Exception{</xhtml:p><xhtml:p>		//1、创建一个Socket，要指定服务器的IP和端口号</xhtml:p><xhtml:p>		Socket socket = new Socket("192.168.24.71",9090);</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//2、接收消息</xhtml:p><xhtml:p>		InputStream is = socket.getInputStream();</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		byte[] data = new byte[1024];</xhtml:p><xhtml:p>		int len;</xhtml:p><xhtml:p>		StringBuilder sb = new StringBuilder();</xhtml:p><xhtml:p>		while((len= is.read(data)) !=-1){</xhtml:p><xhtml:p>			sb.append(new String(data,0,len));</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>		System.out.println("客户端收到的消息：" + sb);</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//3、发送消息</xhtml:p><xhtml:p>		String info = "马上吃饭了";</xhtml:p><xhtml:p>		OutputStream out = socket.getOutputStream();</xhtml:p><xhtml:p>		out.write(info.getBytes());</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//3、关闭连接</xhtml:p><xhtml:p>		socket.close();</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p/></html><plain>package com.atguigu.tcp1;&#13;
&#13;
import java.io.InputStream;&#13;
import java.io.OutputStream;&#13;
import java.net.ServerSocket;&#13;
import java.net.Socket;&#13;
&#13;
import org.junit.Test;&#13;
&#13;
/*&#13;
 * TCP:面向连接&#13;
 * 通信的两端分角色：服务器端和客户端&#13;
 * &#13;
 * 服务器端等着被连接，客户端主动连接&#13;
 * &#13;
 * 服务器端：&#13;
 * 1、ServerSocket：用来接收客户端的连接信息&#13;
 * 2、Socket：用来与某个客户端进行通信&#13;
 * &#13;
 * 客户端：&#13;
 * 1、Socket：用来与服务器进行通信&#13;
 * &#13;
 */&#13;
public class TestTCP1 {&#13;
	@Test&#13;
	public void server()throws Exception{&#13;
		//1、创建ServerSocket，看成：开启服务器 ，需要指定一个端口号，监听是否有客户端来连接&#13;
		ServerSocket ss = new ServerSocket(9090);&#13;
		&#13;
		while(true){&#13;
			System.out.println("等待您的链接....");&#13;
			//2、等待客户端的连接，接收客户端的连接（如果没有人连接，那么这句代码会阻塞）&#13;
			//一旦有客户端连接成功，那么就会产生一个Socket对象，专门负责和这个客户端通信&#13;
			Socket socket = ss.accept();&#13;
			&#13;
			System.out.println(socket.getInetAddress().getHostAddress()+"连接成功");&#13;
			&#13;
			//3、可以接收消息，或发生消息&#13;
			//例如：先发：“欢迎登陆”&#13;
			//在接收消息&#13;
			&#13;
			//发消息：输出流，OutputStream&#13;
			OutputStream output = socket.getOutputStream();&#13;
			output.write("欢迎登陆".getBytes());&#13;
			socket.shutdownOutput();&#13;
			&#13;
			//收消息&#13;
			InputStream is = socket.getInputStream();&#13;
			&#13;
			byte[] data = new byte[1024];&#13;
			int len;&#13;
			StringBuilder sb = new StringBuilder();&#13;
			while((len= is.read(data)) !=-1){&#13;
				sb.append(new String(data,0,len));&#13;
			}&#13;
			System.out.println("服务器收到的消息：" + sb);&#13;
			&#13;
			//4、关闭连接&#13;
			socket.close();//只是与某个客户端断开&#13;
		}&#13;
		&#13;
		//5、服务器关闭&#13;
//		ss.close();&#13;
	}&#13;
	&#13;
	@Test&#13;
	public void client()throws Exception{&#13;
		//1、创建一个Socket，要指定服务器的IP和端口号&#13;
		Socket socket = new Socket("192.168.24.71",9090);&#13;
		&#13;
		//2、接收消息&#13;
		InputStream is = socket.getInputStream();&#13;
		&#13;
		byte[] data = new byte[1024];&#13;
		int len;&#13;
		StringBuilder sb = new StringBuilder();&#13;
		while((len= is.read(data)) !=-1){&#13;
			sb.append(new String(data,0,len));&#13;
		}&#13;
		System.out.println("客户端收到的消息：" + sb);&#13;
		&#13;
		//3、发送消息&#13;
		String info = "马上吃饭了";&#13;
		OutputStream out = socket.getOutputStream();&#13;
		out.write(info.getBytes());&#13;
		&#13;
		//3、关闭连接&#13;
		socket.close();&#13;
	}&#13;
}&#13;
</plain></notes></topic><topic id="7d2qku46k8n0spad6i8r2t88mi" modified-by="" timestamp="1513156922632"><title>示例二</title><notes><html><xhtml:p>package com.atguigu.tcp2;</xhtml:p><xhtml:p/><xhtml:p>import java.io.BufferedReader;</xhtml:p><xhtml:p>import java.io.IOException;</xhtml:p><xhtml:p>import java.io.InputStream;</xhtml:p><xhtml:p>import java.io.InputStreamReader;</xhtml:p><xhtml:p>import java.io.OutputStream;</xhtml:p><xhtml:p>import java.net.ServerSocket;</xhtml:p><xhtml:p>import java.net.Socket;</xhtml:p><xhtml:p>import java.util.Scanner;</xhtml:p><xhtml:p/><xhtml:p>import org.junit.Test;</xhtml:p><xhtml:p/><xhtml:p>public class TestTCP2 {</xhtml:p><xhtml:p>	@Test</xhtml:p><xhtml:p>	public void server()throws Exception{</xhtml:p><xhtml:p>		//1、创建ServerSocket</xhtml:p><xhtml:p>		ServerSocket server = new ServerSocket(9999);</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		while(true){</xhtml:p><xhtml:p>			//2、等待客户端的连接，接收客户端的连接</xhtml:p><xhtml:p>			Socket socket = server.accept();</xhtml:p><xhtml:p>			String clientIp = socket.getInetAddress().getHostAddress();</xhtml:p><xhtml:p>			</xhtml:p><xhtml:p>			System.out.println(clientIp+"上线了");</xhtml:p><xhtml:p>			</xhtml:p><xhtml:p>			//每一个客户端需要一个线程单独维护它的通信，“同时”与服务器通信的效果</xhtml:p><xhtml:p>			new MessageHandler(socket).start();</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>	//和服务器连接上以后，从键盘输入消息，给服务器发送，一直到从键盘输入byebye，在与服务端口连接</xhtml:p><xhtml:p>	@Test</xhtml:p><xhtml:p>	public void client()throws Exception{</xhtml:p><xhtml:p>		//1、连接服务器</xhtml:p><xhtml:p>		Socket socket = new Socket("192.168.24.71",9999);</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		OutputStream out = socket.getOutputStream();</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//2，从键盘输入给服务器发送</xhtml:p><xhtml:p>		Scanner input = new Scanner(System.in);</xhtml:p><xhtml:p>		while(true){</xhtml:p><xhtml:p>			System.out.println("输入要发送的内容：");</xhtml:p><xhtml:p>			String info = input.nextLine();</xhtml:p><xhtml:p>			</xhtml:p><xhtml:p>			if("byebye".equals(info)){</xhtml:p><xhtml:p>				break;</xhtml:p><xhtml:p>			}</xhtml:p><xhtml:p>			</xhtml:p><xhtml:p>			//给服务器发送</xhtml:p><xhtml:p>			out.write((info+"\n").getBytes());</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//3、断开</xhtml:p><xhtml:p>		socket.close();</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p/><xhtml:p/><xhtml:p>class MessageHandler extends Thread{</xhtml:p><xhtml:p>	private Socket socket;</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>	public MessageHandler(Socket socket) {</xhtml:p><xhtml:p>		super();</xhtml:p><xhtml:p>		this.socket = socket;</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p/><xhtml:p>	public void run(){</xhtml:p><xhtml:p>		try {</xhtml:p><xhtml:p>			//3、和一个客户端多次通信，接收到消息后，在控制台打印</xhtml:p><xhtml:p>			InputStream input = socket.getInputStream();</xhtml:p><xhtml:p>			InputStreamReader isr = new InputStreamReader(input);</xhtml:p><xhtml:p>			BufferedReader br = new BufferedReader(isr);</xhtml:p><xhtml:p>			</xhtml:p><xhtml:p>			String str;</xhtml:p><xhtml:p>			while((str = br.readLine())!=null){</xhtml:p><xhtml:p>				System.out.println(socket.getInetAddress().getHostAddress() +"说："+ str);</xhtml:p><xhtml:p>			}</xhtml:p><xhtml:p>			</xhtml:p><xhtml:p>			//4、断开</xhtml:p><xhtml:p>			socket.close();</xhtml:p><xhtml:p>		} catch (IOException e) {</xhtml:p><xhtml:p>			e.printStackTrace();</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p></html><plain>package com.atguigu.tcp2;&#13;
&#13;
import java.io.BufferedReader;&#13;
import java.io.IOException;&#13;
import java.io.InputStream;&#13;
import java.io.InputStreamReader;&#13;
import java.io.OutputStream;&#13;
import java.net.ServerSocket;&#13;
import java.net.Socket;&#13;
import java.util.Scanner;&#13;
&#13;
import org.junit.Test;&#13;
&#13;
public class TestTCP2 {&#13;
	@Test&#13;
	public void server()throws Exception{&#13;
		//1、创建ServerSocket&#13;
		ServerSocket server = new ServerSocket(9999);&#13;
		&#13;
		while(true){&#13;
			//2、等待客户端的连接，接收客户端的连接&#13;
			Socket socket = server.accept();&#13;
			String clientIp = socket.getInetAddress().getHostAddress();&#13;
			&#13;
			System.out.println(clientIp+"上线了");&#13;
			&#13;
			//每一个客户端需要一个线程单独维护它的通信，“同时”与服务器通信的效果&#13;
			new MessageHandler(socket).start();&#13;
		}&#13;
	}&#13;
	&#13;
	//和服务器连接上以后，从键盘输入消息，给服务器发送，一直到从键盘输入byebye，在与服务端口连接&#13;
	@Test&#13;
	public void client()throws Exception{&#13;
		//1、连接服务器&#13;
		Socket socket = new Socket("192.168.24.71",9999);&#13;
		&#13;
		OutputStream out = socket.getOutputStream();&#13;
		&#13;
		//2，从键盘输入给服务器发送&#13;
		Scanner input = new Scanner(System.in);&#13;
		while(true){&#13;
			System.out.println("输入要发送的内容：");&#13;
			String info = input.nextLine();&#13;
			&#13;
			if("byebye".equals(info)){&#13;
				break;&#13;
			}&#13;
			&#13;
			//给服务器发送&#13;
			out.write((info+"\n").getBytes());&#13;
		}&#13;
		&#13;
		//3、断开&#13;
		socket.close();&#13;
	}&#13;
}&#13;
&#13;
&#13;
class MessageHandler extends Thread{&#13;
	private Socket socket;&#13;
	&#13;
	public MessageHandler(Socket socket) {&#13;
		super();&#13;
		this.socket = socket;&#13;
	}&#13;
&#13;
	public void run(){&#13;
		try {&#13;
			//3、和一个客户端多次通信，接收到消息后，在控制台打印&#13;
			InputStream input = socket.getInputStream();&#13;
			InputStreamReader isr = new InputStreamReader(input);&#13;
			BufferedReader br = new BufferedReader(isr);&#13;
			&#13;
			String str;&#13;
			while((str = br.readLine())!=null){&#13;
				System.out.println(socket.getInetAddress().getHostAddress() +"说："+ str);&#13;
			}&#13;
			&#13;
			//4、断开&#13;
			socket.close();&#13;
		} catch (IOException e) {&#13;
			e.printStackTrace();&#13;
		}&#13;
	}&#13;
}</plain></notes></topic><topic id="7rkp1h9a23p31240cligdd72gl" modified-by="" timestamp="1513156940212"><title>示例三：群聊</title><children><topics type="attached"><topic id="44s5ofj1d5dgmi9h8v5mdfbv4q" modified-by="" timestamp="1513156945834"><title>服务器</title><notes><html><xhtml:p>package com.atguigu.tcp2;</xhtml:p><xhtml:p/><xhtml:p>import java.io.BufferedReader;</xhtml:p><xhtml:p>import java.io.IOException;</xhtml:p><xhtml:p>import java.io.InputStream;</xhtml:p><xhtml:p>import java.io.InputStreamReader;</xhtml:p><xhtml:p>import java.io.OutputStream;</xhtml:p><xhtml:p>import java.net.ServerSocket;</xhtml:p><xhtml:p>import java.net.Socket;</xhtml:p><xhtml:p>import java.util.Scanner;</xhtml:p><xhtml:p/><xhtml:p>import org.junit.Test;</xhtml:p><xhtml:p/><xhtml:p>public class TestTCP2 {</xhtml:p><xhtml:p>	@Test</xhtml:p><xhtml:p>	public void server()throws Exception{</xhtml:p><xhtml:p>		//1、创建ServerSocket</xhtml:p><xhtml:p>		ServerSocket server = new ServerSocket(9999);</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		while(true){</xhtml:p><xhtml:p>			//2、等待客户端的连接，接收客户端的连接</xhtml:p><xhtml:p>			Socket socket = server.accept();</xhtml:p><xhtml:p>			String clientIp = socket.getInetAddress().getHostAddress();</xhtml:p><xhtml:p>			</xhtml:p><xhtml:p>			System.out.println(clientIp+"上线了");</xhtml:p><xhtml:p>			</xhtml:p><xhtml:p>			//每一个客户端需要一个线程单独维护它的通信，“同时”与服务器通信的效果</xhtml:p><xhtml:p>			new MessageHandler(socket).start();</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>	//和服务器连接上以后，从键盘输入消息，给服务器发送，一直到从键盘输入byebye，在与服务端口连接</xhtml:p><xhtml:p>	@Test</xhtml:p><xhtml:p>	public void client()throws Exception{</xhtml:p><xhtml:p>		//1、连接服务器</xhtml:p><xhtml:p>		Socket socket = new Socket("192.168.24.71",9999);</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		OutputStream out = socket.getOutputStream();</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//2，从键盘输入给服务器发送</xhtml:p><xhtml:p>		Scanner input = new Scanner(System.in);</xhtml:p><xhtml:p>		while(true){</xhtml:p><xhtml:p>			System.out.println("输入要发送的内容：");</xhtml:p><xhtml:p>			String info = input.nextLine();</xhtml:p><xhtml:p>			</xhtml:p><xhtml:p>			if("byebye".equals(info)){</xhtml:p><xhtml:p>				break;</xhtml:p><xhtml:p>			}</xhtml:p><xhtml:p>			</xhtml:p><xhtml:p>			//给服务器发送</xhtml:p><xhtml:p>			out.write((info+"\n").getBytes());</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//3、断开</xhtml:p><xhtml:p>		socket.close();</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p/><xhtml:p/><xhtml:p>class MessageHandler extends Thread{</xhtml:p><xhtml:p>	private Socket socket;</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>	public MessageHandler(Socket socket) {</xhtml:p><xhtml:p>		super();</xhtml:p><xhtml:p>		this.socket = socket;</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p/><xhtml:p>	public void run(){</xhtml:p><xhtml:p>		try {</xhtml:p><xhtml:p>			//3、和一个客户端多次通信，接收到消息后，在控制台打印</xhtml:p><xhtml:p>			InputStream input = socket.getInputStream();</xhtml:p><xhtml:p>			InputStreamReader isr = new InputStreamReader(input);</xhtml:p><xhtml:p>			BufferedReader br = new BufferedReader(isr);</xhtml:p><xhtml:p>			</xhtml:p><xhtml:p>			String str;</xhtml:p><xhtml:p>			while((str = br.readLine())!=null){</xhtml:p><xhtml:p>				System.out.println(socket.getInetAddress().getHostAddress() +"说："+ str);</xhtml:p><xhtml:p>			}</xhtml:p><xhtml:p>			</xhtml:p><xhtml:p>			//4、断开</xhtml:p><xhtml:p>			socket.close();</xhtml:p><xhtml:p>		} catch (IOException e) {</xhtml:p><xhtml:p>			e.printStackTrace();</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p></html><plain>package com.atguigu.tcp2;&#13;
&#13;
import java.io.BufferedReader;&#13;
import java.io.IOException;&#13;
import java.io.InputStream;&#13;
import java.io.InputStreamReader;&#13;
import java.io.OutputStream;&#13;
import java.net.ServerSocket;&#13;
import java.net.Socket;&#13;
import java.util.Scanner;&#13;
&#13;
import org.junit.Test;&#13;
&#13;
public class TestTCP2 {&#13;
	@Test&#13;
	public void server()throws Exception{&#13;
		//1、创建ServerSocket&#13;
		ServerSocket server = new ServerSocket(9999);&#13;
		&#13;
		while(true){&#13;
			//2、等待客户端的连接，接收客户端的连接&#13;
			Socket socket = server.accept();&#13;
			String clientIp = socket.getInetAddress().getHostAddress();&#13;
			&#13;
			System.out.println(clientIp+"上线了");&#13;
			&#13;
			//每一个客户端需要一个线程单独维护它的通信，“同时”与服务器通信的效果&#13;
			new MessageHandler(socket).start();&#13;
		}&#13;
	}&#13;
	&#13;
	//和服务器连接上以后，从键盘输入消息，给服务器发送，一直到从键盘输入byebye，在与服务端口连接&#13;
	@Test&#13;
	public void client()throws Exception{&#13;
		//1、连接服务器&#13;
		Socket socket = new Socket("192.168.24.71",9999);&#13;
		&#13;
		OutputStream out = socket.getOutputStream();&#13;
		&#13;
		//2，从键盘输入给服务器发送&#13;
		Scanner input = new Scanner(System.in);&#13;
		while(true){&#13;
			System.out.println("输入要发送的内容：");&#13;
			String info = input.nextLine();&#13;
			&#13;
			if("byebye".equals(info)){&#13;
				break;&#13;
			}&#13;
			&#13;
			//给服务器发送&#13;
			out.write((info+"\n").getBytes());&#13;
		}&#13;
		&#13;
		//3、断开&#13;
		socket.close();&#13;
	}&#13;
}&#13;
&#13;
&#13;
class MessageHandler extends Thread{&#13;
	private Socket socket;&#13;
	&#13;
	public MessageHandler(Socket socket) {&#13;
		super();&#13;
		this.socket = socket;&#13;
	}&#13;
&#13;
	public void run(){&#13;
		try {&#13;
			//3、和一个客户端多次通信，接收到消息后，在控制台打印&#13;
			InputStream input = socket.getInputStream();&#13;
			InputStreamReader isr = new InputStreamReader(input);&#13;
			BufferedReader br = new BufferedReader(isr);&#13;
			&#13;
			String str;&#13;
			while((str = br.readLine())!=null){&#13;
				System.out.println(socket.getInetAddress().getHostAddress() +"说："+ str);&#13;
			}&#13;
			&#13;
			//4、断开&#13;
			socket.close();&#13;
		} catch (IOException e) {&#13;
			e.printStackTrace();&#13;
		}&#13;
	}&#13;
}</plain></notes></topic><topic id="7u5vhouvp49p0ujjfp0dlnp2qi" modified-by="" timestamp="1513156953233"><title>客户端</title><notes><html><xhtml:p>package com.atguigu.tcp3;</xhtml:p><xhtml:p/><xhtml:p>import java.io.BufferedReader;</xhtml:p><xhtml:p>import java.io.IOException;</xhtml:p><xhtml:p>import java.io.InputStream;</xhtml:p><xhtml:p>import java.io.InputStreamReader;</xhtml:p><xhtml:p>import java.io.OutputStream;</xhtml:p><xhtml:p>import java.io.PrintStream;</xhtml:p><xhtml:p>import java.net.Socket;</xhtml:p><xhtml:p>import java.net.SocketException;</xhtml:p><xhtml:p>import java.util.Scanner;</xhtml:p><xhtml:p/><xhtml:p>/*</xhtml:p><xhtml:p> * </xhtml:p><xhtml:p> */</xhtml:p><xhtml:p>public class TestTCPClient{</xhtml:p><xhtml:p>	public static void main(String[] args) throws Exception{</xhtml:p><xhtml:p>		//1、连接服务器</xhtml:p><xhtml:p>		Socket socket = new Socket("192.168.24.71",9090);</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//2、创建两个线程，一个收，一个发</xhtml:p><xhtml:p>		SendThread send = new SendThread(socket);</xhtml:p><xhtml:p>		send.start();</xhtml:p><xhtml:p>		RecevierThread r = new RecevierThread(socket);</xhtml:p><xhtml:p>		r.start();</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		send.join();</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		r.setExit(true);</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//3、关闭</xhtml:p><xhtml:p>		socket.close();</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p>class SendThread extends Thread{</xhtml:p><xhtml:p>	private Socket socket;</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>	public SendThread(Socket socket) {</xhtml:p><xhtml:p>		super();</xhtml:p><xhtml:p>		this.socket = socket;</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p/><xhtml:p>	@Override</xhtml:p><xhtml:p>	public void run() {</xhtml:p><xhtml:p>		try {</xhtml:p><xhtml:p>			OutputStream output = socket.getOutputStream();</xhtml:p><xhtml:p>			PrintStream ps = new PrintStream(output);</xhtml:p><xhtml:p>			</xhtml:p><xhtml:p>			Scanner input = new Scanner(System.in);</xhtml:p><xhtml:p>			while(true){</xhtml:p><xhtml:p>				System.out.println("请输入要发送的内容：");</xhtml:p><xhtml:p>				String info = input.nextLine();</xhtml:p><xhtml:p>				if("bye".equals(info)){</xhtml:p><xhtml:p>					break;</xhtml:p><xhtml:p>				}</xhtml:p><xhtml:p>				//给服务器发送</xhtml:p><xhtml:p>				ps.println(info);</xhtml:p><xhtml:p>			}</xhtml:p><xhtml:p>			</xhtml:p><xhtml:p>		} catch (IOException e) {</xhtml:p><xhtml:p>			e.printStackTrace();</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p>class RecevierThread extends Thread{</xhtml:p><xhtml:p>	private Socket socket;</xhtml:p><xhtml:p>	private boolean exit = false;</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>	public RecevierThread(Socket socket) {</xhtml:p><xhtml:p>		super();</xhtml:p><xhtml:p>		this.socket = socket;</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>	@Override</xhtml:p><xhtml:p>	public void run() {</xhtml:p><xhtml:p>		try {</xhtml:p><xhtml:p>			InputStream is = socket.getInputStream();</xhtml:p><xhtml:p>			InputStreamReader isr = new InputStreamReader(is);</xhtml:p><xhtml:p>			BufferedReader br = new BufferedReader(isr);</xhtml:p><xhtml:p>			</xhtml:p><xhtml:p>			String str;</xhtml:p><xhtml:p>			while(exit==false){</xhtml:p><xhtml:p>				try {</xhtml:p><xhtml:p>					str = br.readLine();</xhtml:p><xhtml:p>				} catch (SocketException e) {</xhtml:p><xhtml:p>					break;</xhtml:p><xhtml:p>				}</xhtml:p><xhtml:p>				if(str==null){</xhtml:p><xhtml:p>					break;</xhtml:p><xhtml:p>				}</xhtml:p><xhtml:p>				System.out.println("收到的消息：" + str);</xhtml:p><xhtml:p>			}</xhtml:p><xhtml:p>			</xhtml:p><xhtml:p>		} catch (IOException e) {</xhtml:p><xhtml:p>			e.printStackTrace();</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>	public void setExit(boolean exit) {</xhtml:p><xhtml:p>		this.exit = exit;</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>}</xhtml:p></html><plain>package com.atguigu.tcp3;&#13;
&#13;
import java.io.BufferedReader;&#13;
import java.io.IOException;&#13;
import java.io.InputStream;&#13;
import java.io.InputStreamReader;&#13;
import java.io.OutputStream;&#13;
import java.io.PrintStream;&#13;
import java.net.Socket;&#13;
import java.net.SocketException;&#13;
import java.util.Scanner;&#13;
&#13;
/*&#13;
 * &#13;
 */&#13;
public class TestTCPClient{&#13;
	public static void main(String[] args) throws Exception{&#13;
		//1、连接服务器&#13;
		Socket socket = new Socket("192.168.24.71",9090);&#13;
		&#13;
		//2、创建两个线程，一个收，一个发&#13;
		SendThread send = new SendThread(socket);&#13;
		send.start();&#13;
		RecevierThread r = new RecevierThread(socket);&#13;
		r.start();&#13;
		&#13;
		send.join();&#13;
		&#13;
		r.setExit(true);&#13;
		&#13;
		//3、关闭&#13;
		socket.close();&#13;
	}&#13;
}&#13;
class SendThread extends Thread{&#13;
	private Socket socket;&#13;
	&#13;
	public SendThread(Socket socket) {&#13;
		super();&#13;
		this.socket = socket;&#13;
	}&#13;
&#13;
	@Override&#13;
	public void run() {&#13;
		try {&#13;
			OutputStream output = socket.getOutputStream();&#13;
			PrintStream ps = new PrintStream(output);&#13;
			&#13;
			Scanner input = new Scanner(System.in);&#13;
			while(true){&#13;
				System.out.println("请输入要发送的内容：");&#13;
				String info = input.nextLine();&#13;
				if("bye".equals(info)){&#13;
					break;&#13;
				}&#13;
				//给服务器发送&#13;
				ps.println(info);&#13;
			}&#13;
			&#13;
		} catch (IOException e) {&#13;
			e.printStackTrace();&#13;
		}&#13;
	}&#13;
}&#13;
class RecevierThread extends Thread{&#13;
	private Socket socket;&#13;
	private boolean exit = false;&#13;
	&#13;
	public RecevierThread(Socket socket) {&#13;
		super();&#13;
		this.socket = socket;&#13;
	}&#13;
	@Override&#13;
	public void run() {&#13;
		try {&#13;
			InputStream is = socket.getInputStream();&#13;
			InputStreamReader isr = new InputStreamReader(is);&#13;
			BufferedReader br = new BufferedReader(isr);&#13;
			&#13;
			String str;&#13;
			while(exit==false){&#13;
				try {&#13;
					str = br.readLine();&#13;
				} catch (SocketException e) {&#13;
					break;&#13;
				}&#13;
				if(str==null){&#13;
					break;&#13;
				}&#13;
				System.out.println("收到的消息：" + str);&#13;
			}&#13;
			&#13;
		} catch (IOException e) {&#13;
			e.printStackTrace();&#13;
		}&#13;
	}&#13;
	public void setExit(boolean exit) {&#13;
		this.exit = exit;&#13;
	}&#13;
	&#13;
}</plain></notes></topic></topics></children></topic></topics></children></topic><topic id="41li6695dnhevc9igcpblp15re" modified-by="" timestamp="1513156782822"><title>UDP编程步骤</title><children><topics type="attached"><topic id="3b60dkmrl5rmub51u1kdagi67d" modified-by="" timestamp="1513127192721"><title>发送端</title><children><topics type="attached"><topic id="2cg8mrv8fh0jc5qsiga8gmi18l" modified-by="" timestamp="1513127115477"><title>1、创建一个DatagramSocket</title></topic><topic id="0vc7jrbvd52fmorstkipbk6rva" modified-by="" timestamp="1513127136494"><title>2、准备发送的数据，并且打包</title><children><topics type="attached"><topic id="652pclqqf2gkgo6a2l1lth5ol9" modified-by="" timestamp="1513127145784"><title>DatagramPacket</title><children><topics type="attached"><topic id="5abf8kq50i0iccqqasj4rgp0ak" modified-by="" timestamp="1513127169195"><title svg:width="500">要指定：发送的数据，长度，接收方的IP，接收方的端口号</title></topic></topics></children></topic></topics></children></topic><topic id="6gi2r258r5ofthk54o5hp22mtr" modified-by="" timestamp="1513127191117"><title>3、通过DatagramSocket的send(数据报)</title></topic><topic id="7i18i0b2h965afpgba8j0qt43h" modified-by="" timestamp="1513127202430"><title>4、关闭</title></topic></topics></children></topic><topic id="28efsjd4n2bqstur6bq406ic4o" modified-by="" timestamp="1513127335433"><title>接收端</title><children><topics type="attached"><topic id="360dgna17u66jef3kosr307bo7" modified-by="" timestamp="1513127208563"><title>1、创建一个DatagramSocket</title><children><topics type="attached"><topic id="21cpcnd4o42pdmsrspgvg510qu" modified-by="" timestamp="1513127217826"><title>要指定 监听的端口号</title></topic></topics></children></topic><topic id="06qirj0fb1brqa2iv4dcuf2nmd" modified-by="" timestamp="1513127245410"><title>2、准备一个DatagramPacket，用来接收数据</title><children><topics type="attached"><topic id="1qg91ab5q60munhgh6inen27ps" modified-by="" timestamp="1513127258840"><title>要指定装数据一个字节数组，以及长度</title></topic></topics></children></topic><topic id="5pkdd0qjke0dmk3j1gs4imrnlp" modified-by="" timestamp="1513127288249"><title>3、通过DatagramSocket的receive(数据报)</title></topic><topic id="22iaokdpv5eg0paagfbpnr8f3e" modified-by="" timestamp="1513127295868"><title>4、拆解数据</title><children><topics type="attached"><topic id="2q69e73jpep12dqi36ksvo0ujg" modified-by="" timestamp="1513127333031"><title svg:width="500">通过DatagramPacket对象.getData()数据，DatagramPacket对象.getLength()实际接收的数据长度</title></topic></topics></children></topic><topic id="3g65fchc2b1mehe8bsomtevpbu" modified-by="" timestamp="1513127338226"><title>5、关闭</title></topic></topics></children></topic><topic id="4bdungr7t8un7pci27srsuqngh" modified-by="" timestamp="1513156789673"><title>示例代码</title><notes><html><xhtml:p>package com.atguigu.udp;</xhtml:p><xhtml:p/><xhtml:p>import java.net.DatagramPacket;</xhtml:p><xhtml:p>import java.net.DatagramSocket;</xhtml:p><xhtml:p>import java.net.InetAddress;</xhtml:p><xhtml:p/><xhtml:p>import org.junit.Test;</xhtml:p><xhtml:p/><xhtml:p>/*</xhtml:p><xhtml:p> * UDP:非面向连接的</xhtml:p><xhtml:p> * </xhtml:p><xhtml:p> * 有发送端和接收端两个应用程序</xhtml:p><xhtml:p> */</xhtml:p><xhtml:p>public class TestUDP {</xhtml:p><xhtml:p>	@Test</xhtml:p><xhtml:p>	public void send()throws Exception{</xhtml:p><xhtml:p>		//1、创建Socket</xhtml:p><xhtml:p>		DatagramSocket ds = new DatagramSocket();</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//2、把数据打包成一个数据报，包</xhtml:p><xhtml:p>		String str = "双十二购物快乐";</xhtml:p><xhtml:p>		byte[] bytes = str.getBytes();</xhtml:p><xhtml:p>		InetAddress ip = InetAddress.getByName("192.168.24.71");</xhtml:p><xhtml:p>		DatagramPacket dp = new DatagramPacket(bytes, bytes.length, ip,8989);</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//3、通过socket发送出去</xhtml:p><xhtml:p>		ds.send(dp);</xhtml:p><xhtml:p>		System.out.println("发送完毕");</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//4、释放资源</xhtml:p><xhtml:p>		ds.close();</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>	@Test</xhtml:p><xhtml:p>	public void reveive()throws Exception{</xhtml:p><xhtml:p>		//1、创建Socket</xhtml:p><xhtml:p>		DatagramSocket ds = new DatagramSocket(8989);//为它指定一个端口号，在端口号一直监听着</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//2、先创建一个数据报等着</xhtml:p><xhtml:p>		byte[] data = new byte[1024];</xhtml:p><xhtml:p>		DatagramPacket dp  = new DatagramPacket(data, data.length);</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//3、准备接受数据，从socket中接收数据，如果此时没有数据，这句代码会阻塞</xhtml:p><xhtml:p>		ds.receive(dp);</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//4、拆出数据</xhtml:p><xhtml:p>		String str = new String(dp.getData(),0,dp.getLength());</xhtml:p><xhtml:p>		System.out.println("收到的数据是：" + str);</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//5、关闭</xhtml:p><xhtml:p>		ds.close();</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p/></html><plain>package com.atguigu.udp;&#13;
&#13;
import java.net.DatagramPacket;&#13;
import java.net.DatagramSocket;&#13;
import java.net.InetAddress;&#13;
&#13;
import org.junit.Test;&#13;
&#13;
/*&#13;
 * UDP:非面向连接的&#13;
 * &#13;
 * 有发送端和接收端两个应用程序&#13;
 */&#13;
public class TestUDP {&#13;
	@Test&#13;
	public void send()throws Exception{&#13;
		//1、创建Socket&#13;
		DatagramSocket ds = new DatagramSocket();&#13;
		&#13;
		//2、把数据打包成一个数据报，包&#13;
		String str = "双十二购物快乐";&#13;
		byte[] bytes = str.getBytes();&#13;
		InetAddress ip = InetAddress.getByName("192.168.24.71");&#13;
		DatagramPacket dp = new DatagramPacket(bytes, bytes.length, ip,8989);&#13;
		&#13;
		//3、通过socket发送出去&#13;
		ds.send(dp);&#13;
		System.out.println("发送完毕");&#13;
		&#13;
		//4、释放资源&#13;
		ds.close();&#13;
	}&#13;
	&#13;
	@Test&#13;
	public void reveive()throws Exception{&#13;
		//1、创建Socket&#13;
		DatagramSocket ds = new DatagramSocket(8989);//为它指定一个端口号，在端口号一直监听着&#13;
		&#13;
		//2、先创建一个数据报等着&#13;
		byte[] data = new byte[1024];&#13;
		DatagramPacket dp  = new DatagramPacket(data, data.length);&#13;
		&#13;
		//3、准备接受数据，从socket中接收数据，如果此时没有数据，这句代码会阻塞&#13;
		ds.receive(dp);&#13;
		&#13;
		//4、拆出数据&#13;
		String str = new String(dp.getData(),0,dp.getLength());&#13;
		System.out.println("收到的数据是：" + str);&#13;
		&#13;
		//5、关闭&#13;
		ds.close();&#13;
	}&#13;
}&#13;
</plain></notes></topic></topics></children></topic><topic id="21g8k1i1ffo7qdka3l2pc8mr82" modified-by="" timestamp="1513156793326"><title>URL编程</title><children><topics type="attached"><topic id="3tndc81s1ughv9f2g403brtiuc" modified-by="" timestamp="1513127373355"><title>在TCP的基础上</title><children><topics type="attached"><topic id="297lu8nv2a6fcmsmuded9ontfi" modified-by="" timestamp="1513127380711"><title>服务器端</title><children><topics type="attached"><topic id="2kunuo1ujlkju3qj3a56mmf690" modified-by="" timestamp="1513127386246"><title>Web服务器</title></topic></topics></children></topic><topic id="1m59t9b32hdbapvpn2bl2gmecg" modified-by="" timestamp="1513127712729"><title>客户端</title><children><topics type="attached"><topic id="387dcdrjap44rca7jpsutaedg6" modified-by="" timestamp="1513127399857"><title>1、创建URL的对象</title><children><topics type="attached"><topic id="25cgucmq27hthmd7jgfvdri94h" modified-by="" timestamp="1513127475230"><title>URL url = new URL(网址);</title><children><topics type="attached"><topic id="19474ib8eqcqrggu79hlom06a7" modified-by="" timestamp="1513127450826"><title svg:width="500">网址：协议://主机名:端口号/文件路径名?参数名=参数值&amp;参数名=参数值...</title></topic><topic id="25en0otcpkfch6404l5ku7mav6" modified-by="" timestamp="1513127472261"><title svg:width="500">例如：http://localhost:8080/1108web/index.html</title></topic><topic id="1i7tg6l6l3mist253nc1eonupc" modified-by="" timestamp="1513127490007"><title svg:width="500">例如：http://localhost:8080/1108web/login?username=xx&amp;password=xx</title></topic></topics></children></topic></topics></children></topic><topic id="7e73p7557t5m5hlftumb8ogkib" modified-by="" timestamp="1513127585907"><title>2、与服务器建立连接</title><children><topics type="attached"><topic id="0669cifpekfk1a26kii19oite4" modified-by="" timestamp="1513127524497"><title>InputStream is = url.openStream();</title><children><topics type="attached"><topic id="2v1h7tanlon9t2p1eokr1cqta3" modified-by="" timestamp="1513127561844"><title>这种方式只能使用get方法与服务器进行通信</title><children><topics type="attached"><topic id="6tpqhc8rn7h3peisv5gnkefnce" modified-by="" timestamp="1513127582383"><title svg:width="500">如果要给服务器传参数只能在网址后面通过?参数名=参数值&amp;参数名=参数值...</title></topic></topics></children></topic></topics></children></topic><topic id="32ak2sikcn5tmpmrgf1lionfml" modified-by="" timestamp="1513127629267"><title svg:width="500">HttpURLConnection tc = (HttpURLConnection)url.openConnection();</title><children><topics type="attached"><topic id="0kdkpmdtprc2tb31unqmojg9pq" modified-by="" timestamp="1513127688429"><title>这种方式可以使用post方法与服务器进行通信</title><children><topics type="attached"><topic id="1ufpfk47lm0ppcnsj28t8enlci" modified-by="" timestamp="1513127687330"><title svg:width="500">如果要给服务器传数据，那么需要hc.setDoOutput(true);</title></topic><topic id="3je1oi976ekkinpvoo7d1vetkm" modified-by="" timestamp="1513127697645"><title>然后用OutputStream进行发送数据</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="7o5gf7tv4ilsrl2v6vo30si03a" modified-by="" timestamp="1513127718848"><title>3、处理接收到数据</title></topic></topics></children></topic></topics></children></topic><topic id="13607oupkh2a9k9656rgq2ch9u" modified-by="" timestamp="1513156872687"><title>示例代码</title><children><topics type="attached"><topic id="3h5d3gmasptu850hhbj9jdetpf" modified-by="" timestamp="1513156858318"><title>示例一</title><notes><html><xhtml:p>package com.atguigu.url;</xhtml:p><xhtml:p/><xhtml:p>import java.io.BufferedReader;</xhtml:p><xhtml:p>import java.io.InputStream;</xhtml:p><xhtml:p>import java.io.InputStreamReader;</xhtml:p><xhtml:p>import java.net.URL;</xhtml:p><xhtml:p/><xhtml:p>/*</xhtml:p><xhtml:p> * tomcat：是一个服务器</xhtml:p><xhtml:p> * 浏览器：客户端</xhtml:p><xhtml:p> */</xhtml:p><xhtml:p>public class TestURL {</xhtml:p><xhtml:p/><xhtml:p>	public static void main(String[] args) throws Exception{</xhtml:p><xhtml:p>		//自定义客户端</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		URL url = new URL("http://192.168.24.71:8080/1108JavaWeb/index.html");</xhtml:p><xhtml:p>		/*System.out.println("协议：" + url.getProtocol());</xhtml:p><xhtml:p>		System.out.println("主机名：" + url.getHost());</xhtml:p><xhtml:p>		System.out.println("端口号：" + url.getPort());</xhtml:p><xhtml:p>		System.out.println("路径名：" + url.getPath());*/</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		InputStream input = url.openStream();</xhtml:p><xhtml:p>		InputStreamReader isr = new InputStreamReader(input);</xhtml:p><xhtml:p>		BufferedReader br  = new BufferedReader(isr);	</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		String str ;</xhtml:p><xhtml:p>		while((str=br.readLine())!=null){</xhtml:p><xhtml:p>			System.out.println(str);</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p/><xhtml:p>}</xhtml:p><xhtml:p/></html><plain>package com.atguigu.url;&#13;
&#13;
import java.io.BufferedReader;&#13;
import java.io.InputStream;&#13;
import java.io.InputStreamReader;&#13;
import java.net.URL;&#13;
&#13;
/*&#13;
 * tomcat：是一个服务器&#13;
 * 浏览器：客户端&#13;
 */&#13;
public class TestURL {&#13;
&#13;
	public static void main(String[] args) throws Exception{&#13;
		//自定义客户端&#13;
		&#13;
		URL url = new URL("http://192.168.24.71:8080/1108JavaWeb/index.html");&#13;
		/*System.out.println("协议：" + url.getProtocol());&#13;
		System.out.println("主机名：" + url.getHost());&#13;
		System.out.println("端口号：" + url.getPort());&#13;
		System.out.println("路径名：" + url.getPath());*/&#13;
		&#13;
		InputStream input = url.openStream();&#13;
		InputStreamReader isr = new InputStreamReader(input);&#13;
		BufferedReader br  = new BufferedReader(isr);	&#13;
		&#13;
		String str ;&#13;
		while((str=br.readLine())!=null){&#13;
			System.out.println(str);&#13;
		}&#13;
	}&#13;
&#13;
}&#13;
</plain></notes></topic><topic id="7ogs1ibgk9jl4snk2tvpgp109v" modified-by="" timestamp="1513156872367"><title>示例二：get</title><notes><html><xhtml:p>package com.atguigu.url;</xhtml:p><xhtml:p/><xhtml:p>import java.io.BufferedReader;</xhtml:p><xhtml:p>import java.io.InputStream;</xhtml:p><xhtml:p>import java.io.InputStreamReader;</xhtml:p><xhtml:p>import java.net.URL;</xhtml:p><xhtml:p/><xhtml:p>public class TestURL2 {</xhtml:p><xhtml:p/><xhtml:p>	public static void main(String[] args) throws Exception{</xhtml:p><xhtml:p>		URL url = new URL("http://192.168.24.71:8080/myweb/login?username=admin&amp;pass=123");</xhtml:p><xhtml:p>		InputStream input = url.openStream();</xhtml:p><xhtml:p>		InputStreamReader isr = new InputStreamReader(input);</xhtml:p><xhtml:p>		BufferedReader br  = new BufferedReader(isr);	</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		String str ;</xhtml:p><xhtml:p>		while((str=br.readLine())!=null){</xhtml:p><xhtml:p>			System.out.println(str);</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p/><xhtml:p>}</xhtml:p><xhtml:p/></html><plain>package com.atguigu.url;&#13;
&#13;
import java.io.BufferedReader;&#13;
import java.io.InputStream;&#13;
import java.io.InputStreamReader;&#13;
import java.net.URL;&#13;
&#13;
public class TestURL2 {&#13;
&#13;
	public static void main(String[] args) throws Exception{&#13;
		URL url = new URL("http://192.168.24.71:8080/myweb/login?username=admin&amp;pass=123");&#13;
		InputStream input = url.openStream();&#13;
		InputStreamReader isr = new InputStreamReader(input);&#13;
		BufferedReader br  = new BufferedReader(isr);	&#13;
		&#13;
		String str ;&#13;
		while((str=br.readLine())!=null){&#13;
			System.out.println(str);&#13;
		}&#13;
	}&#13;
&#13;
}&#13;
</plain></notes></topic><topic id="0q3d2f9mcrgrq35vh513tdrhs1" modified-by="" timestamp="1513156887002"><title>示例三：post</title><notes><html><xhtml:p>package com.atguigu.url;</xhtml:p><xhtml:p/><xhtml:p>import java.io.BufferedReader;</xhtml:p><xhtml:p>import java.io.InputStream;</xhtml:p><xhtml:p>import java.io.InputStreamReader;</xhtml:p><xhtml:p>import java.io.OutputStream;</xhtml:p><xhtml:p>import java.io.PrintStream;</xhtml:p><xhtml:p>import java.net.HttpURLConnection;</xhtml:p><xhtml:p>import java.net.URL;</xhtml:p><xhtml:p/><xhtml:p>public class TestURL3 {</xhtml:p><xhtml:p/><xhtml:p>	public static void main(String[] args) throws Exception{</xhtml:p><xhtml:p>		URL url = new URL("http://192.168.24.71:8080/myweb/login");</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		HttpURLConnection hc = (HttpURLConnection) url.openConnection();</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		hc.setDoOutput(true);</xhtml:p><xhtml:p>		OutputStream output = hc.getOutputStream();</xhtml:p><xhtml:p>		PrintStream ps = new PrintStream(output);</xhtml:p><xhtml:p>//		output.write("username=chai&amp;pass=123".getBytes());</xhtml:p><xhtml:p>		ps.println("username=chai&amp;pass=123");</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		InputStream input = hc.getInputStream();</xhtml:p><xhtml:p>		InputStreamReader isr = new InputStreamReader(input);</xhtml:p><xhtml:p>		BufferedReader br  = new BufferedReader(isr);	</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		String str ;</xhtml:p><xhtml:p>		while((str=br.readLine())!=null){</xhtml:p><xhtml:p>			System.out.println(str);</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p/><xhtml:p>}</xhtml:p><xhtml:p/></html><plain>package com.atguigu.url;&#13;
&#13;
import java.io.BufferedReader;&#13;
import java.io.InputStream;&#13;
import java.io.InputStreamReader;&#13;
import java.io.OutputStream;&#13;
import java.io.PrintStream;&#13;
import java.net.HttpURLConnection;&#13;
import java.net.URL;&#13;
&#13;
public class TestURL3 {&#13;
&#13;
	public static void main(String[] args) throws Exception{&#13;
		URL url = new URL("http://192.168.24.71:8080/myweb/login");&#13;
		&#13;
		HttpURLConnection hc = (HttpURLConnection) url.openConnection();&#13;
		&#13;
		hc.setDoOutput(true);&#13;
		OutputStream output = hc.getOutputStream();&#13;
		PrintStream ps = new PrintStream(output);&#13;
//		output.write("username=chai&amp;pass=123".getBytes());&#13;
		ps.println("username=chai&amp;pass=123");&#13;
		&#13;
		InputStream input = hc.getInputStream();&#13;
		InputStreamReader isr = new InputStreamReader(input);&#13;
		BufferedReader br  = new BufferedReader(isr);	&#13;
		&#13;
		String str ;&#13;
		while((str=br.readLine())!=null){&#13;
			System.out.println(str);&#13;
		}&#13;
	}&#13;
&#13;
}&#13;
</plain></notes></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><title>网络编程</title></sheet></xmap-revision-content>