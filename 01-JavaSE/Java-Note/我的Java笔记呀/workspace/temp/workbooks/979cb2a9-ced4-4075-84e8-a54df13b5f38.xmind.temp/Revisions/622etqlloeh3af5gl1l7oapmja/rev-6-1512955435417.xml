<?xml version="1.0" encoding="UTF-8" standalone="no"?><xmap-revision-content xmlns="urn:xmind:xmap:xmlns:revision:1.0" xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:svg="http://www.w3.org/2000/svg" xmlns:xhtml="http://www.w3.org/1999/xhtml" xmlns:xlink="http://www.w3.org/1999/xlink"><sheet id="622etqlloeh3af5gl1l7oapmja" modified-by="" style-id="52uu5g07ehufrlgna6s0eokgph" theme="xminddefaultthemeid" timestamp="1512955433718" xmlns="urn:xmind:xmap:xmlns:content:2.0"><topic id="08aebva4ut5v8fch6dtfnoc509" modified-by="" structure-class="org.xmind.ui.logic.right" timestamp="1511747561976"><title>23种设计模式</title><extensions><extension provider="org.xmind.ui.map.unbalanced"><content><right-number>-1</right-number></content></extension></extensions><children><topics type="attached"><topic id="07enc8kgbmgqr6lse8r1h6vvcp" modified-by="" timestamp="1511574509010"><title>设计模式</title><children><topics type="attached"><topic id="7sqtgj2lg8usr3sa7bafgeo4r8" modified-by="" timestamp="1511574453499"><title>套路</title></topic><topic id="67df5p60isvvrntr6187q0n9b5" modified-by="" timestamp="1511574514400"><title>框架</title><children><topics type="attached"><topic id="3ra232dd3hkdtdgah27ednrrus" modified-by="" timestamp="1511574534632"><title>设计模式 + 反射 + 泛型 + 注解/配置文件等</title></topic></topics></children></topic></topics></children></topic><topic id="0r4lv2bevfjnkdkpp8b3pvqd44" modified-by="" timestamp="1512810176407"><title>单例设计模式</title><children><topics type="attached"><topic id="07fe5crf53o33sv0ftup581h8o" modified-by="" timestamp="1511574610961"><title>最简单，考的最多的一个设计模式</title></topic><topic id="6p769nq5ncfieanrcd68l32rca" modified-by="" timestamp="1511574633002"><title>要点</title><children><topics type="attached"><topic id="69o2745968r4ud8tftu4vbjb22" modified-by="" timestamp="1511574632251"><title>（1）构造器私有化</title></topic><topic id="1kfe8rio5edfvu4ed3pk7k64as" modified-by="" timestamp="1511574647740"><title>（2）在本类中创建这个唯一的实例</title></topic></topics></children></topic><topic id="6fqea5mbv1cm1v56skmvq1om2o" modified-by="" timestamp="1512810177470"><title>分类</title><children><topics type="attached"><topic id="0fl36cqtrdr31aiv5jrb4ds6df" modified-by="" timestamp="1511574689845"><title>饿汉式</title><children><topics type="attached"><topic id="0t9td9nj20uhu24hpllknh5c5n" modified-by="" timestamp="1511574686755"><title>形式一</title><children><topics type="attached"><topic id="4g805nvo2i3257oaidlje17dt1" modified-by="" timestamp="1511574688195"><title svg:width="500">class Hungry{&#13;
	public static final Hungry INSTANCE = new Hungry();&#13;
	private Hungry(){&#13;
	}&#13;
}</title></topic></topics></children></topic><topic id="3oam60ip70drun509u739ovcjo" modified-by="" timestamp="1511574700120"><title>形式二</title><children><topics type="attached"><topic id="0rrubtumd3d9245hoe15rh3eg5" modified-by="" timestamp="1511574702194"><title svg:width="500">class Hungry{&#13;
	private static final Hungry INSTANCE = new Hungry();&#13;
	private Hungry(){&#13;
	}&#13;
	public static Hungry getInstance(){&#13;
		return INSTANCE;&#13;
	}&#13;
}</title></topic></topics></children></topic></topics></children></topic><topic id="6a1lb3tt56rfsnjcslrvebc5fh" modified-by="" timestamp="1512810191634"><title>懒汉式</title><children><topics type="attached"><topic id="4c0fbfav4k5rahbp30b3rg0nd0" modified-by="" timestamp="1511574725641"><title>形式一：（有线程安全问题）</title><children><topics type="attached"><topic id="37os09gmeeg4ljvl6oc28oklrr" modified-by="" timestamp="1511574727423"><title>class Lazy{&#13;
	private static Lazy instance;&#13;
	private Lazy(){&#13;
	}&#13;
	//延迟创建对象&#13;
	public static Lazy getInstance(){&#13;
		if(instance == null){&#13;
			instance = new Lazy();&#13;
		}&#13;
		return instance;&#13;
	}&#13;
}</title></topic></topics></children></topic><topic id="6uldaq01hoqeic05vmcrrgpcmf" modified-by="" timestamp="1512810223810"><title>形式二：解决线程安全问题</title><notes><html><xhtml:p>//懒汉式</xhtml:p><xhtml:p>class Lazy{</xhtml:p><xhtml:p>	//2、在类中声明一个静态变量用来存储这个唯一的对象</xhtml:p><xhtml:p>	private static Lazy instance;</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>	//1、构造器私有化</xhtml:p><xhtml:p>	private Lazy(){</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>	//3、提供一个静态方法用来返回这个唯一的对象，并在第一次获取这个对象时，创建这个唯一的对象</xhtml:p><xhtml:p>	/*synchronized public static Lazy getInstance(){</xhtml:p><xhtml:p>		if(instance == null){</xhtml:p><xhtml:p>			instance = new Lazy();</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>		return instance;</xhtml:p><xhtml:p>	}*/</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>	//考虑的性能</xhtml:p><xhtml:p>	public static Lazy getInstance(){</xhtml:p><xhtml:p>		if(instance == null){//为了效率高</xhtml:p><xhtml:p>			synchronized(Lazy.class){</xhtml:p><xhtml:p>				if(instance == null){//双重条件判断，更安全</xhtml:p><xhtml:p>					instance = new Lazy();</xhtml:p><xhtml:p>				}</xhtml:p><xhtml:p>			}</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>		return instance;</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p></html><plain>//懒汉式&#13;
class Lazy{&#13;
	//2、在类中声明一个静态变量用来存储这个唯一的对象&#13;
	private static Lazy instance;&#13;
	&#13;
	//1、构造器私有化&#13;
	private Lazy(){&#13;
		&#13;
	}&#13;
	&#13;
	//3、提供一个静态方法用来返回这个唯一的对象，并在第一次获取这个对象时，创建这个唯一的对象&#13;
	/*synchronized public static Lazy getInstance(){&#13;
		if(instance == null){&#13;
			instance = new Lazy();&#13;
		}&#13;
		return instance;&#13;
	}*/&#13;
	&#13;
	//考虑的性能&#13;
	public static Lazy getInstance(){&#13;
		if(instance == null){//为了效率高&#13;
			synchronized(Lazy.class){&#13;
				if(instance == null){//双重条件判断，更安全&#13;
					instance = new Lazy();&#13;
				}&#13;
			}&#13;
		}&#13;
		return instance;&#13;
	}&#13;
}</plain></notes></topic></topics></children></topic><topic id="51b7ilrld7igapainn6uhnop5b" modified-by="" timestamp="1512955433718"><title>枚举式</title><children><topics type="attached"><topic id="6592l7kjfcnt7rm0lct9q9paal" modified-by="" timestamp="1512810189110"><title>enum Single{&#13;
	INSTANCE&#13;
}</title></topic><topic id="53idm9k4ilmvdrqtmnh7eq53il" modified-by="" timestamp="1512955426651"><title>特殊的饿汉式</title></topic></topics></children><marker-refs><marker-ref marker-id="flag-red"/></marker-refs></topic></topics></children></topic></topics></children><marker-refs><marker-ref marker-id="star-red"/><marker-ref marker-id="flag-red"/></marker-refs></topic><topic id="7p8c8fbv3711jehp7jce488leb" modified-by="" timestamp="1511746464763"><title>模板设计模式（识别）</title><children><topics type="attached"><topic id="3lpnltn1njba7p57fv22g43gbd" modified-by="" timestamp="1511746360052"><title>使用的情景</title><children><topics type="attached"><topic id="3u98v7rffr8h40mnbv56qacb5c" modified-by="" timestamp="1511746461042"><title svg:width="500">当某个功能在实现时，它的主体的算法结构是确定的，只是其中的某一个或几个步骤无法给出具体的实现，那么这个时候，把这个或几个的步骤抽取成抽象方法，由子类去给出具体的实现，那么子类继承父类时，既可以保留父类的主体算法结构，又可以对这几个抽象部分给出具体的实现</title></topic></topics></children></topic><topic id="6518o0sba28icaucna694fdrj8" modified-by="" timestamp="1511746709850"><title>示例代码</title><notes><html><xhtml:p>例如：计算某段代码的执行时间</xhtml:p><xhtml:p/><xhtml:p>算法结构：</xhtml:p><xhtml:p>1、获取开始时间</xhtml:p><xhtml:p>2、执行代码</xhtml:p><xhtml:p>3、获取结束时间</xhtml:p><xhtml:p>4、计算差值</xhtml:p><xhtml:p/><xhtml:p>public abstract class CalTime{</xhtml:p><xhtml:p>	public final long getTime(){</xhtml:p><xhtml:p>		//1、获取开始时间</xhtml:p><xhtml:p>		long start = System.currentTimeMillis();</xhtml:p><xhtml:p/><xhtml:p>		//2、执行代码</xhtml:p><xhtml:p>		doWork();</xhtml:p><xhtml:p/><xhtml:p>		//3、获取结束时间</xhtml:p><xhtml:p>		long end = System.currentTimeMillis();</xhtml:p><xhtml:p/><xhtml:p>		//4、计算差值</xhtml:p><xhtml:p>		return end - start;</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p/><xhtml:p>	protected abstract void doWork();</xhtml:p><xhtml:p/><xhtml:p>}</xhtml:p><xhtml:p/><xhtml:p>class MyCalTime extends CalTime{</xhtml:p><xhtml:p>	public void doWork(){</xhtml:p><xhtml:p>		.......</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p></html><plain>例如：计算某段代码的执行时间&#13;
&#13;
算法结构：&#13;
1、获取开始时间&#13;
2、执行代码&#13;
3、获取结束时间&#13;
4、计算差值&#13;
&#13;
public abstract class CalTime{&#13;
	public final long getTime(){&#13;
		//1、获取开始时间&#13;
		long start = System.currentTimeMillis();&#13;
&#13;
		//2、执行代码&#13;
		doWork();&#13;
&#13;
		//3、获取结束时间&#13;
		long end = System.currentTimeMillis();&#13;
&#13;
		//4、计算差值&#13;
		return end - start;&#13;
	}&#13;
&#13;
	protected abstract void doWork();&#13;
&#13;
}&#13;
&#13;
class MyCalTime extends CalTime{&#13;
	public void doWork(){&#13;
		.......&#13;
	}&#13;
}</plain></notes></topic></topics></children></topic><topic id="3eeug3633tpqn6ld1pmvs9fein" modified-by="" timestamp="1511747590861"><title>工厂设计模式</title><children><topics type="attached"><topic id="1k6u90ur9n4br3v40bokboisim" modified-by="" timestamp="1511747632315"><title>为什么要用工厂模式</title><children><topics type="attached"><topic id="7r51vcl62aee86ug005rgrfk0u" modified-by="" timestamp="1511747628758"><title svg:width="500">把创建对象者与对象的使用者分离（把创建者与使用者分离）</title></topic><topic id="6l4jhrk9jd080dkbdraqounc9m" modified-by="" timestamp="1511747640541"><title>解耦合</title></topic></topics></children></topic><topic id="6ugks251puesk6642vioamlkhe" modified-by="" timestamp="1511747661845"><title>形式</title><children><topics type="attached"><topic id="2evncf6hns7350t9envucrc1i0" modified-by="" timestamp="1511747821077"><title>1、简单工厂模式</title><children><topics type="attached"><topic id="32ucuubflfo0l3dfr2qvfsri42" modified-by="" timestamp="1511747685568"><title>特点</title><children><topics type="attached"><topic id="2uf9nis92p16quih9a0ghver3f" modified-by="" timestamp="1511747698277"><title>一个工厂生产所有产品</title></topic></topics></children></topic><topic id="64ggaaiqs5jlde81nb3lf4qj7m" modified-by="" timestamp="1511747720589"><title>缺点</title><children><topics type="attached"><topic id="47ehmvj9f93arp7bfb40vkgsbv" modified-by="" timestamp="1511747738515"><title>增加一个新产品， 就要修改工厂类代码</title><children><topics type="attached"><topic id="07f3a8vh8vnpqqqp71r9vftke5" modified-by="" timestamp="1511747774618"><title svg:width="500">违反了“对扩展开发，对修改关闭”的面向对象的设计原则</title></topic></topics></children></topic></topics></children></topic><topic id="79gisjq5173ddbncifoq2fif4o" modified-by="" timestamp="1511747814448"><title>优点</title><children><topics type="attached"><topic id="7tg8co2qksgi2so9rg357ss3aq" modified-by="" timestamp="1511747819044"><title>类少，简单</title></topic></topics></children></topic><topic id="1lg6qu0k2ecptlpg153qigl5lk" modified-by="" timestamp="1511748009668"><title>示例代码</title><notes><html><xhtml:p>//1、产品的接口</xhtml:p><xhtml:p>interface  Car{</xhtml:p><xhtml:p>	void run();</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p/><xhtml:p>//2、各种产品</xhtml:p><xhtml:p>class Benz implements Car{</xhtml:p><xhtml:p>	public void run(){</xhtml:p><xhtml:p>			...</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p/><xhtml:p>class BMW implements Car{</xhtml:p><xhtml:p>	public void run(){</xhtml:p><xhtml:p>			...</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p/><xhtml:p>//3、工厂</xhtml:p><xhtml:p>class SimpleFactory {</xhtml:p><xhtml:p/><xhtml:p>	public static Car getCar(String type){</xhtml:p><xhtml:p>		if("benz".equals(type)){</xhtml:p><xhtml:p>			return new Benz();</xhtml:p><xhtml:p>		}else if("bmw".equals(type)){</xhtml:p><xhtml:p>			return new BMW();</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p/><xhtml:p>		return null;</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p/><xhtml:p/><xhtml:p>//4、使用者</xhtml:p><xhtml:p/><xhtml:p>Car  car = SimpleFactory.getCar("benz");</xhtml:p><xhtml:p>car.run();</xhtml:p></html><plain>//1、产品的接口&#13;
interface  Car{&#13;
	void run();&#13;
}&#13;
&#13;
//2、各种产品&#13;
class Benz implements Car{&#13;
	public void run(){&#13;
			...&#13;
	}&#13;
}&#13;
&#13;
class BMW implements Car{&#13;
	public void run(){&#13;
			...&#13;
	}&#13;
}&#13;
&#13;
//3、工厂&#13;
class SimpleFactory {&#13;
&#13;
	public static Car getCar(String type){&#13;
		if("benz".equals(type)){&#13;
			return new Benz();&#13;
		}else if("bmw".equals(type)){&#13;
			return new BMW();&#13;
		}&#13;
&#13;
		return null;&#13;
	}&#13;
}&#13;
&#13;
&#13;
//4、使用者&#13;
&#13;
Car  car = SimpleFactory.getCar("benz");&#13;
car.run();</plain></notes></topic></topics></children></topic><topic id="7puus1ujg68d9lpaoff00r2bsj" modified-by="" timestamp="1511748044170"><title>2、工厂方法模式</title><children><topics type="attached"><topic id="2g43pe05kg7td8nau0s1m60bvn" modified-by="" timestamp="1511747701538"><title>特点</title><children><topics type="attached"><topic id="76u0ucppter3p465ggerhdav2n" modified-by="" timestamp="1511747708921"><title>一个产品配一个工厂</title></topic></topics></children></topic><topic id="6smmh2ok2d7c0eetf0s40aer45" modified-by="" timestamp="1511747783115"><title>缺点</title><children><topics type="attached"><topic id="130uklt83b1eqrb3d62oln3u5l" modified-by="" timestamp="1511747786049"><title>类比较多</title></topic></topics></children></topic><topic id="426dirt3rdmauf1028aetg793l" modified-by="" timestamp="1511747790411"><title>优点</title><children><topics type="attached"><topic id="38d60ckrscalhb4i24mnb98f59" modified-by="" timestamp="1511747810810"><title svg:width="500">增加一个新产品，对原来的代码不需要修改，只需要增加对应的工厂即可</title></topic></topics></children></topic><topic id="0gi1nats063kg81s9sbp337miv" modified-by="" timestamp="1511748226772"><title>示例代码</title><notes><html><xhtml:p>//1、产品的接口</xhtml:p><xhtml:p>interface  Car{</xhtml:p><xhtml:p>	void run();</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p/><xhtml:p>//2、各种产品</xhtml:p><xhtml:p>class Benz implements Car{</xhtml:p><xhtml:p>	public void run(){</xhtml:p><xhtml:p>			...</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p/><xhtml:p>class BMW implements Car{</xhtml:p><xhtml:p>	public void run(){</xhtml:p><xhtml:p>			...</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p/><xhtml:p>//3、各种工厂</xhtml:p><xhtml:p>interface  Factory{</xhtml:p><xhtml:p>	Car getCar();</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p/><xhtml:p>class BenzFactory implements Factory{</xhtml:p><xhtml:p>	public Benz getCar(){</xhtml:p><xhtml:p>		return new Benz();</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p/><xhtml:p>class BMWFactory implements Factory{</xhtml:p><xhtml:p>	public BMW getCar(){</xhtml:p><xhtml:p>		return new BMW();</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p/><xhtml:p>//4、使用者</xhtml:p><xhtml:p>BenzFactory f = new BenzFactory();</xhtml:p><xhtml:p/><xhtml:p>Car car = f.getCar();</xhtml:p><xhtml:p/><xhtml:p>car.run();</xhtml:p><xhtml:p/></html><plain>//1、产品的接口&#13;
interface  Car{&#13;
	void run();&#13;
}&#13;
&#13;
//2、各种产品&#13;
class Benz implements Car{&#13;
	public void run(){&#13;
			...&#13;
	}&#13;
}&#13;
&#13;
class BMW implements Car{&#13;
	public void run(){&#13;
			...&#13;
	}&#13;
}&#13;
&#13;
//3、各种工厂&#13;
interface  Factory{&#13;
	Car getCar();&#13;
}&#13;
&#13;
class BenzFactory implements Factory{&#13;
	public Benz getCar(){&#13;
		return new Benz();&#13;
	}&#13;
}&#13;
&#13;
class BMWFactory implements Factory{&#13;
	public BMW getCar(){&#13;
		return new BMW();&#13;
	}&#13;
}&#13;
&#13;
//4、使用者&#13;
BenzFactory f = new BenzFactory();&#13;
&#13;
Car car = f.getCar();&#13;
&#13;
car.run();&#13;
</plain></notes></topic></topics></children></topic><topic id="6s04oud701jjvpie9t92a9akqp" modified-by="" timestamp="1511747676766"><title>3、抽象工厂设计模式</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><title>设计模式</title></sheet></xmap-revision-content>