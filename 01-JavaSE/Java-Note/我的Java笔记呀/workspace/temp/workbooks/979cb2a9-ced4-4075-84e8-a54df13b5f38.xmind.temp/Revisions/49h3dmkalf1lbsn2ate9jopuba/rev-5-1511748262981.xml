<?xml version="1.0" encoding="UTF-8" standalone="no"?><xmap-revision-content xmlns="urn:xmind:xmap:xmlns:revision:1.0" xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:svg="http://www.w3.org/2000/svg" xmlns:xhtml="http://www.w3.org/1999/xhtml" xmlns:xlink="http://www.w3.org/1999/xlink"><sheet id="49h3dmkalf1lbsn2ate9jopuba" modified-by="" style-id="487gi5ovjek2lvp9sjqneegdtc" theme="xminddefaultthemeid" timestamp="1511747524680"><topic id="17mrtu3l8chvr316vtlolrv07t" modified-by="" structure-class="org.xmind.ui.logic.right" timestamp="1511745875845"><title>面向对象高级特性</title><extensions><extension provider="org.xmind.ui.map.unbalanced"><content><right-number>-1</right-number></content></extension></extensions><children><topics type="attached"><topic id="1paeq8kqq69qcoreld5icu5r7e" modified-by="" timestamp="1511746221190"><title>抽象</title><children><topics type="attached"><topic id="26lq6ojq91drvctqd194cmlj19" modified-by="" timestamp="1511746062378"><title>为什么会有抽象类</title><children><topics type="attached"><topic id="3flq27ks2u6m029ei8m064pjf1" modified-by="" timestamp="1511746060709"><title svg:width="500">当子类中都有一个共同的方法，每一个子类都有不同的实现，在父类中又要体现所有子类的共同的特点，所以要体现有这个方法，但是在父类中又无法给出具体的实现，那么这个时候就需要把这个方法声明为抽象的，而包含抽象方法的类，必须是抽象类</title></topic><topic id="56fh3u1p97qapvi46m1dek242b" modified-by="" timestamp="1511746062367"><title svg:width="500">某个父类仅仅是表示一个抽象的概念，不希望它被实例化，这个时候父类中可能没有抽象方法，但是我们也把它声明为抽象类</title></topic></topics></children></topic><topic id="123ijf5ufk02e9tkmv621643i8" modified-by="" timestamp="1511746077195"><title>如何声明抽象类</title><children><topics type="attached"><topic id="4nte0l0akjtd9l457l1gdoi2q1" modified-by="" timestamp="1511746081151"><title>语法格式</title><children><topics type="attached"><topic id="78sclc0ffelqj69gv8luujj2bl" modified-by="" timestamp="1511746082334"><title>[public/缺省] abstract class 类名{&#13;
}</title></topic></topics></children></topic></topics></children></topic><topic id="2s6ln2a41ik1mi005guu7p765b" modified-by="" timestamp="1511746096316"><title>如何声明抽象方法</title><children><topics type="attached"><topic id="7tinf1bmpm2jn2micln2jve6tt" modified-by="" timestamp="1511746101722"><title>语法格式</title><children><topics type="attached"><topic id="2mumclp913nt2ejnmknedj5mep" modified-by="" timestamp="1511746171478"><title svg:width="500">[public/protected/缺省]  abstract   返回值类型   方法名([形参列表]);</title><children><topics type="attached"><topic id="3u5381ju238ve24u8h89c2n34p" modified-by="" timestamp="1511746185994"><title>抽象方法是不能private,static,final修饰的</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="0d1jfqfrqcsnua5k2kngt17uvc" modified-by="" timestamp="1511746211072"><title>抽象类的特点</title><children><topics type="attached"><topic id="7ci60vi3d439aabh6la3bh5apt" modified-by="" timestamp="1511746212456"><title svg:width="500">（1）抽象类不能实例化&#13;
（2）抽象类可以包含抽象方法，也可以没有抽象方法。&#13;
如果一个类有抽象方法，那么这个类必须是抽象类，&#13;
如果一个抽象类没有抽象方法，那么它的用意是不想实例化，用它仅仅表示一个抽象的概念。&#13;
（3）抽象类生来就是用来被继承的，那么子类在继承它的时候，必须重写（实现）抽象父类的抽象方法，&#13;
否则该子类也得是抽象类。&#13;
（4）抽象类的变量与子类的对象构成多态引用。&#13;
（5）抽象类除了不能实例化，可以包含抽象方法，其他的和非抽象类是一样的，&#13;
可以有成员变量（类变量、实例变量）、构造器、代码块（静态代码块和非静态代码块）&#13;
方法（静态方法、非静态方法）</title></topic></topics></children></topic><topic id="2ff3r3hk6t1gva75bht27r6p31" modified-by="" timestamp="1511746228241"><title>抽象类不能实例化，为什么要有构造器呢？</title><children><topics type="attached"><topic id="7hljroh7pr5a9an2qtk8iks6jd" modified-by="" timestamp="1511746233915"><title svg:width="500">子类在继承该类时，一定要调用它的构造器，为属性初始化。</title><children><topics type="attached"><topic id="3dp2qh9n1p52f49hpvfbkjous8" modified-by="" timestamp="1511746262782"><title>因为构造器的作用有两点</title><children><topics type="attached"><topic id="01ujrfombs96jta9iln15lunna" modified-by="" timestamp="1511746262111"><title>（1）和new一起创建对象</title></topic><topic id="4kssbig2sem414f7i5bmoc464c" modified-by="" timestamp="1511746274933"><title>（2）为属性初始化</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="689idmgjbepi4ep6e5c9ktn66i" modified-by="" timestamp="1511747076644"><title>接口</title><children><topics type="attached"><topic id="5ucmhu24dj50qkppneuq5g68o9" modified-by="" timestamp="1511746785541"><title>接口即代表行为标准，功能标准</title></topic><topic id="4da2cknbt8vhqhjhfp1g7q2t2u" modified-by="" timestamp="1511746986735"><title>如何声明一个接口？</title><children><topics type="attached"><topic id="4tgoe6vuqilq7bo70n04hmjt79" modified-by="" timestamp="1511746992062"><title>语法结构</title><children><topics type="attached"><topic id="5igv1qs304u3fcf2e8857m5hkq" modified-by="" timestamp="1511746993186"><title>[public/缺省] interface 接口名{&#13;
}</title></topic></topics></children></topic></topics></children></topic><topic id="12mht89p2484t7apl6pkckl5v4" modified-by="" timestamp="1511747006749"><title>如何实现接口？</title><children><topics type="attached"><topic id="4nrn13nokgabbgvkpg4adfullg" modified-by="" timestamp="1511747023551"><title>语法结构</title><children><topics type="attached"><topic id="0jk10oauuk4he90o7uip7875l3" modified-by="" timestamp="1511747024980"><title svg:width="500">[public/缺省] class 子类名 [extends 父类名] implements  接口名1，接口名2。。。{&#13;
	//要实现接口的所有抽象方法&#13;
}</title></topic></topics></children></topic></topics></children></topic><topic id="5o8cp338iokj94q9feebr93e9i" modified-by="" timestamp="1511747134822"><title>接口的特点</title><children><topics type="attached"><topic id="24eln82jcppeijs8aaqj8jo9sa" modified-by="" timestamp="1511747112136"><title>JDK1.7</title><children><topics type="attached"><topic id="30php8rsf5hlg8oj2f6ccckk16" modified-by="" timestamp="1511747114072"><title svg:width="500">JDK1.7：&#13;
（1）接口不能实例化&#13;
（2）接口只能有全局静态的常量和公共的抽象方法&#13;
（3）接口中不能有构造器，因为它没有属性需要初始化，又不能创建对象&#13;
（4）接口生来用来被实现的，那么实现类（像子类）在实现它时，必须实现（和重写要求一样）接口的&#13;
所有抽象方法，否则该实现类也得是抽象类&#13;
（5）一个类可以同时实现多个接口&#13;
（6）一个类还可以继承父类又实现接口，但是必须先继承后实现&#13;
（7）接口与接口之间是继承关系，一个接口可以继承多个接口&#13;
（8）接口与实现类的对象之间构成多态引用</title></topic></topics></children></topic><topic id="6611cktbpm1cpgjskjvlmbt3o7" modified-by="" timestamp="1511747145811"><title>JDK1.8</title><children><topics type="attached"><topic id="6sisbmqcmhc2k58v0ie07tqob2" modified-by="" timestamp="1511747209402"><title svg:width="500">其他的和JDK1.7一样，不一样的是：&#13;
JDK1.8之后，接口中除了全局静态的常量和公共的抽象方法以外，可以有静态方法和默认方法</title><children><topics type="attached"><topic id="3tqv5qo96euci3f05qttp6pc7g" modified-by="" timestamp="1511747196151"><title>接口中的静态方法</title><children><topics type="attached"><topic id="7v80fhtoo1rb64v28t0c6b0riv" modified-by="" timestamp="1511747194942"><title svg:width="500">当接口的所有实现类，对这个方法的实现是一样的，这个方法就设计在接口中，设计为静态方法</title></topic><topic id="3ho2il8t1s3hlf5309dtmanhf1" modified-by="" timestamp="1511747200572"><title>如何调用</title><children><topics type="attached"><topic id="14ngpp1dokp2r4o9st528o5k07" modified-by="" timestamp="1511747205688"><title>接口名.方法</title></topic></topics></children></topic></topics></children></topic><topic id="3ci070vn5iertsm1k055sgmjk3" modified-by="" timestamp="1511747466454"><title>接口中的默认方法</title><children><topics type="attached"><topic id="57gf1e45aea59rqadcd3rm9ofd" modified-by="" timestamp="1511747261595"><title svg:width="500">当接口的大多数实现类，对这个方法的实现是一样，那么这个方法的实现就可以在接口中提供默认实现，如果某个实现类觉得他不合适，只需要重写它即可</title></topic><topic id="3ueqak93ahucgjdkmqs74qdh33" modified-by="" timestamp="1511747302860"><title>如何调用</title><children><topics type="attached"><topic id="3qh3souakitd10m8g054ht1m7h" modified-by="" timestamp="1511747302037"><title>实现类外</title><children><topics type="attached"><topic id="3aqguqh5qs2mcjcl3id7kvsrd8" modified-by="" timestamp="1511747302018"><title>实现类对象.方法</title></topic></topics></children></topic><topic id="3mav7dkjk2k3ageo2d7dg12v8b" modified-by="" timestamp="1511747329806"><title>实现类中</title><children><topics type="attached"><topic id="68lh8jqu05h48l9cqh772c67hm" modified-by="" timestamp="1511747328308"><title svg:width="500">如果实现类要重写该默认方法，但是又想调用接口中的默认实现</title></topic><topic id="2fihn3q16ealhkj9c90nmnipo7" modified-by="" timestamp="1511747339312"><title>接口名.super.方法</title></topic></topics></children></topic></topics></children></topic><topic id="1pfec4j3q62g3lel02u0koqlag" modified-by="" timestamp="1511747376830"><title>什么情况下需要重写</title><children><topics type="attached"><topic id="13ojndejcqqdddbgju9d6jrnbn" modified-by="" timestamp="1511747373525"><title>接口中的默认实现不适合该实现类</title></topic><topic id="4m95lf2fevuv6ib1tr1c80gaq7" modified-by="" timestamp="1511747383155"><title>必须重写</title><children><topics type="attached"><topic id="6l0g11t7hfb47h9mjqd2aq3op6" modified-by="" timestamp="1511747454317"><title svg:width="500">一个类同时实现了多个接口，而多个接口中都相同的默认方法（方法名和形参列表都相同），这个时候实现类必须做出选择，要重写，如果需要保留其中一个的话，通过接口名.super.方法，保留它的默认实现</title></topic></topics></children></topic></topics></children></topic><topic id="6lrim758b6mrpod9uo3t4m44jj" modified-by="" timestamp="1511747475302"><title>类优先原则</title><children><topics type="attached"><topic id="4cs419onrk99p5519s53njqc7l" modified-by="" timestamp="1511747524680"><title svg:width="500">当一个类继承了父类，又实现了接口，而且父类中的某个方法与接口中的默认方法一样（方法名和形参列表），默认保留的是父类中的方法实现</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><title>面向对象高级特性</title></sheet></xmap-revision-content>