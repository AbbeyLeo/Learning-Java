<?xml version="1.0" encoding="UTF-8" standalone="no"?><xmap-revision-content xmlns="urn:xmind:xmap:xmlns:revision:1.0" xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:svg="http://www.w3.org/2000/svg" xmlns:xhtml="http://www.w3.org/1999/xhtml" xmlns:xlink="http://www.w3.org/1999/xlink"><sheet id="6lgaqelsl7vahaqga4b8v9t2n0" modified-by="" style-id="4cvokp6eo22cm3100r95ohtobs" theme="xminddefaultthemeid" timestamp="1511832271311" xmlns="urn:xmind:xmap:xmlns:content:2.0"><topic id="38p178imlngv6oeg71qrap62ko" modified-by="" structure-class="org.xmind.ui.logic.right" timestamp="1511316240491"><title>面向对象</title><extensions><extension provider="org.xmind.ui.map.unbalanced"><content><right-number>-1</right-number></content></extension></extensions><children><topics type="attached"><topic id="7vqmkooiolif9nkr53r35g9vgv" modified-by="" timestamp="1510969245046"><title>面向对象和面向过程的区别</title><children><topics type="attached"><topic id="5jp6s924bksm0io5aoi9ucl552" modified-by="" timestamp="1510969231995"><title>都是编程思想</title></topic><topic id="7qf6he5midsicdvqn2n0rlkvpi" modified-by="" timestamp="1510969269336"><title>面向过程注重过程，步骤，怎么做</title><children><topics type="attached"><topic id="7obu1vh5vk4sl11uu6r29prv67" modified-by="" timestamp="1510969272655"><title>执行者</title></topic></topics></children></topic><topic id="1qfh4n64it1d8fhb828bvuc00h" modified-by="" timestamp="1510969264718"><title>面向对象注重对象，谁来做</title><children><topics type="attached"><topic id="7g5v275uhha0okvtdg8vupfpud" modified-by="" timestamp="1510969285674"><title>指挥者</title></topic></topics></children></topic></topics></children></topic><topic id="0b6hlirrehqa8udkp75uo07e1n" modified-by="" timestamp="1510969361391"><title>面向对象学习</title><children><topics type="attached"><topic id="486r5icrc8qi15at1k55itbbmi" modified-by="" timestamp="1510969400584"><title>1、类与对象</title><children><topics type="attached"><topic id="08naed3otb3nem8rb99a537e31" modified-by="" timestamp="1510969378876"><title>（1）类与对象的概念</title></topic><topic id="1e7r4366h51gg4nqfp1h4thavm" modified-by="" timestamp="1510969385448"><title>（2）类与对象的关系</title></topic><topic id="0tnjk3ojt5tua1fhj9aj3ogpl0" modified-by="" timestamp="1510969399778"><title>（3）如何设计类，类的成员</title></topic><topic id="75p12ljfr4jhnl4jo1grnie0af" modified-by="" timestamp="1510969407156"><title>（4）如何创建对象</title></topic></topics></children></topic><topic id="3meal99au70ic6ea5gq6s6b1re" modified-by="" timestamp="1510969443984"><title>2、面向对象的三个基本特征和高级特性</title><children><topics type="attached"><topic id="3iu3e90066h9p47gfqi3hj7erv" modified-by="" timestamp="1510969453306"><title>基本特性</title><children><topics type="attached"><topic id="478c4qhobph4lt9heinp64a5hs" modified-by="" timestamp="1510969450839"><title>封装</title></topic><topic id="3mlcn5efguqumctbgscnj2ft0p" modified-by="" timestamp="1510969453022"><title>继承</title></topic><topic id="0s10erkmuh1maq7dhff9hkg5g1" modified-by="" timestamp="1510969455798"><title>多态</title></topic></topics></children></topic><topic branch="folded" id="4h0tlsaa6ad0egbdqlhg05t9eo" modified-by="" timestamp="1510969523287"><title>高级特性</title><children><topics type="attached"><topic id="2ov40f939vd7gs386p24jj95f0" modified-by="" timestamp="1510969465642"><title>枚举</title></topic><topic id="443u4opatfo2bbt3apcr58nkgh" modified-by="" timestamp="1510969469737"><title>接口</title></topic><topic id="7nfhdarg2tsrstsh65arj2lge4" modified-by="" timestamp="1510969472189"><title>抽象</title></topic><topic id="6cjgdp8ouga2qcp914iol3aja2" modified-by="" timestamp="1510969476162"><title>泛型</title></topic><topic id="7vslliho62empnag0ogeku934u" modified-by="" timestamp="1510969479908"><title>注解</title></topic><topic id="039lt9kcpmbuqpcou0ehs0km3h" modified-by="" timestamp="1510969485113"><title>可变参数</title></topic><topic id="0bpfk2e0qhbhiq799ht34724of" modified-by="" timestamp="1510969494107"><title>自动装箱与拆箱</title></topic><topic id="45gncr7juapf8eihn508ru0pgr" modified-by="" timestamp="1510969502595"><title>foreach</title></topic><topic id="5c86uap75vpbhjg2savmvfnitj" modified-by="" timestamp="1510969516664"><title>Lambda表达式</title></topic><topic id="50g837eelg011e7o10nqk096vb" modified-by="" timestamp="1510969519088"><title>.....</title></topic></topics></children></topic></topics></children></topic><topic id="730c45en9p6s5bhvhcpr8gv61t" modified-by="" timestamp="1510969596816"><title>3、相关的关键字和API</title><children><topics type="attached"><topic id="07ok66sa7dcttraphc48am9tml" modified-by="" timestamp="1510969596033"><title>关键字</title><children><topics type="attached"><topic id="2sbtsmedigvauhgvf63mtdifd3" modified-by="" timestamp="1510969592250"><title>class</title></topic><topic id="3otdtujqikfo8c9mefnekk9nqt" modified-by="" timestamp="1510969592260"><title>new</title></topic><topic id="21r357benf6fnd3n44khguokho" modified-by="" timestamp="1510969592275"><title>this</title></topic><topic id="3afq88sfd51c6plfoghpfrngo0" modified-by="" timestamp="1510969592291"><title>权限修饰符</title><children><topics type="attached"><topic id="0q37n8i2p90nnari5t10edkcas" modified-by="" timestamp="1510969552166"><title>public</title></topic><topic id="4vl38p0oqa1mqpnbkuaq2ieahc" modified-by="" timestamp="1510969556375"><title>protected</title></topic><topic id="5m6ibi2623s2rtore9uk8i6bhc" modified-by="" timestamp="1510969559408"><title>缺省</title></topic><topic id="09ds2p9i419nqeu66fc8au9prs" modified-by="" timestamp="1510969562249"><title>private</title></topic></topics></children></topic><topic id="7of49ugl33m7vsa1guvdbb5ldp" modified-by="" timestamp="1510969592334"><title>super</title></topic><topic id="4rqtuin2sfpjilu0vet7fh7fgs" modified-by="" timestamp="1510969592355"><title>...</title></topic></topics></children></topic><topic id="3v1a34204gosd4ta1pvk5fovig" modified-by="" timestamp="1510969618063"><title>API</title><children><topics type="attached"><topic id="4rdtq02guhn6r5ktarguik0e7t" modified-by="" timestamp="1510969603720"><title>集合</title></topic><topic id="0ar0uae6akhhj88uec0lru5pif" modified-by="" timestamp="1510969606627"><title>异常</title></topic><topic id="1mcpl58flfjco70tk7ji2oims3" modified-by="" timestamp="1510969609266"><title>IO</title></topic><topic id="56d8ac7t3sth0tgcbbkb69gat9" modified-by="" timestamp="1510969614566"><title>网络编程</title></topic><topic id="40o5ca4eu4v7lr3u4h72clptmm" modified-by="" timestamp="1510969617504"><title>线程</title></topic><topic id="2f0jg92g21chcopc7r2obkl7mm" modified-by="" timestamp="1510969620263"><title>....</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="306fnpuq0v5iliclk2bl048t8n" modified-by="" timestamp="1510970468138"><title>1、类与对象</title><children><topics type="attached"><topic id="06ij68q4i1d7sju6rtn4ki87mi" modified-by="" timestamp="1510969673025"><title>(1)类与对象的概念</title><children><topics type="attached"><topic id="25ns0m76o47sms8c7d05shjitl" modified-by="" timestamp="1510969672116"><title>类：对一类具有相同特征的事物的抽象描述</title></topic><topic id="6qh30ftjeuru0m1ctj838iukln" modified-by="" timestamp="1510969683039"><title>对象：类的实例，是具体的个体</title></topic></topics></children></topic><topic id="49q9lm06s2lh1geojas6kp1k6l" modified-by="" timestamp="1510969708344"><title>(2)类与对象的关系</title><children><topics type="attached"><topic id="0gu0euiahhs71fsr3kr008miql" modified-by="" timestamp="1510969706627"><title>类是对象的设计图，创建的模板</title></topic><topic id="35srakdi66c1js4446cpnlthim" modified-by="" timestamp="1510969724601"><title>对象是类的实例，是一个具体的个体</title></topic></topics></children></topic><topic id="21reh5g7692chiguqg09t2709r" modified-by="" timestamp="1511829561557"><title>(3)类的设计，成员</title><children><topics type="attached"><topic id="71f2cfk7vs935sanh4okkmbjce" modified-by="" timestamp="1510969916821"><title>（1）属性</title><children><topics type="attached"><topic id="4ecotof3ru7e20k60drs0kcia1" modified-by="" timestamp="1510969874025"><title>属性的特点</title><children><topics type="attached"><topic id="5v14m920essmntejbv7fa2vkj0" modified-by="" timestamp="1510969795984"><title>（1）声明的位置</title><children><topics type="attached"><topic id="7gq6s18u26402h5hcqvitd2i0v" modified-by="" timestamp="1510969800751"><title>在类中方法外</title></topic></topics></children></topic><topic id="6q01gstict6qckcl64tca1mt8d" modified-by="" timestamp="1510969819291"><title>（2）保存的位置</title><children><topics type="attached"><topic id="6d0clcldv5isb8tf1sq8ke5qgg" modified-by="" timestamp="1510969836522"><title>static</title><children><topics type="attached"><topic id="3v72g7hcdopn7lu30c5uf6nmpm" modified-by="" timestamp="1510969839685"><title>在方法区</title></topic></topics></children></topic><topic id="7qkt945u3s7qluj8ssknraoev9" modified-by="" timestamp="1510969829943"><title>非static</title><children><topics type="attached"><topic id="740q8m52evj4udc8ctplfqq11i" modified-by="" timestamp="1510969834017"><title>在堆中</title></topic></topics></children></topic></topics></children></topic><topic id="7js439gte460v7mbigefgsd9gb" modified-by="" timestamp="1510969858532"><title>（3）默认值</title><children><topics type="attached"><topic id="50djossk6kafpr804glkdembgn" modified-by="" timestamp="1510969859747"><title svg:width="500">byte,short,int,long是0，float,double是0.0，boolean是false，char是\u0000，引用数据类型都是null</title></topic></topics></children></topic><topic id="32575f68vb4uggji7ol0b50ljv" modified-by="" timestamp="1510969868471"><title>（4）作用域</title><children><topics type="attached"><topic id="0lsgcmqql4qma18foupf6hbut2" modified-by="" timestamp="1510969873140"><title>在整个类中</title></topic></topics></children></topic><topic id="2rlffo9c2q8somuba9dbu538dt" modified-by="" timestamp="1510969881924"><title>（5）生命周期</title><children><topics type="attached"><topic id="4sq0rfch61hbf5948d6joi5v0p" modified-by="" timestamp="1510969913149"><title>随着对象的创建而创建，到垃圾回收为止</title></topic></topics></children></topic></topics></children></topic><topic id="2ecg7cobf58kv86fv73aipmt0j" modified-by="" timestamp="1510969923308"><title>属性声明格式</title><children><topics type="attached"><topic id="3mm8ijkmm9oqk6g796mg7tqah1" modified-by="" timestamp="1510969950430"><title>[修饰符]  数据类型  属性名 【=显式值】; </title><children><topics type="attached"><topic id="3dgeqnk78iuh57omb1r2rf1niv" modified-by="" timestamp="1510969956857"><title>修饰符</title><children><topics type="attached"><topic id="774hj97mjjr3bemh9r7a43ht40" modified-by="" timestamp="1510969960254"><title>private</title><children><topics type="attached"><topic id="1hfun1vuuot6mndedlsvl8f6tk" modified-by="" timestamp="1510969966379"><title>私有化</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="0b9avo6ih7d3r8vm4vovbjv6l3" modified-by="" timestamp="1510970103252"><title>（2）构造器</title><children><topics type="attached"><topic id="5pnas4q9jjp049k6nhqc83knbh" modified-by="" timestamp="1510970002277"><title>构造器的作用</title><children><topics type="attached"><topic id="6j76ml3chb86hv2u1eh26tjvek" modified-by="" timestamp="1510970001017"><title>（1）和new一起创建对象</title></topic><topic id="5pt86eklh7498dim4fgkmiqjc7" modified-by="" timestamp="1510970008282"><title>（2）为属性赋值</title></topic></topics></children></topic><topic id="6k6n8a48qh4vr565ck5c1bs630" modified-by="" timestamp="1510970034013"><title>如何声明</title><children><topics type="attached"><topic id="1p1i859d1061oipv03niu2ku63" modified-by="" timestamp="1510970031700"><title>无参</title><children><topics type="attached"><topic id="3lr99ar8of9us6327oa4vdoejk" modified-by="" timestamp="1510970032884"><title>[修饰符] 类名(){&#13;
}</title></topic></topics></children></topic><topic id="4dcfniifjiaourunjnv5muv8oo" modified-by="" timestamp="1510970040578"><title>有参</title><children><topics type="attached"><topic id="1vp29taud7hlqcls4s1l56g6k3" modified-by="" timestamp="1510970041635"><title>[修饰符] 类名(形参列表){&#13;
}</title></topic></topics></children></topic></topics></children></topic><topic id="4e7ofvi9ukeivdvq8j8t104gfs" modified-by="" timestamp="1510970071611"><title>特点</title><children><topics type="attached"><topic id="3t7ngv2p4t5jkppiljg7232imv" modified-by="" timestamp="1510970091694"><title svg:width="500">构造器的特点：&#13;
（1）构造器名与类名必须相同&#13;
（2）构造器没有返回值&#13;
（3）构造器可以重载&#13;
（4）如果一个类没有声明过构造器，编译器将默认添加一个无参构造&#13;
如果这个类声明了构造器，编译器将不再自动添加无参构造</title></topic></topics></children></topic><topic id="0q44sgelkmf8v7uln3t0a2n4hp" modified-by="" timestamp="1510970155768"><title>如何调用</title><children><topics type="attached"><topic id="5thauu852lnaesrdo1glf05ki4" modified-by="" timestamp="1510970161287"><title>（1）和new一起  </title><children><topics type="attached"><topic id="2jiu6llbbrcebr7m4uttf4o120" modified-by="" timestamp="1510970135268"><title>  new 构造器()&#13;
  new 构造器(实参列表)</title></topic></topics></children></topic><topic id="4h051nnpb2iqor8vf3p873jn2c" modified-by="" timestamp="1510970162730"><title svg:width="500">（2）在本类的其他构造器中或子类的构造器中</title><children><topics type="attached"><topic id="2qinovv8uglem3jedk40o1im01" modified-by="" timestamp="1510970148622"><title>在本类的其他构造器中：this()或this(实参列表)&#13;
在子类的构造器中：super()或super(实参列表)</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="2eabg034823ups92t2gl4hj8v2" modified-by="" timestamp="1510970209829"><title>（3）方法</title><children><topics type="attached"><topic id="2slmrtj4u5v3eepks3nf6jpof9" modified-by="" timestamp="1510970196642"><title>无参无返回值</title></topic><topic id="5113bnis38702ffcc4ni4afpka" modified-by="" timestamp="1510970205025"><title>有参无返回值</title></topic><topic id="45kaq2eqt92jkkv2ghlg6l16kh" modified-by="" timestamp="1510970209570"><title>无参有返回值</title></topic><topic id="2jmof8da0mvlk7i7or0uh6kli1" modified-by="" timestamp="1510970218585"><title>有参有返回值</title></topic></topics></children></topic><topic id="751kar81iolb25bmjnga13ki97" modified-by="" timestamp="1511573759481"><title>（4）代码块</title><children><topics type="attached"><topic id="5vti4fago5hul0ch3ff70h9mo6" modified-by="" timestamp="1511573507975"><title>按位置分</title><children><topics type="attached"><topic id="45lhd9965r887u6u8bsvqhoenh" modified-by="" timestamp="1511573523866"><title>在类中方法外</title><children><topics type="attached"><topic id="3q6ddbvq0rdiqq6a1oaokgspk7" modified-by="" timestamp="1511573552584"><title>是否有static修饰</title><children><topics type="attached"><topic id="4qb94cppg7n0d790hig717ridt" modified-by="" timestamp="1511573672131"><title>有static修饰的：静态代码块</title><children><topics type="attached"><topic id="2padql194iu1j4ra5taoa3oqjl" modified-by="" timestamp="1511573576169"><title>语法结构</title><children><topics type="attached"><topic id="0vn34r3vemmoa76k7q44m6auve" modified-by="" timestamp="1511573604494"><title>class 类{&#13;
	static{&#13;
		静态代码块&#13;
    }&#13;
}</title></topic></topics></children></topic><topic id="07b5kd34pmkkgcm927su1c5at8" modified-by="" timestamp="1511573626225"><title>特点</title><children><topics type="attached"><topic id="2r8if2nonkcj4ejdjfb556878f" modified-by="" timestamp="1511573657096"><title svg:width="500">随着类的加载并初始时而执行，而且一个类的静态代码块只执行一次</title><children><topics type="attached"><topic id="37k19sacbakrms4694shcp24ej" modified-by="" timestamp="1511573655747"><title>而且父类的静态代码块优先于子类的静态代码块</title></topic><topic id="6j1ia5r5g45l7ebh82gusca31j" modified-by="" timestamp="1511573667833"><title>静态代码块肯定优先于构造块和构造器</title></topic></topics></children></topic></topics></children></topic><topic id="02vemqn9rdgftmdacr3nof25e4" modified-by="" timestamp="1511573675124"><title>作用</title><children><topics type="attached"><topic id="0emell9ppdv0j5ej0ifqh86agr" modified-by="" timestamp="1511573688470"><title>为静态变量（类变量）初始化（赋值）</title></topic></topics></children></topic></topics></children></topic><topic id="53rn9et1ihgnbm60hpifu2gsb0" modified-by="" timestamp="1511573711956"><title>没有static修饰的：非静态代码块，构造块</title><children><topics type="attached"><topic id="4kp16ilro7gm9m9j792h1qgvha" modified-by="" timestamp="1511573615272"><title>语法结构</title><children><topics type="attached"><topic id="12lldha76jncf65d4tlb4stghr" modified-by="" timestamp="1511573619135"><title>class 类{&#13;
	{&#13;
		静态代码块&#13;
    }&#13;
}</title></topic></topics></children></topic><topic id="3e1qpmovbpjvn3toqokqaj3ldv" modified-by="" timestamp="1511573694674"><title>特点</title><children><topics type="attached"><topic id="12b64iktr8mjmjmgkh4lu3kpq9" modified-by="" timestamp="1511573710684"><title>每次创建对象时调用，而且先于构造器调用</title></topic></topics></children></topic><topic id="71j9jlin3hu5sgcg4q2j018n2i" modified-by="" timestamp="1511573714939"><title>作用</title><children><topics type="attached"><topic id="5qlj0dtrt9ok63lrkemn1c3t0u" modified-by="" timestamp="1511573739540"><title svg:width="500">为实例变量初始化（赋值），一般是多个构造器中重复的代码提取到构造块</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="74rt7cf5r2npf2dsg085esf5ob" modified-by="" timestamp="1511573511370"><title>在方法中</title><children><topics type="attached"><topic id="5pamve804mj4qnotp9hghk9vrc" modified-by="" timestamp="1511573522041"><title>局部代码块（了解）</title></topic></topics></children></topic></topics></children></topic><topic id="1ka0gab07p9d01evteflabk4nm" modified-by="" timestamp="1511573933800"><title>相关的面试题</title><children><topics type="attached"><topic id="5m2j1b8vksq84o6gtmcllqss6l" modified-by="" timestamp="1511573850855"><title>赋值和执行的顺序</title><children><topics type="attached"><topic id="6rksq40pl6069ccgbvnig83dbe" modified-by="" timestamp="1511573816929"><title svg:width="500">父类的静态代码块 -- 》子类的静态代码块  --》父类的构造块--》父类的构造器 --》子类的构造块 --》子类的构造器</title></topic><topic id="56gbduf2khi1eli2186smuveef" modified-by="" timestamp="1511573916347"><title/><xhtml:img svg:height="306" svg:width="400" xhtml:src="xap:attachments/2gonv6kv6okhdbj0dahp0nnc02.png"/></topic></topics></children></topic><topic id="44f2iqvij3phnioujne299c1bh" modified-by="" timestamp="1511573948825"><title>关于static的重写问题</title><children><topics type="attached"><topic id="6211nv4qoksurp9obvbv1jjjs7" modified-by="" timestamp="1511574019387"><title svg:width="500">静态的方法和属性，没有编译时类型和运行时类型的区别，只有编译时类型，换句话说没有重写（覆盖）一说</title><notes><html><xhtml:p>package com.atguigu.static_.buchong;</xhtml:p><xhtml:p>/*</xhtml:p><xhtml:p> * 静态的方法：不存在编译时和运行时类型，只有编译时类型</xhtml:p><xhtml:p> * 静态的属性：不存在编译时和运行时类型，只有编译时类型</xhtml:p><xhtml:p> */</xhtml:p><xhtml:p>public class Test {</xhtml:p><xhtml:p>	public static void main(String[] args) {</xhtml:p><xhtml:p>		SuperClass s = new SubClass();</xhtml:p><xhtml:p>		s.test();//父类的方法</xhtml:p><xhtml:p>		System.out.println(s.info);//尚硅谷</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		SubClass sub = new SubClass();</xhtml:p><xhtml:p>		sub.test();//子类的方法</xhtml:p><xhtml:p>		System.out.println(sub.info);//atguigu</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p>class SuperClass{</xhtml:p><xhtml:p>	static String info = "尚硅谷";</xhtml:p><xhtml:p>	public static void test(){</xhtml:p><xhtml:p>		System.out.println("父类的方法");</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p>class SubClass extends SuperClass{</xhtml:p><xhtml:p>	static String info = "atguigu";</xhtml:p><xhtml:p>	public static void test(){</xhtml:p><xhtml:p>		System.out.println("子类的方法");</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p></html><plain>package com.atguigu.static_.buchong;&#13;
/*&#13;
 * 静态的方法：不存在编译时和运行时类型，只有编译时类型&#13;
 * 静态的属性：不存在编译时和运行时类型，只有编译时类型&#13;
 */&#13;
public class Test {&#13;
	public static void main(String[] args) {&#13;
		SuperClass s = new SubClass();&#13;
		s.test();//父类的方法&#13;
		System.out.println(s.info);//尚硅谷&#13;
		&#13;
		SubClass sub = new SubClass();&#13;
		sub.test();//子类的方法&#13;
		System.out.println(sub.info);//atguigu&#13;
	}&#13;
}&#13;
class SuperClass{&#13;
	static String info = "尚硅谷";&#13;
	public static void test(){&#13;
		System.out.println("父类的方法");&#13;
	}&#13;
}&#13;
class SubClass extends SuperClass{&#13;
	static String info = "atguigu";&#13;
	public static void test(){&#13;
		System.out.println("子类的方法");&#13;
	}&#13;
}</plain></notes></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="5voiclv6c2oblqkk2gcjs6pk7v" modified-by="" timestamp="1511829795607"><title>（5）内部类</title><children><topics type="attached"><topic id="2gsjjk5kjvtkd12acj8k8vkou7" modified-by="" timestamp="1511829751969"><title>什么情况下使用内部类</title><children><topics type="attached"><topic id="6j8dsmrp03a2vjbgg4hlr8vbkp" modified-by="" timestamp="1511829753919"><title svg:width="500">（1）当一个事物的内部，还有一个部分需要一个完整的结构进行描述，而这个内部的完整的结构又只为外部事物提供服务，那么整个内部的完整结构最好使用内部类&#13;
（2）内部类可以访问外部类的所有的成员，包括私有的</title></topic></topics></children></topic><topic id="7ut1h6fs6kt8pei707br42uilc" modified-by="" timestamp="1511829812112"><title>形式</title><children><topics type="attached"><topic id="1qst29v8f67aesjed5t14vpfij" modified-by="" timestamp="1511829823013"><title>成员</title><children><topics type="attached"><topic id="41jtpk3bbcgnl6jbmkoe0an85r" modified-by="" timestamp="1511830328244"><title>静态内部类</title><children><topics type="attached"><topic id="37n82fhfc1ppu4bg68lmal6od7" modified-by="" timestamp="1511829939740"><title>格式</title><children><topics type="attached"><topic id="1f1d41qjthrtph2qvi2qja6tbk" modified-by="" timestamp="1511829976954"><title>[修饰符] class 外部类{&#13;
	[修饰符] static class 内部类{&#13;
	}&#13;
}</title></topic></topics></children></topic><topic id="2lhocad35elqifka69j0l28ktf" modified-by="" timestamp="1511830223583"><title>修饰符的问题</title><children><topics type="attached"><topic id="0pndnjhuto34ae0httulmpj3bf" modified-by="" timestamp="1511830177182"><title>（1）权限修饰符</title><children><topics type="attached"><topic id="7vqrsidqrshsfqhqkkm2vn73vb" modified-by="" timestamp="1511830180692"><title>4种</title></topic></topics></children></topic><topic id="7smveveu1ov4miln82pvhq8mua" modified-by="" timestamp="1511830201240"><title>（2）static</title><children><topics type="attached"><topic id="44t2mblkptini5htl2nd56tmq9" modified-by="" timestamp="1511830209368"><title>必须得有</title></topic></topics></children></topic><topic id="2ggvapngah5lva51vctejqcmov" modified-by="" timestamp="1511830267354"><title>（3）final（极少）</title><children><topics type="attached"><topic id="31rvlo4iftlvl9pnmhfn1k884u" modified-by="" timestamp="1511830217818"><title>可以</title><children><topics type="attached"><topic id="23vije3ae6k22dtf53ci6k69bg" modified-by="" timestamp="1511830223344"><title>表示不能被继承</title></topic></topics></children></topic></topics></children></topic><topic id="4mnpdkb2c5jrs2pqmpchq360ff" modified-by="" timestamp="1511830265033"><title>（4）abstract（极少）</title><children><topics type="attached"><topic id="6a6hr8usq6fohtah6g2jsgojp5" modified-by="" timestamp="1511830232998"><title>可以</title><children><topics type="attached"><topic id="197gkhn0bhdj85vt4pbtvhgih9" modified-by="" timestamp="1511830247529"><title>表示可以包含抽象方法，需要子类继承</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="53jn18akofm12bdnffa1b5kahh" modified-by="" timestamp="1511830317288"><title>静态内部类的成员</title><children><topics type="attached"><topic id="1fd5oa60vmn8nsi2ujmbfl10gr" modified-by="" timestamp="1511830323816"><title>所有都可以，包括静态的</title></topic></topics></children></topic><topic id="4hkh0ejloimagl537u1l0hstk0" modified-by="" timestamp="1511830421627"><title>使用问题</title><children><topics type="attached"><topic id="283v3r45u67dfinstmge48v4dq" modified-by="" timestamp="1511830354572"><title>（1）在静态内部类中使用外部类的成员</title><children><topics type="attached"><topic id="04hd82q5got4nniv036bdsspre" modified-by="" timestamp="1511830372292"><title>只能使用外部类的静态成员</title></topic></topics></children></topic><topic id="38gplhra36tfuh07ufdgb10ni0" modified-by="" timestamp="1511830402017"><title>（2）在外部类中使用静态内部类</title><children><topics type="attached"><topic id="0i22osrk7le8c1bo8teiav56si" modified-by="" timestamp="1511830406056"><title>都可以</title></topic></topics></children></topic><topic id="6nklperfinj4ve8khg419apfti" modified-by="" timestamp="1511830453230"><title>（3）在外部类的外面，其他类中</title><children><topics type="attached"><topic id="2iiiaf7tuvemfj8l59ikp54gbi" modified-by="" timestamp="1511830467015"><title>（1）用静态内部类的静态成员</title><children><topics type="attached"><topic id="1t22fi4ge81m41c90b6emdao79" modified-by="" timestamp="1511830492614"><title>外部类名.内部类名.静态成员</title></topic></topics></children></topic><topic id="37bt81mmvqqo6ejp186f3kk5b2" modified-by="" timestamp="1511830513861"><title>（2）用静态内部类的非静态成员</title><children><topics type="attached"><topic id="41dvovo0frp9cd0jlc5tl7mkgv" modified-by="" timestamp="1511830513071"><title>需要静态内部类的对象</title></topic><topic id="3to05hukt2g9736pemle9l6jdb" modified-by="" timestamp="1511830545485"><title svg:width="500">外部类名.内部类   变量 = new   外部类名.内部类();&#13;
变量.成员....</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="6q3sbs77n3hugdkb5ah41m9rd4" modified-by="" timestamp="1511831057383"><title>非静态内部类，通常称为成员内部类</title><children><topics type="attached"><topic id="3p29iqrthi1ictolurdu9q07r2" modified-by="" timestamp="1511829989460"><title>格式</title><children><topics type="attached"><topic id="5rao5nkqbkt8fnp7sh3k6qkcs2" modified-by="" timestamp="1511829990906"><title>[修饰符] class 外部类{&#13;
	[修饰符] class 内部类{&#13;
	}&#13;
}</title></topic></topics></children></topic><topic id="59462sugqe0kkqlm0k1ri5evh0" modified-by="" timestamp="1511830590134"><title>修饰符的问题</title><children><topics type="attached"><topic id="0mb2u3faeg5v4ncmc7u3na58d6" modified-by="" timestamp="1511830177182"><title>（1）权限修饰符</title><children><topics type="attached"><topic id="506schralrohrlrvbkhanp9ed5" modified-by="" timestamp="1511830180692"><title>4种</title></topic></topics></children></topic><topic id="4orsso4iku27krmb1jhqsp83so" modified-by="" timestamp="1511830201240"><title>（2）static</title><children><topics type="attached"><topic id="1f6sbksg9lhk8gmdtqak0q0k9v" modified-by="" timestamp="1511830609742"><title>没有</title></topic></topics></children></topic><topic id="403vd7d9qe7m0ohvkab6orbg8f" modified-by="" timestamp="1511830267354"><title>（3）final（极少）</title><children><topics type="attached"><topic id="6j851mpqtkt89hcemh1gubqbh8" modified-by="" timestamp="1511830217818"><title>可以</title><children><topics type="attached"><topic id="0vvr5bq2almir62sadg6pjijfu" modified-by="" timestamp="1511830223344"><title>表示不能被继承</title></topic></topics></children></topic></topics></children></topic><topic id="6g7nplduojubf4c5t061blt5sp" modified-by="" timestamp="1511830265033"><title>（4）abstract（极少）</title><children><topics type="attached"><topic id="6b5qej6s07dcs74pi17pn5ggfp" modified-by="" timestamp="1511830232998"><title>可以</title><children><topics type="attached"><topic id="5e5b8ileo5tb04hp07vhde4htt" modified-by="" timestamp="1511830247529"><title>表示可以包含抽象方法，需要子类继承</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="2s9q3v03m1erk0hbmp3jj76r2s" modified-by="" timestamp="1511830635924"><title>非静态内部类的成员</title><children><topics type="attached"><topic id="5ognhglpv152vipt22rjhq6kta" modified-by="" timestamp="1511830648852"><title>除了静态成员，其他都可以</title></topic></topics></children></topic><topic id="5f1t08biektn71ai3e53posbsn" modified-by="" timestamp="1511830775850"><title>使用的问题</title><children><topics type="attached"><topic id="3snq6kebpvu7vuf7t14ii5faau" modified-by="" timestamp="1511830678195"><title>（1）在非静态成员内部类中使用外部类的成员</title><children><topics type="attached"><topic id="17f10k7fafsc6b0d1drv016mkr" modified-by="" timestamp="1511830681072"><title>都可以</title></topic></topics></children></topic><topic id="2dndt09e2tat4cv7n7ujhbkl28" modified-by="" timestamp="1511830705585"><title>（2）在外部类中使用非静态成员内部类</title><children><topics type="attached"><topic id="175i3ote4b50kp7l14r16ekhuo" modified-by="" timestamp="1511830729539"><title>在外部类的静态成员中不能使用非静态成员内部类</title><children><topics type="attached"><topic id="64dmhul731f6c25rub5vs93lrq" modified-by="" timestamp="1511830742918"><title>静态  （不能用） 非静态</title><children><topics type="attached"><topic id="4ppcciffchnrdpnm891vmdseoa" modified-by="" timestamp="1511830763634"><title svg:width="500">原因，静态的成员先加载，非静态只有创建对象才有</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="1revhiepatignnujitpn9fccou" modified-by="" timestamp="1511830902439"><title>（3）在外部类的外面使用非静态成员内部类</title><children><topics type="attached"><topic id="3abrsh10ic45o4phsqrf3lgc3b" modified-by="" timestamp="1511830797481"><title>依赖于外部类的对象</title></topic><topic id="2hrn6vj5hco0k6kgidpdpff0fu" modified-by="" timestamp="1511830871874"><title>形式一</title><children><topics type="attached"><topic id="0bq4s43scaqrokm0u3mhcm163v" modified-by="" timestamp="1511830814514"><title>（1）先创建外部类的对象</title><children><topics type="attached"><topic id="39pqpka8gubhocrc33fdno8aj4" modified-by="" timestamp="1511830824259"><title>外部类  out = new  外部类();</title></topic></topics></children></topic><topic id="7ig1e7vamitacu4tev07ofbime" modified-by="" timestamp="1511830840846"><title>（2）通过外部类的对象创建内部类的对象</title><children><topics type="attached"><topic id="1aeo7kpsreeo4n424tupoqu8c6" modified-by="" timestamp="1511830868734"><title>外部类.内部类  in = out.new 内部类();</title></topic></topics></children></topic><topic id="0nr56vl0028pfnvem6copbg4ik" modified-by="" timestamp="1511830883904"><title>（3）通过内部类对象调用它的成员</title><children><topics type="attached"><topic id="00sb25ip4kn1soludk16r3jeno" modified-by="" timestamp="1511830889884"><title>in.成员</title></topic></topics></children></topic></topics></children></topic><topic id="3nvpquhu6404fjbo3m56atl6qq" modified-by="" timestamp="1511831026240"><title>形式二</title><children><topics type="attached"><topic id="4qunl7bi2mkasijfgv0q875r3k" modified-by="" timestamp="1511830972852"><title svg:width="500">（1）在外部类中提供一个方法，用来返回内部类的对象</title><children><topics type="attached"><topic id="4lhj8iljei5e6jjekahbj6nem3" modified-by="" timestamp="1511830978201"><title>class 外部类{&#13;
	class  内部类{&#13;
	}&#13;
&#13;
	public 内部类  getInnerInstance(){&#13;
		return new 内部类();&#13;
	}&#13;
&#13;
}</title></topic></topics></children></topic><topic id="3ads76vodr3krcfsljg3imaahl" modified-by="" timestamp="1511830990988"><title>（2）创建外部类的对象</title><children><topics type="attached"><topic id="2fc23733f7v41da35umpsa3m0q" modified-by="" timestamp="1511830990952"><title>外部类  out = new  外部类();</title></topic></topics></children></topic><topic id="50sov68l01v25tf6mjsr3au297" modified-by="" timestamp="1511831008554"><title>（3）通过外部类的对象，获取内部类的对象</title><children><topics type="attached"><topic id="4vkbot4r4br1maj4qlkbjb51fd" modified-by="" timestamp="1511831023421"><title>外部类.内部类  in = out.getInnerInstance();</title></topic></topics></children></topic><topic id="7m7tehbocgpp458v67l8fu6sl9" modified-by="" timestamp="1511831029047"><title>（4）通过内部类对象调用它的成员</title><children><topics type="attached"><topic id="3ha0kkh19b0b3ei0tnrrvvd1el" modified-by="" timestamp="1511830889884"><title>in.成员</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="58oc2joasckcgna9qu2ddbcra0" modified-by="" timestamp="1511831063667"><title>面试题</title><children><topics type="attached"><topic id="5npo3e075tgeqj0289sdupab55" modified-by="" timestamp="1511831137499"><title>如何继承非静态成员的内部类</title><children><topics type="attached"><topic id="1v215j5vbdr7kt3410akmg07rd" modified-by="" timestamp="1511831145390"><title>示例</title><notes><html><xhtml:p>class Outer{</xhtml:p><xhtml:p>	class Inner{</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p>class Other extends Outer.Inner{</xhtml:p><xhtml:p>	Other(Outer out){</xhtml:p><xhtml:p>		out.super();</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p></html><plain>class Outer{&#13;
	class Inner{&#13;
	}&#13;
}&#13;
class Other extends Outer.Inner{&#13;
	Other(Outer out){&#13;
		out.super();&#13;
	}&#13;
}</plain></notes></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="32k8d7b8evi4na58osqll7j23b" modified-by="" timestamp="1511829908071"><title>局部</title><children><topics type="attached"><topic id="19bkgtokcta4kssmqp7gksd57o" modified-by="" timestamp="1511831219463"><title>有名字的局部内部类，通常称为局部内部类</title><children><topics type="attached"><topic id="6dovj47q6qk7uebibg2nmls9dr" modified-by="" timestamp="1511831152639"><title>格式</title><children><topics type="attached"><topic id="0c3hk6eoi257a610mng1jh6mvk" modified-by="" timestamp="1511830046224"><title>[修饰符] class 外部类{&#13;
	[修饰符] 返回值类型  方法名([形参列表]){&#13;
		[修饰符] class 内部类{&#13;
		}&#13;
	}&#13;
}</title></topic></topics></children></topic><topic id="6dlhbr9qrvcmvtbmc99b386l8j" modified-by="" timestamp="1511831161352"><title>修饰符的问题</title><children><topics type="attached"><topic id="0cm3rloj5pmbdiqtca43tn0qu3" modified-by="" timestamp="1511830177182"><title>（1）权限修饰符</title><children><topics type="attached"><topic id="631e7p7keptaaiuaonqfusujuh" modified-by="" timestamp="1511831175556"><title>都不行</title></topic></topics></children></topic><topic id="5hq3ihp5d3kos8pi0ff1hcnqga" modified-by="" timestamp="1511830201240"><title>（2）static</title><children><topics type="attached"><topic id="5lcr5gds7a414b266mne6lh35l" modified-by="" timestamp="1511830609742"><title>没有</title></topic></topics></children></topic><topic id="4huolqjpdm1an2hrtnk920vckc" modified-by="" timestamp="1511830267354"><title>（3）final（极少）</title><children><topics type="attached"><topic id="7h5dmf9njkjjd3tot5qe06d6nh" modified-by="" timestamp="1511830217818"><title>可以</title><children><topics type="attached"><topic id="5bicoef6hjrbjud897ra26k3lo" modified-by="" timestamp="1511830223344"><title>表示不能被继承</title></topic></topics></children></topic></topics></children></topic><topic id="283932opgptj8dru9884ok1i1h" modified-by="" timestamp="1511830265033"><title>（4）abstract（极少）</title><children><topics type="attached"><topic id="63dqqvh2k9pdngs1i98ibgirkp" modified-by="" timestamp="1511830232998"><title>可以</title><children><topics type="attached"><topic id="4g9lhh41ldj3p3e6g7nj7vuvat" modified-by="" timestamp="1511830247529"><title>表示可以包含抽象方法，需要子类继承</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="0oqnpcuu6c7rd6g901cs06k7q3" modified-by="" timestamp="1511831209027"><title>有名字的局部内部类的成员</title><children><topics type="attached"><topic id="0hk7bpu3h3n4ehnn24ri6tv89j" modified-by="" timestamp="1511830648852"><title>除了静态成员，其他都可以</title></topic></topics></children></topic><topic id="24lg1ejv96ji0q9qicsgvieftm" modified-by="" timestamp="1511831386554"><title>使用</title><children><topics type="attached"><topic id="2lh7ni2te0q6r3iipcg3gd290j" modified-by="" timestamp="1511831248207"><title>（1）在内部类中使用外部类的成员</title><children><topics type="attached"><topic id="27riu127tnh40gln4tad3ek6pc" modified-by="" timestamp="1511831279513"><title svg:width="500">受所在方法的约束，如果所在方法是静态的，那么只能使用外部类的静态成员，如果所在方法是非静态的，那么都可以使用</title></topic></topics></children></topic><topic id="1u50dth5j6en7qaqs06fl814lb" modified-by="" timestamp="1511831299237"><title>（2）在内部类中使用外部类的局部变量</title><children><topics type="attached"><topic id="4c6kq8o5e6kn4ppe1rdqttoubo" modified-by="" timestamp="1511831317048"><title>必须是final修饰</title><children><topics type="attached"><topic id="7aaea0qsln2lk68hs384o6b5mc" modified-by="" timestamp="1511831316381"><title>JDK1.8之前，必须显式声明</title></topic><topic id="05vnn74iuh2k7o0cmmn2dpi6uv" modified-by="" timestamp="1511831331898"><title>JDK1.8之后，默认就是final修饰</title></topic></topics></children></topic></topics></children></topic><topic id="1sjcmagvgodrodqm39cj2qift8" modified-by="" timestamp="1511831347535"><title>（3）在外部类中使用内部类</title><children><topics type="attached"><topic id="58f33kvnisbl7813grrer865t9" modified-by="" timestamp="1511831361827"><title svg:width="500">只能在声明它的方法中使用，而且在声明之后使用</title><children><topics type="attached"><topic id="2s39d2e8hdsl65tcv9i79mlhe6" modified-by="" timestamp="1511831366790"><title>和局部变量的作用域一样</title></topic></topics></children></topic></topics></children></topic><topic id="7dhegt884m9hgoll2i58n6o4b6" modified-by="" timestamp="1511831381332"><title>（4）在外部类的外面</title><children><topics type="attached"><topic id="1kbtdb6f11md3pberq7kck896u" modified-by="" timestamp="1511831383619"><title>不可以</title></topic></topics></children></topic><topic id="2ici3pa6m66233346rpnu8h4lj" modified-by="" timestamp="1511831392801"><title>（5）在外部类的其他方法中</title><children><topics type="attached"><topic id="7kbkek76m3iophes1todk2ursh" modified-by="" timestamp="1511831400822"><title>不可以</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="6agfu5nu5u2be9d3urjn2osdbe" modified-by="" timestamp="1511832251002"><title>匿名内部类</title><children><topics type="attached"><topic id="1nsrgv2tt0pm3qss4a87i0g07g" modified-by="" timestamp="1511830125428"><title>格式</title><children><topics type="attached"><topic id="5r0cnmsrgk1aohbj7oda4prjmu" modified-by="" timestamp="1511830147663"><title>new 父类/父接口(){&#13;
	方法&#13;
}</title></topic></topics></children></topic><topic id="420um57k0nvpft16rf4mdidfg3" modified-by="" timestamp="1511831426471"><title>修饰符</title><children><topics type="attached"><topic id="1qgjotibucu5vc2v6akv5m0odt" modified-by="" timestamp="1511831429948"><title>一个都没有</title></topic></topics></children></topic><topic id="6thu5i17ls910q2e98cjvhbvig" modified-by="" timestamp="1511831450284"><title>匿名内部类的成员</title><children><topics type="attached"><topic id="7k1ctcaiid7l60ag7569ja636i" modified-by="" timestamp="1511831499007"><title svg:width="500">除了非静态的都可以，但是一般很少自定义方法等成员，它的成员都是重写父类的，父接口的方法</title></topic></topics></children></topic><topic id="3j45hqehfjj0cbumbjdjg3756e" modified-by="" timestamp="1511831794241"><title>匿名内部类的特点</title><children><topics type="attached"><topic id="7pcqh34tcnn26co1gf7scdsl2i" modified-by="" timestamp="1511831789041"><title>（1）声明类和创建对象同时进行， 只有一个对象</title><notes><html><xhtml:p>	public static void main(String[] args) {</xhtml:p><xhtml:p>		//Object的一个子类对象</xhtml:p><xhtml:p>		new Object(){</xhtml:p><xhtml:p>			public void test(){</xhtml:p><xhtml:p>				System.out.println(this.getClass());</xhtml:p><xhtml:p>			}</xhtml:p><xhtml:p>		}.test();</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//Object的另一个子类对象</xhtml:p><xhtml:p>		new Object(){</xhtml:p><xhtml:p>			public void test(){</xhtml:p><xhtml:p>				System.out.println(this.getClass());</xhtml:p><xhtml:p>			}</xhtml:p><xhtml:p>		}.test();</xhtml:p><xhtml:p>	}</xhtml:p></html><plain>	public static void main(String[] args) {&#13;
		//Object的一个子类对象&#13;
		new Object(){&#13;
			public void test(){&#13;
				System.out.println(this.getClass());&#13;
			}&#13;
		}.test();&#13;
		&#13;
		//Object的另一个子类对象&#13;
		new Object(){&#13;
			public void test(){&#13;
				System.out.println(this.getClass());&#13;
			}&#13;
		}.test();&#13;
	}</plain></notes></topic><topic id="2mksmq3jtkft2n04am3fbgub9l" modified-by="" timestamp="1511831995821"><title>（2）子类一定会调用父类的构造器</title><notes><html><xhtml:p>class MyClass{</xhtml:p><xhtml:p>	private String info;</xhtml:p><xhtml:p>	MyClass(String info){</xhtml:p><xhtml:p>		this.info = info;</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p/><xhtml:p>		//创建一个MyClass的子类对象，使用匿名内部类</xhtml:p><xhtml:p>		MyClass m = new MyClass("参数"){</xhtml:p><xhtml:p>			</xhtml:p><xhtml:p>		};</xhtml:p></html><plain>class MyClass{&#13;
	private String info;&#13;
	MyClass(String info){&#13;
		this.info = info;&#13;
	}&#13;
}&#13;
&#13;
		//创建一个MyClass的子类对象，使用匿名内部类&#13;
		MyClass m = new MyClass("参数"){&#13;
			&#13;
		};</plain></notes></topic></topics></children></topic><topic id="2e1jgk9hd5k81pvg3gvmbtk6bh" modified-by="" timestamp="1511832158390"><title>匿名内部类的使用形式</title><children><topics type="attached"><topic id="4sm6e5lv6k8eu9uj5hmtbva5na" modified-by="" timestamp="1511832026863"><title>形式一</title><children><topics type="attached"><topic id="1psisuqgm5co9ukud3bemoe75h" modified-by="" timestamp="1511832053954"><title>匿名内部类的匿名对象直接调用方法</title><notes><html><xhtml:p>		new Object(){</xhtml:p><xhtml:p>			public void test(){</xhtml:p><xhtml:p>				System.out.println(this.getClass());</xhtml:p><xhtml:p>			}</xhtml:p><xhtml:p>		}.test();</xhtml:p></html><plain>		new Object(){&#13;
			public void test(){&#13;
				System.out.println(this.getClass());&#13;
			}&#13;
		}.test();</plain></notes></topic></topics></children></topic><topic id="6ti7vf1fp4evrlgvm0j4gh5hmo" modified-by="" timestamp="1511832058297"><title>形式二</title><children><topics type="attached"><topic id="66ljcs6qava677r54pvirge3rv" modified-by="" timestamp="1511832157370"><title>与父类或父接口构成多态引用</title><notes><html><xhtml:p>class MyClass{</xhtml:p><xhtml:p>	public void test(){</xhtml:p><xhtml:p>		System.out.println("父类的测试方法");</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p/><xhtml:p>		MyClass m = new MyClass(){</xhtml:p><xhtml:p>			public void test(){</xhtml:p><xhtml:p>				System.out.println("重写");</xhtml:p><xhtml:p>			}</xhtml:p><xhtml:p>		};</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		m.test();</xhtml:p></html><plain>class MyClass{&#13;
	public void test(){&#13;
		System.out.println("父类的测试方法");&#13;
	}&#13;
}&#13;
&#13;
		MyClass m = new MyClass(){&#13;
			public void test(){&#13;
				System.out.println("重写");&#13;
			}&#13;
		};&#13;
		&#13;
		m.test();</plain></notes></topic></topics></children></topic><topic id="5ngsdrdfb43kskvocdej6uohl1" modified-by="" timestamp="1511832162533"><title>形式三</title><children><topics type="attached"><topic id="23do4ttask4em0p426qcjgua4v" modified-by="" timestamp="1511832243547"><title>匿名内部类的匿名对象作为实参</title><notes><html><xhtml:p>		MyClass[] arr = new MyClass[5];</xhtml:p><xhtml:p>		Arrays.sort(arr, new Comparator(){</xhtml:p><xhtml:p/><xhtml:p>			@Override</xhtml:p><xhtml:p>			public int compare(Object o1, Object o2) {</xhtml:p><xhtml:p>				return 0;</xhtml:p><xhtml:p>			}</xhtml:p><xhtml:p>			</xhtml:p><xhtml:p>		});</xhtml:p></html><plain>		MyClass[] arr = new MyClass[5];&#13;
		Arrays.sort(arr, new Comparator(){&#13;
&#13;
			@Override&#13;
			public int compare(Object o1, Object o2) {&#13;
				return 0;&#13;
			}&#13;
			&#13;
		});</plain></notes></topic></topics></children></topic></topics></children></topic><topic id="64vulm1r56hspquoi7o81p6kvt" modified-by="" timestamp="1511832271311"><title>使用其他要求</title><children><topics type="attached"><topic id="5dprsld8ueg8gt9d44bfocualv" modified-by="" timestamp="1511832271202"><title>（1）在内部类中使用外部类的成员</title><children><topics type="attached"><topic id="5m9tgk47h8r40b3j96ira1mmlb" modified-by="" timestamp="1511831279513"><title svg:width="500">受所在方法的约束，如果所在方法是静态的，那么只能使用外部类的静态成员，如果所在方法是非静态的，那么都可以使用</title></topic></topics></children></topic><topic id="1ipdh1l356p4gsa9lsdfq4s58a" modified-by="" timestamp="1511832271202"><title>（2）在内部类中使用外部类的局部变量</title><children><topics type="attached"><topic id="5vivg8ouqcmg0qg3sm1c56fck9" modified-by="" timestamp="1511831317048"><title>必须是final修饰</title><children><topics type="attached"><topic id="69pr2qsdvlpp9p93ih2tjulr6p" modified-by="" timestamp="1511831316381"><title>JDK1.8之前，必须显式声明</title></topic><topic id="62p02vrhql89v4m07sds1t8l0a" modified-by="" timestamp="1511831331898"><title>JDK1.8之后，默认就是final修饰</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic branch="folded" id="3ck76cdrnlvbq11labp67pduhs" modified-by="" timestamp="1511829574014"><title>（4）类的声明格式</title><children><topics type="attached"><topic id="6qv2psnfimoktgg1vnedr1fc9t" modified-by="" timestamp="1510970452398"><title>格式</title><children><topics type="attached"><topic id="7dflctrh4h82nfu1i7jvkrio6m" modified-by="" timestamp="1510970462836"><title>[修饰符] class 类名{&#13;
	//属性列表&#13;
	//构造器列表&#13;
	//get/set方法&#13;
	//其他方法&#13;
}</title></topic></topics></children></topic></topics></children></topic><topic branch="folded" id="36k9n7ge475mthgs0q07g4p1fa" modified-by="" timestamp="1511829576654"><title>（5）如何创建对象</title><children><topics type="attached"><topic id="692pk4899u3gatiohcivur1cpt" modified-by="" timestamp="1510970499105"><title>new 类名()</title><children><topics type="attached"><topic id="127vcctcbdgfk8frjo0s50ns1p" modified-by="" timestamp="1510970502715"><title>用无参构造</title></topic></topics></children></topic><topic id="5ksug1sqtt9a33je34205va54e" modified-by="" timestamp="1510970507795"><title>new 类名(实参列表)</title><children><topics type="attached"><topic id="7eenpo36965dhon05kaa5jkse3" modified-by="" timestamp="1510970511102"><title>用有参构造</title></topic></topics></children></topic><topic id="4m748l8dir0opek2mdbove9ha6" modified-by="" timestamp="1510970552710"><title>匿名对象和有名对象</title><children><topics type="attached"><topic id="22pa131egpo29stoo8rb4mlu08" modified-by="" timestamp="1510970542104"><title>Student stu = new Student();</title><children><topics type="attached"><topic id="04ik6b8suimhccc225m3d58o90" modified-by="" timestamp="1510970551612"><title>stu对象名，也可以称为对象的引用</title></topic></topics></children></topic><topic id="2vlofkpu0p5ouel1mhr5vvofu7" modified-by="" timestamp="1510970556613"><title>匿名对象</title><children><topics type="attached"><topic id="0du78gh7uqbe5k5gf9giq5unlf" modified-by="" timestamp="1510970571368"><title>System.out.println(new Student());</title></topic></topics></children></topic></topics></children></topic><topic id="5da9ffl2bq3hfhj9gs5pa6onvh" modified-by="" timestamp="1510987560940"><title>对象的内存图</title><children><topics type="attached"><topic id="2nvfop4gts768kbs44j87b8o7o" modified-by="" timestamp="1510987571831"><title/><xhtml:img svg:height="167" svg:width="400" xhtml:src="xap:attachments/5j9g7a2pbspd7q4cq3occthomb.png"/></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic branch="folded" id="27q99oc5j8mev0h6vps1m400nf" modified-by="" timestamp="1511829580042"><title>2、面向对象的基本特征</title><children><topics type="attached"><topic id="2g5rdapos8jsvflit2s809gq53" modified-by="" timestamp="1510970312821"><title>封装</title><children><topics type="attached"><topic id="0m5enp4ci4qq9m2psricsp6ctp" modified-by="" timestamp="1510970279465"><title>封装的作用</title><children><topics type="attached"><topic id="1t7l0sk2s9i6h4abp9255hcq3u" modified-by="" timestamp="1510970274660"><title>安全</title></topic><topic id="7bp03dt4rpah6sg8q6g0c0oi5s" modified-by="" timestamp="1510970292937"><title>使用方便</title><children><topics type="attached"><topic id="47m6k4kv5psir8m8hj1j11m93v" modified-by="" timestamp="1510970301382"><title>对于使用者屏蔽实现细节</title></topic></topics></children></topic></topics></children></topic><topic id="64k7frhflfsm7l164a320q66hf" modified-by="" timestamp="1510970331111"><title>概念</title><children><topics type="attached"><topic id="118adtqrps31u2usek30vcroap" modified-by="" timestamp="1510970326674"><title>狭义</title><children><topics type="attached"><topic id="5iqui9hrut0t6rqhsqc05qlkl4" modified-by="" timestamp="1510970361030"><title>属性的封装</title><children><topics type="attached"><topic id="62hu1qetslg4d8b5f4tpk02hb3" modified-by="" timestamp="1510970360342"><title>（1）属性私有化：private</title></topic><topic id="3rb6k2erm3ndhtien7vqvh3t1g" modified-by="" timestamp="1510970372795"><title>（2）提供公共get/set方法</title></topic></topics></children></topic></topics></children></topic><topic id="49j6d6k4pmrns3s7td5jogsn4i" modified-by="" timestamp="1510970344862"><title>广义</title><children><topics type="attached"><topic id="5s2vuuurif90dnqrsiseuovht8" modified-by="" timestamp="1510970338292"><title>方法</title></topic><topic id="3o2bgsoc9hpnne0spp75cg67l4" modified-by="" timestamp="1510970340325"><title>类</title></topic><topic id="4tal9iuttco5noni2953b00a4s" modified-by="" timestamp="1510970342267"><title>包</title></topic><topic id="536bodom1da2q8l5297i014nlc" modified-by="" timestamp="1510970344586"><title>组件</title></topic><topic id="79j33t85p0qutj4gdt3rmruu4s" modified-by="" timestamp="1510970348642"><title>系统</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="3hnfd1dtjbtfebq9i3s2e78f79" modified-by="" timestamp="1511314173555"><title>继承</title><children><topics type="attached"><topic id="5a5hd0c0c3f89hhipgs43cbaq9" modified-by="" timestamp="1511313441660"><title>什么情况下需要继承？继承的好处是什么？</title><children><topics type="attached"><topic id="3lsrng6sp0nfqfmqliqtfk6po7" modified-by="" timestamp="1511313370128"><title>为了代码重用</title><children><topics type="attached"><topic id="4umdb9gp8asp2dh9m9fl6mogsg" modified-by="" timestamp="1511313368996"><title svg:width="500">（1）当有一个父类，如果再声明类时，发现这些类与已经存在的父类有很多相同特征，那么就可以通过继承的方式来简化代码</title></topic><topic id="77onu46n6tj7cbq1547q5ffgu1" modified-by="" timestamp="1511313414669"><title svg:width="500">（2）已经很多类，发现这些类有很多共同的特点，那么我们可以把这些共同的特点抽取到一个父类中，以便简化代码</title></topic></topics></children></topic><topic id="69ejjthppq7f2c0s9br4r15ahs" modified-by="" timestamp="1511313446729"><title>逻辑的角度</title><children><topics type="attached"><topic id="3l56jntpbs15ggr0ccr36d8mrt" modified-by="" timestamp="1511313452847"><title>表示is-a的关系</title></topic></topics></children></topic></topics></children></topic><topic id="6jqmif2hl4no2jqks5va0rl4g8" modified-by="" timestamp="1511313516225"><title>如何继承</title><children><topics type="attached"><topic id="5jk7fj6sks9iol3qfsst5n00d2" modified-by="" timestamp="1511313517516"><title>语法格式：&#13;
[修饰符] class  子类名  extends  父类名{&#13;
}</title></topic></topics></children></topic><topic id="2163i2r34c1svdj0umei09f75d" modified-by="" timestamp="1511313539440"><title>继承后对几个成员的影响</title><children><topics type="attached"><topic id="0i699lidivaurj9nnd0n33s59k" modified-by="" timestamp="1511313632013"><title>属性</title><children><topics type="attached"><topic id="1u5387jpcamq3prqbaborqtgb6" modified-by="" timestamp="1511313625272"><title svg:width="500">（1）子类继承父类时，一定会继承父类的所有的属性，包括私有的，但是由于私有的关键字private的原因，在子类中无法直接操作它，但是可以通过get/set方式操作它</title></topic><topic id="45pt594h6jle9ru3vmqm194np6" modified-by="" timestamp="1511314020431"><title svg:width="500">（2）当子类的属性与父类的属性重名时，而且父类的属性没有私有化，如果要访问父类的属性那么通过super.属性进行访问，如果子类中没有通过super.属性访问，那这个属性就表示是子类自己的</title><children><topics type="attached"><topic id="631mgtmtllpu7n8b7nk6g4gpbo" modified-by="" timestamp="1511314043396"><title>面试题</title><notes><html><xhtml:p>package com.atguigu.review;</xhtml:p><xhtml:p/><xhtml:p>public class Test {</xhtml:p><xhtml:p/><xhtml:p>	public static void main(String[] args) {</xhtml:p><xhtml:p>		Student stu = new Student();</xhtml:p><xhtml:p>		System.out.println(stu.getInfo());//结果？  年龄：10</xhtml:p><xhtml:p>		System.out.println(stu.getAge());//结果？20   如果子类重写，答案是10</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p/><xhtml:p>}</xhtml:p><xhtml:p>class Person{</xhtml:p><xhtml:p>	int age = 20;</xhtml:p><xhtml:p/><xhtml:p>	public int getAge() {</xhtml:p><xhtml:p>		return age;</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p/><xhtml:p>	public void setAge(int age) {</xhtml:p><xhtml:p>		this.age = age;</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p>class Student extends Person{</xhtml:p><xhtml:p>	int age = 10;</xhtml:p><xhtml:p>	/*public int getAge(){</xhtml:p><xhtml:p>		return age;</xhtml:p><xhtml:p>	}*/</xhtml:p><xhtml:p>	public String getInfo(){</xhtml:p><xhtml:p>		return "年龄：" + age;</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p></html><plain>package com.atguigu.review;&#13;
&#13;
public class Test {&#13;
&#13;
	public static void main(String[] args) {&#13;
		Student stu = new Student();&#13;
		System.out.println(stu.getInfo());//结果？  年龄：10&#13;
		System.out.println(stu.getAge());//结果？20   如果子类重写，答案是10&#13;
	}&#13;
&#13;
}&#13;
class Person{&#13;
	int age = 20;&#13;
&#13;
	public int getAge() {&#13;
		return age;&#13;
	}&#13;
&#13;
	public void setAge(int age) {&#13;
		this.age = age;&#13;
	}&#13;
	&#13;
}&#13;
class Student extends Person{&#13;
	int age = 10;&#13;
	/*public int getAge(){&#13;
		return age;&#13;
	}*/&#13;
	public String getInfo(){&#13;
		return "年龄：" + age;&#13;
	}&#13;
}</plain></notes></topic></topics></children></topic></topics></children></topic><topic id="72n4jmjmh6s6nf4squo79a5pog" modified-by="" timestamp="1511314091356"><title>方法</title><children><topics type="attached"><topic id="1v2914pr4mu7rh6cn14qrb167f" modified-by="" timestamp="1511314088790"><title svg:width="500">（1）子类继承父类时，一定会继承父类的所有的方法，包括私有的，但是由于private，在子类中无法直接操作，但是可以间接操作</title></topic><topic id="48r4u8i4ihtdnt9tm7pade2m8q" modified-by="" timestamp="1511314118016"><title svg:width="500">（2）当父类的方法实现不适用于子类时，子类可以对父类的方法的进行重写</title></topic></topics></children></topic><topic id="5li0ed00a9oh49cqusg3ajnkr9" modified-by="" timestamp="1511314144895"><title>构造器</title><children><topics type="attached"><topic id="38ndve9drhm4v9pmn7ql99ei2r" modified-by="" timestamp="1511314143759"><title>（1）子类继承父类时，不会继承父类的构造器</title></topic><topic id="25no2sc84dfboi41df8tdbh0br" modified-by="" timestamp="1511314161391"><title>（2）子类继承父类时，一定会调用父类的构造器</title><children><topics type="attached"><topic id="2kom373nk8bmb38fc46g1r5i42" modified-by="" timestamp="1511314155648"><title svg:width="500">如果父类有无参构造，那么子类会默认去调用父类的无参构造&#13;
如果父类没有无参构造，只有有参构造，那么子类必须在子类构造器中手动调用父类的有参构造</title></topic><topic id="011eojeugurl28817g2e5hr978" modified-by="" timestamp="1511314162985"><title>调用父类的无参构造的语句：super();&#13;
调用父类的有参构造的语句：super(实参列表);&#13;
而且这两个语句必须在子类的构造器的首行。</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="6evq13cee245jjhmvau9h909uh" modified-by="" timestamp="1511314412183"><title>继承的原则</title><children><topics type="attached"><topic id="08jbnbenq3s6cvvcs4vloilsv0" modified-by="" timestamp="1511314188181"><title>（1）单继承</title><children><topics type="attached"><topic id="00mfv7nn7f0ddo7q0gckp5q3ts" modified-by="" timestamp="1511314217719"><title svg:width="500">在Java中只支持单继承，也就是说一个类只能有一个直接父类     --》一个唯一的亲生父亲</title></topic></topics></children></topic><topic id="40socelajf9ujao8gq8dm6lja8" modified-by="" timestamp="1511314237457"><title>（2）多层继承</title><children><topics type="attached"><topic id="1ve9sh7eftkj9pkn6kj9cka0o4" modified-by="" timestamp="1511314359832"><title svg:width="500">在Java中父类还可以有父类，而且在子类中会继承父类以及父类的父类的所有的属性与方法			--》代代相传</title><children><topics type="attached"><topic id="46lk41vegtf6tehgv1eucmtfrp" modified-by="" timestamp="1511314355441"><title svg:width="500">子类对象在寻找一个方法、属性时，如果本类中找不到，会去直接父类中查找，如果直接父类中也找不到，在往上找，找到为止，一直追溯到java.lang.Object根父类中</title></topic><topic id="0mt1ua4earm12j83bcmll1nii1" modified-by="" timestamp="1511314403921"><title svg:width="500">通过super.属性和方法时，先从直接父类中查找，如果没有，再往上找，直到找到为止，一直可以到java.lang.Object</title></topic></topics></children></topic></topics></children></topic><topic id="28qe06lsb5k19tvus0acb1pdcq" modified-by="" timestamp="1511314435901"><title svg:width="500">（3）一个类可以有很多个子类，子类还可以有子类</title><children><topics type="attached"><topic id="3mr5qd8mov2rl128i9tam3anp4" modified-by="" timestamp="1511314435590"><title>子孙满堂</title></topic><topic id="4p0vi0923d6o5vu74sfrpe5pgn" modified-by="" timestamp="1511314439677"><title>开枝散叶</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="4p8vrodhpdg3s3d2asbkj1qdk7" modified-by="" timestamp="1511487667796"><title>多态</title><children><topics type="attached"><topic id="3u6l3hlcubqvb6p9igqm5a72v9" modified-by="" timestamp="1511487565282"><title>多态的表现形式</title><children><topics type="attached"><topic id="5hq81lal3a55cs2s1g1is1t80q" modified-by="" timestamp="1511487564270"><title svg:width="500">（1）方法的重载：同一个类中，功能多种实现形式&#13;
方法的重写：父子类中，功能的不同实现形式</title></topic><topic id="1126veqrothpk77riskk6pngal" modified-by="" timestamp="1511487579348"><title>（2）对象的多态性</title><children><topics type="attached"><topic id="7m4lb5g9dlhisk4vegp5o7je9o" modified-by="" timestamp="1511487577941"><title svg:width="500">编译时类型与运行时的类型不一致，编译时看“左边”，运行时看“右边”，&#13;
编译时从“父类”中寻找方法，运行时执行的是“子类”重写过的代码</title></topic><topic id="7ov600ap9kshq31cjihbfqmk9g" modified-by="" timestamp="1511487603814"><title>对象的多态性的前提：&#13;
（1）继承&#13;
（2）方法的重写&#13;
（3）多态引用</title><children><topics type="attached"><topic id="3942sc3b1ahikauns5u8hor6to" modified-by="" timestamp="1511487593427"><title>多态引用</title><children><topics type="attached"><topic id="2l0qanf0epa7qrqbvkolg224go" modified-by="" timestamp="1511487602503"><title>Person p = new Student();</title></topic></topics></children></topic><topic id="484m7t88gjalgni31eeouv53d1" modified-by="" timestamp="1511487616240"><title>本态引用</title><children><topics type="attached"><topic id="5fo5213fs1ocrbnn14uvgitjdl" modified-by="" timestamp="1511487625899"><title>Person p = new Person();</title></topic><topic id="32eb0idpjvps0voj5146d0ndj0" modified-by="" timestamp="1511487622974"><title>Student s = new Student();</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="6t59ccma0oc572i03tc0ig8r1u" modified-by="" timestamp="1511487649715"><title>多态的应用</title><children><topics type="attached"><topic id="0mcs1rt9iu1pokrdemf12a991b" modified-by="" timestamp="1511487649489"><title>（1）多态参数</title></topic><topic id="4gsfq9v7pj2cco930794ritg32" modified-by="" timestamp="1511487651031"><title>（2）多态数组</title></topic></topics></children></topic><topic id="62t5grm7blumo4ldg6oa784tdr" modified-by="" timestamp="1511487697651"><title>类型的转换</title><children><topics type="attached"><topic id="7uc4l5643vr8ct42sjq5f12i3h" modified-by="" timestamp="1511487689611"><title>向上转型</title><children><topics type="attached"><topic id="753il2hrremadr374jhn0gl8fd" modified-by="" timestamp="1511487688555"><title>子类的对象赋值给父类的变量</title></topic><topic id="4vhsqkubbfj2m0f2vr20gsa8mm" modified-by="" timestamp="1511487693397"><title>自动完成</title></topic></topics></children></topic><topic id="78ej1d6rcl2c3digmjoo2gbepm" modified-by="" timestamp="1511487838937"><title>向下转型</title><children><topics type="attached"><topic id="03pfe5eq9rg1o28ap0aq9llkdi" modified-by="" timestamp="1511487723372"><title>把父类的变量赋值给子类的变量</title></topic><topic id="7d7gclg5k27eg3bl3d09bl7frc" modified-by="" timestamp="1511487730172"><title>强制类型转换</title></topic><topic id="6mdak8u1b3c58jedsbvt189st8" modified-by="" timestamp="1511487739231"><title>如果想要向下转型成功</title><children><topics type="attached"><topic id="5pu99tc9e1536m5sg5e4uoqihj" modified-by="" timestamp="1511487753415"><title>父类的变量本身指向的就是该子类的对象</title></topic></topics></children></topic><topic id="617lhk6k55i9bli1jg3qdmbele" modified-by="" timestamp="1511487775766"><title>如何避免ClassCastException</title><children><topics type="attached"><topic id="7kb3stb6oje3vn9gsp7hi631p4" modified-by="" timestamp="1511487787544"><title>在向下转型之前，加判断</title><children><topics type="attached"><topic id="7mf113rsrrqvduegd66vqbtbro" modified-by="" timestamp="1511487815860"><title>if(变量  instanceof  子类类型){&#13;
	子类类型  temp = (子类类型)变量;&#13;
}</title></topic></topics></children></topic></topics></children></topic><topic id="7fovhfebf0moa3dnhjvq41p0gp" modified-by="" timestamp="1511487883723"><title>什么情况下需要向下转型</title><children><topics type="attached"><topic id="6ltlt0bng62m5mj9oi5bj3gvf4" modified-by="" timestamp="1511487882810"><title svg:width="500">因为一个对一旦向上转型后，那么就无法访问该子类对象中特有的方法，只能访问父类有的方法</title></topic><topic id="15qpv5vv302eedmvckkuf8n3t2" modified-by="" timestamp="1511487902759"><title svg:width="500">如果需要通过该对象，访问子类的特有的方法等，那么就需要向下转型</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic branch="folded" id="4qqbrcpo1grrhmnfjbair31n7c" modified-by="" timestamp="1511829582928"><title>3、关键字</title><children><topics type="attached"><topic id="2i4paqkufaa5ifc9bul7k48u6k" modified-by="" timestamp="1510970608521"><title>class</title><children><topics type="attached"><topic id="2lh2a6rlci64fb1svalleqmie5" modified-by="" timestamp="1510970613800"><title>声明类</title></topic></topics></children></topic><topic id="4t1jo4h58kjrrud4n6bor543ju" modified-by="" timestamp="1510970660015"><title>new</title><children><topics type="attached"><topic id="1e3tj5k3eppb26e1mdlstkjhbp" modified-by="" timestamp="1510970624637"><title>创建实例，创建对象</title></topic><topic id="4ui1qnj05kdauaucl9q0pqm58l" modified-by="" timestamp="1510970636117"><title>在堆中申请一块空间</title></topic><topic id="6nco08n3n1g9hke9n4hdqkgaj1" modified-by="" timestamp="1510970654844"><title>只要new就创建新的对象</title></topic><topic id="0seq23pqdvlmimm17meuvec166" modified-by="" timestamp="1510970666126"><title>new后面一定是构造器</title></topic></topics></children></topic><topic id="290pb9ojqa7qkuotb8fd2ik99j" modified-by="" timestamp="1510970716153"><title>this</title><children><topics type="attached"><topic id="2u124vpd3na305hh0krg67p356" modified-by="" timestamp="1510970691141"><title>当前对象</title><children><topics type="attached"><topic id="1tk3shrffrs5fle0s6mhso3q9o" modified-by="" timestamp="1510970707847"><title svg:width="500">（1）如果在构造器中，表示正在被创建的那个对象&#13;
（2）如果在其他方法中，表示调用该方法的那个对象</title></topic></topics></children></topic><topic id="5i0qmg0t8qqarlfr09ooiviij7" modified-by="" timestamp="1510970731363"><title>使用</title><children><topics type="attached"><topic id="5k0v864ek3br4mmk41l7p10ouo" modified-by="" timestamp="1511314579462"><title svg:width="500">（1）this.属性</title><children><topics type="attached"><topic id="5ut62vueqjcs569b82vmu56j26" modified-by="" timestamp="1511314708819"><title svg:width="500">当成员变量（属性名）与局部变量（形参）重名时，使用this.属性进行区别</title></topic></topics></children></topic><topic id="7ak0kf1u36jp470h5buph8ioca" modified-by="" timestamp="1511314924022"><title svg:width="500">（2）this.方法</title><children><topics type="attached"><topic id="24b9dl1smq3uu1mve3b33cgq06" modified-by="" timestamp="1511314950845"><title>表示调用“当前类”的方法</title></topic><topic id="5hml5o7cibuljv55d24t137rs2" modified-by="" timestamp="1511314906332"><title svg:width="500">如果子类继承了父类，子类没有重写父类的方法，this.方法也可能是从父类继承的方法</title></topic><topic id="0gdprqa1rbgi1pmouvjiaorp5s" modified-by="" timestamp="1511314938051"><title svg:width="500">如果子类继承了父类，子类重写父类的方法，this.方法就代表子类重写过的代码</title></topic></topics></children></topic><topic id="3gggi2r69trgvn2qtk2sj3lv7f" modified-by="" timestamp="1511314988584"><title svg:width="500">（3）this()或this(实参列表)</title><children><topics type="attached"><topic id="2iaobvcen4eibafvsnacodn46l" modified-by="" timestamp="1511314989968"><title svg:width="500">表示调用本类的其他构造器，而且必须在构造器的首行</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="3f2pemi2ldb3e7or44mipahv3n" modified-by="" timestamp="1511314554532"><title>super</title><children><topics type="attached"><topic id="450hbf0n84p789cb7vclgo298c" modified-by="" timestamp="1511314527901"><title>父类引用</title></topic><topic id="33p286blk682ccqdnian7o5cv9" modified-by="" timestamp="1511314955108"><title>使用</title><children><topics type="attached"><topic id="49keq0t77r8qdktv4b0di5gthi" modified-by="" timestamp="1511314572641"><title>（1）super.属性</title><children><topics type="attached"><topic id="1kadtop89djtrirt1sbgr43479" modified-by="" timestamp="1511314573736"><title svg:width="500">当子类的属性与父类的属性重名时，而且父类的属性没有私有化&#13;
如果需要调用父类的属性，那么通过super.属性进行区别</title></topic></topics></children></topic><topic id="49j98qj6thi79iije0r6oo3hm4" modified-by="" timestamp="1511314876591"><title>（2）super.方法</title><children><topics type="attached"><topic id="0pfv6e39alhb1dkjjm63ajrjgq" modified-by="" timestamp="1511314877860"><title svg:width="500">当子类的方法重写了父类的方法时，&#13;
如果需要调用父类的被重写的方法，那么通过super.方法进行调用</title></topic></topics></children></topic><topic id="47emr2tpede19gtumb8pumhgpn" modified-by="" timestamp="1511314968513"><title>（3）super()或super(实参列表)</title><children><topics type="attached"><topic id="294e6i580mjvnnb1d8ssjdo5da" modified-by="" timestamp="1511314971773"><title svg:width="500">当子类需要调用父类的构造器时，通过super()或super(实参列表)进行调用&#13;
&#13;
调用父类的无参构造的语句：super();&#13;
调用父类的有参构造的语句：super(实参列表);&#13;
而且这两个语句必须在子类的构造器的首行。</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="06odglqbmheqccf8vl3o3te1vk" modified-by="" timestamp="1511315248640"><title>权限修饰符</title><children><topics type="attached"><topic id="5sggqrilsbmli26s6sja7m3tef" modified-by="" timestamp="1511315262132"><title svg:width="500">三个单词，四种形式：&#13;
public；公共的，范围：任意位置，可以修饰类、成员&#13;
protected：受保护的，范围：本包或子类中，可以修饰成员&#13;
缺省：默认的，范围：本包，可以修饰类、成员&#13;
private：私有的，范围：本类中，可以修饰成员</title></topic><topic id="3ab4hoj9vt6l4e41989a5n6q70" modified-by="" timestamp="1511315248610"><xhtml:img xhtml:src="xap:attachments/6b5g48r4eekg4hpnjcmftcv0lb.png"/></topic></topics></children></topic><topic id="64cmi3c95mcqhql0r875blhs1t" modified-by="" timestamp="1511573417785"><title>static</title><children><topics type="attached"><topic id="3iagnibt6pq8jn35hkteif04hq" modified-by="" timestamp="1511573396250"><title>静态的</title></topic><topic id="744mouh7rk5ts0h9d7haulv66s" modified-by="" timestamp="1511573402249"><title>可以修饰成员</title></topic><topic id="29f7h3riaa80964ln0crf17mlh" modified-by="" timestamp="1511573424569"><title>（1）属性</title><children><topics type="attached"><topic id="0hbmm1fna9ohu4kg5ju772o9fc" modified-by="" timestamp="1511573433578"><title svg:width="500">	这个属性就称为类变量，它的值是所有对象共享的，存储在方法区&#13;
	它的get/set方法也是静态的</title></topic></topics></children></topic><topic id="56nq23rik95kgd0lorrj2anrrd" modified-by="" timestamp="1511573441017"><title>（2）方法</title><children><topics type="attached"><topic id="3nqgrlttjvmtidcs8cob3eps3b" modified-by="" timestamp="1511573442401"><title svg:width="500">这个方法就称为类方法，调用它不需要创建对象，直接可以通过”类名.方法“调用</title></topic></topics></children></topic><topic id="7tok0pu28i7pfckuhss0brmvis" modified-by="" timestamp="1511573449485"><title>（3）代码块	</title><children><topics type="attached"><topic id="1c4c1o1fod4tt47r3s2rso4evj" modified-by="" timestamp="1511573451157"><title svg:width="500">	用static修饰的代码块称为静态代码块。&#13;
	随着类的加载并初始时而执行，而且一个类的静态代码块只执行一次&#13;
	为静态变量赋值，如果静态变量有显式初始化和静态代码块初始化，它俩属于同级，谁在前谁先执行</title></topic></topics></children></topic><topic id="5bjh9b34ci7d8euql5echu4ncn" modified-by="" timestamp="1511573423492"><title>（4）内部类</title></topic></topics></children></topic><topic id="0siccnt2i1suf0tq2ugfrjq49g" modified-by="" timestamp="1511574055371"><title>final</title><children><topics type="attached"><topic id="2un9jdaqt2hb15haf474d8cuvn" modified-by="" timestamp="1511574055144"><title>最终的</title></topic><topic id="1be1q18hh2hebpd6bp91creife" modified-by="" timestamp="1511574065800"><title>可以修饰</title><children><topics type="attached"><topic id="6d0jgs9nc9rqpmk88deoc4msig" modified-by="" timestamp="1511574103090"><title>（1）类</title><children><topics type="attached"><topic id="3n8m41540tt4t6u6noo5d01oli" modified-by="" timestamp="1511574111124"><title>这个类不能被继承，俗称“太监类”</title></topic></topics></children></topic><topic id="5f7r70el8quqlm0ijfc4gufeoi" modified-by="" timestamp="1511574111337"><title>（2）方法</title><children><topics type="attached"><topic id="41ekmsi7qung8t9f79orleghln" modified-by="" timestamp="1511574112827"><title>这个方法不能被重写，像“圣旨”</title></topic></topics></children></topic><topic id="7uungf629aj5oitvdrn2afg1pk" modified-by="" timestamp="1511574073228"><title>（3）变量</title><children><topics type="attached"><topic id="7ofe1p0ims9bsmg6n7jlhsjihk" modified-by="" timestamp="1511574084495"><title>成员变量</title><children><topics type="attached"><topic id="35mcdrjk1dllq1to0f6d6o5d8t" modified-by="" timestamp="1511574113709"><title>常量</title><children><topics type="attached"><topic id="13ovf1bj63b5supotnj192v7jo" modified-by="" timestamp="1511574117677"><title>值不能被修改</title></topic></topics></children></topic><topic id="0kj2ic6806jpvhn8u9sm7jpcv5" modified-by="" timestamp="1511574309586"><title>必须手动初始化</title><children><topics type="attached"><topic id="1mli9e1ik9mc3rdgktcjv8l0hi" modified-by="" timestamp="1511574320416"><title>示例</title><notes><html><xhtml:p>package com.atguigu.review;</xhtml:p><xhtml:p/><xhtml:p>public class TestFinal {</xhtml:p><xhtml:p/><xhtml:p>}</xhtml:p><xhtml:p>class Human{</xhtml:p><xhtml:p>//	private static final String country = "中国";</xhtml:p><xhtml:p>	private static final String country;</xhtml:p><xhtml:p>	static{</xhtml:p><xhtml:p>		country = "中国";</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p>class Person{</xhtml:p><xhtml:p>//	final String country = "中国";</xhtml:p><xhtml:p>	private final String country;</xhtml:p><xhtml:p>	private String name;</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>/*	{</xhtml:p><xhtml:p>		country = "中国";</xhtml:p><xhtml:p>	}*/</xhtml:p><xhtml:p>	Person(){</xhtml:p><xhtml:p>		country = "中国";</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p/><xhtml:p>	public Person(String name) {</xhtml:p><xhtml:p>		super();</xhtml:p><xhtml:p>		country = "中国";</xhtml:p><xhtml:p>		this.name = name;</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>}</xhtml:p></html><plain>package com.atguigu.review;&#13;
&#13;
public class TestFinal {&#13;
&#13;
}&#13;
class Human{&#13;
//	private static final String country = "中国";&#13;
	private static final String country;&#13;
	static{&#13;
		country = "中国";&#13;
	}&#13;
}&#13;
class Person{&#13;
//	final String country = "中国";&#13;
	private final String country;&#13;
	private String name;&#13;
	&#13;
/*	{&#13;
		country = "中国";&#13;
	}*/&#13;
	Person(){&#13;
		country = "中国";&#13;
	}&#13;
&#13;
	public Person(String name) {&#13;
		super();&#13;
		country = "中国";&#13;
		this.name = name;&#13;
	}&#13;
	&#13;
}</plain></notes></topic></topics></children></topic></topics></children></topic><topic id="0c3iuej2nile8g6vg4v33uurle" modified-by="" timestamp="1511574088711"><title>局部变量</title><children><topics type="attached"><topic id="2p931g7bme3e30j84phvahoqvq" modified-by="" timestamp="1511574120233"><title>常量</title><children><topics type="attached"><topic id="2if631kl7mpr4qm6132k7rv82i" modified-by="" timestamp="1511574121707"><title>值不能被修改</title></topic></topics></children></topic><topic id="04galki9c706lqui0e3imrqsed" modified-by="" timestamp="1511574093294"><title>必须手动初始化</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="34v6rp5uu69fv8dsb3f2fk7enu" modified-by="" timestamp="1511574339008"><title>native</title><children><topics type="attached"><topic id="2a0a3hnge7m7v4jaubqe7nghjp" modified-by="" timestamp="1511574338045"><title>原生的</title></topic><topic id="2pkrrpaq8i7oapmuu7m81clt5t" modified-by="" timestamp="1511574343081"><title>可以修饰</title><children><topics type="attached"><topic id="78n011hiv3ij60htkcl7rh4ekv" modified-by="" timestamp="1511574391793"><title>方法</title><children><topics type="attached"><topic id="2pm63716k6ekbsun62qemo49jl" modified-by="" timestamp="1511574364756"><title>（1）表示这个方法的方法体是非Java语言实现</title></topic><topic id="3pn42a7vabavbugropllaljvds" modified-by="" timestamp="1511574383053"><title svg:width="500">（2）对于使用这个方法者来说，和普通的Java 方法一样使用</title></topic><topic id="1cnqqjonnpgi94ha0pas43ofos" modified-by="" timestamp="1511574400700"><title>（3）如果有需要，也可以进行重写</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic branch="folded" id="3o4t8tl92habn9b5v66afrmkr2" modified-by="" timestamp="1511829584842"><title>4、包</title><children><topics type="attached"><topic id="6rumm8qshosptbivho15gvkl9c" modified-by="" timestamp="1510970786395"><title>包的作用</title><children><topics type="attached"><topic id="4o5tmkd5jq28b6d1e0gttbuuo2" modified-by="" timestamp="1510970787624"><title>（1）避免类的重名&#13;
（2）访问权限的控制&#13;
（3）便于管理</title></topic></topics></children></topic><topic id="2b0ev4p0tinth2kr11cjv5ti6t" modified-by="" timestamp="1510970801970"><title>如何声明包</title><children><topics type="attached"><topic id="6ufmpnp8l22eelk6qv0rkjj76a" modified-by="" timestamp="1510970801141"><title>package 包;</title></topic><topic id="0bncgff23latmjbcc6f9rhm9ob" modified-by="" timestamp="1510970818723"><title>要求</title><children><topics type="attached"><topic id="0v3a9mqqid0m84hji60iope4n8" modified-by="" timestamp="1510970813898"><title>必须在源文件的首行，一个源文件只能有一句</title></topic><topic id="3goudkv26iendep29ptemroq5h" modified-by="" timestamp="1510970819851"><title svg:width="500">遵循命名规范，所有字母都小写，单词之间使用.，一般以公司的域名倒置</title></topic></topics></children></topic></topics></children></topic><topic id="4i9jrs9near912776ve17itoig" modified-by="" timestamp="1510970898141"><title>如何使用其他包的类</title><children><topics type="attached"><topic id="5dl2s08238imr6cadhn14l5f8b" modified-by="" timestamp="1510970838831"><title>需要import 包.类名;</title></topic><topic id="7luhldjr7sbsurmvo0d03mctou" modified-by="" timestamp="1510970859837"><title>要求</title><children><topics type="attached"><topic id="697q3qslqok720b4nhmnbjjj37" modified-by="" timestamp="1510970853292"><title>在package和class声明之间，可以多句</title></topic><topic id="1bnjr3f9v36s7l7s2srvv5enrl" modified-by="" timestamp="1510970893248"><title>被使用的类必须是public 或 protected（父子类）</title></topic></topics></children></topic><topic id="2ktjtrujedrdkceu2ih8jrtfr4" modified-by="" timestamp="1510971323765"><title>形式</title><children><topics type="attached"><topic id="29tp48c6o152v9p1oojoudlneo" modified-by="" timestamp="1510971033382"><title>一一列举</title><children><topics type="attached"><topic id="6387qb9esgrqpds0j5vb6rkaq2" modified-by="" timestamp="1510971034587"><title>import java.util.Random;&#13;
import java.util.Scanner;</title></topic></topics></children></topic><topic id="168ds11i1pgnhha0tqt47oj4iu" modified-by="" timestamp="1510971080902"><title>某个包的类</title><children><topics type="attached"><topic id="1v4gqf5gabikh1eumu9gqknegt" modified-by="" timestamp="1510971082156"><title>import java.util.*;</title></topic></topics></children></topic><topic id="7c1vcg53trlqgeg8obijm11ko0" modified-by="" timestamp="1510971336246"><title>静态导入</title><children><topics type="attached"><topic id="6uoa0rfua6ignhllof2fpgboi8" modified-by="" timestamp="1510971330750"><title>import static java.lang.Math.*;</title></topic><topic id="50diibuner05573tuinnopid51" modified-by="" timestamp="1510971341600"><title>System.out.println(PI);&#13;
System.out.println(sqrt(4));</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic branch="folded" id="1isn1028bmtue27eottiv97lj7" modified-by="" timestamp="1511829586501"><title>Overload和Override的区别</title><children><topics type="attached"><topic id="6jmqa4bi665lhi92laanlg2vrd" modified-by="" timestamp="1511316209273"><title svg:width="500">Overload：方法的重载&#13;
	在同一类，方法名称相同，形参列表不同的两个或多个方法称为重载。&#13;
Override：方法的重写&#13;
	在子类继承父类时，如果父类的方法实现不适用于子类，子类就可以对父类的方法进行重写，覆盖。</title></topic><topic id="43d5n1qrgviqntm450c1nanmhl" modified-by="" timestamp="1511316148101"><title/><children><topics type="attached"><topic id="4761htgu6s2n9ah31ko3itghvo" modified-by="" timestamp="1511316148074"><xhtml:img xhtml:src="xap:attachments/4mcckr8rc4k8qk796ccusp06qj.png"/></topic></topics></children></topic></topics></children></topic></topics></children></topic><title>面向对象</title></sheet></xmap-revision-content>