<?xml version="1.0" encoding="UTF-8" standalone="no"?><xmap-revision-content xmlns="urn:xmind:xmap:xmlns:revision:1.0" xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:svg="http://www.w3.org/2000/svg" xmlns:xhtml="http://www.w3.org/1999/xhtml" xmlns:xlink="http://www.w3.org/1999/xlink"><sheet id="7068ei3mi62j73rqnq32qdi3sa" modified-by="" style-id="0kstj9p5njfq9famsfnsd1bk44" theme="xminddefaultthemeid" timestamp="1513125511380" xmlns="urn:xmind:xmap:xmlns:content:2.0"><topic id="7ahcc0rkuhkv2avc0ktoru1mph" modified-by="" structure-class="org.xmind.ui.logic.right" timestamp="1513042406204"><title>反射机制</title><extensions><extension provider="org.xmind.ui.map.unbalanced"><content><right-number>-1</right-number></content></extension></extensions><children><topics type="attached"><topic id="75ap3focngkct538ucqm7flpn0" modified-by="" timestamp="1513039339241"><title>为什么要用反射？</title><children><topics type="attached"><topic id="4sdlu9vs868bknpakf5vpma8iv" modified-by="" timestamp="1513039405682"><title svg:width="500">因为Java是静态的强类型语言，在编译阶段就需要确定类型</title><children><topics type="attached"><topic id="2hhourjhfkc9fgknavinhevfsu" modified-by="" timestamp="1513039842426"><title>Java为了实现“动态性“特征，引入了反射机制</title><children><topics type="attached"><topic id="0j6j7m3ida2jhtaj867u2toir1" modified-by="" timestamp="1513039489365"><title svg:width="500">变量可以使用Object声明，然后在运行时确定某个对象的运行时类型</title></topic><topic id="299qhflgqs8p0h6jdsuso98t3u" modified-by="" timestamp="1513039526843"><title svg:width="500">或者在运行时动态的”注入“某个类型的对象，动态的创建某个类型的对象</title><children><topics type="attached"><topic id="0rqdo3o0n1b1ht9vq756ijc4lc" modified-by="" timestamp="1513039540571"><title svg:width="500">例如：用这个类型的Class对象，然后创建它的实例</title></topic></topics></children></topic><topic id="3ba2b56nru91htu1pgp3p2moo1" modified-by="" timestamp="1513039847191"><title>。。。。</title></topic></topics></children></topic></topics></children></topic><topic id="5kb0310eu1487vots4ffu5aici" modified-by="" timestamp="1513039373516"><title svg:width="500">例如：JS等是动态的弱类型的语言，在运行时确定变量的类型，根据赋的值确定变量的类型</title></topic></topics></children></topic><topic id="7c39fhkbkffiien8r2thkfvpci" modified-by="" timestamp="1513040148085"><title>反射的根源</title><children><topics type="attached"><topic id="0pap2qm32f8964e1k2a682ttk9" modified-by="" timestamp="1513039901216"><title>java.lang.Class</title><children><topics type="attached"><topic id="4fk691plab5a9mkj2i050fpjul" modified-by="" timestamp="1513039968687"><title svg:width="500">Class 类的实例表示正在运行的 Java 应用程序中的类和接口。枚举是一种类，注释是一种接口。每个数组属于被映射为 Class 对象的一个类，所有具有相同元素类型和维数的数组都共享该 Class 对象。基本的 Java 类型（boolean、byte、char、short、int、long、float 和 double）和关键字 void 也表示为 Class 对象。 </title><children><topics type="attached"><topic id="6u5rnpu2etvcna9pnc02bt805k" modified-by="" timestamp="1513040025766"><title>示例代码</title><children><topics type="attached"><topic id="14254lghnq3papk9dinbpbqrbc" modified-by="" timestamp="1513040027802"><title svg:width="500">	@Test&#13;
	public void test() {&#13;
		Class c1 = int.class;&#13;
		Class c2 = void.class;&#13;
		Class c3 = String.class;&#13;
		Class c4 = Comparable.class;&#13;
		Class c5 = ElementType.class;&#13;
		Class c6 = Override.class;&#13;
		Class c7 = int[].class;&#13;
		&#13;
		int[] arr1 = new int[5];&#13;
		int[] arr2 = new int[10];&#13;
		&#13;
		System.out.println(arr1.getClass() == arr2.getClass());&#13;
		System.out.println(int[].class == arr2.getClass());&#13;
		&#13;
		int[][] arr3 = new int[5][10];&#13;
		System.out.println(arr1.getClass());&#13;
		System.out.println(arr3.getClass());&#13;
	}</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="0tldv37hoijg0donmd5bm1v9lk" modified-by="" timestamp="1513040293963"><title>四种获取Class对象的方式</title><children><topics type="attached"><topic id="4nuo1ov94ss3skv10uf9253cn2" modified-by="" timestamp="1513040177875"><title>（1）如果类型已知：</title><children><topics type="attached"><topic id="6nv65q8432u5es9abs4ognurph" modified-by="" timestamp="1513040196830"><title>类型名.class</title></topic></topics></children></topic><topic id="06n9d2tnkrshi85uq6n53c3ijd" modified-by="" timestamp="1513040226757"><title>（2）如果对象存在</title><children><topics type="attached"><topic id="37hiqo54hj1auh31qv8g3mme9l" modified-by="" timestamp="1513040233118"><title>对象.getClass()</title></topic></topics></children></topic><topic id="5pqnq8hr0ojruk38rclntepd8v" modified-by="" timestamp="1513040276796"><title svg:width="500">（3）如果在编译阶段未知，但是运行阶段可以获取它的类型全名称</title><children><topics type="attached"><topic id="6vrfjvdhmsq7pn2l3qlvn9qf6o" modified-by="" timestamp="1513040289312"><title>Class.forName("类型全名称")</title></topic></topics></children></topic><topic id="4vevq5f7ctvbp66g57guboe6v4" modified-by="" timestamp="1513040297402"><title svg:width="500">（4）如果在编译阶段未知，但是运行阶段可以获取它的类型全名称</title><children><topics type="attached"><topic id="4b0cigc8le7925k8hlpqgr12v5" modified-by="" timestamp="1513040308123"><title>类加载对象.loadClass("类型全名称")</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="5brc2s5m70clnb00pqml2u3c7j" modified-by="" timestamp="1513069675422"><title>相关的API（了解）</title><children><topics type="attached"><topic id="0di5flmtn0mj5ds0ls36dfnu36" modified-by="" timestamp="1513040460333"><title>java.lang.Class</title><children><topics type="attached"><topic id="52vv6dvrc7avde7fsaig7uljvt" modified-by="" timestamp="1513041184557"><title>方法</title><children><topics type="attached"><topic id="2169d5qkg33q0203o35qe4gdqo" modified-by="" timestamp="1513040482014"><title>（1）获取类型名：</title><children><topics type="attached"><topic id="5pdl6a2a34m79mhmhs4feaar3q" modified-by="" timestamp="1513040485319"><title>getName()</title></topic></topics></children></topic><topic id="121ivu1m3jlf3db0926oajdg9q" modified-by="" timestamp="1513040506621"><title>（2）创建实例对象</title><children><topics type="attached"><topic id="7bvouss179i1l63lgdcu5rd7fa" modified-by="" timestamp="1513041455302"><title>newInstance()</title><children><topics type="attached"><topic id="7s8m5h7n3p3t0amnvdjbnjjfup" modified-by="" timestamp="1513040524158"><title>这个类型必须有无参构造</title></topic><topic id="2kinf7o45mfldjkli3agkoji88" modified-by="" timestamp="1513041467670"><title>Class对象.newInstance()</title></topic></topics></children></topic></topics></children><marker-refs><marker-ref marker-id="star-red"/></marker-refs></topic><topic id="4g5ffurh9v01io4k749flc8f55" modified-by="" timestamp="1513040542752"><title>（3）获取包的信息</title><children><topics type="attached"><topic id="0ak9sfsqpd0akedtoo7mil5m1s" modified-by="" timestamp="1513040553048"><title>getPackage()</title></topic></topics></children></topic><topic id="63mbgfujlp968fsb00t4ti7sgo" modified-by="" timestamp="1513041288435"><title>（4）获取父类</title><children><topics type="attached"><topic id="72ftq5u3026rqdjupnpsbmrpt4" modified-by="" timestamp="1513040624379"><title>Class  getSuperClass()</title><children><topics type="attached"><topic id="5gr5thgvemka3grho3la06vsfv" modified-by="" timestamp="1513040618901"><title>不带泛型</title></topic></topics></children></topic><topic id="2o4c38nler142k42lgevq84tde" modified-by="" timestamp="1513040646607"><title>Type  getGenericSuperClass()</title><children><topics type="attached"><topic id="5onsk80rnlftlaau6hgi4s99l9" modified-by="" timestamp="1513040651852"><title>可以带泛型</title></topic></topics></children></topic></topics></children><marker-refs><marker-ref marker-id="star-red"/></marker-refs></topic><topic id="5qehdlvnv0lfie39igff7lsjuk" modified-by="" timestamp="1513040737847"><title>（5）获取父接口</title><children><topics type="attached"><topic id="19hnlnaunk5erq4eat1723rq8s" modified-by="" timestamp="1513040841717"><title>Class[]  getInterfaces()</title><children><topics type="attached"><topic id="3m68lc01milt9uq520ceul9m92" modified-by="" timestamp="1513040693019"><title>不带泛型</title></topic></topics></children></topic><topic id="4ik1nlmmc2bbsu5gc62d820bk0" modified-by="" timestamp="1513040744642"><title>Type[]  getGenericInterfaces()</title><children><topics type="attached"><topic id="1bopig65rtrouo8ngko30p65m8" modified-by="" timestamp="1513040747358"><title>可以带泛型</title></topic></topics></children></topic></topics></children></topic><topic id="09hosl8h60j7ibr7tm2at8pku1" modified-by="" timestamp="1513040899929"><title>（6）获取该类型的属性</title><children><topics type="attached"><topic id="5rr96966idkdmqarrqlctkt83r" modified-by="" timestamp="1513040801873"><title>获取全部可访问的公共的属性</title><children><topics type="attached"><topic id="3i32d8m78ueebg7b5ldr7jdcqv" modified-by="" timestamp="1513040834117"><title>Field[]   getFields()</title></topic></topics></children></topic><topic id="1ch6i34r7apbj17i8fdg02dlqp" modified-by="" timestamp="1513040816178"><title>获取全部已声明的属性</title><children><topics type="attached"><topic id="0klvf9km2a2um8in1bg05kaccv" modified-by="" timestamp="1513040845389"><title>Field[]  getDeclaredFields()</title></topic></topics></children></topic><topic id="18f4hd6eghsq0dbl1enjbidjk2" modified-by="" timestamp="1513040860015"><title>获取某一个公共的属性</title><children><topics type="attached"><topic id="0s2pmjt07ggu2ajo4a3khn7j6r" modified-by="" timestamp="1513040890117"><title>Field  getField("属性名")</title></topic></topics></children></topic><topic id="3ti755a2doo2oreii1h7vp1ahs" modified-by="" timestamp="1513041295282"><title>获取某一个声明过的属性，可能是私有的等</title><children><topics type="attached"><topic id="114ldrmncqelidn8ssc1qhe17e" modified-by="" timestamp="1513040923105"><title>Field  getDeclaredField("属性名")</title></topic><topic id="77cc5pu3ad1lvjg0u6n7l00mca" modified-by="" timestamp="1513041154549"><title>通过属性名就可以唯一确定一个属性</title></topic></topics></children><marker-refs><marker-ref marker-id="flag-red"/></marker-refs></topic></topics></children></topic><topic id="1bcfn17456el95ecatn8a6994l" modified-by="" timestamp="1513040989200"><title>（7）获取该类的构造器</title><children><topics type="attached"><topic id="20nrbho351kgogdp77n403is5k" modified-by="" timestamp="1513040964494"><title>获取全部的公共的构造器</title></topic><topic id="6ks31gbmpo2d22hg9svghkdra3" modified-by="" timestamp="1513040977284"><title>获取全部已声明的构造器</title></topic><topic id="2o1iln24prr4v2b08qttb17ca8" modified-by="" timestamp="1513040988326"><title>获取某一个公共的构造器</title></topic><topic id="4qcpaburiumkooodav0kb4gnro" modified-by="" timestamp="1513041155417"><title>获取某一个已声明的构造器</title><children><topics type="attached"><topic id="4412kfjj6han6n9rf8e9cfjj08" modified-by="" timestamp="1513041055562"><title svg:width="500">Constructor  getDeclaredConstructor(形参列表的类型Class列表...  )</title></topic><topic id="1m8vc8399ucu83hns871c4e0hk" modified-by="" timestamp="1513041170131"><title>通过构造器的形参列表就可以唯一确定一个构造器</title></topic></topics></children></topic></topics></children></topic><topic id="52k52u66g9fkf802ucvnbkb38o" modified-by="" timestamp="1513041079038"><title>（8）获取该类的方法</title><children><topics type="attached"><topic id="333mkoqbqa0htcrkjc5isnjt6m" modified-by="" timestamp="1513041084102"><title>获取全部的公共的方法</title></topic><topic id="34vhkpdl1g268pkl1u0e07m0b7" modified-by="" timestamp="1513041087367"><title>获取全部已声明的方法</title></topic><topic id="0g7d8010fbhjo8a5pjl5pjbasg" modified-by="" timestamp="1513041090724"><title>获取某一个公共的方法</title></topic><topic id="4ud4mmhk98r8mltp5ejv3dnf7v" modified-by="" timestamp="1513041306457"><title>获取某一个已声明的方法</title><children><topics type="attached"><topic id="5ru183eb5e9suncljqoodsa59k" modified-by="" timestamp="1513041137099"><title svg:width="500">Method getDeclaredMethod("方法名", 形参列表的类型Class列表 ....)</title></topic><topic id="15hqqsipjq0t9g2d7kfbs0kin4" modified-by="" timestamp="1513041180484"><title svg:width="500">通过方法的名称+形参列表才能唯一确定一个方法</title></topic></topics></children><marker-refs><marker-ref marker-id="star-red"/></marker-refs></topic></topics></children></topic><topic id="5d9dtugk1kub0c1um2n751hgen" modified-by="" timestamp="1513041235049"><title>（9）获取类上的注解</title><children><topics type="attached"><topic id="530vnk70ggl6vktintj3poeh1l" modified-by="" timestamp="1513041226901"><title>获取所有的注解/注释</title><children><topics type="attached"><topic id="31grmbg4rs2nfms881n6o70573" modified-by="" timestamp="1513041233776"><title> Annotation[] getAnnotations() </title></topic></topics></children></topic><topic id="56spgfu8hvfv7554971m49sanp" modified-by="" timestamp="1513041309447"><title>获取指定的注解</title><children><topics type="attached"><topic id="5q74vpqassi446934ddn0r23ai" modified-by="" timestamp="1513041276776"><title svg:width="500">&lt;A extends Annotation&gt;  A   getAnnotation(Class&lt;A&gt; annotationClass) </title></topic></topics></children><marker-refs><marker-ref marker-id="star-red"/></marker-refs></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="190p8gf0l2622g3haf0551gfum" modified-by="" timestamp="1513040455894"><title>java.lang.reflect</title><children><topics type="attached"><topic id="13k4rippcvn7l8c46nnnl6ttd1" modified-by="" timestamp="1513041323066"><title>Package</title><children><topics type="attached"><topic id="5uu3ou8mh8d0cta9qeo4l7unue" modified-by="" timestamp="1513041330811"><title>获取包名</title><children><topics type="attached"><topic id="55155lbr6j2a28hombpdqg43re" modified-by="" timestamp="1513041336391"><title>getName()</title></topic></topics></children></topic></topics></children></topic><topic id="3hfivgo3vu0udh9m2uggs2tefk" modified-by="" timestamp="1513041349980"><title>Modifier</title><children><topics type="attached"><topic id="1nob34obshqsnl5j3vct30uola" modified-by="" timestamp="1513041362020"><title>Modifier.toString(mod)</title></topic></topics></children></topic><topic id="5u66ebm1uaq8b1amin055nue6h" modified-by="" timestamp="1513041370454"><title>Constructor</title><children><topics type="attached"><topic id="2thvt7paisu28m6tjrsp2aae5h" modified-by="" timestamp="1513041378725"><title>创建实例对象</title><children><topics type="attached"><topic id="3d7jp6fvleqop9hs17vmdg97kv" modified-by="" timestamp="1513041427654"><title>newInstance(Object ...)</title><children><topics type="attached"><topic id="108u1g9t6f0mde52ek7voejlsm" modified-by="" timestamp="1513041426614"><title svg:width="500">如果无参，那么就直接“构造器对象.newInstance()”</title></topic><topic id="5l8dvsfs7383eh6p7ki5supe2g" modified-by="" timestamp="1513041448578"><title svg:width="500">如果有参：构造器对象.newInstance(给构造器的实参列表)</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="0gtt4bjgqgosp7ad5gp860h68i" modified-by="" timestamp="1513041518349"><title>Field</title><children><topics type="attached"><topic id="4rl2lk5r2itjds55atq3qhspeq" modified-by="" timestamp="1513041508939"><title>（1）setAccessible(true)</title></topic><topic id="15amdst3jjs8252c793cn7bbh4" modified-by="" timestamp="1513041562629"><title>（2）Object  get(实例对象)</title><children><topics type="attached"><topic id="51iuu1mfmvc67tkrb43vfb9g39" modified-by="" timestamp="1513041561777"><title>Object  属性对象.get(实例对象)</title></topic><topic id="4jd74f24ihv8c848knb05pra2d" modified-by="" timestamp="1513041579713"><title>原来是：  实例对象.get属性名();</title></topic></topics></children></topic><topic id="6r54il63nn7vu5lrvqot98hunr" modified-by="" timestamp="1513041634748"><title>（3）set(实例对象， 属性的新值)</title><children><topics type="attached"><topic id="0ge3lcu9ae7cnfpvvkur3nrs7k" modified-by="" timestamp="1513041633679"><title>属性对象.set（实例对象，属性值）</title></topic><topic id="1m3enfh5o259mbbn5a0k8l9ejo" modified-by="" timestamp="1513041646995"><title>原来是：实例对象.set属性名（属性值）</title></topic></topics></children></topic></topics></children></topic><topic id="1c7b917e985mvaks5rs3ia17ul" modified-by="" timestamp="1513041699537"><title>Method</title><children><topics type="attached"><topic id="6v5127n9p7slquk85fdc4guubl" modified-by="" timestamp="1513041689906"><title>（1）setAccessible(true)</title><children><topics type="attached"><topic id="7q8nevv4bvjvd7rnmu895v9el3" modified-by="" timestamp="1513041698203"><title>如果方法不是public才需要</title></topic></topics></children></topic><topic id="1lf9imhqofoba45aik7end2msp" modified-by="" timestamp="1513041797797"><title svg:width="500">（2）Object invoke(实例对象, 传给被调用方法的实参列表)</title><children><topics type="attached"><topic id="3gij4vfcnh9lfcb96j1ubl2224" modified-by="" timestamp="1513041857208"><title svg:width="500">Object  returnValue = 方法对象.invoke(实例对象，实参列表...）</title><children><topics type="attached"><topic id="3hrpg8erbfp1f84lfga0qso31r" modified-by="" timestamp="1513041794376"><title svg:width="500">如果原来的方法对象是没有返回值，即是void，那么returnValue是null</title></topic></topics></children></topic><topic id="0b7m1lh08c6uhaggb5irrp0vdk" modified-by="" timestamp="1513041837919"><title>原来：</title><children><topics type="attached"><topic id="3slqfffgpd0gahvaqj5svd65ac" modified-by="" timestamp="1513041841743"><title>有返回值</title><children><topics type="attached"><topic id="01rlnv5finbhapqmt5704rtifq" modified-by="" timestamp="1513041843265"><title>变量 = 实例对象.方法名(实参列表)</title></topic></topics></children></topic><topic id="0npetnujpn5lfcpep2hp9itj2c" modified-by="" timestamp="1513041847205"><title>无返回值</title><children><topics type="attached"><topic id="4j7a4ss9npr5s5khrrhf9ui61i" modified-by="" timestamp="1513041850601"><title>实例对象.方法名(实参列表);</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="1hb6o3ir780qt52shr9pchgor2" modified-by="" timestamp="1513069682753"><title>示例代码</title><notes><html><xhtml:p>package com.atguigu.reflect;</xhtml:p><xhtml:p/><xhtml:p>import java.lang.reflect.Constructor;</xhtml:p><xhtml:p>import java.lang.reflect.Field;</xhtml:p><xhtml:p>import java.lang.reflect.Method;</xhtml:p><xhtml:p>import java.lang.reflect.Modifier;</xhtml:p><xhtml:p>import java.nio.charset.Charset;</xhtml:p><xhtml:p>import java.util.Arrays;</xhtml:p><xhtml:p/><xhtml:p>/*</xhtml:p><xhtml:p> * 有了Class对象后，都可以做什么事？你想干啥干啥</xhtml:p><xhtml:p> * </xhtml:p><xhtml:p> * 1、获取类的详细信息</xhtml:p><xhtml:p> * 2、创建实例对象</xhtml:p><xhtml:p> * 3、获取属性，设置属性</xhtml:p><xhtml:p> * 4、获取方法，设置方法</xhtml:p><xhtml:p> * ...</xhtml:p><xhtml:p> */</xhtml:p><xhtml:p>public class TestReflectAPI {</xhtml:p><xhtml:p/><xhtml:p>	public static void main(String[] args) throws Exception {</xhtml:p><xhtml:p>		Object obj = "hello";</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		Class clazz = obj.getClass();</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//1、获取类名</xhtml:p><xhtml:p>		System.out.println("类名：" + clazz.getName());</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//2、获取包信息</xhtml:p><xhtml:p>		/*</xhtml:p><xhtml:p>		 * 所有的包有共同点--&gt;Package</xhtml:p><xhtml:p>		 */</xhtml:p><xhtml:p>		Package pack = clazz.getPackage();</xhtml:p><xhtml:p>		System.out.println("包名：" + pack.getName());</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//3、获取类的修饰符</xhtml:p><xhtml:p>		int mod = clazz.getModifiers();</xhtml:p><xhtml:p>		//每一种修饰符，有一个常量表示</xhtml:p><xhtml:p>		//这个常量在Modifier类型声明</xhtml:p><xhtml:p>		System.out.println(Modifier.toString(mod));</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//4、父类</xhtml:p><xhtml:p>		Class superclass = clazz.getSuperclass();</xhtml:p><xhtml:p>		System.out.println("父类：" + superclass);</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//5、接口</xhtml:p><xhtml:p>		Class[] interfaces = clazz.getInterfaces();</xhtml:p><xhtml:p>		System.out.println("接口们：");</xhtml:p><xhtml:p>		for (Class class1 : interfaces) {</xhtml:p><xhtml:p>			System.out.println(class1);</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//6、属性：Field</xhtml:p><xhtml:p>		/*</xhtml:p><xhtml:p>		 * 属性共同点：  修饰符   数据类型   属性名      属性对应set值，get值的操作</xhtml:p><xhtml:p>		 * 任意类型的一个属性对应Field对象</xhtml:p><xhtml:p>		 * </xhtml:p><xhtml:p>		 * 一切皆对象</xhtml:p><xhtml:p>		 */</xhtml:p><xhtml:p>//		Field[] fields = clazz.getFields();//返回公共的属性</xhtml:p><xhtml:p>/*		Field[] fields = clazz.getDeclaredFields();</xhtml:p><xhtml:p>		System.out.println("属性们：");</xhtml:p><xhtml:p>		for (Field field : fields) {</xhtml:p><xhtml:p>			System.out.println("属性的类型："+field.getType());</xhtml:p><xhtml:p>			System.out.println("属性的名称："+field.getName());</xhtml:p><xhtml:p>			System.out.println("属性的所有信息："+field);</xhtml:p><xhtml:p>		}*/</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//单独获取某个属性对象，例如：获取value属性</xhtml:p><xhtml:p>		//假设从配置文件中知晓属性名是value</xhtml:p><xhtml:p>//		Field field = clazz.getField("value");//得到公共的</xhtml:p><xhtml:p>		Field field = clazz.getDeclaredField("value");//得到已声明的</xhtml:p><xhtml:p>		System.out.println(field);</xhtml:p><xhtml:p>		//设置属性值，获取属性值</xhtml:p><xhtml:p>		//先有对象，才能有属性值</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>//		获取"hello"对象的value属性值</xhtml:p><xhtml:p>		field.setAccessible(true);//设置可访问</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		Object object = field.get(obj);</xhtml:p><xhtml:p>		char[] v = (char[]) object;</xhtml:p><xhtml:p>		System.out.println(Arrays.toString(v));</xhtml:p><xhtml:p>		v[0] = 'w';</xhtml:p><xhtml:p>		v[1] = 'o';</xhtml:p><xhtml:p>		v[2] = 'r';</xhtml:p><xhtml:p>		v[3] = 'l';</xhtml:p><xhtml:p>		v[4] = 'd';</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//参数一：哪个对象的field属性，第二个参数：设置为xx新值</xhtml:p><xhtml:p>//		field.set("hello", "world");//因为是final</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		System.out.println(obj);</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//7、创建对象    创建Class对应的类型的对象</xhtml:p><xhtml:p>//		Object obj = clazz.newInstance();</xhtml:p><xhtml:p>//		System.out.println(obj);</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//8、构造器</xhtml:p><xhtml:p>//		clazz.getConstructors()//获取所有公共的构造器</xhtml:p><xhtml:p>//		clazz.getDeclaredConstructors();//获取所有该类拥有的构造器</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		/*</xhtml:p><xhtml:p>		 * 构造器的共同特点：修饰符   构造器名   形参列表      可以创建对象的操作</xhtml:p><xhtml:p>		 */</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		/*</xhtml:p><xhtml:p>		 * 构造器可以重载，构造器的名称都一样</xhtml:p><xhtml:p>		 * 如何在类中唯一确定一个构造器：靠形参列表（个数和类型）</xhtml:p><xhtml:p>		 */</xhtml:p><xhtml:p>//		 Constructor c = clazz.getDeclaredConstructor();//获取无参构造</xhtml:p><xhtml:p>//		 Object newInstance = c.newInstance();//用无参构造创建对象</xhtml:p><xhtml:p>//		 System.out.println("对象："+newInstance);</xhtml:p><xhtml:p>		 </xhtml:p><xhtml:p>		//public String(char value[])</xhtml:p><xhtml:p>		 Constructor c = clazz.getDeclaredConstructor(char[].class);//char[]数组类型</xhtml:p><xhtml:p>		 //用有参构造创建对象，需要实参列表</xhtml:p><xhtml:p>		 char[] params= {'c','h','a','i'};</xhtml:p><xhtml:p>		 Object newInstance = c.newInstance(params);</xhtml:p><xhtml:p>		System.out.println("对象："+newInstance);</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//9、方法</xhtml:p><xhtml:p>		/*</xhtml:p><xhtml:p>		 * 所有方法共同特点：</xhtml:p><xhtml:p>		 * 修饰符  返回值类型  方法名（形参列表）抛出的异常列表</xhtml:p><xhtml:p>		 * 方法可以被调用</xhtml:p><xhtml:p>		 */</xhtml:p><xhtml:p>//		clazz.getMethods()//获取所有公共的方法</xhtml:p><xhtml:p>//		clazz.getDeclaredMethods();//获取所有方法</xhtml:p><xhtml:p>		/*</xhtml:p><xhtml:p>		 * 方法可以重载，如何在一个类中，唯一确定方法：方法名+形参列表（个数和类型）</xhtml:p><xhtml:p>		 * </xhtml:p><xhtml:p>		 * toString()</xhtml:p><xhtml:p>		 */</xhtml:p><xhtml:p>		Method m = clazz.getDeclaredMethod("toString");//获取无参的方法</xhtml:p><xhtml:p>		System.out.println(m);</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//调用方法</xhtml:p><xhtml:p>		//参数一：那个实例对象调用m方法，参数二：传给m方法的实参列表</xhtml:p><xhtml:p>		Object returnValue = m.invoke(obj);</xhtml:p><xhtml:p>		System.out.println(returnValue);</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		// public byte[] getBytes(Charset charset) </xhtml:p><xhtml:p>		Method m2 = clazz.getDeclaredMethod("getBytes", Charset.class);</xhtml:p><xhtml:p>		Object returnValue2 = m2.invoke(obj, Charset.forName("GBK"));</xhtml:p><xhtml:p>		System.out.println(returnValue2);</xhtml:p><xhtml:p>		byte[] data = (byte[]) returnValue2;</xhtml:p><xhtml:p>		System.out.println(Arrays.toString(data));</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p/><xhtml:p>}</xhtml:p><xhtml:p/></html><plain>package com.atguigu.reflect;&#13;
&#13;
import java.lang.reflect.Constructor;&#13;
import java.lang.reflect.Field;&#13;
import java.lang.reflect.Method;&#13;
import java.lang.reflect.Modifier;&#13;
import java.nio.charset.Charset;&#13;
import java.util.Arrays;&#13;
&#13;
/*&#13;
 * 有了Class对象后，都可以做什么事？你想干啥干啥&#13;
 * &#13;
 * 1、获取类的详细信息&#13;
 * 2、创建实例对象&#13;
 * 3、获取属性，设置属性&#13;
 * 4、获取方法，设置方法&#13;
 * ...&#13;
 */&#13;
public class TestReflectAPI {&#13;
&#13;
	public static void main(String[] args) throws Exception {&#13;
		Object obj = "hello";&#13;
		&#13;
		Class clazz = obj.getClass();&#13;
		&#13;
		//1、获取类名&#13;
		System.out.println("类名：" + clazz.getName());&#13;
		&#13;
		//2、获取包信息&#13;
		/*&#13;
		 * 所有的包有共同点--&gt;Package&#13;
		 */&#13;
		Package pack = clazz.getPackage();&#13;
		System.out.println("包名：" + pack.getName());&#13;
		&#13;
		//3、获取类的修饰符&#13;
		int mod = clazz.getModifiers();&#13;
		//每一种修饰符，有一个常量表示&#13;
		//这个常量在Modifier类型声明&#13;
		System.out.println(Modifier.toString(mod));&#13;
		&#13;
		//4、父类&#13;
		Class superclass = clazz.getSuperclass();&#13;
		System.out.println("父类：" + superclass);&#13;
		&#13;
		//5、接口&#13;
		Class[] interfaces = clazz.getInterfaces();&#13;
		System.out.println("接口们：");&#13;
		for (Class class1 : interfaces) {&#13;
			System.out.println(class1);&#13;
		}&#13;
		&#13;
		//6、属性：Field&#13;
		/*&#13;
		 * 属性共同点：  修饰符   数据类型   属性名      属性对应set值，get值的操作&#13;
		 * 任意类型的一个属性对应Field对象&#13;
		 * &#13;
		 * 一切皆对象&#13;
		 */&#13;
//		Field[] fields = clazz.getFields();//返回公共的属性&#13;
/*		Field[] fields = clazz.getDeclaredFields();&#13;
		System.out.println("属性们：");&#13;
		for (Field field : fields) {&#13;
			System.out.println("属性的类型："+field.getType());&#13;
			System.out.println("属性的名称："+field.getName());&#13;
			System.out.println("属性的所有信息："+field);&#13;
		}*/&#13;
		&#13;
		//单独获取某个属性对象，例如：获取value属性&#13;
		//假设从配置文件中知晓属性名是value&#13;
//		Field field = clazz.getField("value");//得到公共的&#13;
		Field field = clazz.getDeclaredField("value");//得到已声明的&#13;
		System.out.println(field);&#13;
		//设置属性值，获取属性值&#13;
		//先有对象，才能有属性值&#13;
		&#13;
//		获取"hello"对象的value属性值&#13;
		field.setAccessible(true);//设置可访问&#13;
		&#13;
		Object object = field.get(obj);&#13;
		char[] v = (char[]) object;&#13;
		System.out.println(Arrays.toString(v));&#13;
		v[0] = 'w';&#13;
		v[1] = 'o';&#13;
		v[2] = 'r';&#13;
		v[3] = 'l';&#13;
		v[4] = 'd';&#13;
		&#13;
		//参数一：哪个对象的field属性，第二个参数：设置为xx新值&#13;
//		field.set("hello", "world");//因为是final&#13;
		&#13;
		System.out.println(obj);&#13;
		&#13;
		//7、创建对象    创建Class对应的类型的对象&#13;
//		Object obj = clazz.newInstance();&#13;
//		System.out.println(obj);&#13;
		&#13;
		//8、构造器&#13;
//		clazz.getConstructors()//获取所有公共的构造器&#13;
//		clazz.getDeclaredConstructors();//获取所有该类拥有的构造器&#13;
		&#13;
		/*&#13;
		 * 构造器的共同特点：修饰符   构造器名   形参列表      可以创建对象的操作&#13;
		 */&#13;
		&#13;
		/*&#13;
		 * 构造器可以重载，构造器的名称都一样&#13;
		 * 如何在类中唯一确定一个构造器：靠形参列表（个数和类型）&#13;
		 */&#13;
//		 Constructor c = clazz.getDeclaredConstructor();//获取无参构造&#13;
//		 Object newInstance = c.newInstance();//用无参构造创建对象&#13;
//		 System.out.println("对象："+newInstance);&#13;
		 &#13;
		//public String(char value[])&#13;
		 Constructor c = clazz.getDeclaredConstructor(char[].class);//char[]数组类型&#13;
		 //用有参构造创建对象，需要实参列表&#13;
		 char[] params= {'c','h','a','i'};&#13;
		 Object newInstance = c.newInstance(params);&#13;
		System.out.println("对象："+newInstance);&#13;
		&#13;
		&#13;
		//9、方法&#13;
		/*&#13;
		 * 所有方法共同特点：&#13;
		 * 修饰符  返回值类型  方法名（形参列表）抛出的异常列表&#13;
		 * 方法可以被调用&#13;
		 */&#13;
//		clazz.getMethods()//获取所有公共的方法&#13;
//		clazz.getDeclaredMethods();//获取所有方法&#13;
		/*&#13;
		 * 方法可以重载，如何在一个类中，唯一确定方法：方法名+形参列表（个数和类型）&#13;
		 * &#13;
		 * toString()&#13;
		 */&#13;
		Method m = clazz.getDeclaredMethod("toString");//获取无参的方法&#13;
		System.out.println(m);&#13;
		&#13;
		//调用方法&#13;
		//参数一：那个实例对象调用m方法，参数二：传给m方法的实参列表&#13;
		Object returnValue = m.invoke(obj);&#13;
		System.out.println(returnValue);&#13;
		&#13;
		// public byte[] getBytes(Charset charset) &#13;
		Method m2 = clazz.getDeclaredMethod("getBytes", Charset.class);&#13;
		Object returnValue2 = m2.invoke(obj, Charset.forName("GBK"));&#13;
		System.out.println(returnValue2);&#13;
		byte[] data = (byte[]) returnValue2;&#13;
		System.out.println(Arrays.toString(data));&#13;
	}&#13;
&#13;
}&#13;
</plain></notes></topic></topics></children></topic><topic id="6rshg0ehu82f2sj7o57tk0fpo6" modified-by="" timestamp="1513069540434"><title>如何获取类上的泛型</title><children><topics type="attached"><topic id="6sf3bd3dcud0us8gaan0quuvtl" modified-by="" timestamp="1513042200507"><title>步骤</title><children><topics type="attached"><topic id="49023vmkfpmsrepo95odouum69" modified-by="" timestamp="1513042087731"><title>（1）先得到类的Class对象</title></topic><topic id="6u6c4pha22d844aig330kj4jgp" modified-by="" timestamp="1513042126194"><title>（2）获取它的父类</title><children><topics type="attached"><topic id="0ok14a57d967jiaea7gpriekud" modified-by="" timestamp="1513042131541"><title>Type  getGenericSuperClass() 可以带泛型</title></topic></topics></children></topic><topic id="37pvjcd0bd6hbsrnspf64sdi45" modified-by="" timestamp="1513042174979"><title>（3）类型转换</title><children><topics type="attached"><topic id="0lda0ssukj2u6uv88b6u6uoke7" modified-by="" timestamp="1513042172410"><title>如果是父类是这样的类型    父类名&lt;泛型实参&gt;</title></topic><topic id="0p3bp0c6tk97p4unc45v768c5s" modified-by="" timestamp="1513042198444"><title svg:width="500">ParameterizedType  p = (ParameterizedType )type;</title></topic></topics></children></topic><topic id="1p1vr8ahteuflspnufslmvsgsk" modified-by="" timestamp="1513042208408"><title>（4）获取泛型实参</title><children><topics type="attached"><topic id="5dsl0ba1hjdh8pvq70th7isp8t" modified-by="" timestamp="1513042223738"><title>Type[] getActualTypeArguments()  </title></topic></topics></children></topic></topics></children></topic><topic id="02qe28775q6uvu8ubcfdc5osu5" modified-by="" timestamp="1513069597925"><title>示例代码</title><notes><html><xhtml:p>package com.atguigu.reflect;</xhtml:p><xhtml:p/><xhtml:p>import java.lang.reflect.ParameterizedType;</xhtml:p><xhtml:p>import java.lang.reflect.Type;</xhtml:p><xhtml:p>import java.util.Date;</xhtml:p><xhtml:p/><xhtml:p>public class TestGenericType {</xhtml:p><xhtml:p/><xhtml:p>	public static void main(String[] args) {</xhtml:p><xhtml:p>		GenericSub g = new GenericSub();</xhtml:p><xhtml:p>		System.out.println(g.getType1());</xhtml:p><xhtml:p>		System.out.println(g.getType2());</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		GenericSub2 g2 = new GenericSub2();</xhtml:p><xhtml:p>		System.out.println(g2.getType1());</xhtml:p><xhtml:p>		System.out.println(g2.getType2());</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p/><xhtml:p>}</xhtml:p><xhtml:p>//T叫做类型形参</xhtml:p><xhtml:p>abstract class GenericSuper&lt;T,U&gt;{</xhtml:p><xhtml:p>	private Class&lt;T&gt; type1;</xhtml:p><xhtml:p>	private Class&lt;U&gt; type2;</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>	public GenericSuper(){</xhtml:p><xhtml:p>		Class clazz = this.getClass();//this是当前对象，在构造器中，就是代表那个正在创建的对象</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//Type是包含Class等的所有类型</xhtml:p><xhtml:p>		Type gs = clazz.getGenericSuperclass();</xhtml:p><xhtml:p>		//GenericSuper&lt;String&gt;：参数化的类型</xhtml:p><xhtml:p>		ParameterizedType p  = (ParameterizedType) gs;</xhtml:p><xhtml:p>		//获取类型实参</xhtml:p><xhtml:p>		Type[] arr = p.getActualTypeArguments();</xhtml:p><xhtml:p>				</xhtml:p><xhtml:p>		type1 = (Class&lt;T&gt;) arr[0];</xhtml:p><xhtml:p>		type2 = (Class&lt;U&gt;) arr[1];</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p/><xhtml:p>	public Class&lt;T&gt; getType1() {</xhtml:p><xhtml:p>		return type1;</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>	public Class&lt;U&gt; getType2() {</xhtml:p><xhtml:p>		return type2;</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p/><xhtml:p>}</xhtml:p><xhtml:p>//String是类型实参</xhtml:p><xhtml:p>class GenericSub extends GenericSuper&lt;String,Integer&gt;{</xhtml:p><xhtml:p/><xhtml:p>}</xhtml:p><xhtml:p/><xhtml:p>class GenericSub2 extends GenericSuper&lt;Date,Double&gt;{</xhtml:p><xhtml:p/><xhtml:p>}</xhtml:p></html><plain>package com.atguigu.reflect;&#13;
&#13;
import java.lang.reflect.ParameterizedType;&#13;
import java.lang.reflect.Type;&#13;
import java.util.Date;&#13;
&#13;
public class TestGenericType {&#13;
&#13;
	public static void main(String[] args) {&#13;
		GenericSub g = new GenericSub();&#13;
		System.out.println(g.getType1());&#13;
		System.out.println(g.getType2());&#13;
		&#13;
		GenericSub2 g2 = new GenericSub2();&#13;
		System.out.println(g2.getType1());&#13;
		System.out.println(g2.getType2());&#13;
	}&#13;
&#13;
}&#13;
//T叫做类型形参&#13;
abstract class GenericSuper&lt;T,U&gt;{&#13;
	private Class&lt;T&gt; type1;&#13;
	private Class&lt;U&gt; type2;&#13;
	&#13;
	public GenericSuper(){&#13;
		Class clazz = this.getClass();//this是当前对象，在构造器中，就是代表那个正在创建的对象&#13;
		&#13;
		//Type是包含Class等的所有类型&#13;
		Type gs = clazz.getGenericSuperclass();&#13;
		//GenericSuper&lt;String&gt;：参数化的类型&#13;
		ParameterizedType p  = (ParameterizedType) gs;&#13;
		//获取类型实参&#13;
		Type[] arr = p.getActualTypeArguments();&#13;
				&#13;
		type1 = (Class&lt;T&gt;) arr[0];&#13;
		type2 = (Class&lt;U&gt;) arr[1];&#13;
	}&#13;
&#13;
	public Class&lt;T&gt; getType1() {&#13;
		return type1;&#13;
	}&#13;
	public Class&lt;U&gt; getType2() {&#13;
		return type2;&#13;
	}&#13;
&#13;
}&#13;
//String是类型实参&#13;
class GenericSub extends GenericSuper&lt;String,Integer&gt;{&#13;
&#13;
}&#13;
&#13;
class GenericSub2 extends GenericSuper&lt;Date,Double&gt;{&#13;
&#13;
}</plain></notes></topic><topic id="10ht6s28p2b3fk40bfqs5sst1d" modified-by="" timestamp="1513069565766"><title>核心代码</title><notes><html><xhtml:p>		Class clazz = GenericSub.class;</xhtml:p><xhtml:p>//		Class sup = clazz.getSuperclass();//得不到泛型的信息</xhtml:p><xhtml:p>//		System.out.println(sup);</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//Type是包含Class等的所有类型</xhtml:p><xhtml:p>		Type gs = clazz.getGenericSuperclass();</xhtml:p><xhtml:p>		//GenericSuper&lt;String&gt;：参数化的类型</xhtml:p><xhtml:p>		ParameterizedType p  = (ParameterizedType) gs;</xhtml:p><xhtml:p>		//获取类型实参</xhtml:p><xhtml:p>		Type[] arr = p.getActualTypeArguments();</xhtml:p><xhtml:p>		System.out.println(arr[0]);</xhtml:p><xhtml:p>		System.out.println(arr[1]);</xhtml:p></html><plain>		Class clazz = GenericSub.class;&#13;
//		Class sup = clazz.getSuperclass();//得不到泛型的信息&#13;
//		System.out.println(sup);&#13;
		&#13;
		//Type是包含Class等的所有类型&#13;
		Type gs = clazz.getGenericSuperclass();&#13;
		//GenericSuper&lt;String&gt;：参数化的类型&#13;
		ParameterizedType p  = (ParameterizedType) gs;&#13;
		//获取类型实参&#13;
		Type[] arr = p.getActualTypeArguments();&#13;
		System.out.println(arr[0]);&#13;
		System.out.println(arr[1]);</plain></notes></topic></topics></children></topic><topic id="217nb63lpmda0lkfha7fc4vnjs" modified-by="" timestamp="1513069510490"><title>获取注解</title><children><topics type="attached"><topic id="2g427s5a8mo4bmc1sfhd2mvtag" modified-by="" timestamp="1513069497014"><title>获取类上的注解</title><children><topics type="attached"><topic id="4nsksd5tbe4465r9t2l4lsffli" modified-by="" timestamp="1513042286670"><title>步骤</title><children><topics type="attached"><topic id="65pqiupmsuuk412fravjop3mfo" modified-by="" timestamp="1513042272296"><title>（1）先得到类的Class对象</title></topic><topic id="3gbufgc2h3lenu5ohn4f4has5s" modified-by="" timestamp="1513042282272"><title>（2）</title><children><topics type="attached"><topic id="04ud19gcgcvlkt478nuedi2cc5" modified-by="" timestamp="1513042301443"><title>获取指定的注解</title><children><topics type="attached"><topic id="1sf9543gkn3gpufsfvfu8covn0" modified-by="" timestamp="1513041276776"><title svg:width="500">&lt;A extends Annotation&gt;  A   getAnnotation(Class&lt;A&gt; annotationClass) </title></topic><topic id="3rs0f04mv8tlkohklfaqbcj61s" modified-by="" timestamp="1513042316638"><title>可以获取到的注解，必须声明周期是RUNTIME</title></topic></topics></children><marker-refs><marker-ref marker-id="star-red"/></marker-refs></topic></topics></children></topic><topic id="5j7rcghvgiac4rkei3lv8modh9" modified-by="" timestamp="1513042296298"><title>（3）获取注解的配置参数的值</title></topic></topics></children></topic><topic id="44rni979jppm1goe3u2amflcbu" modified-by="" timestamp="1513069507368"><title>示例代码</title><notes><html><xhtml:p>package com.atguigu.reflect;</xhtml:p><xhtml:p/><xhtml:p>import java.lang.annotation.Retention;</xhtml:p><xhtml:p>import java.lang.annotation.RetentionPolicy;</xhtml:p><xhtml:p/><xhtml:p>import org.junit.Test;</xhtml:p><xhtml:p/><xhtml:p>@MyAnnoation</xhtml:p><xhtml:p>public class TestAnnotatio {</xhtml:p><xhtml:p/><xhtml:p>	@MyAnnoation(value = "尚硅谷")</xhtml:p><xhtml:p>	private String info;</xhtml:p><xhtml:p/><xhtml:p>	//获取类上的注解信息</xhtml:p><xhtml:p>	@Test</xhtml:p><xhtml:p>	public void test() {</xhtml:p><xhtml:p>		// 1、先得到Class对象</xhtml:p><xhtml:p>		Class clazz = TestAnnotatio.class;</xhtml:p><xhtml:p/><xhtml:p>		// 2、获取类上的注解信息：得到MyAnnoation注解对象</xhtml:p><xhtml:p>		MyAnnoation m = (MyAnnoation) clazz.getAnnotation(MyAnnoation.class);</xhtml:p><xhtml:p/><xhtml:p>		// 3、得到注解的配置参数的值</xhtml:p><xhtml:p>		String value = m.value();</xhtml:p><xhtml:p>		System.out.println(value);</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p/><xhtml:p>@Retention(RetentionPolicy.RUNTIME) // 为了在反射阶段可以读取到该注解的信息，生命周期一定要在RUNTIME</xhtml:p><xhtml:p>@interface MyAnnoation {</xhtml:p><xhtml:p>	String value() default "atguigu";</xhtml:p><xhtml:p>}</xhtml:p></html><plain>package com.atguigu.reflect;&#13;
&#13;
import java.lang.annotation.Retention;&#13;
import java.lang.annotation.RetentionPolicy;&#13;
&#13;
import org.junit.Test;&#13;
&#13;
@MyAnnoation&#13;
public class TestAnnotatio {&#13;
&#13;
	@MyAnnoation(value = "尚硅谷")&#13;
	private String info;&#13;
&#13;
	//获取类上的注解信息&#13;
	@Test&#13;
	public void test() {&#13;
		// 1、先得到Class对象&#13;
		Class clazz = TestAnnotatio.class;&#13;
&#13;
		// 2、获取类上的注解信息：得到MyAnnoation注解对象&#13;
		MyAnnoation m = (MyAnnoation) clazz.getAnnotation(MyAnnoation.class);&#13;
&#13;
		// 3、得到注解的配置参数的值&#13;
		String value = m.value();&#13;
		System.out.println(value);&#13;
	}&#13;
}&#13;
&#13;
@Retention(RetentionPolicy.RUNTIME) // 为了在反射阶段可以读取到该注解的信息，生命周期一定要在RUNTIME&#13;
@interface MyAnnoation {&#13;
	String value() default "atguigu";&#13;
}</plain></notes></topic></topics></children></topic><topic id="32qit3u7bb5bmna6gq5b22kn81" modified-by="" timestamp="1513069510508"><title>获取属性上的注解</title><children><topics type="attached"><topic id="1h12v8d4e3t9sacforgonhqqn8" modified-by="" timestamp="1513042348838"><title>步骤</title><children><topics type="attached"><topic id="4oshv9n0k2kvdfoc6iskirastc" modified-by="" timestamp="1513042272296"><title>（1）先得到类的Class对象</title></topic><topic id="7kbejp1euuvasro4us46tak5d7" modified-by="" timestamp="1513042348820"><title>（2）获取属性对象</title></topic><topic id="6uvdh8oemq38i8rlerqfealrsf" modified-by="" timestamp="1513042353126"><title>（3）</title><children><topics type="attached"><topic id="6gfneim0utaa7nujlav0df7gbf" modified-by="" timestamp="1513042301443"><title>获取指定的注解</title><children><topics type="attached"><topic id="1evsdavjptq99db6k3t3ndlolh" modified-by="" timestamp="1513041276776"><title svg:width="500">&lt;A extends Annotation&gt;  A   getAnnotation(Class&lt;A&gt; annotationClass) </title></topic><topic id="4flpo5mhtdjrev0c5fofhvopbe" modified-by="" timestamp="1513042316638"><title>可以获取到的注解，必须声明周期是RUNTIME</title></topic></topics></children><marker-refs><marker-ref marker-id="star-red"/></marker-refs></topic></topics></children></topic><topic id="41ee7m48rk5tq5gb15ghptbnge" modified-by="" timestamp="1513042357060"><title>（4）获取注解的配置参数的值</title></topic></topics></children></topic><topic id="15e7enpk9ldpvisupk4vkokd3f" modified-by="" timestamp="1513069531410"><title>示例代码</title><notes><html><xhtml:p>package com.atguigu.reflect;</xhtml:p><xhtml:p/><xhtml:p>import java.lang.annotation.Retention;</xhtml:p><xhtml:p>import java.lang.annotation.RetentionPolicy;</xhtml:p><xhtml:p>import java.lang.reflect.Field;</xhtml:p><xhtml:p/><xhtml:p>import org.junit.Test;</xhtml:p><xhtml:p/><xhtml:p>public class TestAnnotatio {</xhtml:p><xhtml:p/><xhtml:p>	@MyAnnoation(value = "尚硅谷")</xhtml:p><xhtml:p>	private String info;</xhtml:p><xhtml:p/><xhtml:p>	//获取属性上的注解信息</xhtml:p><xhtml:p>	@Test</xhtml:p><xhtml:p>	public void test2() throws Exception {</xhtml:p><xhtml:p>		// 1、获取Class对象</xhtml:p><xhtml:p>		Class clazz = TestAnnotatio.class;</xhtml:p><xhtml:p/><xhtml:p>		// 2、先获取属性对象</xhtml:p><xhtml:p>		Field field = clazz.getDeclaredField("info");</xhtml:p><xhtml:p/><xhtml:p>		// 3、得到注解对象</xhtml:p><xhtml:p>		MyAnnoation m = (MyAnnoation) field.getAnnotation(MyAnnoation.class);</xhtml:p><xhtml:p/><xhtml:p>		// 4、得到属性值</xhtml:p><xhtml:p>		System.out.println(m.value());</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p/><xhtml:p>@Retention(RetentionPolicy.RUNTIME) // 为了在反射阶段可以读取到该注解的信息，生命周期一定要在RUNTIME</xhtml:p><xhtml:p>@interface MyAnnoation {</xhtml:p><xhtml:p>	String value() default "atguigu";</xhtml:p><xhtml:p>}</xhtml:p></html><plain>package com.atguigu.reflect;&#13;
&#13;
import java.lang.annotation.Retention;&#13;
import java.lang.annotation.RetentionPolicy;&#13;
import java.lang.reflect.Field;&#13;
&#13;
import org.junit.Test;&#13;
&#13;
public class TestAnnotatio {&#13;
&#13;
	@MyAnnoation(value = "尚硅谷")&#13;
	private String info;&#13;
&#13;
	//获取属性上的注解信息&#13;
	@Test&#13;
	public void test2() throws Exception {&#13;
		// 1、获取Class对象&#13;
		Class clazz = TestAnnotatio.class;&#13;
&#13;
		// 2、先获取属性对象&#13;
		Field field = clazz.getDeclaredField("info");&#13;
&#13;
		// 3、得到注解对象&#13;
		MyAnnoation m = (MyAnnoation) field.getAnnotation(MyAnnoation.class);&#13;
&#13;
		// 4、得到属性值&#13;
		System.out.println(m.value());&#13;
	}&#13;
}&#13;
&#13;
@Retention(RetentionPolicy.RUNTIME) // 为了在反射阶段可以读取到该注解的信息，生命周期一定要在RUNTIME&#13;
@interface MyAnnoation {&#13;
	String value() default "atguigu";&#13;
}</plain></notes></topic></topics></children></topic></topics></children></topic><topic id="6d1v0i6j0rrv1tcpd9r9tniab7" modified-by="" timestamp="1513042864009"><title>类加载器</title><children><topics type="attached"><topic id="56lhe11cjgq7e43ntabmqeop0r" modified-by="" timestamp="1513042430247"><title>类加载的过程（了解）</title><children><topics type="attached"><topic id="14hr2h7sng1u7ajgegebc7tqge" modified-by="" timestamp="1513042900434"><title>双亲委托模式/机制</title><children><topics type="attached"><topic id="1mtnhimg84utv8qio965mmdel5" modified-by="" timestamp="1513042589433"><title svg:width="500">某个类加载器接到加载任务，先把加载任务交给“父”加载器，层层往上，一直到引导类加载器，如果“父”加载器可以加载，那么就由“父”加载器加载，如果不可以，传回它的“子”加载器，“子”加载器尝试加载，如果可以，那么就加载，如果不可以，再往回传，一到回到最初接到任务的那个加载器，如果它可以，也正常加载，如果它也不能加载，报异常：ClassNotFoundException</title></topic><topic id="5gftpotl2nkpr26020q1husio1" modified-by="" timestamp="1513042906951"><title>作用：安全</title></topic></topics></children></topic></topics></children></topic><topic id="7fuo8rdpmaq5ffmcr1t8p2vpug" modified-by="" timestamp="1513042831926"><title>类加载器的体系结构</title><children><topics type="attached"><topic id="39ohr52kk1fgv12fs2qp88t6e1" modified-by="" timestamp="1513042669427"><title>1、引导类加载器BootStrap</title><children><topics type="attached"><topic id="75dgv40ssho13c05n8837sa06t" modified-by="" timestamp="1513042640034"><title>非Java语言实现的</title><children><topics type="attached"><topic id="1niov8aif59s2t6qs3ih5km898" modified-by="" timestamp="1513042650167"><title>获取不到它的对象，只能得到null</title></topic></topics></children></topic><topic id="304ukjle2ehb52v8rv6fjaamjj" modified-by="" timestamp="1513042664085"><title>加载核心类库rt.jar</title></topic><topic id="3s05ip980oi64lp4qvha0bf63t" modified-by="" timestamp="1513042711505"><title>加载sun.boot.class.path路径下的内容</title></topic></topics></children></topic><topic id="6usavbeaglr8rk85natkiubcql" modified-by="" timestamp="1513042776598"><title>2、扩展类加载器ExtClassLoader</title><children><topics type="attached"><topic id="3pr2h7gpdtmgt3ist79f3t5hj0" modified-by="" timestamp="1513042766336"><title>加载jre/ext目录</title></topic><topic id="41s6o3841m956jpp9sg4macts5" modified-by="" timestamp="1513042780704"><title>java.ext.dirs路径下的内容</title></topic></topics></children></topic><topic id="2hl62m9eadob4nng83q0kgb7h9" modified-by="" timestamp="1513042812797"><title svg:width="500">3、应用程序类加载器，系统类加载器AppClassLoader</title><children><topics type="attached"><topic id="4ffet2q1m8q08hm0gejg8473k0" modified-by="" timestamp="1513042807067"><title>加载用户自定义的类型</title></topic><topic id="4dqqms4kkaosr3ged2o1j73pav" modified-by="" timestamp="1513042826938"><title>加载src目录下的内容（bin）</title></topic></topics></children></topic><topic id="7i7tcd4urtek6iic2lpjckeed6" modified-by="" timestamp="1513042853434"><title>4、自定义类加载器</title></topic></topics></children></topic><topic id="5okg9b0cub4v970q3jks23r14c" modified-by="" timestamp="1513042877867"><title>类加载的作用</title><children><topics type="attached"><topic id="24f4v8m39j94bogpap8nncd0b5" modified-by="" timestamp="1513042877287"><title>（1）加载类</title></topic><topic id="4k8uv9phau2bkk0jgii40k456m" modified-by="" timestamp="1513069629725"><title>（2）加载资源文件</title><notes><html><xhtml:p>	@Test</xhtml:p><xhtml:p>	public void test8()throws Exception{</xhtml:p><xhtml:p>		Properties pro = new Properties();</xhtml:p><xhtml:p>		//JavaSE和Web项目</xhtml:p><xhtml:p>		//在web项目中，因为项目部署到tomcat中运行，又因为tomcat用自己的类加载器的</xhtml:p><xhtml:p>		//把配置文件放在了src中，最终代码在WEB-INFO的classes目录</xhtml:p><xhtml:p>		//可以用类加载器加载这个配置文件，但是不是系统类加载器</xhtml:p><xhtml:p>		//this.getClass().getClassLoader()目的是得到tomcat的自定义类加载器对象</xhtml:p><xhtml:p>		pro.load(this.getClass().getClassLoader().getResourceAsStream("3.properties"));</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>		System.out.println(pro.getProperty("user3"));</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>	@Test</xhtml:p><xhtml:p>	public void test7()throws Exception{</xhtml:p><xhtml:p>		Properties pro = new Properties();</xhtml:p><xhtml:p>		//JavaSE和Web都可以</xhtml:p><xhtml:p>		//把配置文件放在了项目根目录下，在src外面</xhtml:p><xhtml:p>		//不可以用类加载器加载这个配置文件</xhtml:p><xhtml:p>		//可以使用FileInputStream获取</xhtml:p><xhtml:p>		pro.load(new FileInputStream("2.properties"));</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>		System.out.println(pro.getProperty("user2"));</xhtml:p><xhtml:p>	}</xhtml:p></html><plain>	@Test&#13;
	public void test8()throws Exception{&#13;
		Properties pro = new Properties();&#13;
		//JavaSE和Web项目&#13;
		//在web项目中，因为项目部署到tomcat中运行，又因为tomcat用自己的类加载器的&#13;
		//把配置文件放在了src中，最终代码在WEB-INFO的classes目录&#13;
		//可以用类加载器加载这个配置文件，但是不是系统类加载器&#13;
		//this.getClass().getClassLoader()目的是得到tomcat的自定义类加载器对象&#13;
		pro.load(this.getClass().getClassLoader().getResourceAsStream("3.properties"));&#13;
	&#13;
		System.out.println(pro.getProperty("user3"));&#13;
	}&#13;
	&#13;
	@Test&#13;
	public void test7()throws Exception{&#13;
		Properties pro = new Properties();&#13;
		//JavaSE和Web都可以&#13;
		//把配置文件放在了项目根目录下，在src外面&#13;
		//不可以用类加载器加载这个配置文件&#13;
		//可以使用FileInputStream获取&#13;
		pro.load(new FileInputStream("2.properties"));&#13;
	&#13;
		System.out.println(pro.getProperty("user2"));&#13;
	}</plain></notes></topic></topics></children></topic></topics></children></topic></topics></children></topic><title>反射</title></sheet></xmap-revision-content>