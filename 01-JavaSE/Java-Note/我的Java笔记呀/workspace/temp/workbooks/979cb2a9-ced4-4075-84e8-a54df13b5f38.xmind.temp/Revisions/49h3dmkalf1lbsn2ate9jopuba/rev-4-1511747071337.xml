<?xml version="1.0" encoding="UTF-8" standalone="no"?><xmap-revision-content xmlns="urn:xmind:xmap:xmlns:revision:1.0" xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:svg="http://www.w3.org/2000/svg" xmlns:xhtml="http://www.w3.org/1999/xhtml" xmlns:xlink="http://www.w3.org/1999/xlink"><sheet id="49h3dmkalf1lbsn2ate9jopuba" modified-by="" style-id="487gi5ovjek2lvp9sjqneegdtc" theme="xminddefaultthemeid" timestamp="1511747024980"><topic id="17mrtu3l8chvr316vtlolrv07t" modified-by="" structure-class="org.xmind.ui.logic.right" timestamp="1511745875845"><title>面向对象高级特性</title><extensions><extension provider="org.xmind.ui.map.unbalanced"><content><right-number>-1</right-number></content></extension></extensions><children><topics type="attached"><topic id="1paeq8kqq69qcoreld5icu5r7e" modified-by="" timestamp="1511746221190"><title>抽象</title><children><topics type="attached"><topic id="26lq6ojq91drvctqd194cmlj19" modified-by="" timestamp="1511746062378"><title>为什么会有抽象类</title><children><topics type="attached"><topic id="3flq27ks2u6m029ei8m064pjf1" modified-by="" timestamp="1511746060709"><title svg:width="500">当子类中都有一个共同的方法，每一个子类都有不同的实现，在父类中又要体现所有子类的共同的特点，所以要体现有这个方法，但是在父类中又无法给出具体的实现，那么这个时候就需要把这个方法声明为抽象的，而包含抽象方法的类，必须是抽象类</title></topic><topic id="56fh3u1p97qapvi46m1dek242b" modified-by="" timestamp="1511746062367"><title svg:width="500">某个父类仅仅是表示一个抽象的概念，不希望它被实例化，这个时候父类中可能没有抽象方法，但是我们也把它声明为抽象类</title></topic></topics></children></topic><topic id="123ijf5ufk02e9tkmv621643i8" modified-by="" timestamp="1511746077195"><title>如何声明抽象类</title><children><topics type="attached"><topic id="4nte0l0akjtd9l457l1gdoi2q1" modified-by="" timestamp="1511746081151"><title>语法格式</title><children><topics type="attached"><topic id="78sclc0ffelqj69gv8luujj2bl" modified-by="" timestamp="1511746082334"><title>[public/缺省] abstract class 类名{&#13;
}</title></topic></topics></children></topic></topics></children></topic><topic id="2s6ln2a41ik1mi005guu7p765b" modified-by="" timestamp="1511746096316"><title>如何声明抽象方法</title><children><topics type="attached"><topic id="7tinf1bmpm2jn2micln2jve6tt" modified-by="" timestamp="1511746101722"><title>语法格式</title><children><topics type="attached"><topic id="2mumclp913nt2ejnmknedj5mep" modified-by="" timestamp="1511746171478"><title svg:width="500">[public/protected/缺省]  abstract   返回值类型   方法名([形参列表]);</title><children><topics type="attached"><topic id="3u5381ju238ve24u8h89c2n34p" modified-by="" timestamp="1511746185994"><title>抽象方法是不能private,static,final修饰的</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="0d1jfqfrqcsnua5k2kngt17uvc" modified-by="" timestamp="1511746211072"><title>抽象类的特点</title><children><topics type="attached"><topic id="7ci60vi3d439aabh6la3bh5apt" modified-by="" timestamp="1511746212456"><title svg:width="500">（1）抽象类不能实例化&#13;
（2）抽象类可以包含抽象方法，也可以没有抽象方法。&#13;
如果一个类有抽象方法，那么这个类必须是抽象类，&#13;
如果一个抽象类没有抽象方法，那么它的用意是不想实例化，用它仅仅表示一个抽象的概念。&#13;
（3）抽象类生来就是用来被继承的，那么子类在继承它的时候，必须重写（实现）抽象父类的抽象方法，&#13;
否则该子类也得是抽象类。&#13;
（4）抽象类的变量与子类的对象构成多态引用。&#13;
（5）抽象类除了不能实例化，可以包含抽象方法，其他的和非抽象类是一样的，&#13;
可以有成员变量（类变量、实例变量）、构造器、代码块（静态代码块和非静态代码块）&#13;
方法（静态方法、非静态方法）</title></topic></topics></children></topic><topic id="2ff3r3hk6t1gva75bht27r6p31" modified-by="" timestamp="1511746228241"><title>抽象类不能实例化，为什么要有构造器呢？</title><children><topics type="attached"><topic id="7hljroh7pr5a9an2qtk8iks6jd" modified-by="" timestamp="1511746233915"><title svg:width="500">子类在继承该类时，一定要调用它的构造器，为属性初始化。</title><children><topics type="attached"><topic id="3dp2qh9n1p52f49hpvfbkjous8" modified-by="" timestamp="1511746262782"><title>因为构造器的作用有两点</title><children><topics type="attached"><topic id="01ujrfombs96jta9iln15lunna" modified-by="" timestamp="1511746262111"><title>（1）和new一起创建对象</title></topic><topic id="4kssbig2sem414f7i5bmoc464c" modified-by="" timestamp="1511746274933"><title>（2）为属性初始化</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="689idmgjbepi4ep6e5c9ktn66i" modified-by="" timestamp="1511746994711"><title>接口</title><children><topics type="attached"><topic id="5ucmhu24dj50qkppneuq5g68o9" modified-by="" timestamp="1511746785541"><title>接口即代表行为标准，功能标准</title></topic><topic id="4da2cknbt8vhqhjhfp1g7q2t2u" modified-by="" timestamp="1511746986735"><title>如何声明一个接口？</title><children><topics type="attached"><topic id="4tgoe6vuqilq7bo70n04hmjt79" modified-by="" timestamp="1511746992062"><title>语法结构</title><children><topics type="attached"><topic id="5igv1qs304u3fcf2e8857m5hkq" modified-by="" timestamp="1511746993186"><title>[public/缺省] interface 接口名{&#13;
}</title></topic></topics></children></topic></topics></children></topic><topic id="12mht89p2484t7apl6pkckl5v4" modified-by="" timestamp="1511747006749"><title>如何实现接口？</title><children><topics type="attached"><topic id="4nrn13nokgabbgvkpg4adfullg" modified-by="" timestamp="1511747023551"><title>语法结构</title><children><topics type="attached"><topic id="0jk10oauuk4he90o7uip7875l3" modified-by="" timestamp="1511747024980"><title svg:width="500">[public/缺省] class 子类名 [extends 父类名] implements  接口名1，接口名2。。。{&#13;
	//要实现接口的所有抽象方法&#13;
}</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><title>面向对象高级特性</title></sheet></xmap-revision-content>