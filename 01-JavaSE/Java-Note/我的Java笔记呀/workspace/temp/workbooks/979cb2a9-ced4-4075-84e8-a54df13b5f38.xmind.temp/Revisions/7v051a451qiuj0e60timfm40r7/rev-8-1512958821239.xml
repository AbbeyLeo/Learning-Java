<?xml version="1.0" encoding="UTF-8" standalone="no"?><xmap-revision-content xmlns="urn:xmind:xmap:xmlns:revision:1.0" xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:svg="http://www.w3.org/2000/svg" xmlns:xhtml="http://www.w3.org/1999/xhtml" xmlns:xlink="http://www.w3.org/1999/xlink"><sheet id="7v051a451qiuj0e60timfm40r7" modified-by="" style-id="3482hp5csuf60d6r2su8h350er" theme="xminddefaultthemeid" timestamp="1512958805321"><topic id="0jh6ocu530vfag7v9k22itg740" modified-by="" structure-class="org.xmind.ui.logic.right" timestamp="1512957852242"><title>多线程</title><extensions><extension provider="org.xmind.ui.map.unbalanced"><content><right-number>-1</right-number></content></extension></extensions><children><topics type="attached"><topic id="1okhv2frtj48nhs8ijekrrm75q" modified-by="" timestamp="1512955578936"><title>概念</title><children><topics type="attached"><topic id="5svjjfbh9ff9djm8via0g7lfi5" modified-by="" timestamp="1512955584232"><title>程序</title><children><topics type="attached"><topic id="36crg0glo54cn0c5ofhnl2ukj9" modified-by="" timestamp="1512955630830"><title svg:width="500">为了完成某个任务或功能，选择某个编程语言而编写的一组代码指令的集合</title></topic></topics></children></topic><topic id="7q8udblrrvek36gem3gjko52jc" modified-by="" timestamp="1512955714723"><title>进程</title><children><topics type="attached"><topic id="33qebe12rgd3qje9qupo0fn5j4" modified-by="" timestamp="1512955768184"><title svg:width="500">程序的一次运行，是操作系统管理和调度的最小单位，每一个进程之间内存是相互独立的，如果进程之间要通信比较麻烦，可以通过文件，或网络通信方式等</title></topic></topics></children></topic><topic id="59qjikkeq268lp9q24haridn4u" modified-by="" timestamp="1512955772367"><title>线程</title><children><topics type="attached"><topic id="7442ufh5ebfhbvj2ccr718kui3" modified-by="" timestamp="1512955822823"><title svg:width="500">是进程中的其中一条执行路径，是CPU调度任务的最小单位</title><children><topics type="attached"><topic id="40fcbraruitd0sll9hs4fvfi9h" modified-by="" timestamp="1512955834503"><title>线程是共享同一个进程的内存</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="060rclpn1qprqe0si8evo4m1tk" modified-by="" timestamp="1512958805321"><title>如何开启主线程以外的线程</title><children><topics type="attached"><topic id="0tcf3ehm1s0tp68rmdn7uqu780" modified-by="" timestamp="1512955889831"><title>方式一：继承java.lang.Thread类</title><children><topics type="attached"><topic id="25qhnkej0c6keko9uo9lofdhlt" modified-by="" timestamp="1512955892648"><title>步骤</title><children><topics type="attached"><topic id="2te1tbffj3tbcbcblpp4a7fggh" modified-by="" timestamp="1512955894097"><title>①继承Thread类&#13;
②重写public void run(){}&#13;
	编写线程体，即该线程需要完成的任务代码&#13;
③创建线程对象&#13;
④启动线程：线程对象.start();</title></topic></topics></children></topic></topics></children></topic><topic id="63cfk8m8rk1vs30dl9vh6t5cic" modified-by="" timestamp="1512955910981"><title>方式二：实现java.lang.Runnable接口</title><children><topics type="attached"><topic id="5a6eud203tqa7un71ilq0acmb8" modified-by="" timestamp="1512955919995"><title>步骤</title><children><topics type="attached"><topic id="1onrjkr6qtorikgtcmc94dtbo3" modified-by="" timestamp="1512955921415"><title>①实现java.lang.Runnable接口&#13;
②实现public void run(){}&#13;
	编写线程体，即该线程需要完成的任务代码&#13;
③创建线程对象&#13;
④启动线程：借助Thread类的对象&#13;
		new Thread(自定义线程对象).start();</title></topic></topics></children></topic></topics></children></topic><topic id="7jv34hi0951po58jg02vr8fsd5" modified-by="" timestamp="1512955950989"><title>经典面试题</title><children><topics type="attached"><topic id="73u17ng0ge6mh3eb29dm0gnmva" modified-by="" timestamp="1512955955145"><title>两种方式的区别</title><children><topics type="attached"><topic id="2obqh6kj35h8j1kl5dqjjpn9dp" modified-by="" timestamp="1512955956721"><title svg:width="500">区别：&#13;
（1）继承Thread类会有单继承的限制&#13;
	实现Runnable接口不会有单继承的限制&#13;
（2）继承Thread类的方式，共享数据方面比较麻烦，使用static方式	&#13;
	实现Runnable接口，共享数据时，只需要共用同一个的Runnable接口的实现类的对象即可&#13;
（3）继承Thread类的方式，同步的锁的选择要么选择一个static对象作为锁，要么选择“类名.class即当前类Class对象”	&#13;
	实现Runnable接口，同步锁可以直接选择this对象</title></topic></topics></children></topic></topics></children></topic></topics></children><marker-refs><marker-ref marker-id="flag-red"/></marker-refs></topic><topic id="2sp58k5023n8hoqqja5801sld6" modified-by="" timestamp="1512958798644"><title>线程安全问题</title><children><topics type="attached"><topic id="13mvqtnf41a60ev42n7i34t6fv" modified-by="" timestamp="1512956017288"><title>前提条件</title><children><topics type="attached"><topic id="3d5a9csc1sftb7rtgakr1hhhmv" modified-by="" timestamp="1512956018795"><title>（1）有多个线程&#13;
（2）共享数据&#13;
（3）多条语句操作共享数据</title></topic></topics></children></topic><topic id="1f8olcjsb9qeo8lteo76628rg8" modified-by="" timestamp="1512956032721"><title>解决方法</title><children><topics type="attached"><topic id="3huo3m83culpogugah95msugt4" modified-by="" timestamp="1512957235914"><title>同步synchronized</title><children><topics type="attached"><topic id="55bjdboj5cofv44s37dhp98nrf" modified-by="" timestamp="1512956844519"><title>形式</title><children><topics type="attached"><topic id="1oiabjr573kmmddrl6701itcng" modified-by="" timestamp="1512956841016"><title>同步代码块</title><children><topics type="attached"><topic id="3o8k474l998gqq53442g45t0d9" modified-by="" timestamp="1512956842385"><title>synchronized(锁对象){&#13;
	同步代码，即需要加锁的代码&#13;
}</title></topic></topics></children></topic><topic id="57h5d425rdce9j2khsnas475hl" modified-by="" timestamp="1512956856775"><title>同步方法</title><children><topics type="attached"><topic id="32vgroct6ob167n79ujrjmbt74" modified-by="" timestamp="1512956858081"><title svg:width="500">synchronized [修饰符] 返回值类型 方法名(形参列表)抛出的异常列表</title></topic></topics></children></topic></topics></children></topic><topic id="6v8qdbsj5pu2msm39uqqig45g3" modified-by="" timestamp="1512957181411"><title>同步锁</title><children><topics type="attached"><topic id="5oebf0r2dctchd3mh2reqoqkaa" modified-by="" timestamp="1512957182730"><title svg:width="500">（1）任意类型的对象&#13;
（2）保证使用共享数据的多个线程，共用同一个锁对象</title></topic></topics></children></topic><topic id="1kr8lf55m9223eujfstuclheam" modified-by="" timestamp="1512957208502"><title>锁的范围</title><children><topics type="attached"><topic id="5gocr24c989dn4lk0rm2nu61od" modified-by="" timestamp="1512957213539"><title>同步代码块：范围&#13;
（1）不能太大：机会不均匀&#13;
（2）不能太小：安全问题没解决&#13;
（3）最好锁一次任务代码</title></topic></topics></children></topic><topic id="287e7nctt56dvjd41v8mnm62bh" modified-by="" timestamp="1512957235939"><title>同步方法的锁：</title><children><topics type="attached"><topic id="6k7a1ites6o5ej2o2d74i65lt6" modified-by="" timestamp="1512957235914"><title svg:width="500">静态方法的锁：当前类的Class对象，即当前类名.class&#13;
非静态方法的锁：当前对象，this</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children><marker-refs><marker-ref marker-id="flag-red"/></marker-refs></topic><topic id="39f27dqu35vpuaklrgmkrhajnf" modified-by="" timestamp="1512957442521"><title>线程通信</title><children><topics type="attached"><topic id="6gpcso1hbnqba1eqi14v07kgfd" modified-by="" timestamp="1512957265587"><title>问题：生产者消费者问题</title><children><topics type="attached"><topic id="1m6t9b5ab892tf67kpphb0sgl9" modified-by="" timestamp="1512957287114"><title>问题</title><children><topics type="attached"><topic id="5v2h2bvgke37jhgu0nhc11fv75" modified-by="" timestamp="1512957288944"><title>现象描述</title><children><topics type="attached"><topic id="535cdsmpggkl69vk8s3ha74cs6" modified-by="" timestamp="1512957356455"><title svg:width="500">有多个线程共享一个缓冲区（例如：数据仓库，文件等），有的线程往里放数据，有的线程往外取数据</title><children><topics type="attached"><topic id="59n60fjf29aak75c5r8st8kq6t" modified-by="" timestamp="1512957382482"><title>问题有两个</title><children><topics type="attached"><topic id="4t01h8o1unlicb92lj2acpei6n" modified-by="" timestamp="1512957397147"><title>问题：线程安全问题</title><children><topics type="attached"><topic id="5p4bhimgjd00pdn93838ucflsn" modified-by="" timestamp="1512957381489"><title>因为有共享数据</title></topic><topic id="7ute2oqsh8d3ldgibgos99gf8l" modified-by="" timestamp="1512957403125"><title>如何解决：同步</title></topic></topics></children></topic><topic id="71pgte2bsdmvkdvhgi0h63gmv0" modified-by="" timestamp="1512957406427"><title>问题：缓冲区大小有限的</title><children><topics type="attached"><topic id="2rtulrpvcdqai9ghas1tn3e75k" modified-by="" timestamp="1512957416912"><title>如何解决：线程通信</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="0ncn4p7i0hb5sb1b47qjhqkcl6" modified-by="" timestamp="1512957522587"><title>线程通信的方法</title><children><topics type="attached"><topic id="6gunik3hgcs3sj2rlbkfm79fvs" modified-by="" timestamp="1512957455146"><title>（1）wait()&#13;
（2）notify()和notifyAll()</title><children><topics type="attached"><topic id="3al13o3ti6ekd4k04jr7h9mrjd" modified-by="" timestamp="1512957463723"><title>在java.lang.Object</title><children><topics type="attached"><topic id="4ukl213hadbfp6g4c64hfdlrn5" modified-by="" timestamp="1512957498555"><title>为什么？</title><children><topics type="attached"><topic id="02f8v5cs7hc87856pad0qnpvuo" modified-by="" timestamp="1512957495815"><title svg:width="500">线程通信依赖于锁对象，即wait()和notify()是由锁对象调用</title></topic><topic id="0lthmtis10fj82h048f7epgie2" modified-by="" timestamp="1512957514996"><title svg:width="500">锁对象可能是任意类型的对象，那么这些方法只能在Object类中声明</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="54h3bgo4k64usnu1aj04eedapt" modified-by="" timestamp="1512957683060"><title>面试题：wait()和sleep()的异同？</title><children><topics type="attached"><topic id="3f279amhvu99vol7uu400o4p4p" modified-by="" timestamp="1512957579300"><title>同</title><children><topics type="attached"><topic id="0cm8p4fe7in3oal2ejpscehe1e" modified-by="" timestamp="1512957593188"><title svg:width="500">这两个方法都会导致当前线程从运行状态到阻塞状态</title></topic></topics></children></topic><topic id="0c3s6gu7fl4th6ft5h3bc8a2va" modified-by="" timestamp="1512957726228"><title>不同</title><children><topics type="attached"><topic id="2r0cq9ljpab69n1iq4a1ga4ke6" modified-by="" timestamp="1512957619608"><title>从阻塞回到就绪状态</title><children><topics type="attached"><topic id="7cbu41f6qt05gu0lrcg9h8rkpv" modified-by="" timestamp="1512957618839"><title>sleep()睡眠时间到了</title></topic><topic id="4lo7mb9m65u61c4gjqolfkij62" modified-by="" timestamp="1512957678200"><title>wait()也可以设置时间，但更多时候是通过notify()</title></topic></topics></children></topic><topic id="110bmmnqfdqhdpdi7e7gpvh73i" modified-by="" timestamp="1512957702449"><title>声明的类不同</title><children><topics type="attached"><topic id="5lsa7b6jejvp677vuvl5bffka7" modified-by="" timestamp="1512957722425"><title>wait是Object中，非静态方法</title></topic><topic id="2cqfvmcasu7n868cs6b8o56o5j" modified-by="" timestamp="1512957717593"><title>sleep是Thread类中，静态方法</title></topic></topics></children></topic><topic id="66ug9rsn9h56hqi0pmvddvl9tv" modified-by="" timestamp="1512957751477"><title>锁释放问题</title><children><topics type="attached"><topic id="5cils58au4i0iorbtp5nohjrjp" modified-by="" timestamp="1512957769349"><title>sleep：不会释放锁的</title><children><topics type="attached"><topic id="3c7251te8oh6f2pldvg1g06fob" modified-by="" timestamp="1512957780566"><title>例如：在卫生间睡着了，锁还在手上</title></topic></topics></children></topic><topic id="13419ugjq0cgr6e837brocmsj5" modified-by="" timestamp="1512957788717"><title>wait()：会释放锁的</title><children><topics type="attached"><topic id="7h5q1pmgb21e4bape6365ft14g" modified-by="" timestamp="1512957811761"><title svg:width="500">例如：抢到锁了，但是因为一些条件不满足，就释放锁，由其他线程执行</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="2avt0ni8eipc5uddirtp2drgus" modified-by="" timestamp="1512958688496"><title>java.lang.Thread</title><children><topics type="attached"><topic id="1heiojr27fkt2rqvv8afusc49d" modified-by="" timestamp="1512958676132"><title>方法</title><children><topics type="attached"><topic id="765qtdnnbs2uerb4p196pqrj5h" modified-by="" timestamp="1512958428412"><title>1、获取线程名称的方法</title><children><topics type="attached"><topic id="1jurfgjflaqca3k77soc8m9dbc" modified-by="" timestamp="1512958431577"><title>getName()</title></topic></topics></children></topic><topic id="5u4b0sjle5c516uq0uf5kmt9k0" modified-by="" timestamp="1512958443618"><title>2、获取当前线程对象</title><children><topics type="attached"><topic id="6p1vigauec109n1bpj8l01ulf3" modified-by="" timestamp="1512958457508"><title>Thread.currentThread()</title></topic></topics></children></topic><topic id="1bu3usr2qg2jc9dbtqgd27u4m1" modified-by="" timestamp="1512958479698"><title>3、线程休眠</title><children><topics type="attached"><topic id="4fp1g8r0p2gd2vkvc8fdu417ns" modified-by="" timestamp="1512958477919"><title>Thread.sleep(毫秒)</title></topic><topic id="2eh2i3e333hi6038nr9blaa4b8" modified-by="" timestamp="1512958484768"><title>Thread.sleep(毫秒，纳秒)</title></topic></topics></children></topic><topic id="1i6kq5st1ti3keflaggfbh819v" modified-by="" timestamp="1512958601854"><title>4、线程的优先级</title><children><topics type="attached"><topic id="14rc87m10luhhc820bni2m5a2p" modified-by="" timestamp="1512958522447"><title>getPriority()</title></topic><topic id="39oitt350noio61vi5dgmla94q" modified-by="" timestamp="1512958531853"><title>setPriority()</title><children><topics type="attached"><topic id="52knjnae1nkei6etn1s806n6lv" modified-by="" timestamp="1512958568811"><title>优先级的范围是1-10</title><children><topics type="attached"><topic id="748icc73lcjs8ie8k4omg9dpdb" modified-by="" timestamp="1512958568378"><title>MAX_PRIORITY:10</title></topic><topic id="18ttp8slua3gl9fclhub8ssher" modified-by="" timestamp="1512958565561"><title>MIN_PRIORITY:1</title></topic><topic id="75bvbcki7m9mu9kgh5v5o6a230" modified-by="" timestamp="1512958582837"><title>NORMAL_PRIORITY:5</title></topic></topics></children></topic></topics></children></topic><topic id="6jj2jca018d8ptsgft498hi4br" modified-by="" timestamp="1512958613311"><title>注意：业务逻辑不能依赖于优先级</title></topic></topics></children></topic><topic id="63uiu1brrgml5mdk47dja6aicd" modified-by="" timestamp="1512958622690"><title>5、加塞</title><children><topics type="attached"><topic id="5mtm4ebgo4ooglldu3ubmku0r1" modified-by="" timestamp="1512958630633"><title>join()</title><children><topics type="attached"><topic id="0bu53joa6c4llv84be0js7svcd" modified-by="" timestamp="1512958652538"><title svg:width="500">这句代码写在那个线程体中，哪个线程被加塞，被调用这个join()的线程加塞</title></topic></topics></children></topic></topics></children></topic><topic id="5u0se0pts56it3hl7j0hg3e0dq" modified-by="" timestamp="1512958674158"><title>6、run()：所有线程都要写</title></topic><topic id="65plbehinkgoveoair6had8cr4" modified-by="" timestamp="1512958682984"><title>7、start()：启动线程</title></topic></topics></children></topic><topic id="63cracnpsokr1ot3i5n1i7nceu" modified-by="" timestamp="1512958719208"><title>生命周期</title><children><topics type="attached"><topic id="56j865fo41h6cpn52p220h5jt4" modified-by="" timestamp="1512958731132"><title/><xhtml:img svg:height="189" svg:width="400" xhtml:src="xap:attachments/1ve8c3k91r26620auhutao4jkv.png"/></topic></topics></children></topic></topics></children></topic></topics></children></topic><title>画布 14</title></sheet></xmap-revision-content>