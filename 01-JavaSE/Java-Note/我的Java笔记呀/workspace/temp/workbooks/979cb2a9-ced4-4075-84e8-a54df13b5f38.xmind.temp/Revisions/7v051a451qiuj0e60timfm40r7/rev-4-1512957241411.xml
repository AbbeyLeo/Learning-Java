<?xml version="1.0" encoding="UTF-8" standalone="no"?><xmap-revision-content xmlns="urn:xmind:xmap:xmlns:revision:1.0" xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:svg="http://www.w3.org/2000/svg" xmlns:xhtml="http://www.w3.org/1999/xhtml" xmlns:xlink="http://www.w3.org/1999/xlink"><sheet id="7v051a451qiuj0e60timfm40r7" modified-by="" style-id="3482hp5csuf60d6r2su8h350er" theme="xminddefaultthemeid" timestamp="1512957235939"><topic id="0jh6ocu530vfag7v9k22itg740" modified-by="" structure-class="org.xmind.ui.logic.right" timestamp="1512955967885"><title>多线程</title><extensions><extension provider="org.xmind.ui.map.unbalanced"><content><right-number>-1</right-number></content></extension></extensions><children><topics type="attached"><topic id="1okhv2frtj48nhs8ijekrrm75q" modified-by="" timestamp="1512955578936"><title>概念</title><children><topics type="attached"><topic id="5svjjfbh9ff9djm8via0g7lfi5" modified-by="" timestamp="1512955584232"><title>程序</title><children><topics type="attached"><topic id="36crg0glo54cn0c5ofhnl2ukj9" modified-by="" timestamp="1512955630830"><title svg:width="500">为了完成某个任务或功能，选择某个编程语言而编写的一组代码指令的集合</title></topic></topics></children></topic><topic id="7q8udblrrvek36gem3gjko52jc" modified-by="" timestamp="1512955714723"><title>进程</title><children><topics type="attached"><topic id="33qebe12rgd3qje9qupo0fn5j4" modified-by="" timestamp="1512955768184"><title svg:width="500">程序的一次运行，是操作系统管理和调度的最小单位，每一个进程之间内存是相互独立的，如果进程之间要通信比较麻烦，可以通过文件，或网络通信方式等</title></topic></topics></children></topic><topic id="59qjikkeq268lp9q24haridn4u" modified-by="" timestamp="1512955772367"><title>线程</title><children><topics type="attached"><topic id="7442ufh5ebfhbvj2ccr718kui3" modified-by="" timestamp="1512955822823"><title svg:width="500">是进程中的其中一条执行路径，是CPU调度任务的最小单位</title><children><topics type="attached"><topic id="40fcbraruitd0sll9hs4fvfi9h" modified-by="" timestamp="1512955834503"><title>线程是共享同一个进程的内存</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="060rclpn1qprqe0si8evo4m1tk" modified-by="" timestamp="1512955944226"><title>如何开启主线程以外的线程</title><children><topics type="attached"><topic id="0tcf3ehm1s0tp68rmdn7uqu780" modified-by="" timestamp="1512955889831"><title>方式一：继承java.lang.Thread类</title><children><topics type="attached"><topic id="25qhnkej0c6keko9uo9lofdhlt" modified-by="" timestamp="1512955892648"><title>步骤</title><children><topics type="attached"><topic id="2te1tbffj3tbcbcblpp4a7fggh" modified-by="" timestamp="1512955894097"><title>①继承Thread类&#13;
②重写public void run(){}&#13;
	编写线程体，即该线程需要完成的任务代码&#13;
③创建线程对象&#13;
④启动线程：线程对象.start();</title></topic></topics></children></topic></topics></children></topic><topic id="63cfk8m8rk1vs30dl9vh6t5cic" modified-by="" timestamp="1512955910981"><title>方式二：实现java.lang.Runnable接口</title><children><topics type="attached"><topic id="5a6eud203tqa7un71ilq0acmb8" modified-by="" timestamp="1512955919995"><title>步骤</title><children><topics type="attached"><topic id="1onrjkr6qtorikgtcmc94dtbo3" modified-by="" timestamp="1512955921415"><title>①实现java.lang.Runnable接口&#13;
②实现public void run(){}&#13;
	编写线程体，即该线程需要完成的任务代码&#13;
③创建线程对象&#13;
④启动线程：借助Thread类的对象&#13;
		new Thread(自定义线程对象).start();</title></topic></topics></children></topic></topics></children></topic><topic id="7jv34hi0951po58jg02vr8fsd5" modified-by="" timestamp="1512955950989"><title>经典面试题</title><children><topics type="attached"><topic id="73u17ng0ge6mh3eb29dm0gnmva" modified-by="" timestamp="1512955955145"><title>两种方式的区别</title><children><topics type="attached"><topic id="2obqh6kj35h8j1kl5dqjjpn9dp" modified-by="" timestamp="1512955956721"><title svg:width="500">区别：&#13;
（1）继承Thread类会有单继承的限制&#13;
	实现Runnable接口不会有单继承的限制&#13;
（2）继承Thread类的方式，共享数据方面比较麻烦，使用static方式	&#13;
	实现Runnable接口，共享数据时，只需要共用同一个的Runnable接口的实现类的对象即可&#13;
（3）继承Thread类的方式，同步的锁的选择要么选择一个static对象作为锁，要么选择“类名.class即当前类Class对象”	&#13;
	实现Runnable接口，同步锁可以直接选择this对象</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="2sp58k5023n8hoqqja5801sld6" modified-by="" timestamp="1512956806217"><title>线程安全问题</title><children><topics type="attached"><topic id="13mvqtnf41a60ev42n7i34t6fv" modified-by="" timestamp="1512956017288"><title>前提条件</title><children><topics type="attached"><topic id="3d5a9csc1sftb7rtgakr1hhhmv" modified-by="" timestamp="1512956018795"><title>（1）有多个线程&#13;
（2）共享数据&#13;
（3）多条语句操作共享数据</title></topic></topics></children></topic><topic id="1f8olcjsb9qeo8lteo76628rg8" modified-by="" timestamp="1512956032721"><title>解决方法</title><children><topics type="attached"><topic id="3huo3m83culpogugah95msugt4" modified-by="" timestamp="1512957235914"><title>同步synchronized</title><children><topics type="attached"><topic id="55bjdboj5cofv44s37dhp98nrf" modified-by="" timestamp="1512956844519"><title>形式</title><children><topics type="attached"><topic id="1oiabjr573kmmddrl6701itcng" modified-by="" timestamp="1512956841016"><title>同步代码块</title><children><topics type="attached"><topic id="3o8k474l998gqq53442g45t0d9" modified-by="" timestamp="1512956842385"><title>synchronized(锁对象){&#13;
	同步代码，即需要加锁的代码&#13;
}</title></topic></topics></children></topic><topic id="57h5d425rdce9j2khsnas475hl" modified-by="" timestamp="1512956856775"><title>同步方法</title><children><topics type="attached"><topic id="32vgroct6ob167n79ujrjmbt74" modified-by="" timestamp="1512956858081"><title svg:width="500">synchronized [修饰符] 返回值类型 方法名(形参列表)抛出的异常列表</title></topic></topics></children></topic></topics></children></topic><topic id="6v8qdbsj5pu2msm39uqqig45g3" modified-by="" timestamp="1512957181411"><title>同步锁</title><children><topics type="attached"><topic id="5oebf0r2dctchd3mh2reqoqkaa" modified-by="" timestamp="1512957182730"><title svg:width="500">（1）任意类型的对象&#13;
（2）保证使用共享数据的多个线程，共用同一个锁对象</title></topic></topics></children></topic><topic id="1kr8lf55m9223eujfstuclheam" modified-by="" timestamp="1512957208502"><title>锁的范围</title><children><topics type="attached"><topic id="5gocr24c989dn4lk0rm2nu61od" modified-by="" timestamp="1512957213539"><title>同步代码块：范围&#13;
（1）不能太大：机会不均匀&#13;
（2）不能太小：安全问题没解决&#13;
（3）最好锁一次任务代码</title></topic></topics></children></topic><topic id="287e7nctt56dvjd41v8mnm62bh" modified-by="" timestamp="1512957235939"><title>同步方法的锁：</title><children><topics type="attached"><topic id="6k7a1ites6o5ej2o2d74i65lt6" modified-by="" timestamp="1512957235914"><title svg:width="500">静态方法的锁：当前类的Class对象，即当前类名.class&#13;
非静态方法的锁：当前对象，this</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><title>画布 14</title></sheet></xmap-revision-content>