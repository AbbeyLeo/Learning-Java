<?xml version="1.0" encoding="UTF-8" standalone="no"?><xmap-revision-content xmlns="urn:xmind:xmap:xmlns:revision:1.0" xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:svg="http://www.w3.org/2000/svg" xmlns:xhtml="http://www.w3.org/1999/xhtml" xmlns:xlink="http://www.w3.org/1999/xlink"><sheet id="49h3dmkalf1lbsn2ate9jopuba" modified-by="" style-id="487gi5ovjek2lvp9sjqneegdtc" theme="xminddefaultthemeid" timestamp="1511918060800" xmlns="urn:xmind:xmap:xmlns:content:2.0"><topic id="17mrtu3l8chvr316vtlolrv07t" modified-by="" structure-class="org.xmind.ui.logic.right" timestamp="1511917490164"><title>面向对象高级特性</title><extensions><extension provider="org.xmind.ui.map.unbalanced"><content><right-number>-1</right-number></content></extension></extensions><children><topics type="attached"><topic id="1paeq8kqq69qcoreld5icu5r7e" modified-by="" timestamp="1511746221190"><title>抽象</title><children><topics type="attached"><topic id="26lq6ojq91drvctqd194cmlj19" modified-by="" timestamp="1511746062378"><title>为什么会有抽象类</title><children><topics type="attached"><topic id="3flq27ks2u6m029ei8m064pjf1" modified-by="" timestamp="1511746060709"><title svg:width="500">当子类中都有一个共同的方法，每一个子类都有不同的实现，在父类中又要体现所有子类的共同的特点，所以要体现有这个方法，但是在父类中又无法给出具体的实现，那么这个时候就需要把这个方法声明为抽象的，而包含抽象方法的类，必须是抽象类</title></topic><topic id="56fh3u1p97qapvi46m1dek242b" modified-by="" timestamp="1511746062367"><title svg:width="500">某个父类仅仅是表示一个抽象的概念，不希望它被实例化，这个时候父类中可能没有抽象方法，但是我们也把它声明为抽象类</title></topic></topics></children></topic><topic id="123ijf5ufk02e9tkmv621643i8" modified-by="" timestamp="1511746077195"><title>如何声明抽象类</title><children><topics type="attached"><topic id="4nte0l0akjtd9l457l1gdoi2q1" modified-by="" timestamp="1511746081151"><title>语法格式</title><children><topics type="attached"><topic id="78sclc0ffelqj69gv8luujj2bl" modified-by="" timestamp="1511746082334"><title>[public/缺省] abstract class 类名{&#13;
}</title></topic></topics></children></topic></topics></children></topic><topic id="2s6ln2a41ik1mi005guu7p765b" modified-by="" timestamp="1511746096316"><title>如何声明抽象方法</title><children><topics type="attached"><topic id="7tinf1bmpm2jn2micln2jve6tt" modified-by="" timestamp="1511746101722"><title>语法格式</title><children><topics type="attached"><topic id="2mumclp913nt2ejnmknedj5mep" modified-by="" timestamp="1511746171478"><title svg:width="500">[public/protected/缺省]  abstract   返回值类型   方法名([形参列表]);</title><children><topics type="attached"><topic id="3u5381ju238ve24u8h89c2n34p" modified-by="" timestamp="1511746185994"><title>抽象方法是不能private,static,final修饰的</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="0d1jfqfrqcsnua5k2kngt17uvc" modified-by="" timestamp="1511746211072"><title>抽象类的特点</title><children><topics type="attached"><topic id="7ci60vi3d439aabh6la3bh5apt" modified-by="" timestamp="1511746212456"><title svg:width="500">（1）抽象类不能实例化&#13;
（2）抽象类可以包含抽象方法，也可以没有抽象方法。&#13;
如果一个类有抽象方法，那么这个类必须是抽象类，&#13;
如果一个抽象类没有抽象方法，那么它的用意是不想实例化，用它仅仅表示一个抽象的概念。&#13;
（3）抽象类生来就是用来被继承的，那么子类在继承它的时候，必须重写（实现）抽象父类的抽象方法，&#13;
否则该子类也得是抽象类。&#13;
（4）抽象类的变量与子类的对象构成多态引用。&#13;
（5）抽象类除了不能实例化，可以包含抽象方法，其他的和非抽象类是一样的，&#13;
可以有成员变量（类变量、实例变量）、构造器、代码块（静态代码块和非静态代码块）&#13;
方法（静态方法、非静态方法）</title></topic></topics></children></topic><topic id="2ff3r3hk6t1gva75bht27r6p31" modified-by="" timestamp="1511746228241"><title>抽象类不能实例化，为什么要有构造器呢？</title><children><topics type="attached"><topic id="7hljroh7pr5a9an2qtk8iks6jd" modified-by="" timestamp="1511746233915"><title svg:width="500">子类在继承该类时，一定要调用它的构造器，为属性初始化。</title><children><topics type="attached"><topic id="3dp2qh9n1p52f49hpvfbkjous8" modified-by="" timestamp="1511746262782"><title>因为构造器的作用有两点</title><children><topics type="attached"><topic id="01ujrfombs96jta9iln15lunna" modified-by="" timestamp="1511746262111"><title>（1）和new一起创建对象</title></topic><topic id="4kssbig2sem414f7i5bmoc464c" modified-by="" timestamp="1511746274933"><title>（2）为属性初始化</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="689idmgjbepi4ep6e5c9ktn66i" modified-by="" timestamp="1511747076644"><title>接口</title><children><topics type="attached"><topic id="5ucmhu24dj50qkppneuq5g68o9" modified-by="" timestamp="1511746785541"><title>接口即代表行为标准，功能标准</title></topic><topic id="4da2cknbt8vhqhjhfp1g7q2t2u" modified-by="" timestamp="1511746986735"><title>如何声明一个接口？</title><children><topics type="attached"><topic id="4tgoe6vuqilq7bo70n04hmjt79" modified-by="" timestamp="1511746992062"><title>语法结构</title><children><topics type="attached"><topic id="5igv1qs304u3fcf2e8857m5hkq" modified-by="" timestamp="1511746993186"><title>[public/缺省] interface 接口名{&#13;
}</title></topic></topics></children></topic></topics></children></topic><topic id="12mht89p2484t7apl6pkckl5v4" modified-by="" timestamp="1511747006749"><title>如何实现接口？</title><children><topics type="attached"><topic id="4nrn13nokgabbgvkpg4adfullg" modified-by="" timestamp="1511747023551"><title>语法结构</title><children><topics type="attached"><topic id="0jk10oauuk4he90o7uip7875l3" modified-by="" timestamp="1511747024980"><title svg:width="500">[public/缺省] class 子类名 [extends 父类名] implements  接口名1，接口名2。。。{&#13;
	//要实现接口的所有抽象方法&#13;
}</title></topic></topics></children></topic></topics></children></topic><topic id="5o8cp338iokj94q9feebr93e9i" modified-by="" timestamp="1511747134822"><title>接口的特点</title><children><topics type="attached"><topic id="24eln82jcppeijs8aaqj8jo9sa" modified-by="" timestamp="1511747112136"><title>JDK1.7</title><children><topics type="attached"><topic id="30php8rsf5hlg8oj2f6ccckk16" modified-by="" timestamp="1511747114072"><title svg:width="500">JDK1.7：&#13;
（1）接口不能实例化&#13;
（2）接口只能有全局静态的常量和公共的抽象方法&#13;
（3）接口中不能有构造器，因为它没有属性需要初始化，又不能创建对象&#13;
（4）接口生来用来被实现的，那么实现类（像子类）在实现它时，必须实现（和重写要求一样）接口的&#13;
所有抽象方法，否则该实现类也得是抽象类&#13;
（5）一个类可以同时实现多个接口&#13;
（6）一个类还可以继承父类又实现接口，但是必须先继承后实现&#13;
（7）接口与接口之间是继承关系，一个接口可以继承多个接口&#13;
（8）接口与实现类的对象之间构成多态引用</title></topic></topics></children></topic><topic id="6611cktbpm1cpgjskjvlmbt3o7" modified-by="" timestamp="1511747145811"><title>JDK1.8</title><children><topics type="attached"><topic id="6sisbmqcmhc2k58v0ie07tqob2" modified-by="" timestamp="1511747209402"><title svg:width="500">其他的和JDK1.7一样，不一样的是：&#13;
JDK1.8之后，接口中除了全局静态的常量和公共的抽象方法以外，可以有静态方法和默认方法</title><children><topics type="attached"><topic id="3tqv5qo96euci3f05qttp6pc7g" modified-by="" timestamp="1511747196151"><title>接口中的静态方法</title><children><topics type="attached"><topic id="7v80fhtoo1rb64v28t0c6b0riv" modified-by="" timestamp="1511747194942"><title svg:width="500">当接口的所有实现类，对这个方法的实现是一样的，这个方法就设计在接口中，设计为静态方法</title></topic><topic id="3ho2il8t1s3hlf5309dtmanhf1" modified-by="" timestamp="1511747200572"><title>如何调用</title><children><topics type="attached"><topic id="14ngpp1dokp2r4o9st528o5k07" modified-by="" timestamp="1511747205688"><title>接口名.方法</title></topic></topics></children></topic></topics></children></topic><topic id="3ci070vn5iertsm1k055sgmjk3" modified-by="" timestamp="1511747466454"><title>接口中的默认方法</title><children><topics type="attached"><topic id="57gf1e45aea59rqadcd3rm9ofd" modified-by="" timestamp="1511747261595"><title svg:width="500">当接口的大多数实现类，对这个方法的实现是一样，那么这个方法的实现就可以在接口中提供默认实现，如果某个实现类觉得他不合适，只需要重写它即可</title></topic><topic id="3ueqak93ahucgjdkmqs74qdh33" modified-by="" timestamp="1511747302860"><title>如何调用</title><children><topics type="attached"><topic id="3qh3souakitd10m8g054ht1m7h" modified-by="" timestamp="1511747302037"><title>实现类外</title><children><topics type="attached"><topic id="3aqguqh5qs2mcjcl3id7kvsrd8" modified-by="" timestamp="1511747302018"><title>实现类对象.方法</title></topic></topics></children></topic><topic id="3mav7dkjk2k3ageo2d7dg12v8b" modified-by="" timestamp="1511747329806"><title>实现类中</title><children><topics type="attached"><topic id="68lh8jqu05h48l9cqh772c67hm" modified-by="" timestamp="1511747328308"><title svg:width="500">如果实现类要重写该默认方法，但是又想调用接口中的默认实现</title></topic><topic id="2fihn3q16ealhkj9c90nmnipo7" modified-by="" timestamp="1511747339312"><title>接口名.super.方法</title></topic></topics></children></topic></topics></children></topic><topic id="1pfec4j3q62g3lel02u0koqlag" modified-by="" timestamp="1511747376830"><title>什么情况下需要重写</title><children><topics type="attached"><topic id="13ojndejcqqdddbgju9d6jrnbn" modified-by="" timestamp="1511747373525"><title>接口中的默认实现不适合该实现类</title></topic><topic id="4m95lf2fevuv6ib1tr1c80gaq7" modified-by="" timestamp="1511747383155"><title>必须重写</title><children><topics type="attached"><topic id="6l0g11t7hfb47h9mjqd2aq3op6" modified-by="" timestamp="1511747454317"><title svg:width="500">一个类同时实现了多个接口，而多个接口中都相同的默认方法（方法名和形参列表都相同），这个时候实现类必须做出选择，要重写，如果需要保留其中一个的话，通过接口名.super.方法，保留它的默认实现</title></topic></topics></children></topic></topics></children></topic><topic id="6lrim758b6mrpod9uo3t4m44jj" modified-by="" timestamp="1511747475302"><title>类优先原则</title><children><topics type="attached"><topic id="4cs419onrk99p5519s53njqc7l" modified-by="" timestamp="1511747524680"><title svg:width="500">当一个类继承了父类，又实现了接口，而且父类中的某个方法与接口中的默认方法一样（方法名和形参列表），默认保留的是父类中的方法实现</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="7ia5a5520b8e8d8ei531imdsac" modified-by="" timestamp="1511832345324"><title>枚举</title><children><topics type="attached"><topic id="1j0vdmir49eefkm55jcufsklvg" modified-by="" timestamp="1511832334881"><title svg:width="500">枚举是指某个类型的对象是有限个，在类型中一一创建并列举它的对象</title></topic><topic id="65t48r4dd5sndlsfam6rkp9j0u" modified-by="" timestamp="1511832383251"><title>JDK1.5之前，如何解决</title><children><topics type="attached"><topic id="3omaj95f2kgf76kof7qje1fave" modified-by="" timestamp="1511832369927"><title>（1）构造器私有化</title></topic><topic id="16v4k852661sm5j02hmji73qpo" modified-by="" timestamp="1511832381966"><title>（2）通过常量的方式创建好所有对象</title></topic><topic id="48domp1vd060almp5nb2ggfu8b" modified-by="" timestamp="1511832417126"><title>示例</title><notes><html><xhtml:p>class Week{</xhtml:p><xhtml:p>	public static final Week MONDAY = new Week();</xhtml:p><xhtml:p>	public static final Week TUESDAY = new Week();</xhtml:p><xhtml:p>	public static final Week WEDNESDAY = new Week();</xhtml:p><xhtml:p>	public static final Week THURSDAY = new Week();</xhtml:p><xhtml:p>	public static final Week FRIDAY = new Week();</xhtml:p><xhtml:p>	public static final Week SATURDAY = new Week();</xhtml:p><xhtml:p>	public static final Week SUNDAY = new Week();</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>	private Week(){</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p/><xhtml:p/><xhtml:p>Week w = Week.MONDAY;</xhtml:p></html><plain>class Week{&#13;
	public static final Week MONDAY = new Week();&#13;
	public static final Week TUESDAY = new Week();&#13;
	public static final Week WEDNESDAY = new Week();&#13;
	public static final Week THURSDAY = new Week();&#13;
	public static final Week FRIDAY = new Week();&#13;
	public static final Week SATURDAY = new Week();&#13;
	public static final Week SUNDAY = new Week();&#13;
	&#13;
	private Week(){&#13;
		&#13;
	}&#13;
}&#13;
&#13;
&#13;
Week w = Week.MONDAY;</plain></notes></topic></topics></children></topic><topic id="0mtbis72dor198m903rlr8hbtr" modified-by="" timestamp="1511832491652"><title>JDK1.5之后，如何解决</title><children><topics type="attached"><topic id="5lpd8tddk3fr03qot6rr1tur1t" modified-by="" timestamp="1511832486061"><title>如何声明</title><children><topics type="attached"><topic id="1qokinkjcg5v0vkvqmokm4mhnv" modified-by="" timestamp="1511832472742"><title>[修饰符] enum  枚举类型名{&#13;
	常量对象列表&#13;
}</title></topic><topic id="0pspajk423pg160pqcef1ss3g1" modified-by="" timestamp="1511832487609"><title>[修饰符] enum  枚举类型名{&#13;
	常量对象列表;&#13;
	其他成员;&#13;
}</title></topic></topics></children></topic><topic id="0kitt3dt52hi3v44gcpa45cslj" modified-by="" timestamp="1511832830624"><title>特点</title><children><topics type="attached"><topic id="1aqosu7ifs8d5h0dko7bkgbfqj" modified-by="" timestamp="1511832519457"><title>（1）枚举类型中的构造器都是私有化</title></topic><topic id="32c97albste0k5bmcot59ji8fo" modified-by="" timestamp="1511832546476"><title svg:width="500">（2）常量对象列表必须在首行，如果常量对象列表后面还有其他的代码，那么要用;结束</title></topic><topic id="66bvntbi20d3e41i65j85or9dl" modified-by="" timestamp="1511832762090"><title svg:width="500">（3）枚举类型不能继承别的类型，因为它默认继承java.lang.Enum</title><children><topics type="attached"><topic id="5imsvrabh4u58hbdenskuvqksv" modified-by="" timestamp="1511832741911"><title>它有一些方法</title><children><topics type="attached"><topic id="2en4e889vp49l0adodbpan6l4n" modified-by="" timestamp="1511832610160"><title>name()</title><children><topics type="attached"><topic id="2onobn15p3d90oo1jvuq6l8fgp" modified-by="" timestamp="1511832619099"><title>返回常量对象名</title></topic></topics></children></topic><topic id="16r3fftdfs7b6hk72hpf3ebebs" modified-by="" timestamp="1511832624528"><title>ordinal()</title><children><topics type="attached"><topic id="7bp0a4o08dlbuvb54472dphcvq" modified-by="" timestamp="1511832636602"><title>返回常量对象的序号，从0开始</title></topic></topics></children></topic><topic id="1opncbqtbhv7blr0g8imppbjkq" modified-by="" timestamp="1511832670253"><title svg:width="500">实现了java.lang.Comparable接口，重写compareTo()，按照常量对象的顺序排序</title><children><topics type="attached"><topic id="66v5169umvf91v01n665bhhhab" modified-by="" timestamp="1511832684812"><title>如果自己的枚举类中不适合，可以重写</title></topic></topics></children></topic><topic id="3i64hb27fv50q4upi66h26uemd" modified-by="" timestamp="1511832748662"><title>toString()</title><children><topics type="attached"><topic id="4i6iadg1m3007utrc9b05aeehg" modified-by="" timestamp="1511832750046"><title>返回常量对象名</title><children><topics type="attached"><topic id="07i5bubda8p6nnil79ngvlke4t" modified-by="" timestamp="1511832752852"><title>可以重写</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="7chqneahq8uauc9nfghf89adrg" modified-by="" timestamp="1511832793557"><title>API中没有的方法</title><children><topics type="attached"><topic id="7gk0ondc2g2slp3vmjtnrhvbt3" modified-by="" timestamp="1511832783117"><title>枚举类型名.values()</title><children><topics type="attached"><topic branch="folded" id="2ionc3k8atllnajog1noa4kdce" modified-by="" timestamp="1511832792630"><title>返回枚举常量对象组成的数组</title></topic></topics></children></topic><topic id="2u9acbec8p04ovubkv0g2v5spg" modified-by="" timestamp="1511832811881"><title>枚举类型名.valueOf（常量对象的名称）</title><children><topics type="attached"><topic id="1mqtj04mdkb2ahagmna2tc8im0" modified-by="" timestamp="1511832822714"><title>返回某一个指定的对象</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="6lnia719nojagpv5imdg3pdeha" modified-by="" timestamp="1511832907003"><title>（4）switch对枚举加入支持</title><children><topics type="attached"><topic id="2hqdc4jacooj2mab1ms6ue3388" modified-by="" timestamp="1511832908346"><title>switch(枚举类型表达式){&#13;
	case 常量对象名1:&#13;
		语句;&#13;
		[break;]&#13;
	case 常量对象名2:&#13;
		语句;&#13;
		[break;]&#13;
	case 常量对象名3:&#13;
		语句;&#13;
		[break;]	&#13;
	default:&#13;
		语句;&#13;
		[break;]		&#13;
}</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="65i9jlphpqp40p1ro47gbtp0go" modified-by="" timestamp="1511917571663"><title>注解</title><children><topics type="attached"><topic id="3ci3p3ba2tu4ujtk7cporv7k39" modified-by="" timestamp="1511917536068"><title>概念</title><children><topics type="attached"><topic id="2saf0do1vc9kvuli43lvk8mkng" modified-by="" timestamp="1511917533462"><title>代码级别的注释</title></topic><topic id="7etj8kf7rl7c2vbv04jdq5catr" modified-by="" timestamp="1511917542666"><title>给代码读取的注释</title><children><topics type="attached"><topic id="3s4vi33qdr3fa8enhs23lfe2f6" modified-by="" timestamp="1511917567576"><title>不同普通的注释（给人看的）</title><children><topics type="attached"><topic id="7vdt2bltk42qatbqjqgk8cnuk6" modified-by="" timestamp="1511917554139"><title>单行注释</title></topic><topic id="7p6nc7ivi7ii4adpmriubjpsa4" modified-by="" timestamp="1511917558136"><title>多行注释</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="4lslfhoe04lu2h5no2ke83c3il" modified-by="" timestamp="1511917616934"><title>四种</title><children><topics type="attached"><topic id="0bs3m24qv0oproosliigfku7ei" modified-by="" timestamp="1511917698451"><title>1、编译器的格式检查</title><children><topics type="attached"><topic id="5atm2m0o21moqf3r9rkbi1em8t" modified-by="" timestamp="1511917656968"><title svg:width="500">（1）@Override：告知编译器对该方法按照“重写”的要求进行格式检查</title></topic><topic id="2f7pg4hqagf5h5udb79enu8fo3" modified-by="" timestamp="1511917686705"><title svg:width="500">（2）@SuppressWarnings：告知编译器抑制警告</title></topic><topic id="1vr69h1kure7bn1h7vluph4gj2" modified-by="" timestamp="1511917700125"><title svg:width="500">（3）@Deprecated：告知编译器某个元素是已过时，有人用了就弹出警告</title></topic></topics></children></topic><topic id="6f57ejkqgbmd6g9it98vhdv9iu" modified-by="" timestamp="1511918051824"><title>2、文档注释</title><children><topics type="attached"><topic id="1npi2c3g2610keg3hei80bhhg5" modified-by="" timestamp="1511917791112"><title>（1）@version</title><children><topics type="attached"><topic id="5dr9hsa4o35lrq9sgtg1dg8ic3" modified-by="" timestamp="1511917796851"><title>指定当前版本</title></topic></topics></children></topic><topic id="64nagkslt62go4gch4h5553n0l" modified-by="" timestamp="1511917797087"><title>（2）@author</title><children><topics type="attached"><topic id="6fuggojblgoam6nc91ini9ft1u" modified-by="" timestamp="1511917800644"><title>指定作者</title></topic></topics></children></topic><topic id="19864n0m5iq9mkuregakgjqhh4" modified-by="" timestamp="1511917801049"><title>（3）@since</title><children><topics type="attached"><topic id="74de6ovi6oshvfbpcnh5qkf11q" modified-by="" timestamp="1511917808102"><title>指定从哪个版本开始</title></topic></topics></children></topic><topic id="4545kfps2ln6jc62u1kdi3c2j4" modified-by="" timestamp="1511917808425"><title>（4）@see</title><children><topics type="attached"><topic id="7hbu5djecok1c96ren9b5i2llp" modified-by="" timestamp="1511917814251"><title>另请参阅</title></topic></topics></children></topic><topic id="1ljsl24jbhpap71ijk1rro2dmi" modified-by="" timestamp="1511917922163"><title>（5）param</title><children><topics type="attached"><topic id="7oa0gahq60g1tbqiahd672kjfe" modified-by="" timestamp="1511917830486"><title>指定当前方法的形参信息</title></topic><topic id="42bri3p998b025ivilai6v433p" modified-by="" timestamp="1511917857409"><title>可以多个</title></topic><topic id="5hnf0cavqakgo74tnkfacf0orm" modified-by="" timestamp="1511917899057"><title>只有方法有形参才能标记</title></topic><topic id="1qi4jqj8kf8ns7j20dgas8ngdn" modified-by="" timestamp="1511917927034"><title>格式：</title><children><topics type="attached"><topic id="5g7k8t7ppc1vjodclodleao8bq" modified-by="" timestamp="1511917961297"><title>@param  形参名  形参类型   形参的描述信息</title></topic></topics></children></topic></topics></children></topic><topic id="3mljegutd04ijn3trubmps7s7s" modified-by="" timestamp="1511917963103"><title>（6）@return</title><children><topics type="attached"><topic id="2mvg834o7gs6j14lknpk575p2q" modified-by="" timestamp="1511917838308"><title>指定当前方法的返回值信息</title></topic><topic id="2sbcu5u7nlpridqimljroi7v0j" modified-by="" timestamp="1511917887758"><title svg:width="500">一个方法只能有一个，如果方法是void，就不能标记@return</title></topic><topic id="4ki6f56fn8bmjbrbllifhc5jk5" modified-by="" timestamp="1511917966966"><title>格式</title><children><topics type="attached"><topic id="3f9csf3hgesidiiv0hk2i3op9m" modified-by="" timestamp="1511917984388"><title>@return  返回值的类型  返回值的描述</title></topic></topics></children></topic></topics></children></topic><topic id="2fpp1eukort9tarkkm2afasq62" modified-by="" timestamp="1511917988178"><title>（7）@exception</title><children><topics type="attached"><topic id="3c5gqjh72l6h9prmg9c0in8bvk" modified-by="" timestamp="1511917850249"><title>指定当前方法抛出异常的信息</title></topic><topic id="77cab2enhifs4vcnbvugobss5n" modified-by="" timestamp="1511917860645"><title>可以多个</title></topic><topic id="5g63q46tca2aepg3bp0g4k17nh" modified-by="" timestamp="1511917910812"><title>只有方法抛出异常才能标记</title></topic><topic id="6a7bnu3j0rn43pd5knig9r9e8a" modified-by="" timestamp="1511917988145"><title>格式</title><children><topics type="attached"><topic id="7lkdrfngdj76g1jjr04a8jrnn1" modified-by="" timestamp="1511918008220"><title>@exception  异常类型  异常的描述</title></topic></topics></children></topic></topics></children></topic><topic id="4vqk1c77jnev9ef4ued454rqr1" modified-by="" timestamp="1511918060800"><title>结合javadoc.exe</title></topic></topics></children></topic><topic id="6q6s426jtc27i46e1l2ea05edm" modified-by="" timestamp="1511917616508"><title>3、JUnit的单元测试</title></topic><topic id="64m91btiaethhdkn4b6bt0pqvj" modified-by="" timestamp="1511917634028"><title>4、各大框架等替代配置文件</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><title>面向对象高级特性</title></sheet></xmap-revision-content>