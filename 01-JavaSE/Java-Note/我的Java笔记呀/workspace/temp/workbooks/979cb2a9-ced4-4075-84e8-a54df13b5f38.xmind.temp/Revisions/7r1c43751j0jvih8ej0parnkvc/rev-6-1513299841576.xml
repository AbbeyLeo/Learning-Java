<?xml version="1.0" encoding="UTF-8" standalone="no"?><xmap-revision-content xmlns="urn:xmind:xmap:xmlns:revision:1.0" xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:svg="http://www.w3.org/2000/svg" xmlns:xhtml="http://www.w3.org/1999/xhtml" xmlns:xlink="http://www.w3.org/1999/xlink"><sheet id="7r1c43751j0jvih8ej0parnkvc" modified-by="" theme="xminddefaultthemeid" timestamp="1513299198554" xmlns="urn:xmind:xmap:xmlns:content:2.0"><topic id="0v8j0co7s9rj1ln4e94743rl1d" modified-by="" structure-class="org.xmind.ui.logic.right" timestamp="1508468416715"><title svg:width="500">Lambda表达式与StreamAPI</title><extensions><extension provider="org.xmind.ui.map.unbalanced"><content><right-number>-1</right-number></content></extension></extensions><children><topics type="attached"><topic id="4mn0bj08kblqvtudkfs1n87qpd" modified-by="" timestamp="1508465755519"><title>JDK1.8</title></topic><topic id="1b4rqjv8t99gptsqtr55k435v9" modified-by="" timestamp="1508465789493"><title svg:width="500">这两个的目的都是想要使得Java能够实现函数式编程</title></topic><topic id="0v7supds7rk9juuo2tocj8feuf" modified-by="" timestamp="1508465860430"><title svg:width="500">Lambada表达式主要针对接口，函数式接口进行的优化，简化代码</title></topic><topic id="318c493fu66ve684jaf4nim5rn" modified-by="" timestamp="1508465855039"><title svg:width="500">StreamAPI主要是针对集合的处理操作进行的优化，简化代码</title></topic><topic id="7scue6n5m0lfctufnrfsgc02td" modified-by="" timestamp="1508467717878"><title>Lambda表达式</title><children><topics type="attached"><topic id="6go5h8erdops12ncregjqlb0ct" modified-by="" timestamp="1508465896339"><title svg:width="500">是一个匿名的函数，为了把方法体的实现代码当做数据一样进行传递</title></topic><topic id="44kspil4c23fg4hvod0a3omrmh" modified-by="" timestamp="1508466007426"><title>JDK1.8之前，用匿名内部类完成</title><children><topics type="attached"><topic id="5qnqpbniifljrsfq6jh1ar84fj" modified-by="" timestamp="1508465959207"><title>Runnable r = new Runnable(){&#13;
	public void run(){&#13;
		......&#13;
	}&#13;
}</title><children><topics type="attached"><topic id="4451175g6ilpulgbj6d231cs54" modified-by="" timestamp="1508465974143"><title>目的就是传递run()方法的实现代码</title></topic></topics></children></topic><topic id="0ng6bpp6mnfdca2s5f4cn8av3q" modified-by="" timestamp="1508466038181"><title>new Thread(new Runnable(){&#13;
	public void run(){&#13;
		......&#13;
	}&#13;
}).start();</title></topic></topics></children></topic><topic id="5ukpq6tpphuh750l7epf8dl5gt" modified-by="" timestamp="1508466040021"><title>使用Lambda表达式</title><children><topics type="attached"><topic id="0hfioshg942ccn6cecq4hhgahb" modified-by="" timestamp="1508465999474"><title>Runnable r = () -&gt; {....};</title></topic><topic id="3637hqqbt9fho0dp2ug4cimhq4" modified-by="" timestamp="1508466054678"><title>new Thread(() -&gt; {....}).start();</title></topic></topics></children></topic><topic id="464707hipm7u5sr48ui0ea4tk6" modified-by="" timestamp="1508466066317"><title>语法</title><children><topics type="attached"><topic id="535kkuv97iari68u8h9edcvmue" modified-by="" timestamp="1513298699338"><title>格式： (形参列表) -&gt;  {Lambda体}</title></topic></topics></children></topic><topic id="49girpupb8v92p87ntpj1i2q5g" modified-by="" timestamp="1508466114117"><title>四种形式</title><children><topics type="attached"><topic id="0ki4hrfdhhitvuepsdg68r518c" modified-by="" timestamp="1508466473343"><title>（1）无参无返回值</title><children><topics type="attached"><topic id="71pfrnjo9fstv7r0an8045930u" modified-by="" timestamp="1508466126596"><title>格式</title><children><topics type="attached"><topic id="281ge9be9rtnv216d7mavpph35" modified-by="" timestamp="1508466137769"><title>() -&gt; {Lambda体}</title></topic></topics></children></topic><topic id="49eg881drf68hpdhr51qfbhs6j" modified-by="" timestamp="1513156165465"><title>说明：</title><children><topics type="attached"><topic id="3gm9e1phre0q5l98ubqrdg4ol8" modified-by="" timestamp="1513156154204"><title>（1）无参，()</title></topic><topic id="6q9m3a87b3pah2r0veqvr1gspk" modified-by="" timestamp="1513156156212"><title svg:width="500">（2）如果Lambda体是多句语句，那么{}是不可以省略</title></topic><topic id="6kvqr91dntb672j70tobm53120" modified-by="" timestamp="1513156158621"><title svg:width="500">（3）如果Lambda体是1句语句，那么{}如果不省略，那么语句后面要加; ，即{;}</title></topic><topic id="260373t148eaqv36a8jelfoqck" modified-by="" timestamp="1513156161976"><title svg:width="500">（4）如果Lambda体是1句语句，那么{;}可以省略</title></topic></topics></children></topic><topic id="5kpflt1tuhno72huatkle711dl" modified-by="" timestamp="1508466502099"><title>代表</title><children><topics type="attached"><topic id="7ccaipd34fsesn7a1av1bps2fn" modified-by="" timestamp="1508466518824"><title svg:width="500">Runnable r = ()  -&gt; {System.out.println("hello");};</title></topic><topic id="5ir52090sa2jgtpi97o8v9i75k" modified-by="" timestamp="1508466516988"><title>Runnable r = ()  -&gt; System.out.println("hello");</title></topic></topics></children></topic></topics></children></topic><topic id="359m5jprb9vjf4ha9rpet29a9m" modified-by="" timestamp="1508466525566"><title>（2）有参无返回值</title><children><topics type="attached"><topic id="7h7gedn9ro5fc3c19eonj1g21h" modified-by="" timestamp="1508466224272"><title>格式</title><children><topics type="attached"><topic id="209q2s7fvfnhtlh4oe3tbcqcrc" modified-by="" timestamp="1508466231303"><title>(形参列表) -&gt; {Lambda体}</title></topic></topics></children></topic><topic id="7gers9s3o33hl6bel6ltdr165e" modified-by="" timestamp="1513156234910"><title>说明：</title><children><topics type="attached"><topic id="3j7gph3jmab6qaf7g8p14v7scp" modified-by="" timestamp="1513156219729"><title> （1）如果Lambda体是多句语句，那么{}是不可以省略</title></topic><topic id="11elnc67svlrc44fjsn2ilu29b" modified-by="" timestamp="1513156219729"><title> （2）如果Lambda体是1句语句，那么{}如果不省略，那么语句后面要加; ，即{;}</title></topic><topic id="2hoilq2ld03d66qrkadc50ren3" modified-by="" timestamp="1513156219729"><title> （3）如果Lambda体是1句语句，那么{;}可以省略</title></topic><topic id="47ud408r1itg4mcspltre3vnbp" modified-by="" timestamp="1513156255273"><title svg:width="500">（4）如果参数列表的参数类型是可以确定的，那么类型可以省略，如果形参个数是多个，那么()不可以省略</title></topic><topic id="01tkqhb5n459gbgjnesrk3qf9m" modified-by="" timestamp="1513156268623"><title svg:width="500"> （5）如果参数列表的个数只有1个，类型可以确定，()可以省略,形参名不可以省略，但是形参名可以和接口的抽象方法的形参名不一样</title></topic></topics></children></topic><topic id="5s7fh682vhta4qu4n83u5ktm1r" modified-by="" timestamp="1508466557468"><title>代表</title><children><topics type="attached"><topic id="3h36fsn71k75krkrm4mt2gica4" modified-by="" timestamp="1508466538670"><title>消费型</title></topic><topic id="013f0n9hb497g57jpl7km1lek1" modified-by="" timestamp="1508466556556"><title>Consumer&lt;T&gt;   void  accept(T t)</title></topic><topic id="7kvam981m9ori2n0q9v8153b3n" modified-by="" timestamp="1508466588644"><title>java.lang.Iterable&lt;T&gt;</title><children><topics type="attached"><topic id="0rd156fddeom0qnkg53vl41pj0" modified-by="" timestamp="1508466585664"><title>forEach(Consumer&lt;T&gt;)</title></topic><topic id="5unbc1m8i82604mmhs9olis520" modified-by="" timestamp="1508466618725"><title>集合对象.forEach(t  -&gt; System.out.println(t));</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="0n94urtuupam7i6djnj4q98glt" modified-by="" timestamp="1508466625047"><title>（3）无参有返回值</title><children><topics type="attached"><topic id="041tv3dsmqunos3kikh3foe111" modified-by="" timestamp="1508466332157"><title>格式</title><children><topics type="attached"><topic id="7njg9477793qkjqtsf33sni9u0" modified-by="" timestamp="1508466338884"><title>() -&gt; {Lambda体}</title><children><topics type="attached"><topic id="1ggbg9t75sjlk8nn1ai811t0l2" modified-by="" timestamp="1508466355398"><title>Lambda体中，肯定有return语句</title></topic></topics></children></topic></topics></children></topic><topic id="1ekpbpu03h7po10pgjj0o7i114" modified-by="" timestamp="1513156423343"><title>说明：</title><children><topics type="attached"><topic id="2qa7efddeooejss8smkggp42bv" modified-by="" timestamp="1513156423275"><title> （1）无参，()不可以省略</title></topic><topic id="5iqi1cru6cv2dq1n8n3ovid4sb" modified-by="" timestamp="1513156423275"><title> （2）如果Lambda体是多句语句，那么{}是不可以省略，，每一个语句后面要;，并且必须有return 返回值;的语句</title></topic><topic id="37ai6nftljtn4krtt2katn42ch" modified-by="" timestamp="1513156423275"><title> （3）如果Lambda体是1句语句，那么{}如果不省略，那么一定是{return 返回值;}的语句</title></topic><topic id="1dl8c4vp42jgo8sco9sm8om6rt" modified-by="" timestamp="1513156423275"><title> （4）如果Lambda体是1句语句，那么{;}可以省略，而且return要省略</title></topic></topics></children></topic><topic id="6lc0hljk5k8ifhe3ibfjd5nj1o" modified-by="" timestamp="1508466651817"><title>代表</title><children><topics type="attached"><topic id="5s5blf8a2grmcdn36jmr68lft0" modified-by="" timestamp="1508466634323"><title>供给型</title></topic><topic id="2n4d7qhc2d0go10urvhpiav6a6" modified-by="" timestamp="1508466649772"><title>Supplier&lt;T&gt;   T get()</title></topic><topic id="3g6pigtu0p07gnbog270m7veau" modified-by="" timestamp="1508466708186"><title>java.util.Optional&lt;T&gt;   orElseGet(Supplier)</title><children><topics type="attached"><topic id="32bt6qjh0ealsb3s59j74uumsg" modified-by="" timestamp="1508466706706"><title svg:width="500">Optional&lt;String&gt; opt = Optional.ofNullable(address);</title></topic><topic id="0f8vn6lrvbo9qm0i2kaq1b9pc3" modified-by="" timestamp="1508466753954"><title svg:width="500">String address = opt.orElseGet(() -&gt; new String("北京"));</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="0n9mpnt2rqr8k6tjtb0o1p024a" modified-by="" timestamp="1508466759241"><title>（4）有参有返回值</title><children><topics type="attached"><topic id="25e2b58jduv0mqh3m9rpenshdo" modified-by="" timestamp="1508466435124"><title>格式</title><children><topics type="attached"><topic id="2dpbtuia2ppv390tkg2p8fnm1f" modified-by="" timestamp="1508466231303"><title>(形参列表) -&gt; {Lambda体}</title></topic></topics></children></topic><topic id="5ki8e04do5hhan079fsv6ugbhh" modified-by="" timestamp="1513156501384"><title>说明：</title><children><topics type="attached"><topic id="54bdcptlritr7m52e7tjnmn7fq" modified-by="" timestamp="1513156501284"><title> （1）如果Lambda体是多句语句，那么{}是不可以省略，并且必须有return 返回值;的语句</title></topic><topic id="6cdahp9bouppbp7k9e33llfc95" modified-by="" timestamp="1513156501284"><title> （2）如果Lambda体是1句语句，那么{}如果不省略，那么一定是{return 返回值;}的语句</title></topic><topic id="4mriolb8u0mv37n6u1njqph2h2" modified-by="" timestamp="1513156501284"><title> （3）如果Lambda体是1句语句，那么{;}可以省略，而且return也可以省略</title></topic><topic id="5t4e4utpuvr7bbdg315bekcl5v" modified-by="" timestamp="1513156501284"><title> （4）参数列表，如果类型可以确定，那么类型可以省略,()不可以省略</title></topic><topic id="3i2v5q1und31ckju13u72kslbl" modified-by="" timestamp="1513156501284"><title> （5）参数列表，如果类型可以确定，并且参数个数只有一个，那么类型和()都可以省略</title></topic></topics></children></topic><topic id="32ope7kvijskjbvdrh961alttg" modified-by="" timestamp="1508466804733"><title>代表</title><children><topics type="attached"><topic id="4ik86pm0ekero94mp6da5qbs5e" modified-by="" timestamp="1508466842660"><title svg:width="500">java.util.Comparator&lt;T&gt;： int compare(T t1, T t2)</title><children><topics type="attached"><topic id="47ep6ikjuducou81ggcv17uusg" modified-by="" timestamp="1508466878760"><title svg:width="500">Comparator&lt;Student&gt; com = (t1,t2) -&gt; t1.getId() - t2.getId();</title></topic></topics></children></topic><topic id="3uocn9achjrortd7qlmku7qq5q" modified-by="" timestamp="1508466882548"><title>Predicate&lt;T&gt;  : boolean  test(T t)</title><children><topics type="attached"><topic id="6joi95qfac8jadr6v558kefaf5" modified-by="" timestamp="1508466905240"><title svg:width="500">Predicate&lt;Employee&gt;  p = t -&gt; t.getSalary() &gt; 10000;</title></topic></topics></children></topic><topic id="5ml92m4u38eeip06ul7s85qgv7" modified-by="" timestamp="1508466976085"><title>Function&lt;T,R&gt; :  R apply(T t)</title><children><topics type="attached"><topic id="0v9ibuagmupiss4rrk0lfnc1iq" modified-by="" timestamp="1508466992162"><title svg:width="500">如果Employee对象的薪资低于10000，涨薪10%，并且返回新工作</title></topic><topic id="7ugdsaisrhufmt6mruash7he82" modified-by="" timestamp="1508467119926"><title svg:width="500">Function&lt;Employee, Double&gt;  f = e -&gt; {&#13;
		if(e.getSalary()&lt;10000){&#13;
			e.setSalary(e.getSalary()*1.1;&#13;
		}&#13;
		return e.getSalary();	&#13;
}</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="5nlnqe7g488luk7aa83g927j9d" modified-by="" timestamp="1508467335102"><title>使用的形式</title><children><topics type="attached"><topic id="6duhgu0oulvae8fo1hn39dr4l4" modified-by="" timestamp="1508467328798"><title>1、给函数式接口的变量赋值：多态引用</title><children><topics type="attached"><topic id="6sdcd01uqggbb1uevhntqbud7f" modified-by="" timestamp="1508467328761"><title svg:width="500">Comparator&lt;Student&gt; com = (t1,t2) -&gt; t1.getId() - t2.getId();</title></topic></topics></children></topic><topic id="6c3ott9c5l4u4eg8hbc90jthfc" modified-by="" timestamp="1508467349534"><title>2、给函数式接口的形参赋值：多态参数</title><children><topics type="attached"><topic id="23ig2gh6mkqksqtknteesodl73" modified-by="" timestamp="1508467363463"><title>new TreeSet( (t1,t2) -&gt; t1.getId() - t2.getId());</title></topic></topics></children></topic></topics></children></topic><topic id="2re99koore7mogbr2urfcbsleo" modified-by="" timestamp="1508467372730"><title>函数式接口</title><children><topics type="attached"><topic id="4l799tuajivol5g5iskqdbivjv" modified-by="" timestamp="1508467161051"><title svg:width="500">函数式接口也是接口，是个特殊的接口，SAM型接口</title><children><topics type="attached"><topic id="0ca7057am6tcvk5uut6j0tts5b" modified-by="" timestamp="1513299110542"><title>SAM：Single  Abstract  Method</title><children><topics type="attached"><topic id="0c348j3ee69ateebhpsvd9frhh" modified-by="" timestamp="1513299121234"><title>使用注解声明@FunctionInterface</title></topic></topics></children></topic></topics></children></topic><topic id="7do8rvv6o1c2a1od5eojakk8ks" modified-by="" timestamp="1508467208313"><title svg:width="500">在这个类接口中只有一个抽象方法，但是可以有静态方法和默认方法以及Object中的方法</title></topic><topic id="16g1ncmm5h3fnddv3li9m6nqke" modified-by="" timestamp="1508467240158"><title svg:width="500">只有函数式接口的变量或形参才能用Lambda表达式赋值</title></topic><topic id="2tvgid3g8shg4glg3kqulpn1a6" modified-by="" timestamp="1508467656070"><title>四个核心的函数式</title><children><topics type="attached"><topic id="13dfvi0oktsftktk0ao068b5ql" modified-by="" timestamp="1508467442849"><title>1、消费型</title><children><topics type="attached"><topic id="391cktrl7nbbtcjoh55hgkhr6r" modified-by="" timestamp="1508467403233"><title>Consumer&lt;T&gt;   void  accept(T t)</title></topic><topic id="1i6oe6koqmgm10g7r2ikcb6d56" modified-by="" timestamp="1508467471803"><title>还有延伸版</title><children><topics type="attached"><topic id="4a4h81ps692q115m4bs2vg9un4" modified-by="" timestamp="1508467467838"><title>BiConsumer&lt;T,U&gt;: void  accept(T t,U u)</title></topic><topic id="5mk0kau6bl2v4bigirgr50hign" modified-by="" timestamp="1508467474112"><title>。。。。</title></topic></topics></children></topic></topics></children></topic><topic id="5c2q9rt5m5fem35f84aea8gp4i" modified-by="" timestamp="1508467530674"><title>2、供给型</title><children><topics type="attached"><topic id="65mtvu7pavng3uguudoahljft6" modified-by="" timestamp="1508467488518"><title>Supplier&lt;T&gt;   T get()</title></topic><topic id="5gkke5mad1hr08pbrtigo8ohg0" modified-by="" timestamp="1508467530054"><title>DoubleSupplier   Double get()</title></topic><topic id="59b2ie8jurh3u70u46mrinq4mv" modified-by="" timestamp="1508467532472"><title>....</title></topic></topics></children></topic><topic id="7bmjnt0slfhdfhaeq3vbkd89bd" modified-by="" timestamp="1508467581878"><title>3、功能型</title><children><topics type="attached"><topic id="33gc7tr01afhfg4ah3hscaeob8" modified-by="" timestamp="1508467572887"><title>Function&lt;T,R&gt;  R  apply(T t)</title></topic><topic id="5584s1a7c8e06de601qual3vj1" modified-by="" timestamp="1508467653288"><title>延伸版</title><children><topics type="attached"><topic id="13fm395htv5dpq3r5sla2s8epk" modified-by="" timestamp="1508467652237"><title>BiFunction&lt;T,U,R&gt;  R apply(T t,U u)</title></topic><topic id="4r5n8smei0sbv6sfcb6cakfp30" modified-by="" timestamp="1508467640303"><title>BinaryOperator&lt;T&gt;  T apply(T t2, T t2)</title></topic><topic id="6ho8h7m5bt0il29vd4euvfeq3b" modified-by="" timestamp="1508467655273"><title>....</title></topic></topics></children></topic></topics></children></topic><topic id="3ur74crf9iebt8sdqa374oo3og" modified-by="" timestamp="1508467686200"><title>4、断定型</title><children><topics type="attached"><topic id="48pdquv0448dnbeft8b8a1i7ar" modified-by="" timestamp="1508467670100"><title>Predicate&lt;T&gt;  : boolean  test(T t)</title></topic><topic id="3ihvnb1vaogd0nnnj4k4bdiofv" modified-by="" timestamp="1508467705570"><title>延伸版</title><children><topics type="attached"><topic id="0ljdp77h4o10alklklkofkohgf" modified-by="" timestamp="1508467902347"><title>BiPredicate&lt;T,U&gt;  boolean test(T t ,U u)</title></topic><topic id="4gnmpfke9jaagouk01gni1regm" modified-by="" timestamp="1508467707663"><title>....</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="3s4g3tnf8d4g8601vvhgtq8qfr" modified-by="" timestamp="1513299198554"><title>再简化版</title><children><topics type="attached"><topic id="3403iee3i1s41beg9nbghfb9jj" modified-by="" timestamp="1508467804328"><title>方法引用</title><children><topics type="attached"><topic id="3jfi7g5ri8ga2f5srk6k2tjfof" modified-by="" timestamp="1508467781736"><title>条件</title><children><topics type="attached"><topic id="3fvk99k0gapjhfd6cd2901qint" modified-by="" timestamp="1508467778757"><title>（1）Lambda体通过调用一个现成的方法来完成</title></topic><topic id="76re6etvehaq2ol7lcqnggl16s" modified-by="" timestamp="1508467802908"><title svg:width="500">（2）Lambda的形参列表刚好是用于这个方法的实参</title></topic></topics></children></topic><topic id="561mjglvdl8a8e2ootb6pgavpt" modified-by="" timestamp="1508468033898"><title>形式有三种</title><children><topics type="attached"><topic id="3he956id7jd1b7hgakn9rpf9nh" modified-by="" timestamp="1508467907759"><title>（1）实例对象::实例方法名</title><children><topics type="attached"><topic id="7hmvmlliplm0ci42tk0tq6n5gu" modified-by="" timestamp="1508467885270"><title>集合对象.forEach(t -&gt; System.out.println(t));</title></topic><topic id="7911da00na4d161tcclkpfslbt" modified-by="" timestamp="1508467905788"><title>集合对象.forEach(System.out::println)</title></topic></topics></children></topic><topic id="5dvenff6vrphdvdqkedu0gae85" modified-by="" timestamp="1508467977924"><title>（2）类名::静态方法名</title><children><topics type="attached"><topic id="6jec9deu579j1bl9pr1n0d83q8" modified-by="" timestamp="1508467962096"><title>Supplier&lt;Double&gt;  s = () -&gt; Math.random();</title><children><topics type="attached"><topic id="1bdc88t0i342vaub4ajddk2gqu" modified-by="" timestamp="1508467974418"><title>Supplier&lt;Double&gt;  s = Math::random;</title></topic></topics></children></topic><topic id="7bqlsvtj90fvq52ods62asmash" modified-by="" timestamp="1508468020138"><title svg:width="500">BiFunction&lt;Integer,Integer,Integer&gt; b = (a,b) -&gt; Math.max(a,b);</title><children><topics type="attached"><topic id="1e2r8vtufb67335tmsba3gvb10" modified-by="" timestamp="1508468028744"><title svg:width="500">BiFunction&lt;Integer,Integer,Integer&gt; b = Math::max;</title></topic></topics></children></topic></topics></children></topic><topic id="4vm92udmpfqmasan50e9js44nr" modified-by="" timestamp="1508468050000"><title>（3）类名::实例方法名</title><children><topics type="attached"><topic id="3h8gk58muutr87jq5sng6s1i7j" modified-by="" timestamp="1508468150077"><title svg:width="500">Comparator&lt;String&gt;  c = (t1,t2)  -&gt;  t1.compareTo(t2);</title><children><topics type="attached"><topic id="4iq3dcb7o3b45girbra2pup4ta" modified-by="" timestamp="1508468144887"><title svg:width="500">Lambda表达式的形参的第一个作为调用方法的对象，第二个，作为这个实例方法的实参</title></topic><topic id="0v038jqq070bo15rk2ajuesvt2" modified-by="" timestamp="1508468164276"><title>Comparator&lt;String&gt;  c = String::compareTo;</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="0pthr0vf104l7uacvnisrgc2np" modified-by="" timestamp="1508468233031"><title>构造器引用</title><children><topics type="attached"><topic id="2pe06bthev4cfpsm9b6vi80fa4" modified-by="" timestamp="1508468224099"><title>条件</title><children><topics type="attached"><topic id="6177ndlufhafq7ba56glr9egkt" modified-by="" timestamp="1508468222159"><title svg:width="500">（1）Lambda体通过调用一个构造器完成，返回这个新建的对象</title></topic><topic id="5k0eio2uk4kb1l6l2b4hdave8c" modified-by="" timestamp="1508468230496"><title svg:width="500">（2）Lambda的形参列表刚好是用于这个构造器的实参</title></topic></topics></children></topic><topic id="67n2jbhfn843bahraj1srkkmfr" modified-by="" timestamp="1508468302855"><title>示例</title><children><topics type="attached"><topic id="5od8ud8sivkin7n76lmlribp83" modified-by="" timestamp="1508468301651"><title svg:width="500">Fuction&lt;String ,Employee&gt;  f = name -&gt; new Employee(name);</title></topic><topic id="4uamtmh6pdrloc4u62a034tuav" modified-by="" timestamp="1508468312971"><title svg:width="500">Fuction&lt;String ,Employee&gt;  f = Employee::new;</title></topic></topics></children></topic></topics></children></topic><topic id="32c9n43vivsukf74q8odd2p37v" modified-by="" timestamp="1508468353109"><title>数组构造引用</title><children><topics type="attached"><topic id="3drhocbgn0j5atl1ov6upcpdi7" modified-by="" timestamp="1508468324920"><title>条件</title><children><topics type="attached"><topic id="529q9bkku3vriar7gvbqguf0go" modified-by="" timestamp="1508468338974"><title svg:width="500">（1）Lambda体通过创建一个数组对象完成，返回这个新建的数组对象</title></topic><topic id="4endj2n27al6hlrq4q2j6mssjn" modified-by="" timestamp="1508468350198"><title svg:width="500">（2）Lambda的形参列表刚好是用于这个数组对象的创建的长度</title></topic></topics></children></topic><topic id="6ukgiog1rda69itkd1trqa2r3t" modified-by="" timestamp="1508468382478"><title>示例</title><children><topics type="attached"><topic id="0hiomsrq2rbnqoi3f2n8of1u4m" modified-by="" timestamp="1508468379915"><title svg:width="500">Fuction&lt;Integer ,Employee[]&gt;  f = len -&gt; new Employee[len];</title></topic><topic id="3e4okmb66fb8sh1rr705tiis7l" modified-by="" timestamp="1508468391604"><title svg:width="500">Fuction&lt;Integer ,Employee[]&gt;  f = Employee[]::new;</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="1nkomqnvquj2rv6tjn31qc8k1j" modified-by="" timestamp="1508469143013"><title>StreamAPI</title><children><topics type="attached"><topic id="0ttfte3pb4u1do3e9j8th3oqst" modified-by="" timestamp="1508469114890"><title>作用</title><children><topics type="attached"><topic id="7nts35p4dn4tr02pp039ssmpsa" modified-by="" timestamp="1508469116150"><title svg:width="500">Stream API ( java.util.stream) 把真正的函数式编程风格引入到Java中。这是目前为止对Java类库最好的补充，因为Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。&#13;
Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。 使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。也可以使用 Stream API 来并行执行操作。简言之，Stream API 提供了一种高效且易于使用的处理数据的方式。</title></topic></topics></children></topic><topic id="5e7drp7ctmhm1c73fi45e0atra" modified-by="" timestamp="1508469162007"><title>特点</title><children><topics type="attached"><topic id="3s8famp0ujuh073qf2nrhha4q6" modified-by="" timestamp="1508469142778"><title>1、Stream不负责存储数据</title></topic><topic id="2l7hla4afnt2bqkko5rceqhju4" modified-by="" timestamp="1508469176242"><title svg:width="500">2、Stream的操作不影响数据源，每次操作返回一个新的Stream</title></topic><topic id="541s1e8nrbffod0aaesacbj4io" modified-by="" timestamp="1508469219610"><title svg:width="500">3、Stream的中间操作是一个“懒惰求值”，一直要到终结操作，才会一口气完成</title></topic></topics></children></topic><topic id="1qcue0cl19a8p23f1793ftqs0u" modified-by="" timestamp="1508469339413"><title>步骤</title><children><topics type="attached"><topic id="430i75pkti4at086g77p1rc2s1" modified-by="" timestamp="1508469230925"><title>1、创建Stream</title><children><topics type="attached"><topic id="7qqo1hh96pjpeabjsg6nfa3ue0" modified-by="" timestamp="1508490203813"><title>四种方式</title><children><topics type="attached"><topic id="6ugnu44cgpbgrs6q6jh3aejacq" modified-by="" timestamp="1508490051760"><title>1、Collection集合对象.stream()</title><children><topics type="attached"><topic id="15c7i2erb6kg7chj16cneera1e" modified-by="" timestamp="1508490094872"><title svg:width="500">ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();&#13;
。。。	&#13;
//创建stream&#13;
Stream&lt;String&gt; stream = list.stream();</title></topic></topics></children></topic><topic id="5htl5fhscpl6u1ji4scrv18n5t" modified-by="" timestamp="1508490107168"><title>2、Arrays.stream(数组对象)</title><children><topics type="attached"><topic id="61g3k84puogahauln0aef8d1aq" modified-by="" timestamp="1508490110143"><title svg:width="500">String[] arr = {"hello","world","java","lambda","stream"};&#13;
Stream&lt;String&gt; stream = Arrays.stream(arr);</title></topic></topics></children></topic><topic id="5ajqeg4asttmfud0p62aseumr3" modified-by="" timestamp="1508490111986"><title>3、Stream.of(T...)</title><children><topics type="attached"><topic id="6521up8bqb88t9bstc7tmdg0lc" modified-by="" timestamp="1508490120008"><title svg:width="500">Stream&lt;String&gt; stream = Stream.of("hello","world","java","lambda","stream");</title></topic></topics></children></topic><topic id="5bsq6fs7j8krblsq3f8qukrt1q" modified-by="" timestamp="1508490168393"><title>4、无限流</title><children><topics type="attached"><topic id="4vqrsu5h75ggrkdmru36au7d1q" modified-by="" timestamp="1508490157907"><title>Stream.iterator(..)</title><children><topics type="attached"><topic id="2bm4trfb0tusn8fu7pu8656do8" modified-by="" timestamp="1508490197149"><title>示例</title><notes><html><xhtml:p>	@Test</xhtml:p><xhtml:p>	public void test4(){</xhtml:p><xhtml:p>		//Interface UnaryOperator&lt;T&gt;是特殊的Function&lt;T,T&gt;： T apply(T t)</xhtml:p><xhtml:p>		Stream&lt;Integer&gt; stream = Stream.iterate(1, x -&gt; x+2);</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//中间操作</xhtml:p><xhtml:p>		stream = stream.limit(10);//取前面的10个</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		stream.forEach(System.out::println);</xhtml:p><xhtml:p>	}</xhtml:p></html><plain>	@Test&#13;
	public void test4(){&#13;
		//Interface UnaryOperator&lt;T&gt;是特殊的Function&lt;T,T&gt;： T apply(T t)&#13;
		Stream&lt;Integer&gt; stream = Stream.iterate(1, x -&gt; x+2);&#13;
		&#13;
		//中间操作&#13;
		stream = stream.limit(10);//取前面的10个&#13;
		&#13;
		stream.forEach(System.out::println);&#13;
	}</plain></notes></topic></topics></children></topic><topic id="5frhg462j39ueq85ag53kjhpfe" modified-by="" timestamp="1508490189549"><title>Stream.generate(xx)</title><children><topics type="attached"><topic id="2m1ahadmqek0ibtt3kmdkbh5nu" modified-by="" timestamp="1508490200395"><title>示例</title><notes><html><xhtml:p>	@Test</xhtml:p><xhtml:p>	public void test5(){</xhtml:p><xhtml:p>		//Supplier&lt;T&gt; ：T  apply()</xhtml:p><xhtml:p>//		Stream&lt;Double&gt; generate = Stream.generate(() -&gt; Math.random());</xhtml:p><xhtml:p>		Stream&lt;Double&gt; stream = Stream.generate(Math::random);</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>//		stream = stream.limit(5);</xhtml:p><xhtml:p>//		stream.forEach(System.out::println);</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		stream.limit(5).forEach(System.out::println);</xhtml:p><xhtml:p>	}</xhtml:p></html><plain>	@Test&#13;
	public void test5(){&#13;
		//Supplier&lt;T&gt; ：T  apply()&#13;
//		Stream&lt;Double&gt; generate = Stream.generate(() -&gt; Math.random());&#13;
		Stream&lt;Double&gt; stream = Stream.generate(Math::random);&#13;
		&#13;
//		stream = stream.limit(5);&#13;
//		stream.forEach(System.out::println);&#13;
		&#13;
		stream.limit(5).forEach(System.out::println);&#13;
	}</plain></notes></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="6ajivf4iha59p2dq9s4cugc6ps" modified-by="" timestamp="1508469317246"><title>2、中间操作</title><children><topics type="attached"><topic id="29e2qi4l8r99mj6cbur3c1v426" modified-by="" timestamp="1508469290295"><title>（1筛选与切片</title><children><topics type="attached"><topic id="5ov9q3lc7n3jvl968deblj5q7q" modified-by="" timestamp="1513156579654"><title>（1）筛选与切片&#13;
A：过滤：filter&#13;
B：去重：distinct&#13;
C：取前面的几个：limit&#13;
D：跳过前面几个：skip&#13;
 *   要取中间几个：skip + limit</title></topic></topics></children></topic><topic id="6nupcafqf1o7tmhf3p1gk7jnvn" modified-by="" timestamp="1508469326608"><title>（2）映射</title><children><topics type="attached"><topic id="5l1rtu7j0k8sb4ote92h7op3bv" modified-by="" timestamp="1513156602129"><title svg:width="500"> A：map(Function)：对Stream中的每一个元素执行某个操作，返回值组成一个新的Stream&#13;
 B：返回值是特殊类型&#13;
 *   mapToInt()&#13;
 *   mapToLong()&#13;
 *   mapToDouble()&#13;
 C：flatMap(Function)：对stream的每一个元素执行某个操作，返回值是一个stream，这些个stream再合成一个大的stream</title></topic></topics></children></topic><topic id="3674vg02411libaldn8hjndqdc" modified-by="" timestamp="1508469334346"><title>（3）排序</title><children><topics type="attached"><topic id="7knvdge4h12ph40dhddh5g4i3b" modified-by="" timestamp="1513156614922"><title>A：sorted()：自然排序&#13;
B：sorted(Comparator)：定制排序</title></topic></topics></children></topic></topics></children></topic><topic id="4i3kk92i97epkcecr0nhjh0k7o" modified-by="" timestamp="1508469414026"><title>3、终结操作</title><children><topics type="attached"><topic id="0n5vur4mjabkefdb8unr1v6m6u" modified-by="" timestamp="1508469362421"><title>（1）遍历</title><children><topics type="attached"><topic id="5acki9tpdjti0hq6v75d0hnorh" modified-by="" timestamp="1508469363560"><title>forEach(Consumer)</title></topic></topics></children></topic><topic id="5pu1t78o6lptp4fhbnr8h8m6t1" modified-by="" timestamp="1508469382603"><title>（2）匹配与查找</title><children><topics type="attached"><topic id="1e2f4k0et7d4volh7k9j7eknm4" modified-by="" timestamp="1513156644492"><title svg:width="500">A：allMatch(Predicate p)：每一个元素是否都满足某个条件&#13;
B：anyMatch(Predicate p)：是否有一个元素满足条件&#13;
C：noneMatch(Predicate p)：是否所有元素都不满足&#13;
 * &#13;
D：findFirst（）:返回第一个&#13;
E：findAny()：如果是并行流，返回的结果是任意一个，如果是一个稳定的流，返回的结果是和findFirst()一样&#13;
 * &#13;
 F：count()：统计&#13;
G：max(Comparator)&#13;
H:min(Comparator)</title></topic></topics></children></topic><topic id="742ueiahamjp6a1im2mna2leci" modified-by="" timestamp="1508469409742"><title>（3）规约</title><children><topics type="attached"><topic id="2nj5uakjd359lbd4oa00n0fap1" modified-by="" timestamp="1513156652861"><title svg:width="500">A:Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator)&#13;
 		BinaryOperator&lt;T&gt;是一个BiFunction&lt;T,T,T&gt;接口：  T apply(T t1, T t2)&#13;
B:T reduce(T identity,BinaryOperator&lt;T&gt; accumulator)</title></topic></topics></children></topic><topic id="4r22r2837p7gdo8462535eijhc" modified-by="" timestamp="1508469428413"><title>（4）收集</title><children><topics type="attached"><topic id="4frt3mugjstvr9r7al2p2v32m7" modified-by="" timestamp="1513156668042"><title svg:width="500">&lt;R,A&gt; R collect(Collector&lt;? super T,A,R&gt; collector)</title><children><topics type="attached"><topic id="6vqesedet2qnrhcmd4md9pvk57" modified-by="" timestamp="1513156669691"><title svg:width="500">Collector 接口中方法的实现决定了如何对流执行收集的操作&#13;
Collectors 实用类提供了很多静态方法，可以方便地创建常见收集器实例，例如、List，Set,Map</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><title>Lambda表达式与StreamAPI</title></sheet></xmap-revision-content>