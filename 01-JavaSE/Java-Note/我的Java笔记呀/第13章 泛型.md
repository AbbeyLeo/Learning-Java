# 第13章 泛型

# 第13章 泛型

## 13.1 泛型的概述

泛型：参数化类型

类型形参：<T>，<E>，<K>，<V>，<U>，<R>。。。。

类型实参：必须是引用数据类型，不能是基本数据类型

​	<String>，<Integer>，<Student>，<ArrayList<String>>。。。



## 13.2 形式一：泛型类与泛型接口

1、声明语法格式：

```
【修饰符】 class 类名/接口<类型形参列表>{
    
}

【修饰符】 class 类名/接口<类型形参1 extends 父类上限>{
    
}
【修饰符】 class 类名/接口<类型形参1 extends 父类上限 & 父接口上限>{
    
}
```

> 在类名或接口名后面声明的泛型形参类型，可以在当前类或接口中使用，用作声明成员变量、方法的形参、方法的返回值。
>
> 但是不能用于**静态成员**上

2、使用语法格式

在（1）创建泛型类、泛型接口的对象时，为泛型形参指定具体类型

​	（2）在继承泛型类或实现泛型接口时，为泛型形参指定具体类型

示例代码

```java
ArrayList<String> list = new ArrayList<String>();

ArrayList<String> list = new ArrayList<>();//JDK1.7之后可以省略

class MyStringArrayList extends ArrayList<String>{
    
}

class Employee implements Comparable<Employee>{
    public int compareTo(Employee e){
        
    }
}

Arrays.sort(数组,  new  Comparator<泛型实参>(){
    public int compare(泛型实参类型  o1, 泛型实参类型  o2){
        
    }
});
```

3、泛型如果没有指定，会被擦除，按照最左边的上限处理，如果没有指定上限，按照Object处理



## 13.3 形式二：泛型方法

1、声明的语法格式

```
【修饰符】 <泛型形参列表>  返回值类型  方法名(【数据形参列表】)【throws 异常列表】{}
【修饰符】 <泛型形参 extends 父类上限 & 父接口上限>  返回值类型  方法名(【数据形参列表】)【throws 异常列表】{}
```

> （1）在方法返回值类型前面声明的泛型形参类型，只能在当前方法中使用，用于表示形参的类型或返回值类型，或方法局部变量的类型，和别的方法无关。
>
> （2）泛型方法可以是静态方法，也可以是非静态方法

2、 使用

当调用方法，会根据具体的数据的实参的类型，来确定泛型实参的类型。



## 13.4 通配符？

（1）?：代表任意引用数据类型

（2）?  extends 上限：代表上限本身或它的子类

（3）? super 下限：代表下限本身或它的父类

例如：

ArrayList<?>：表示可以接受任意类型

```java
ArrayList<?> list = new ArrayList<String>();
ArrayList<?> list = new ArrayList<Integer>();
ArrayList<?> list = new ArrayList<Animal>();
```

ArrayList<? extends 上限>：

```
ArrayList<? extends Person> list = new ArrayList<Person>();
ArrayList<? extends Person> list = new ArrayList<Animal>();//Animal不行，因为Animal是父类
ArrayList<? extends Person> list = new ArrayList<Student>();
ArrayList<? extends Person> list = new ArrayList<Dog>();//Dog也不行
```

ArrayList<? super 下限>：

```java
ArrayList<? super Person> list = new ArrayList<Person>();
ArrayList<? super Person> list = new ArrayList<Animal>();
ArrayList<? super Person> list = new ArrayList<Student>();//Student，因为Student是子类
ArrayList<? super Person> list = new ArrayList<Dog>();//Dog也不行
```

> ArrayList<?>：不能添加元素，除了null
>
> ArrayList<? extends 上限>：不能添加元素，除了null
>
> ArrayList<? super 下限>：可以添加下限或下限子类的对象

## 13.5 Collections工具类

java.util.Collections：工具类，操作集合

（1）public static <T> boolean addAll(Collection<? super T> c, T... elements)

添加elements的几个对象到c集合中。T是elements对象的类型，要求Collection集合的元素类型必须是T或T的父类

（2）public static <T> int binarySearch(List<? extends Comparable<? super T>> list,T key)  

在list集合中用二分查找key的下标，如果存在返回的是合理的下标，如果不存在返回的是一个负数下标   

T是元素的类型，

<? extends Comparable<? super T>>，要求集合的元素必须实现Comparable接口

<? super T>，在实现Comparable接口，可以指定Comparable<类型实参>为T或T的父类。

（3）public static boolean disjoint(Collection<?> c1, Collection<?> c2)

判断c1和c2没有交集就为true

（4）public static <T extends Object & Comparable<? super T>> T max(Collection<? extends T> coll)

求coll集合中最大元素

<T extends Object & Comparable<? super T>>：要求T或T的父类实现Comparable接口

因为找最大值需要比较大小

（5）public static <T extends Comparable<? super T>> void sort(List<T> list) 给list集合排序   

<T extends Comparable<? super T>>：要求T或T的父类实现Comparable接口

（6）public static <T> Collection<T> synchronizedCollection(Collection<T> c)

以synchronizedXX开头的方法，表示把某种非线程安全集合转为一个线程安全的集合。

（7）public static <T> List<T> unmodifiableList(List<? extends T> list)

以unmodifiableXx开头的方法，表示返回一个“只读”的集合。