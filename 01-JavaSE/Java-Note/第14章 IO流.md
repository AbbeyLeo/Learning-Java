第14章 IO流

# 第14章 IO流

## 14.1 java.io.File类

它是文件和目录路径名的抽象描述。

API：

（1）getName()：获取文件或目录的名称

（2）getPath()：获取文件或目录的路径

（3）getAbsolutePath()：获取文件或目录的绝对路径

（4） getCanonicalPath()：获取文件或目录的规范路径

（5）long length()：获取文件的长度，单位字节

（6）long lastModified()：最后修改时间，单位毫秒

（7）String getParent()：获取上级或父目录

​          File getParentFile()：获取上级或父目录

（8）isFile()：判断是否是文件，当且仅当是文件并且是存在的，才会true

（9）isDirectory()：判断是否是目录，当且仅当是目录并且存在的，才会true

（10）exists()：是否存在

（11）isHidden()：是否隐藏

（12）canWrite()：是否可写

（13）canRead()：是否可读

（14）String[] list()：获取下一级

​	    File[]  listFiles()：获取下一级

​             File[] listFiles(FileFilter f)：获取下一级，但是会过滤掉一下文件和目录

（15）createNewFile()：创建文件

​            createTempFile(String prefix, String suffix)

（16）mkdir()：创建一级目录，如果父目录不存在，就失败，但是不报异常

​            mkdirs()：创建多级目录

（17）delete()：删除文件或空目录

（18）renameTo(File f)：重命名文件或目录



## 14.2 IO流的四大抽象基类

1、四大超类

（1）InputStream：字节输入流

（2）OutputStream：字节输出流

（3）Reader：字符输入流

（4）Writer：字符输出流



2、分类

（1）按照方向分：输入流和输出流

（2）按照处理的方式不同：字节流和字符流

字符流只能处理纯文本的数据（使用范围很窄）

（3）按照角色不同：节点流和处理流

处理流是建立在节点流的基础上的，处理流需要包装一个节点流的对象。

处理流也可以包装另外一个处理流。

> 其实JDK中IO体系是用到了一个装饰者设计模式



3、API

（1）InputStream：

int read()：一次读取一个字节，返回的是本次读取的字节的值，如果流末尾返回-1

int read(byte[] data)：一次读取多个字节，读取的数据存储到data字节数组中，最多读取data.length个字节，返回的是实际本次读取的字节的个数，如果流末尾返回-1。从data[0]开始存储。

int read(byte[] data,int offset, int len)：一次读取多个字节，读取的数据存储到data字节数组中，最多读取len个字节，返回的是实际本次读取的字节的个数，如果流末尾返回-1。从data[offset]开始存储。

void close()：关闭



（2）OutputStream：

void write(int data)：一次写一个字节

void write(byte[] data)：一次写整个字节数组

void write(byte[] data, int offset, int len)：一次字节数组的一部分，从[offset]开始，一共len个

void close()：关闭

void flush()：刷新



（3）Reader：

int read()：一次读取一个字符，返回的是本次读取的字符的Unicode值，如果流末尾返回-1

int read(char[] data)：一次读取多个字符，读取的数据存储到data字符数组中，最多读取data.length个字符，返回的是实际本次读取的字符的个数，如果流末尾返回-1。从data[0]开始存储。

int read(char[] data,int offset, int len)：一次读取多个字符，读取的数据存储到data字符数组中，最多读取len个字符，返回的是实际本次读取的字符的个数，如果流末尾返回-1。从data[offset]开始存储。

void close()：关闭



（4）Writer

void write(int data)：一次写一个字符

void write(char[] data)：一次写整个字符数组

void write(char[] data, int offset, int len)：一次字符数组的一部分，从[offset]开始，一共len个

void write(String str)：一次写整个字符串

void write(String str, int offset, int count)：一次写字符串的一部分，从[offset]开始，一共count个

void close()：关闭

void flush()：刷新



## 14.3 文件IO流

1、类型

FileInputStream：文件字节输入流，可以读取任意类型的文件

FileOutputStream：文件字节输出流，可以把字节数据输出到任意类型的文件

FileReader：文件字符输入流，只能读取纯文本的文件。按照平台默认的字符编码进行解码。

FileWriter：文件字符输出流，只能把字符数据输出到纯文本文件。按照平台默认的字符编码进行编码。



2、读写文件的代码

示例代码：

```java
public void copy(File src, File dest)throws IOException{
    //选择IO流
    FileInputStream fis = new FileInputStream(src);
    FileOutputStream fos = new FileOutputStream(dest);
    
    //读写
    byte[] data = new byte[1024];
    while(true){
        int len = fis.read(data);
        if(len==-1){
            break;
        }
        fos.write(data,0,len);
    }
    
    //关闭
     fis.close();
    fos.close();
}
```

## 14.4 缓冲IO流

1、分为

BufferedInputStream：字节输入缓冲流，给InputStream系列IO流增加缓冲效果
BufferedOutputStream：字节输出缓冲流，给OutputStream系列IO流增加缓冲效果
BufferedReader：字符输入缓冲流，给Reader系列IO流增加缓冲效果

> String readLine()：按行读取

BufferedWriter：字符输出缓冲流，给Writer系列IO流增加缓冲效果

> void newLine()：输出换行符



2、默认的缓冲区的大小是8192 = 1024 * 8（字节/字符）

3、可以给读写的过程提高效率

> 不仅仅是可以给文件IO流增加缓冲效果，可以给任意符合对应类型的IO流增加缓冲效果。

示例代码：

```java
	public void copyBuffer(File src, File dest)throws IOException{
	    //选择IO流
	    FileInputStream fis = new FileInputStream(src);
	    FileOutputStream fos = new FileOutputStream(dest);
	    
	    //BufferedInputStream只能给FileInputStream增加缓冲效果，读的过程加快了
	    BufferedInputStream bis = new BufferedInputStream(fis);//fis在里面，bis在外面，fis比喻成内衣，bis比喻成外套
	    
	    //BufferedOutputStream只能FileOutputStream增加缓冲效果，写的过程加快了
	    BufferedOutputStream bos = new BufferedOutputStream(fos);
	    
	    //数据流向：src-->fis-->bis（从fis先缓冲到bis）-->data-->bos（从data缓冲到bos中）-->fos-->dest
	    
	    //读写
	    byte[] data = new byte[1024];
	    while(true){
	        int len = bis.read(data);
	        if(len==-1){
	            break;
	        }
	        bos.write(data,0,len);
	    }
	    
	    //关闭
	    //关闭比喻成脱衣服
	    bos.close();
        fos.close();
        
	    bis.close();//先脱外套，再脱内衣
	    fis.close();	    
	}
```

## 14.5  编码与解码的IO流（转换流）

1、编码：OutputStreamWriter

​	可以把字符流转为字节流输出，并且在转换的过程中，可以指定字符编码。

2、解码：InputStreamReader

​	可以把字节输入流转为字符输入流，并且在转换的过程中，可以指定字符编码。

3、示例代码：解码（文件是GBK，当前平台是UTF-8）

```java
	@Test
	public void test4()throws IOException{
		//因为这里想要用在程序中按照“指定”的编码方式进行解码，而不是按照平台“默认的”编码方式进行解码
		//所以，我这里仍然用FileInputStream字节流，把文件编码后的数据，原样读取
		//从文件到FileInputStream fis内存的过程中，先不解码
		//因为如果选择FileReader，从文件到FileReader的过程中，就已经按照平台“默认的”编码方式解码好了，我们无法控制
		
		FileInputStream fis = new FileInputStream("d:/File类概述.txt");
		//我要使用InputStreamReader，把FileInputStream转为字符流
//		InputStreamReader isr = new InputStreamReader(fis);//如果没有指定，还是按照默认的编码方式
		InputStreamReader isr = new InputStreamReader(fis,"GBK");//如果指定，就按照指定的编码方式解码
		
		//文件-->fis（字节流）-->解码-->isr（字符流）-->br ->读取的是字符
		//字符流，要么按照char[]读取，要么可以用BufferedReader包装按行读取
		BufferedReader br = new BufferedReader(isr);
		String line;
		while((line = br.readLine()) !=null){
			System.out.println(line);
		}
		
		br.close();
		isr.close();
		fis.close();
	}
```

4、示例代码：编码（文件是GBK，当前平台是UTF-8）

```java
	@Test
	public void test3()throws IOException{
		String hua = "File类可以使用文件路径字符串来创建File实例";
		
		//因为想要用在程序中进行编码，所以这里选用FileOutputStream
		FileOutputStream fos = new FileOutputStream("d:/File类概述.txt",true);
		
		//这里xx，想要直接操作字符串，那么必须是字符流，而fos是字节流，无法直接操作字符串
//		xx.write("\r\n");
//		xx.write(hua);
		
		//数据流向：内存 --> osw （字符流）-->在写入fos过程中进行编码-->fos（字节流）-->文件
		
		OutputStreamWriter osw = new OutputStreamWriter(fos,"GBK");
		osw.write("\r\n");
		osw.write(hua);
		
		osw.close();
		fos.close();
	}
```

## 14.6 数据IO流

1、类型

DataInputStream：允许应用程序以与机器无关方式从底层输入流中读取基本 Java 数据类型。
DataOutputStream：允许应用程序以适当方式将基本 Java 数据类型写入输出流中。

> 它俩必须配对使用
>
> 读的顺序要与写的顺序一致



2、API

| DataOutputStream                   | DataInputStream       |
| ---------------------------------- | --------------------- |
| writeInt(xx)：输出int类型整数      | int readInt()         |
| writeDouble(xx)：输出double类型    | double readDouble()   |
| writeBoolean(xx)                   | boolean readBoolean() |
| writeLong(xx)                      | long readLong()       |
| writeChar(xx)                      | char readChar()       |
| writeByte(xx)                      | byte readByte()       |
| writeShort(xx)                     | short readShort()     |
| writeFloat(xx)                     | float readFloat()     |
| writeUTF(String str)：输出字符串的 | String readUTF()      |

## 14.7 对象IO流

1、类型

ObjectOutputStream：对象序列化，输出对象，把对象转为字节序列输出

ObjectInputStream：对象反序列化，读取对象，把字节序列重构成Java对象

2、API

ObjectOutputStream：writeObject(对象)

ObjectInputStream：Object  readObject()

3、序列化需要注意哪些内容？

（1）所有要序列化的对象的类型都必须实现java.io.Serializable接口

> 如果对象的属性类型也是引用数据类型，那么也要实现java.io.Serializable接口

（2）希望类的修改对象反序列化不产生影响，那么我们最后能够增加一个序列化版本ID

> private static final long serialVersionUID = 1L;

（3）如果有些属性不想要序列化，可以加transient

（4）如果某个属性前面有static修饰，也不参与序列化

4、除了Serializable接口之外，还可以实现java.io.Externalizable接口，但是要求重写：

void readExternal(ObjectInput in) 
void writeExternal(ObjectOutput out)

  关于哪些属性序列化和反序列化，由程序员自己定。

## 14.8 其他的IO流相关内容

1、如果要实现按行读取，可选择什么类型？

BufferedReader：String readLine()

Scanner：String nextLine()

2、如果要按行输出，可以选择什么类型？

（1）自己处理\r\n

（2）BufferedWriter：newLine()

（3）PrintStream和PrintWriter：println()



## 14.9 JDK1.7之后引入新try..catch

语法格式：

```java
try(需要关闭的资源对象的声明){
    业务逻辑代码
}catch(异常类型 e){
    处理异常代码
}catch(异常类型 e){
    处理异常代码
}
....
```

它没有finally，也不需要程序员去关闭资源对象，无论是否发生异常，都会关闭资源对象

示例代码：

```java
	@Test
	public void test03() {
		//从d:/1.txt(GBK)文件中，读取内容，写到项目根目录下1.txt(UTF-8)文件中
		try(
			FileInputStream fis = new FileInputStream("d:/1.txt");
			InputStreamReader isr = new InputStreamReader(fis,"GBK");
			BufferedReader br = new BufferedReader(isr);
			
			FileOutputStream fos = new FileOutputStream("1.txt");
			OutputStreamWriter osw = new OutputStreamWriter(fos,"UTF-8");
			BufferedWriter bw = new BufferedWriter(osw);
		){
			String str;
			while((str = br.readLine()) != null){
				bw.write(str);
				bw.newLine();
			}
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
```

#