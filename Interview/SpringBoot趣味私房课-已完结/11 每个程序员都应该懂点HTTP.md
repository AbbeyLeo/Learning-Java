**11 每个程序员都应该懂点HTTP**

11 每个程序员都应该懂点HTTP

更新时间：2020-05-26 11:46:24

![img](http://img4.sycdn.imooc.com/5e9cfff60001702d06400359.jpg)

![img](http://www.imooc.com/static/img/column/bg-l.png)![img](http://www.imooc.com/static/img/column/bg-r.png)

机会不会上门来找人，只有人去找机会。

——狄更斯

![图片描述](http://img1.sycdn.imooc.com/5e9ac1310001bc3712000630.jpg)

说起 HTTP 有这样一个现象：前端觉得这应该是后端掌握的知识，后端觉得这应该是前端掌握的知识。对此，HTTP 表示：我招谁惹谁了？那么 HTTP 究竟是谁该掌握的呢？我认为，每个程序员都应该了解 HTTP！



# 1. 简介

我们都知道，HTTP 就是超文本传输协议（ HyperText Transfer Protocol ）的缩写。它是一种关于 `传输` 的协议，既然是传输，那么至少要在两个对象之间进行，在 HTTP 中对应的就是客户端和服务端。两端对应两个动作——请求和响应。客户端向服务端发送请求，服务端根据客户端的请求做出相应的响应。

客户端能够发出请求，服务端能够做出响应才能形成一个完整的 HTTP 通信过程。假如只有客户端没有服务端，发出请求收不到响应，那不成了傻老婆等汉子了吗？假如没有人发送请求，服务端一直在那不停的响应（姑且还把它叫做响应，没有请求其实谈不上响应），又好像一个人站在楼上朝楼下的行人边招手边喊：大爷来玩呀！这两种情况都不太好，只有一个人喊一句：有船吗？另一个回应：船来啦！这样才圆满（ 2 路汽车要发车了，快上车！）。



# 2. 报文

如果你接触过 HTTP 那么对于 `报文` 肯定有所耳闻。HTTP 的报文有两种——请求报文和响应报文。



## 2.1 请求

```http
GET /course/list HTTP/1.1
Host: www.imooc.com
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8

...
```

开头的 `GET` 表示请求的类型， 称为 HTTP 的方法（ method ） 。 随后的 `/course/list` 表示请求的路径 。 最后的 `HTTP/1.1` ，表示本次请求使用的是什么版本的 HTTP 协议。接下来的 `Host` 和 `Accept` 都属于首部字段（ Header ），属于可选字段。空行下面的 `...` 代表实体的主体部分（entity body ）同样是可选内容。

这段请求内容的意思是： 以 GET 方式基于 HTTP 协议 1.1 版本请求访问 [www.imooc.com](http://www.imooc.com/)（慕课网）服务器上的 /course/list（课程列表）页面资源。



## 2.2 响应

```http
HTTP/1.1 200 OK
Server: nginx
Date: Sun, 14 Jul 2019 10:06:09 GMT
Content-Type: text/html; charset=UTF-8
Set-Cookie: imooc_isnew=2; expires=Mon, 13-Jul-2020 10:06:09 GMT; Max-Age=31536000; 
	path=/; domain=.imooc.comcvde=5d231163916b5-41; path=/; domain=.imooc.com

<html>
...
```

开头的 `HTTP/1.1` 与请求报文意义相同。后面的 `200 OK` 表示响应的状态码（ status code ）和原因短语（ reason-phrase ），接下来的 `Date` 、 `Content-Type` 等都属于头部字段。接着以一空行分隔， 之后的内容称为资源实体的主体（ entity body ）。



## 2.3 报文格式

根据上面请求和响应的例子，我们可以知道报文由三部分组成：

- 起始行（请求行、响应行）

  报文的第一行，请求行（请求报文中的起始行）用来说明要做什么，响应行（响应报文中的起始行）用来说明结果如何。

- 首部

  起始行后面有零到多个首部字段，首部字段是 key：value 的方式构成，类似 Java 中的 Map 结构。首部以一个空行作为结束。

- 主体（部分请求方法没有主体）

  空行之后是报文主体，请求主体包含了客户端发给服务器的数据；响应主体则是服务器要返回给客户端的内容。起始行和首部都是文本格式，且其结构都是相对固定的。而主体则不一样，主体中可以包含任何格式的数据（如：文本、图片、音频、视频、其他文件）。

形式如下图所示：

![图片描述](http://img1.sycdn.imooc.com/5e9ac1200001680203200276.png)

> PS：首部和主体之间有一个空行



# 3. 状态码

状态码与原因短语用来描述请求的处理结果，状态码一共有五大类：

| **状态码** | **类别**         | **示例** |
| :--------- | :--------------- | :------- |
| 1xx        | 信息性状态码     | 100      |
| 2xx        | 成功状态码       | 200      |
| 3xx        | 重定向状态码     | 304      |
| 4xx        | 客户端错误状态码 | 404      |
| 5xx        | 服务端错误状态码 | 500      |

目前 1xx 的状态码我们并不常见，原因是对于这类状态码，人们还存在很多争议，所以对其应用非常少。常见状态码包括：200、304、403、404、500 等，



# 4. 安全性&幂等性

安全性和幂等性都是指的 HTTP 方法的特性。安全性指的是不会对服务端造成影响，也就是说如果一个方法是安全的，那么无论怎么请求，服务端都不会因为这个请求而发生变化，简而言之就是只读。幂等性指的是多次请求对服务器造成的影响与第一次请求完全一样。例如调用一个 PUT 方法将用户的年龄设置为 18 ，那么这个方法不论调用多少次，那么它对服务端的影响都是将用户的年龄设置成 18。

下面是我们常用的 HTTP 方法的安全性和幂等性对照表：

| HTTP方法 | 安全性 | 幂等性 | 接口说明           |
| :------- | :----- | :----- | :----------------- |
| GET      | 安全   | 幂等   | 获取资源（Read）   |
| POST     | 不安全 | 非幂等 | 创建资源（Create） |
| PUT      | 不安全 | 幂等   | 更新资源（Update） |
| DELETE   | 不安全 | 幂等   | 删除资源（Delete） |

> 安全性和幂等性依赖于服务端实现，这种方式是一种契约，并不是说将一个删除操作的接口设置为 GET 请求，它依然具备安全性。而是告诉我们对应类型的请求在实现的时候要符合它们的安全性、幂等性的约定。



# 5. 版本

在上面我们介绍报文的时候，你可能已经发现，不管是请求还是响应，里面都有这么一个值—— HTTP/1.1。这个值主要用来说明当前请求/响应使用的是 HTTP 的哪个版本。HTTP 发展至今，也经历了几个版本更迭，一直在进化，在成长。前面示例中用的是目前最为流行的 1.1 版本。除了这个版本，在这个版本之前还有 HTTP/0.9、HTTP/1.0，还有最新的 HTTP/2.0。下面我们一起了解一下这些版本之间的异同吧。



## 5.1 HTTP/0.9

这个版本只能算做一个原型版本，诞生于 1991 年，它非常的简陋，并且存在着严重的设计缺陷。它只支持 GET 请求，没有 Header （也就是我们上面说的首部），它的设计初衷就是为了从服务器获取简单的 HTML 对象。好在后面很快就被 HTTP/1.0 取代了。



## 5.2 HTTP/1.0

到了 HTTP/1.0 算是真正意义上的正式版本了，这个版本设计已经非常良好与完善了，后面也得到了广泛的应用。HTTP/1.0 在之前的基础上增加了 Header、状态码的支持，并且支持更多的 HTTP 方法。还加入了对于多媒体格式的支持，另外还支持了缓存。



## 5.3 HTTP/1.1

HTTP/1.1 是目前应用最广泛的版本了，在 HTTP/1.0 的基础上进行了进一步的完善。该版本最大的变化是引入了持久连接，建立一次连接可以发送多次 HTTP 请求，提高了资源利用率。增加的 PUT、PACTH、DELETE 方法对后来 RESTful 的发展也有一定的促进作用。另外，Header 中还增加了 Host 字段，这使得在同一主机可以提供多个服务。



## 5.4 HTTP/2.0

HTTP/2.0 目前还没有得到广泛的应用，但这也只是时间问题而已。这个版本主要是在性能方面的优化，所有数据都改为二进制传输（之前基本上都是字符串），对于首部内容进行了压缩传输。此外，还增加了双工模式，客户端可以在一个 HTTP 连接中同时发送多个请求，服务端也能同时处理多个请求。HTTP/2.0 还增加了一个新特性——服务器推送（Server Push），即由服务器主动发起的操作，这一特性很适合静态资源（CSS、JS 等）的加载。



# 6. 总结

OK，本小节我们对 HTTP 进行了系统的学习，我们知道了 HTTP 有客户端和服务端，有请求和响应。还了解了 HTTP 的报文和状态码。最后还学习了 HTTP 方法的安全性和幂等性。最后还一起回顾了 HTTP 的各个历史版本，并对每个版本进行了相应的介绍。相信学完这一节，你对于 HTTP 已经有了非常全面的认识，更加细节的内容，让我们在今后的实战中一步一步深入的学习吧！

[10 面向资源编程-RESTful风格](http://www.imooc.com/read/75/article/1806)[12 数据库操作之简单到令人发指的JPA](http://www.imooc.com/read/75/article/1808)

精选留言 2

欢迎在这里发表留言，作者筛选后可公开显示

- [慕慕童鞋](http://www.imooc.com/u/8954842/articles)

  看完就懂了

   0

  回复

  2020-06-25

  - [刘水镜](http://www.imooc.com/u/8840839/articles)

    回复[慕慕童鞋](http://www.imooc.com/u/8954842/articles)

    那太好了

    回复

    2020-06-28 20:27:02

- [草鱼禾](http://www.imooc.com/u/350271/articles)

  PACTH这里写错了，应该是PATCH。

   0

  回复

  2020-05-29

  - [刘水镜](http://www.imooc.com/u/8840839/articles)

    回复[草鱼禾](http://www.imooc.com/u/350271/articles)

    好的，感谢提醒！

    回复

    2020-05-29 21:30:14

 

千学不如一看，千看不如一练