**23 天有不测风云，人有旦夕祸福——异常处理**



23 天有不测风云，人有旦夕祸福——异常处理

更新时间：2020-06-12 13:01:26

![img](http://img1.sycdn.imooc.com/5ebe608d000182ce06400426.jpg)

![img](http://www.imooc.com/static/img/column/bg-l.png)![img](http://www.imooc.com/static/img/column/bg-r.png)

古之立大事者，不唯有超世之才，亦必有坚韧不拔之志。

——苏轼



# 1. 前言

前面两小节我们一起学习了日志相关的知识，我们了解到利用好日志可以让我们快速的定位、解决问题。而我们今天要聊的内容 —— 异常，同样也是我们定位问题的关键依据。相信只要你接触过 Java 那么对于异常就不会陌生，尤其是 Java 中大名鼎鼎的空指针异常 —— NullPointerException（简称 NPE）。Java 也因为空指针问题而饱受诟病，虽然从 Java 8 开始引入了 Optional，但也并没有根除这个问题。

扯远了，下面我们先看看什么是异常：

> 程序在运行过程中，由于某些原因（操作不当或其他外部原因）导致程序执行发生意外，导致程序提前终止。

首先，郑重声明，这不是什么权威的定义，是我对异常的一个简单概括。其实程序中的异常就相当于我们现实生活中的意外。

我们日常生活中会遇到各种意料之外的情况，比如考试忘带准考证，答完题忘记写名字；比如因为交通拥堵导致赶不上火车或者飞机；再夸张一点比如 6500 万年前一颗小行星撞击地球，导致恐龙这个物种从此在地球上消失。对于这些情况，古人们已经总结的非常到位了。下面两句著名的诗词，相信你也耳熟能详了：

> 天有不测风云，人有旦夕祸福。—— 吕蒙正

> 人有悲欢离合，月有阴晴圆缺。—— 苏轼

PS：巧得是，吕蒙正和苏轼都是北宋时期的知识分子。

人生总是充满了未知与不确定性，纵使你智商爆表、智慧超群，也不能掌控一切预测未来；同样的道理，任你代码写得多么无懈可击，系统架构再怎么高可用，也不能阻挡异常的发生。所以，我们要做的不是完全的避免异常的发生。而是当异常发生后，我们如何更优雅的处理，从而降低异常对程序的影响，以及可以及时人工介入解决问题。



# 2. 异常分类

通过上面的内容，我们了解到，异常就是程序执行过程中发生了意外。而这些意外可以按照其严重性以及我们对于意外的处理能力分成不同的类型，下面我们就一起看看异常有哪些类型吧。

![图片描述](http://img1.sycdn.imooc.com/5ebe60bf0001c5cd13950322.png)

Java 中有非常完整的异常机制，所有的异常类型都有一个共同的爸比 ——Throwable。由上图可以看出 Throwable 下面有两个分支一个是 Error（致命异常），另一个是 Exception（非致命异常）。



## 2.1 Error

Error 比较特殊，它有两个声名远播的子类：OutOfMemoryError 和 StackOverflowError。光看这两个子类我们也能知道 Error 不好惹，一旦发生 Error 类型的错误，程序根本无法处理，只能进行人为干预（施展重启大法）。



## 2.2 checked 异常 与 unchecked 异常

Exception 这一分支下面分为了两个类型：checked 异常和 unchecked 异常。



### checked 异常

checked 异常继承自 Exception，需要进行显式处理（try 或者 throws）的异常，否则发生编译错误，IDE 中会有错误提示（下图是 IDEA 中的提示效果）。Java 中的 checked 是一个庞大的家族，除了 RuntimeException 和 Error 以外的类都属于 checked 异常（上图中的 IOException 就是其中一员，下图中的 ClassNotFoundException 也是）。
![图片描述](http://img1.sycdn.imooc.com/5ebe60b10001e3ed04760129.png)



### unchecked 异常

unchecked 异常也是 Exception 下的分支，并且它们全部是 RuntimeException 的子类。这类异常是我们日常开发中真正需要特别关心的（Error 我们的程序处理不了，checked 异常必须按规定处理），而我们在程序中编写的自定义异常，通常来说也应该继承自 RuntimeException（这里需要注意：Spring 的事务管理只有遇到 RuntimeException 的异常是才会回滚）。

需要注意的是，unchecked 异常中有一些异常是我们可以通过编写更健壮的代码来避免的，没错，就是避免，可以做到完全避免。这类异常包括最常见的 NullPointerException、IndexOutOtBoundsException 等，需要避免这类异常的出现并不难，只需要我们在调用对象方法、获取集合元素时先做安全检查即可（比如先判断 person 对象是否为 null，在调用 person.getName () 方法），这需要我们在日常编码中养成好的编码习惯。



# 3. 全局异常处理

上面我们从理论层面对于异常有了很全面的了解，接下来我们就动手实战一下在 Spring Boot 进行全局的异常处理。



## 3.1 全局异常捕获

Spring Boot 中进行全局异常捕获非常简单，其核心就是一个注解 ——@ControllerAdvice/@RestControllerAdvice。两者的区别类似 @Controller 与 @RestControllerAdvice，这里就不过多赘述了。我们直接看代码：

```java
@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(Exception.class)
    public Result handle(Exception e) {
        Result result = new Result();
        result.setCode(MessageEnum.UNKNOW_ERROR.getCode());
        result.setMessage(e.getMessage() == null ? MessageEnum.UNKNOW_ERROR.getMessage() : e.getMessage());
        log.error(e.getMessage(),e);
        return result;
    }

    @ExceptionHandler(ApiException.class)
    public Result handle(ApiException e) {
        Result result = new Result();
        result.setCode(e.getCode());
        result.setMessage(e.getMessage());
        log.error(e.getMessage(),e);
        return result;
    }
}
```

GlobalExceptionHandler 的代码很简单，核心逻辑就是捕获异常，然后将错误信息进行封装，最后以 JSON 格式返回给前端。这里我们只是粗略的对 APIException 和 Exception 进行了分别捕获，实际应用中可以根据自己的情况定制更细化的方案，也就是多加上几个对应不同类型异常的方法而已，So Easy！



## 3.2 辅助类

为了让我们的代码更加的优雅，我们需要添加两个辅助类 ——MessageEnum 和 Result。



### 错误消息封装

MessageEnum 类封装了错误信息和错误代码，将它们集中起来统一管理为的是更好的应对将来的变化。假如程序中有 100 处都使用了 “操作成功！” 这句话作为 message 的话，我们就要写 100 遍。而当有一天，产品经理说，四个字太多了，我们直接改成 “成功！”，这样简洁。那你就需要将那 100 个 “操作成功！” 改成 “成功！”，想想都崩溃了。

```java
public enum MessageEnum {
    UNKNOW_ERROR(-1, "未知错误！"),
    ERROR(500, "系统错误"),
    SUCCESS(0, "操作成功！"),
    ;
    private Integer code;
    private String message;

    public Integer getCode() {
        return code;
    }

    public String getMessage() {
        return message;
    }

    MessageEnum(Integer code, String message) {
        this.code = code;
        this.message = message;
    }
}
```

集中管理的好处显而易见，产品经理提出上面的需求，只需要在这个类中去掉两个字就搞定了。



### 接口返回值统一结构

Result 类的作用是让我们的接口返回值变得更加优雅，不管什么接口返回值都是三大件：code、message 和 业务数据。

```java
public class Result<T> {

    private Integer code;

    private String message;

    private T data;

    public static Result sucess() {
        return sucess(null);
    }

    public static Result sucess(Object data) {
        Result result = new Result();
        result.setMessage(MessageEnum.SUCCESS.getMessage());
        result.setCode(MessageEnum.SUCCESS.getCode());
        result.setData(data);
        return result;
    }

    public static Result error(Integer code, String message) {
        Result result = new Result();
        result.setMessage(message);
        result.setCode(code);
        return result;
    }


    // getter and setter
    ......
      
}
```



## 3.3 异常接口

做好上面的准备工作，下面只需要编写几个抛出异常的接口来测试一下效果了。

```java
@Api
@RestController
@RequestMapping("/exception")
public class ExceptionController {

    @GetMapping("/apiexception")
    public Result apiException() {
        throw new ApiException(MessageEnum.ERROR);
    }

    @GetMapping("/runtimeexception")
    public Result runtimeException() {
        throw new RuntimeException();
    }
}
```

发挥你的脑洞，多写几个不同的异常来玩玩吧。



# 4. 一点感悟

我经常暗自庆幸自己阴差阳错学了计算机专业，毕业后也一直在做与编程相关的事情。嗯？不都说程序员苦逼吗？咋你还庆幸呢？原因有很多，其中一个就是在编程的路上我总能收获一些意外之喜。就拿我们今天聊的异常处理来说吧，Error 类型是程序无法左右的，遇上了就只能接受，没有别的办法；而 checked 异常则是程序必须处理的异常，不处理程序就无法运行；还有像 NullPointerException 这类的异常，则是完全可以通过良好的编码习惯彻底规避掉的。

看起来是新的知识，但仔细想想这不就是我们的人生吗？在我们的生命中，有些事是我们根本无法左右的（天灾人祸、生老病死），有些事情是遇到后必须处理的（比如女朋友要求我们做的事情），有些事是完全可以避免的（上课迟到、与家人因小事产生的争吵）。

真的是人生如码，码如人生！



# 5. 总结

OK，这一节我们学习了什么是异常、异常的分类以及如何在 Spring Boot 中进行全局异常处理。最后还小小的感悟了一下人生。最后抛出一个思考题 —— 做全局异常处理的意义何在，现实中的你需要全局异常处理吗？

[22 软件系统的“黑匣子”——日志（二）](http://www.imooc.com/read/75/article/1818)[24 一个五星级公厕的故事讲明白定时任务的三种模式](http://www.imooc.com/read/75/article/1820)

精选留言 3

欢迎在这里发表留言，作者筛选后可公开显示

- [hwl_01](http://www.imooc.com/u/2198631/articles)

  checked异常只包含Exception下非RuntimeException下面的异常类，不包含Error类下面的吗？

   0

  回复

  2020-06-10

  - [刘水镜](http://www.imooc.com/u/8840839/articles)

    回复[hwl_01](http://www.imooc.com/u/2198631/articles)

    按定义来说，Error 不属于异常，异常专指 Exception 及其子类。可以参考这里：https://www.runoob.com/java/java-exceptions.html

    回复

    2020-06-11 23:21:31

  - [刘水镜](http://www.imooc.com/u/8840839/articles)

    回复[hwl_01](http://www.imooc.com/u/2198631/articles)

    在《Java 核心技术卷》中，将 Error 归为了 unchecked 异常。而在《Effective Java》中，则认为 Error 不属于 unchecked 异常。

    回复

    2020-06-12 01:33:17

- [hwl_01](http://www.imooc.com/u/2198631/articles)

  uncharted 异常 这儿拼错了哦，老师。

   0

  回复

  2020-06-10

  - [刘水镜](http://www.imooc.com/u/8840839/articles)

    回复[hwl_01](http://www.imooc.com/u/2198631/articles)

    收到，感谢提醒。

    回复

    2020-06-11 22:54:54

- [weixin_慕雪0583377](http://www.imooc.com/u/7735904/articles)

  全局异常让我们大胆的去throw，不在想着掩耳盗铃，也拒绝了套娃式的try catch。另外一些业务规则（譬如查无结果），发现有些人也总是喜欢用异常的来处理，在我看来这是有问题的，不知老师怎么看？全局异常处理某种意义上有点像java的垃圾回收，我们需要jvm，我们始终是长不大的小孩子啊→_→

   0

  回复

  2020-06-05

  - [刘水镜](http://www.imooc.com/u/8840839/articles)

    回复[weixin_慕雪0583377](http://www.imooc.com/u/7735904/articles)

    根据业务规则抛异常，只要业务合理就没什么问题。全局异常和垃圾回收有哪些相似之处呢？

    回复

    2020-06-08 22:46:23

 

千学不如一看，千看不如一练