**22 软件系统的“黑匣子”——日志（二）**

22 软件系统的“黑匣子”——日志（二）

更新时间：2020-05-26 11:53:25

![img](http://img2.sycdn.imooc.com/5ebe603e00018a7906400419.jpg)

![img](http://www.imooc.com/static/img/column/bg-l.png)![img](http://www.imooc.com/static/img/column/bg-r.png)

没有智慧的头脑，就像没有蜡烛的灯笼。

——托尔斯泰



# 1. 前言

上一节我们从理论层面学习了日志的相关知识，了解了日志的重要意义，那么这一小节我们就该动手实践一下啦！在动手之前我们需要了解一下市面上有哪些日志框架可以使用，以及它们各自的特点，知己知彼才能选择一款最适合自己的，下面我们就一起来看看常见的日志框架都有哪些吧！



# 2. 常见日志框架

日志框架中其实还有两个更细的分类——日志门面和日志实现。如果你了解设计模式，对于门面这个词你应该不会感到陌生，就是 facade 模式。如果你不了解设计模式那么你可以将日志门面理解为日志的接口框架，是对日志输出定义了一套标准，可以配合相应的日志实现框架一起使用。

**日志门面**

- JCL
- SLF4J

**日志实现**

- Log4j
- Log4j2
- Logback
- J.U.L



## 2.1 JCL

JCL（Jakarta commons-logging）是 Apache 出品的一款日志门面框架，于 2005 年面世，到 2014 年已经不再更新了。



## 2.2 SLF4J

SLF4J（Simple Logging Facade For Java）由于 SLF4J（艾斯 艾楼 艾福 for J） 读起来太费劲，所以我更喜欢称呼它为 `水立方`（**S**hui **L**i **F**ang），是 Ceki 大佬写的一个日志门面框架。当年他觉得 Apache 的 commons-logging 写得不够好，于是乎就自己动手写了“水立方”，有技术就是任性，一言不合就写一个框架玩。“水立方”目前还在不断更新和维护中。



## 2.3 Log4J

Log4J 很多人应该都听过或者用过，非常经典的日志框架。其作者与 SLF4J 也是 Ceki，后来托管给了 Apache，目前也不再更新了。



## 2.4 Log4J2

看到 Log4J2 的名字你可能会说，肯定又是 Ceki 写的，是 Log4J 的升级版。巧了，还真不是！非要将它俩扯上点关系，那我只能说它们是「不同父且异母」的亲兄弟了（因为除了名字真的就没啥关系了）。Log4J2 出品自 Apache，与 Log4J 除了名字像以外，其他的连根毛都不一样。



## 2.5 Logback

Logback 才是 Log4J 的一奶同胞，同样出自 Ceki 之手。当初作者觉得老大不好，直接选择了生二胎。都是亲儿子不能这样呀！不过话说回来 Logback 也确实优秀，目前 Spring Boot 也选择了它作为默认的日志框架。



## 2.6 J.U.L

JUL 是 Java 原生的日志，从 1.4 版本开始引入，功能过于简陋，这里拿出来说一下，是因为毕竟是 JDK 中自带的，了解一下就好。



# 3. 选择

通过上面的简单了解，我们需要在门面和实现中各选一个组合起来使用。直接给出结果吧，我们选择 SLF4J + Logback 的组合，原因如下：

- 同根同源配合默契
- Spring Boot 的默认组合，权威验证



# 4. 配置

在 Spring Boot 中日志的配置有两种方式，一种是直接在 application.yml 文件中配置；另一种是在外置 logback-spring.xml 文件中进行配置。在修改配置之前，我们先看一下默认情况下的日志输出格式：

```
2019-11-19 21:54:34.041  INFO 1768 --- [nio-8080-exec-1] c.i.s.log.controller.LogController       : log level info
```

可以看到默认情况下一条日志是由以下几部分组成的：

- 日期时间
- 日志级别
- 进程 ID
- — 分隔符
- [xxx] 线程名
- 类路径
- 日志消息



## 4.1 application.yml 方式

接下来我们在 application.yml 文件中进行一些简单的配置：

```yaml
logging:
  pattern:
    console: "%d - %m%n"
```

然后再来看一下输出效果：

```
2019-11-19 22:25:59,015 - log level info
```

可以看到我们的配置生效了，现在是按照我们的配置格式打印的日志。

application.yml 文件中适合比较简单的配置，日志相关的配置项如下图所示：

![图片描述](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)



## 4.2 logback-spring.xml 方式

如果你有更多样的配置需求，那么就需要使用外置 XML 文件的配置方式了。我们来看一个详细的配置示例：

```xml
<?xml version="1.0" encoding="UTF-8" ?>

<configuration>

    <!-- 日志文件存放路径-->
    <property name="PATH" value="/var/logs"/>

    <!-- 彩色日志依赖的渲染类 -->
    <conversionRule conversionWord="clr" converterClass="org.springframework.boot.logging.logback.ColorConverter"/>
    <conversionRule conversionWord="wex"
                    converterClass="org.springframework.boot.logging.logback.WhitespaceThrowableProxyConverter"/>
    <conversionRule conversionWord="wEx"
                    converterClass="org.springframework.boot.logging.logback.ExtendedWhitespaceThrowableProxyConverter"/>
    <!-- 彩色日志格式 -->
    <property name="CONSOLE_LOG_PATTERN"
              value="${CONSOLE_LOG_PATTERN:-%clr(%d{yyyy-MM-dd HH:mm:ss.SSS}){faint} %clr(${LOG_LEVEL_PATTERN:-%5p}) %clr(${PID:- }){magenta} %clr(---){faint} %clr([%15.15t]){faint} %clr(%-40.40logger{39}){cyan} %clr(:){faint} %m%n${LOG_EXCEPTION_CONVERSION_WORD:-%wEx}}"/>
    <!-- 文件日志格式 -->
    <property name="FILE_LOG_PATTERN"
              value="%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} -%msg%n"/>

    <!-- 控制台输出配置-->
    <appender name="console" class="ch.qos.logback.core.ConsoleAppender">
        <!--日志输出格式-->
        <layout class="ch.qos.logback.classic.PatternLayout">
            <pattern>
                ${CONSOLE_LOG_PATTERN}
            </pattern>
        </layout>
    </appender>

    <!-- INFO 级别日志文件输出配置-->
    <appender name="info" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <!--按级别过滤日志，只输出 INFO 级别-->
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <level>INFO</level>
            <onMatch>ACCEPT</onMatch>
            <onMismatch>DENY</onMismatch>
        </filter>
        <!--当天日志文件名-->
        <File>${PATH}/info.log</File>
        <!--按天分割日志文件-->
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <!--历史日志文件名规则-->
            <fileNamePattern>${PATH}/info.log.%d{yyyy-MM-dd}.%i</fileNamePattern>
            <!--按大小分割同一天的日志-->
            <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
                <maxFileSize>100MB</maxFileSize>
            </timeBasedFileNamingAndTriggeringPolicy>
            <!--日志文件保留天数-->
            <maxHistory>30</maxHistory>
        </rollingPolicy>
        <!--日志输出格式-->
        <layout class="ch.qos.logback.classic.PatternLayout">
            <Pattern>${FILE_LOG_PATTERN}</Pattern>
        </layout>
    </appender>

    <!-- ERROR 级别日志文件输出配置-->
    <appender name="error" class="ch.qos.logback.core.rolling.RollingFileAppender">
        ......
    </appender>
    
    <!--日志级别-->
    <root level="info">
        <appender-ref ref="console"/>
        <appender-ref ref="info"/>
        <appender-ref ref="error"/>
    </root>

</configuration>
```

我们配置了日志的输出路径，日志的输出格式，日志的滚动分割规则、保留时间和日志文件大小，还将不同级别的日志分别输出到相应的日志文件中。这已经算得上是一个比较完整的配置了，当然还可以加上针对不同环境使用不同的策略配置，这里给你留一个自己探索的空间。



## 4.3 日志格式变量介绍

- **%level**：表示输出日志级别 ；
- **%date**：表示日志发生时的时间，可缩写为 %d；
- **%logger**：用于输出 Logger 的类路径，包名＋类名，｛n｝限定了输出长度，如果输出长度不够，尽可能显示类名、压缩包名；
- **%thread**：当前线程名；
- **%M**：日志发生时的方法名字；
- **%L**：日志调用所在代码行，线上运行时不建议使用此参数，因为获取代码行对性能有消耗；
- **%m**：日志、消息；
- **%n**：日志换行。



# 5. 规范



## 5.1 使用日志门面

不要直接使用日志实现（ Log4j、 Logback 等） 中的 API，应该使用日志门面框架 SLF4J 中的 API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。



## 5.2 使用占位符

不要使用以下这种字符串拼接的方式打印日志：

```java
log.info("username: " + username + " IP: "+ ip + "platform: " + platform);
```

原因：

- 可读性差，变量越多会越差
- 当日志级别为 WARN 或 ERROR 时，该日志不打印，但仍然会进行字符串拼接，浪费资源。

应该使用如下占位符方式：

```java
log.info("username: {} IP: {} platform: {}", username, ip, platform);
```



## 5.3 完整的堆栈信息

当发生异常时要将完整的堆栈信息打印出来，这样才能更准确的定位问题，而下面这种方式只会打印基本的错信息，比如只会告诉你发生了空指针，但你根本不知道发生在了哪里。

```java
log.error("xxx错误：{}", e.getMessage());
```

正确的姿势：

```java
log.error("xxx错误：{}", e.getMessage(), e);
```



## 5.4 日志最少保存两周以上

日志文件至少保存 15 天，因为有些异常具备以“周”为频次发生的特点。



## 5.5 禁止 System.out.println

System.out.println 只会将内容打印到控制台，不会输出到文件中。e.printStackTrace() 也是相同的效果。



## 5.6 正确的使用日志级别

正确合理的使用相应的日志级别打印相应的信息（日志级别的相关介绍参考上一节），如果程序发生了异常却使用 INFO 级别打印日志，那么在排查问题时会增加不必要的障碍。



## 5.7 使用 @Slf4j

推荐使用 Lombok 框架的 @Slf4j 注解开启日志，减少样板代码的编写提升效率，还能避免书写错误导致的问题。

> 以上七条规范是我觉得比较重要的点，为你提供一个参考，你可以在此基础上不断的进行完善。



# 6. 总结

OK，通过这两个小节的学习，不管是理论层面还是动手实战，对于日志的相关知识你已经掌握的差不多了。后面多多动手练习，假以时日就可以信手拈来了。

程序中的日志记录的程序运行的轨迹与状态，可以帮助我们很好的对程序进行分析与优化。你有没有想过为自己的人生也加上日志呢？这样一来岂不是可以更好的掌控自己的人生了吗？嗯？怎么给自己的人生加日志？答案很简单就是——写东西。没错，就是写东西，随便写，可能你会说，自己写的不好，不知道写什么，写完也没有人看… 等等。

1，莫言也不是一生下来就能拿诺贝尔奖的，谁都是从写不好开始的

2，可以从写学习咱们这个专栏的笔记开始

3，只要你敢把你写的贴在评论里，我就敢看，不信你试试

最后，将我很喜欢的一句话送给你：

> 写东西就是用文字整理自己的生命 —— 席慕蓉

是时候打印你的人生了！

[21 软件系统的“黑匣子”——日志（一）](http://www.imooc.com/read/75/article/1817)[23 天有不测风云，人有旦夕祸福——异常处理](http://www.imooc.com/read/75/article/1819)

精选留言 2

欢迎在这里发表留言，作者筛选后可公开显示

- [慕田峪4063386](http://www.imooc.com/u/6226285/articles)

  接下来好好研究日志

   0

  回复

  2020-06-11

  - [刘水镜](http://www.imooc.com/u/8840839/articles)

    回复[慕田峪4063386](http://www.imooc.com/u/6226285/articles)

    加油加油！

    回复

    2020-06-12 20:59:49

- [慕仔7214391](http://www.imooc.com/u/7485583/articles)

  老师，这么么配置文件怎么记得住？开发中配置是自己写的吗？

   0

  回复

  2020-05-21

  - [刘水镜](http://www.imooc.com/u/8840839/articles)

    回复[慕仔7214391](http://www.imooc.com/u/7485583/articles)

    这些配置是不需要主动去记住的，用到的时候查阅文档就行了。然后用得多了以后，常用的自然就记住了。没必要专门去记这些东西。

    回复

    2020-05-21 21:22:49

 

千学不如一看，千看不如一练

 