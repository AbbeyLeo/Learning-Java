**30 掰开揉碎刨铣自动配置的原理**

30 掰开揉碎刨铣自动配置的原理

更新时间：2020-05-29 09:54:00

![img](http://img1.sycdn.imooc.com/5ebe62ab00018f1106400426.jpg)

![img](http://www.imooc.com/static/img/column/bg-l.png)![img](http://www.imooc.com/static/img/column/bg-r.png)

立志是事业的大门，工作是登堂入室的旅程。

——巴斯德

# 1. 前言

书接上文，上一节中我们一起分析了 Spring Boot 的启动流程，最后还挖了一个坑，这一节就来把坑填上。上一节我们剩下了 `refreshContext()` 没有讲，我们接下来要说的内容都跟它有着紧密的联系，不过我们不会以它为入口，而是从 `@SpringBootApplication` 注解开始。

> 至于自动配置和 `refreshContext()` 有什么联系，留个悬念，看看你能不能发现。

# 2. 自动配置原理

上一节我们从 run () 方法切入，分析了 Spring 容器的启动流程。今天我们拿 `@SpringBootApplication` 注解开刀，我们来看看这个注解为我们做了什么。先看它的源码：

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),
		@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })
public @interface SpringBootApplication {
	......
}
```

可以看到，`@SpringBootApplication` 是一个组合注解。除了最上面的几个元注解以以外，还有三个 Spring 的注解：

- `@SpringBootConfiguration`，表示被注解的元素为一个 Spring Boot 配置类
- `@EnableAutoConfiguration`，负责开启自动配置的注解，这一小节最靓的仔
- `@ComponentScan`，用于配置扫描的包路径

## 2.1 关键点

我们重点关注 `@EnableAutoConfiguration`，我们继续深入源码：

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@AutoConfigurationPackage
@Import(AutoConfigurationImportSelector.class)
public @interface EnableAutoConfiguration {
	......
}
```

`@Import` 注解和 `AutoConfigurationImportSelector` 类是我们需要特别关注的。先剧透一下结论：自动配置的工作就是在 `AutoConfigurationImportSelector` 类中完成的。通过 `getAutoConfigurationEntry` 方法得到一个需要自动配置的列表：

```java
protected AutoConfigurationEntry getAutoConfigurationEntry(
    AutoConfigurationMetadata autoConfigurationMetadata,
    AnnotationMetadata annotationMetadata) {
    if (!isEnabled(annotationMetadata)) {
        return EMPTY_ENTRY;
    }
    AnnotationAttributes attributes = getAttributes(annotationMetadata);
    // 得到一个包含 118 个元素的列表
    List<String> configurations = getCandidateConfigurations(annotationMetadata,
                                                             attributes);
    configurations = removeDuplicates(configurations);
    Set<String> exclusions = getExclusions(annotationMetadata, attributes);
    checkExcludedClasses(configurations, exclusions);
    // 这里会删除我们手动关闭的自动配置项
    configurations.removeAll(exclusions);
    // 过滤掉不需要自动配置的项
    configurations = filter(configurations, autoConfigurationMetadata);
    fireAutoConfigurationImportEvents(configurations, exclusions);
    return new AutoConfigurationEntry(configurations, exclusions);
}
```

`getCandidateConfigurations` 方法会获取到 Spring 预设的自动配置列表，共 118 个，这个列表的名单就放在 `spring-boot-autoconfigure-x.x.x.RELEASE.jar` 包中的 `/META-INF/spring.factories` 文件中。如果我们手动配置了需要关闭的自动配置，那么会通过 `configurations.removeAll(exclusions)` 将其从列表中移除。最后通过 filter 方法过滤掉不需要自动配置的项，最终会得到一个包含所有需要自动配置项的列表。

## 2.2 拆解

### 获取预设自动配置列表

`AutoConfigurationImportSelector` 类通过调用 `SpringFactoriesLoader` 的 `loadFactoryNames()` 方法来读取 spring.factories 文件中的 `key（org.springframework.boot.autoconfigure.EnableAutoConfiguration）`来加载 Spring 预设的自动配置列表。

读取 spring.factories 文件的源码示例：

```java
public final class SpringFactoriesLoader {
    // spring.factories 文件路径
    public static final String FACTORIES_RESOURCE_LOCATION = "META-INF/spring.factories";
    ......
        
    public static List<String> loadFactoryNames(Class<?> factoryClass, @Nullable ClassLoader classLoader) {
		String factoryClassName = factoryClass.getName();
        // 调用真正读取 spring.factories 文件的方法
		return loadSpringFactories(classLoader).getOrDefault(factoryTypeName, Collections.emptyList());
	}

	private static Map<String, List<String>> loadSpringFactories(@Nullable ClassLoader classLoader) {
		......

		try {
            // 读取 spring.factories 文件
			Enumeration<URL> urls = (classLoader != null ?
					classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :
					ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));
			......
		}
		......
	}
    ......
}    
```

### 处理 @Import

分析完 `AutoConfigurationImportSelector` 类，下面来分析 `@Import` 注解。正是因为这个注解，`ImportSelector` 才能处理自动配置的逻辑。`@Import` 的处理逻辑是由 `ConfigurationClassParser` 类完成的，入口是 `doProcessConfigurationClass()` 方法：

```java
class ConfigurationClassParser {
    ......
    protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)
			throws IOException {

		......

		// 处理 @PropertySource 注解
		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(
				sourceClass.getMetadata(), PropertySources.class,
				org.springframework.context.annotation.PropertySource.class)) {
			......
		}

		// 处理 @ComponentScan 注解
		Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(
				sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);
		......

		// 处理 @Import 注解
		processImports(configClass, sourceClass, getImports(sourceClass), filter, true);

		// 处理 @ImportResource 注解
		AnnotationAttributes importResource =
				AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);

		......
	}
    
    ......
        
	private void processImports(ConfigurationClass configClass, SourceClass currentSourceClass,
			Collection<SourceClass> importCandidates, Predicate<String> exclusionFilter,
			boolean checkForCircularImports) {
		......

		if (checkForCircularImports && isChainedImportOnStack(configClass)) {
			......
		}
		else {
			try {
				for (SourceClass candidate : importCandidates) {
                    // 处理 ImportSelector
					if (candidate.isAssignable(ImportSelector.class)) {
						Class<?> candidateClass = candidate.loadClass();
						ImportSelector selector = ParserStrategyUtils.instantiateClass(candidateClass, ImportSelector.class,
								this.environment, this.resourceLoader, this.registry);
                        Predicate<String> selectorFilter = selector.getExclusionFilter();
                        if (selectorFilter != null) {
                            exclusionFilter = exclusionFilter.or(selectorFilter);
                        }
						if (selector instanceof DeferredImportSelector) {
							this.deferredImportSelectorHandler.handle(configClass, (DeferredImportSelector) selector);
						}
						else {
							String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());
							Collection<SourceClass> importSourceClasses = asSourceClasses(importClassNames, exclusionFilter);
                            // 递归调用
							processImports(configClass, currentSourceClass, importSourceClasses, exclusionFilter, false);
						}
					}
					else if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) {
						......
					}
					else {
						processConfigurationClass(candidate.asConfigClass(configClass), exclusionFilter);
					}
				}
			}
			......
		}
	}    
}
```

`doProcessConfigurationClass()` 方法调用 `processImports()` 方法来处理 `@Import` 注解。`processImports()` 方法中又分情况对 `@Import` 注解中的值执行了不同的处理逻辑。当值为 ImportSelector.class（AutoConfigurationImportSelector 是 ImportSelector 的实现类 ） 类型时，还会通过递归再次调用自己。

这段逻辑相对比较复杂，不仅有自我递归，还有多个方法间的 “串联递归”。上面代码中，进入最后一个 else 下面的 `processConfigurationClass()` 方法，你会看到它调用了最上面的 `doProcessConfigurationClass()` 方法，这样就形成了一个调用环： `doProcessConfigurationClass()` ->`processImports()`-> `processConfigurationClass()` -> `doProcessConfigurationClass()`。

### 调用链

整理了一份从 Spring 容器启动一直到自动配置功能完成的方法调用链，可以在看源码或者 Debug 的时候作为参考：

```java
1. SpringApplication
   1. run()
   2. refreshContext()
   3. refresh()
2. AbstractApplicationContext
   1. refresh()
   2. invokeBeanFactoryPostProcessors()
3. PostProcessorRegistrationDelegate
   1. invokeBeanFactoryPostProcessors()
4. ConfigurationClassPostProcessor
   1. postProcessBeanDefinitionRegistry()
   2. processConfigBeanDefinitions()
5. ConfigurationClassParser
   1. parse()
6. ConfigurationClassParser.DeferredImportSelectorHandler
   1. process()
7. ConfigurationClassParser.DeferredImportSelectorGroupingHandler
   1. processGroupImports()
8. ConfigurationClassParser.DeferredImportSelectorGrouping
   1. getImports()
9. AutoConfigurationImportSelector.AutoConfigurationGroup
   1. process()
10. AutoConfigurationImportSelector
    1. getAutoConfigurationEntry()
```

> 第一层级为类，其中还有几个是内部类，用 “.” 和主类隔开了，第二层级为该类下的方法。从上到下按顺序依次调用。

大致的调用关系就是这样，可以当做一个参考，不能保证完全严谨正确，需要注意不同版本可能有些许的出入，如果发现上述顺序有误，欢迎留言交流。

#### 注意

如果你在网上搜索 Spring Boot 自动配置，你会发现很多文章的入手点是 `AutoConfigurationImportSelector.selectImports()`。那么他的文章是基于 Spring Boot 2.1.0 之前的版本。

之所以有这样的结论是因为在 2.1.0 之后的版本中 `ConfigurationClassParser.processImports()` 的代码如下：

```java
if (selector instanceof DeferredImportSelector) {
    this.deferredImportSelectorHandler.handle(configClass, (DeferredImportSelector) selector);
}
else {
    String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());
    ......
}
```

而 `AutoConfigurationImportSelector` 就是 `DeferredImportSelector` 的实现类，所以根本不会走 else 中的逻辑。

> 还记得文章开头那个悬念吗？自动配置到底跟 `refreshContext()` 有什么联系？如果你按照上面我列出的调用链去 Debug 了，那么你肯定就已经发现了。没错，自动配置的入口就是 `refreshContext()` 方法。

# 3. 按需配置

Spring Boot 的自动配置再一次践行了约定优于配置的原则。它的自动配置并不是一股脑的将所有预设列表全部加载进来，而是非常智能的 “按需配置”。能做到这一点要归功于 @Conditional 注解和 Condition 接口。它们使得各种配置只有在符合一定的条件时才会被加载。

> 在讲自动配置原理的时候，我们了解到 `AutoConfigurationImportSelector.getAutoConfigurationEntry()` 方法中 configurations = filter (configurations, autoConfigurationMetadata) 就是用来过滤那些不符合条件配置的。

我们以 `DataSourceAutoConfiguration` 为例来具体分析一下，先来看一下源码：

```java
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass({ DataSource.class, EmbeddedDatabaseType.class })
@EnableConfigurationProperties(DataSourceProperties.class)
@Import({ DataSourcePoolMetadataProvidersConfiguration.class, DataSourceInitializationConfiguration.class })
public class DataSourceAutoConfiguration {
    ......
}
```

`DataSourceAutoConfiguration` 通过 `@ConditionalOnClass({ DataSource.class, EmbeddedDatabaseType.class })` 告诉 Spring，只有当 classpath 下存在 `DataSource.class` 和 `EmbeddedDatabaseType.class` 时，`DataSourceAutoConfiguration` 才会被加载。

`@ConditionalOnClass` 是 `@Conditional` 的衍生注解，由 `@Conditional` 和 `OnClassCondition` 类组成，源码如下：

```java
@Target({ ElementType.TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Conditional(OnClassCondition.class)
public @interface ConditionalOnClass {
	......
}
```

`OnClassCondition` 是一个实现了 Condition 接口的类，`@ConditionalOnClass` 表示 classpath 里有指定的类时加载配置。它是 `@Conditional` 众多衍生注解中的一个，Spring Boot 提供了一些基于 `@Conditional` 的衍生注解：

| 注解                            | 说明                                                         |
| :------------------------------ | :----------------------------------------------------------- |
| @ConditionalOnBean              | 当容器里有指定 Bean 时                                       |
| @ConditionalOnMissingBean       | 当容器里没有指定 Bean 时                                     |
| @ConditionalOnClass             | classpath 里有指定的类时                                     |
| @ConditionalOnMissingClass      | classpath 里没有指定的类时                                   |
| @ConditionalOnExpression        | 给定的 Spring Expression Language（SpEL）表达式计算结果为 true 时 |
| @ConditionalOnJava              | JVM 的版本匹配特定值或者一个范围时                           |
| @ConditionalOnJndi              | 参数中给定的 JNDI 位置至少存在一个时（如果没有给参数，则要有 JNDI InitialContext） |
| @ConditionalOnProperty          | 指定的属性为指定的值时                                       |
| @ConditionalOnResource          | classpath 里有指定的资源时                                   |
| @ConditionalOnWebApplication    | 当前应用是 Web 应用时                                        |
| @ConditionalOnNotWebApplication | 当前应用不是 Web 应用时                                      |

这些注解都是基于 `@Conditional`，可以覆盖到我们大多数的使用场景，如果以上情况不能满足你的需求，还可以通过自己实现 Condition 接口来完成自定义的需求。

# 4. 总结

OK，这一节我们学习了 Spring Boot 自动配置的原理。还分析了不少源码，对于 Spring Boot 的自动配置原理有了比较全面的理解。如果想要更加深刻的理解，需要多看几遍这部分逻辑的源码，而读源码比较好的方式就是打断点，然后 Debug，这样可以清晰的跟着断点来梳理整个流程，需要多多实践。

Spring Boot 通过之前讲的起步依赖（Starters）和今天学习的自动配置，大大降低了我们的开发成本。这两点是 Spring Boot 如此简洁和高效的基石，理解了它们也就理解了 Spring Boot 的核心设计逻辑。

[29 哲学三问：你从哪来之Spring Boot启动流程](http://www.imooc.com/read/75/article/1825)[31 运行 Spring Boot 应用的几种方式](http://www.imooc.com/read/75/article/1827)

精选留言 1

欢迎在这里发表留言，作者筛选后可公开显示

- [猪肉哥哥](http://www.imooc.com/u/208393/articles)

  cool

   0

  回复

  2020-05-30

  - [刘水镜](http://www.imooc.com/u/8840839/articles)

    回复[猪肉哥哥](http://www.imooc.com/u/208393/articles)

    yeah

    回复

    2020-06-01 21:17:15

 

千学不如一看，千看不如一练