**08 代码的护身符-单元测试**

# 08 代码的护身符-单元测试

更新时间：2020-05-26 11:43:04

![img](http://img3.sycdn.imooc.com/5e9cff4d0001221b06400359.jpg)

![img](http://www.imooc.com/static/img/column/bg-l.png)![img](http://www.imooc.com/static/img/column/bg-r.png)

理想必须要人们去实现它，它不但需要决心和勇敢而且需要知识。

——吴玉章

> 在计算机编程中，单元测试（英语：Unit Testing）又称为模块测试，是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。
> ——维基百科



单元测试  模块测试

程序模块

正确性检验 测试工作

程序单元是应用的最小可测试部件





过程化编程 

一个单元就是单个程序 函数 过程 

对于面向对象编程  最小单元就是方法  包括基类 超类  抽象类 派生类  子类中的方法



维基百科 



# 1. 为什么要写单元测试

了解软件工程的人都知道，测试是软件开发阶段的最后一环，是保证软件质量的关键步骤（这也是为什么测试人员会被称作 [QA](https://baike.baidu.com/item/测试工程师/1907788?fromtitle=QA&fromid=23680686#viewPageContent) 的原因）。只有通过严谨的测试，确保软件达到预期，才能够交付/上线。而单元测试是软件测试中与开发人员关系最紧密的一个环节。

测试工程师，[软件质量](https://baike.baidu.com/item/软件质量/707685)的把关者，工作起点高，发展空间大。我国的[软件测试](https://baike.baidu.com/item/软件测试/327953)职业还处于一个发展的阶段，所以测试工程师具有较大发展前景。

传统的软件行业还是以软件测试工程师为主，但是在新兴的互联网行业大多还是以QA来命名这个职位，也就是质量保证。



测试是软件开发阶段的最后一环  是保证软件质量的关键步骤  

测试是软件开发阶段的最后一环  

QA  质量保证 

刚刚接触单元测试的时候，看到它的名字我脑海中不由自主的蹦出一个疑问——测试不应该是专门的测试人员做的事情吗，跟开发人员有毛线关系呢？你是不是和我一样有过同样的疑问呢？后来随着对单元测试有了更深入的了解以后，发现写单元测试是每个开发者责无旁贷的事情。

测试跟开发人员非常有关 

曾经看到过一篇文章写单元测试的七种境界，可以看看自己在哪一层。七种境界大致如下：

1. 以各种借口拒绝单元测试
2. 尝试单元测试
3. 单元测试一切
4. 无法忍受脆弱的单元测试
5. 发现了一种模拟 mocking 框架，并且乐于使用强制语义
6. 模拟 mock 所有可能模拟 mocked 的对象
7. 开始真正有效单元测试

以各种借口拒绝单元测试

测试单元测试

单元测试一切

无法忍受脆弱的单元测试

发现了一种模拟mocking框架

并且乐于使用强制语义

模拟mock所有可能模拟mocked的对象

开始真正有效单元测试



通常来说，开发人员对代码进行一次改动，就应该进行一次单元测试。在编写完一个相对独立和完整的功能时，就应该为其编写对应的单元测试代码，而不是等功能开发完再去写单元测试，

不过在我有限的了解中，能够做到单元测试与业务代码同步开发的，真的是凤毛麟角了。能够在写完业务代码就去完成单元测试已经是不错的情况了，更为甚者等功能都上线了，再回过头来去补写单元测试。这种为了写单元测试而写单元测试的做法，完全背离的单元测试的初衷。不过这还不是最糟糕的，还有完全不写单元测试的呢。



单元测试理想的情况是，语句覆盖率可以达到 70% ；核心模块的语句覆盖率和分支覆盖率都要达到 100% 的标准（当年在一家日企工作时，就是这个标准）。

**单元测试的意义**：

- 对自己代码质量的一种保障
- 为将来的重构保驾护航
- 可以让新人更快熟悉代码

**测试金字塔**

还记得我们之前讲过的学习金字塔吗？今天我们聊一下另外一个金字塔——测试金字塔：

![图片描述](http://img1.sycdn.imooc.com/5e9abe1d0001ea5506190341.jpg)

测试金字塔大致可以分为三层，由下到上分别是：

- 单元测试
- 服务测试
- 用户界面测试

测试金字塔要表达的思想是：自下而上，成本越来越高（右边箭头），效率越来越低（左边箭头）。说得通俗一点就是，往上走事倍功半，往下走事半功倍。有一种说法，这三层的相对收益比（由上到下）为：1 : 2 : 7。但是目前很多公司还在 UI 层面拼命努力着。

结合我们之前讲过的学习金字塔，我们会发现一个非常有意思的现象——大多数人都在收益率最低的那一层拼命努力！想到这里，你有没有觉得后背发凉呢？有没有意识到自己曾经或者正在在某个低收益的层面拼命努力着呢？



大多数人都在收益率最低的那一层拼命努力



我就是收益率最低的那一层





# 2. 一个单元测试的自我修养

身为一个单元测试，要明确自己的定位，时时刻刻都要谨记——自己是一个单元测试。那么我们来看一下具备哪些素质才能称之为一个合格的单元测试呢？

- 有明确的预期
- 可重复运行
- 独立且完整

我是一个单元测试  来看一下具备哪些素质才能称之为一个合格的单元测试呢？

有明确的预期  这个很好理解   程序输入什么 将会输出什么 



有明确的预期，这个很好理解，我们的程序输入什么，将会输出什么，这是对于软件的最低要求；

可重复运行也不必多说了，如果我们的单元测试都是一锤子买卖，那也就没有什么写的必要了；

作为一个人，我们要有独立完整的自尊体系，同样，作为一个单元测试也要做到独立且完整。怎么理解呢？



独立 完整 

举个例子，假如我们要写一个 Service 层的单元测试，那么运行这个单元测试的时候，就不能去真的访问数据库（因为与数据库打交道是 Dao 层的工作），这叫做独立。虽然不能访问数据库，但是还要保证整个流程可以正确完整的走通（你这不是强人所难吗？），这就是要完整。

那么我们如何做到独立且完整呢？答案就是—— Mock。市面上有很多的 Mock 框架，比如 Mockito、Jmock、easyMock 等。借助这些工具我们可以很轻松的 Mock 出我们想要的依赖。

mock测试就是在[测试过程](https://baike.baidu.com/item/测试过程/10921538)中，对于某些不容易构造或者不容易获取的对象，用一个虚拟的对象来创建以便测试的测试方法。



Mock

v. 嘲笑 mock



Mock.js

生成随机数据，拦截 Ajax 请求




前后端分离

让前端攻城师独立于后端进行开发。

增加单元测试的真实性

通过随机数据，模拟各种场景。

开发无侵入

不需要修改既有代码，就可以拦截 Ajax 请求，返回模拟的响应数据。

用法简单

符合直觉的接口。

数据类型丰富

支持生成随机的文本、数字、布尔值、日期、邮箱、链接、图片、颜色等。

方便扩展

支持支持扩展更多数据类型，支持自定义函数和正则。



独立且完整是单元测试的核心思想所在，单元二字将这种思想表达的淋漓尽致。在做单元测试时，我们默认当前功能的所有依赖都是可以正确执行的，我们的目的是测试当前功能的正确性，而这些 Mock 框架可以很好的将被测功能与其他功能隔离开。



测试当前功能的正确性



Mock框架可以很好的将被测功能与其他功能隔离开



# 3. JUnit

JUnit 是一个 Java 语言的单元测试框架，也是 Spring Boot 默认的单元测试工具，我们先来看一下 JUnit 的几个核心概念和常用注解。

**JUnit 核心概念：**

| **JUnit 的相关概念**   | **说明**                                                     |
| :--------------------- | :----------------------------------------------------------- |
| Test Class （测试类）  | 一个测试类包含一个或多个测试用例                             |
| Test Case （测试用例） | 一个以 ＠Test 注释的方法称为 一个测试用例，测试用例必须存在于测试类中。 |
| Assert （断言）        | 定义想测试的条件，当条件成立时， Assert 方法保持沉默，条件不成立时则抛出异常 |
| Suite （测试组）       | 关联性紧密的一组测试可以定义为一个 Suite                     |
| Runner （运行器）      | 单元测试的运行器（如 SpringRunner），JUnit4 是向后兼容的，可以运行 JUnit3 的测试 |

**JUnit 常用注解：**

| **注解**     | **说明**                           |
| :----------- | :--------------------------------- |
| @RunWith     | 指定运行器                         |
| @BeforeClass | 作用于测试类类加载之前（静态方法） |
| @AfterClass  | 作用于测试类运行结束时（静态方法） |
| @Before      | 作用于测试用例运行前               |
| @After       | 作用于测试用例运行后               |
| @Test        | 作用于测试用例                     |

# 4. 实战

手痒了  想来实践一把了

过过瘾

使用单元测试

首选需要添加依赖

希望我们去写单元测试的

依赖引用 



OK，上面唠叨了那么多，是不是已经手痒了？接下来就来实践一把，过过瘾。要使用单元测试，我们首先需要添加依赖。不过，这次 Spring Boot 好像察觉到了我们的心思，在创建 Web 工程的时候，已经帮我们把 `Test` 的依赖添加好了，可见 Spring Boot 也是希望我们去写单元测试的。依赖引用如下：

```xml
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-test</artifactId>
  <scope>test</scope>
</dependency>
```

在 `HelloController` 类中按 `Command + N` （WIn 下是 `Alt + Insert`）或者鼠标右键单击选择 `Generate..` 然后在弹出的菜单中选择 `Test...` ：

![图片描述](http://img1.sycdn.imooc.com/5e9abe0a000161ef11200564.png)
然后在接下来的对话框按如下图所示，勾选上对于的复选框，然后点击 OK ：

![图片描述](http://img1.sycdn.imooc.com/5e9abdf90001efa208840984.png)

然后去 `src/test` 目录下去找到我们创建的测试类，然后补充剩下的代码：

```java
@RunWith(SpringRunner.class)
@SpringBootTest
@AutoConfigureMockMvc
public class HelloControllerTest {

    @Autowired
    private MockMvc mvc;

    @BeforeClass
    public static void beforeClass() {
        System.out.println("===before class===");
    }

    @Before
    public void setUp() throws Exception {
        System.out.println("===before method===");
    }

    @Test
    public void hello() throws Exception {
        MvcResult result = mvc.perform(get("/")
                                .param("name", "IMOOC")
                                .contentType(MediaType.APPLICATION_JSON))
                                    .andExpect(content()
                                    .string("Hello IMOOC"))
                                    	.andReturn();

        System.out.println("==="+result.getResponse().getContentAsString()+"===");
    }

    @After
    public void tearDown() throws Exception {
        System.out.println("===after method===");
    }

    @AfterClass
    public static void afterClass() {
        System.out.println("===after class===");
    }

}
```

测试通过的运行效果：

```
...........

===before class===

01:16:18.853 [main] DEBUG org.springframework.t
test class [com.imooc.springboot.HelloControlle
...........

  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::        (v2.1.5.RELEASE)

2019-06-17 01:16:19.602  INFO 66981 --- [      
...........
3.474 seconds (JVM running for 4.558)

===before method===
===Hello IMOOC===
===after method===
===after class===

...........
```

以上打印的内容进一步验证了上面几个注解的作用。

# 5. 总结

OK，本小节我们一起学习了一下单元测试相关的内容。知道了 JUnit 的核心概念以及常用注解，并且做了一个 Spring Boot + JUnit 的实例，进一步加深了对于单元测试以及 JUnit 的理解。

相信通过这一小节的学习，你会有一些收获。希望通过本小节的学习，你不仅可以掌握单元测试的用法，还能够理解单元测试的思想，并且希望结合两个金字塔的分析可以给你一些启发。选对方向比前进的速度更重要，方向不对，累死你也得不到你想要的；方向对了，我们只需要一些时间与耐心，最终都会到达我们想去的地方，我们下节见！

[07 懒惰使人进步-Spring Boot集成Swagger2](http://www.imooc.com/read/75/article/1803)[09 斗转星移再现江湖-Spring MVC](http://www.imooc.com/read/75/article/1805)

精选留言 7

欢迎在这里发表留言，作者筛选后可公开显示

- [qq_Sophia_20](http://www.imooc.com/u/4429399/articles)

  does not support filtering and will therefore be run completely. 运行的时候可能会出现上述的问题，后来发现导入是 import org.junit.jupiter.api.Test; 应该替换为 import org.junit.Test;

   0

  回复

  2020-06-20

  - [刘水镜](http://www.imooc.com/u/8840839/articles)

    回复[qq_Sophia_20](http://www.imooc.com/u/4429399/articles)

    高手。

    回复

    2020-06-22 20:23:02

- [MarchGoGo](http://www.imooc.com/u/9029620/articles)

  @Test public void hello() throws Exception { MvcResult result = mvc.perform(get("/") .param("name", "IMOOC") .contentType(MediaType.APPLICATION_JSON)) .andExpect(content() .string("Hello IMOOC")) .andReturn(); System.out.println("==="+result.getResponse().getContentAsString()+"==="); } 老师这个get("/")爆红怎么解决？

   0

  回复

  2020-05-30

  - [刘水镜](http://www.imooc.com/u/8840839/articles)

    回复[MarchGoGo](http://www.imooc.com/u/9029620/articles)

    双引号是中文的？加微信给你看看？微信号：liushuijinger

    回复

    2020-06-01 21:18:08

  - [MarchGoGo](http://www.imooc.com/u/9029620/articles)

    回复

    [刘水镜](http://www.imooc.com/u/8840839/articles)

    不是中文的

    回复

    2020-06-01 21:23:31

  - [刘水镜](http://www.imooc.com/u/8840839/articles)

    回复[MarchGoGo](http://www.imooc.com/u/9029620/articles)

    通过私聊找到了问题，缺少 import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get; 静态引用。

    回复

    2020-06-01 21:32:57

  点击展开后面 2 条

- [草鱼禾](http://www.imooc.com/u/350271/articles)

  建议老师在讲解代码的时候，把导入的包也贴一下比较好，有时候都不知道是import哪个包。

   0

  回复

  2020-05-29

  - [刘水镜](http://www.imooc.com/u/8840839/articles)

    回复[草鱼禾](http://www.imooc.com/u/350271/articles)

    嗯嗯，当时没有贴出 Import 是为了更简洁一些，哈哈。可以参考一下源码：https://github.com/liushuijinger/springboot

    回复

    2020-05-29 21:33:28

  - [qq_Sophia_20](http://www.imooc.com/u/4429399/articles)

    回复[草鱼禾](http://www.imooc.com/u/350271/articles)

    import org.junit.After; import org.junit.AfterClass; import org.junit.Before; import org.junit.BeforeClass; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.

    回复

    2020-06-20 14:57:27

- [慕尼黑3019814](http://www.imooc.com/u/6141919/articles)

  org.junit.platformjunit-platform-launcher1.6.2testorg.junit.jupiterjunit-jupiter-engine5.6.2testorg.junit.vintagejunit-vintage-engine5.6.2test

   0

  回复

  2020-05-20

  - [刘水镜](http://www.imooc.com/u/8840839/articles)

    回复[慕尼黑3019814](http://www.imooc.com/u/6141919/articles)

    你的 pom 文件中都引用哪些依赖了？可以尝试移除 spring-boot-starter-test 中的 junit-vintage-engine 依赖，再运行试试。

    回复

    2020-05-20 19:51:03

  - [qq_Sophia_20](http://www.imooc.com/u/4429399/articles)

    回复

    [刘水镜](http://www.imooc.com/u/8840839/articles)

    org.junit.vintagejunit-vintage-engine 老师说的对，创建web项目中，依赖中自带了上述的配置，这导致创建 controller 测试类的时候无法导入@RunWith(SpringRunner.class) 注解。

    回复

    2020-06-20 09:25:59

  - [qq_Sophia_20](http://www.imooc.com/u/4429399/articles)

    回复[慕尼黑3019814](http://www.imooc.com/u/6141919/articles)

    老师文章中不是写了 org.springframework.bootspring-boot-starter-testtest 直接用这个依赖就可以了，默认创建的项目有 org.junit.vintagejunit-vintage-engine

    回复

    2020-06-20 09:28:01

  点击展开后面 1 条

- [慕妹3499681](http://www.imooc.com/u/8956286/articles)

  催更+1

   0

  回复

  2020-04-26

  - [刘水镜](http://www.imooc.com/u/8840839/articles)

    回复[慕妹3499681](http://www.imooc.com/u/8956286/articles)

    感谢支持，专栏是周一到周五，每天更新一篇的，如果放假会顺延的。

    回复

    2020-04-26 20:35:56

- [慕粉18210162816](http://www.imooc.com/u/3617905/articles)

  1

   0

  回复

  2020-04-25

- [qq_庞庞_0](http://www.imooc.com/u/6173405/articles)

  怎么没了，，快更新啊

   0

  回复

  2020-04-25

  - [刘水镜](http://www.imooc.com/u/8840839/articles)

    回复[qq_庞庞_0](http://www.imooc.com/u/6173405/articles)

    感谢支持，专栏是周一到周五，每天更新一篇的，如果放假会顺延的。 明天就会更新啦！

    回复

    2020-04-26 20:36:40

 

千学不如一看，千看不如一练