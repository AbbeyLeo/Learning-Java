**24 一个五星级公厕的故事讲明白定时任务的三种模式**

24 一个五星级公厕的故事讲明白定时任务的三种模式

更新时间：2020-05-26 11:15:47

![img](http://img3.sycdn.imooc.com/5ebe620c00016e5206400425.jpg)

![img](http://www.imooc.com/static/img/column/bg-l.png)![img](http://www.imooc.com/static/img/column/bg-r.png)

散步促进我的思想。我的身体必须不断运动，脑筋才会开动起来。

—— 卢梭

定时任务在我们的系统中有着很重要的作用，对于那些没有实时性要求，并且需要周期性重复执行的任务来说，使用定时任务再合适不过了。即使你在工作和学习中还没有开发过定时任务，在日常生活中你也一定使用过定时任务相关的功能。



# 1. 业务场景

当我们在 12306 提交车票订单后不支付，返回订单页面，你会发现一个三十分钟的倒计时，三十分钟内未支付自动取消订单，车票将自动回到票池中，等待他人购买。

想一想你在淘宝上买的东西，哪一次是你手动确认收货的（反正我没有？淘宝默认在卖家发货十天后自动确认收货（更新订单状态，将钱打到卖家账户等一系列操作）。

还有吃瓜群众最喜欢的微博热搜，也会定时去汇总热搜词条，更新热搜榜（以前是十分钟一次，现在好像改成了一分钟一次了，每一次更新都能听到哗啦哗啦数钱的声音）。

…

使用定时任务的场景太多了，这里就不过多的列举了。你可以想一想你经常使用的 APP 中有哪些地方使用了定时任务？相信你可以列出一大堆。然后你观察这些场景，你会发现虽然它们属于不同的业务，完成的事情各不相同，但是它们都可以用一句话来概括 —— 在指定的时间，按照指定的频率（或执行次数）自动的执行指定的任务。



# 2. java 中的定时任务



## 2.1 单机

**Timer**：来自 JDK，从 JDK 1.3 开始引入。JDK 自带，不需要引入外部依赖，简单易用，当然功能相对单一；

**ScheduledExecutorService**：同样来自 JDK，比 Timer 要晚一些，JDK 1.5 才引入，它的引入弥补了 Timer 的一些缺陷；

**Spring Task**：看名字就知道来自 Spring，Spring 环境中单机定时任务的不二之选。



## 2.2 分布式

**Quartz**：分布式定时任务的基石（其本身并不支持分布式任务调度）。功能丰富且强大，即能与简单的单体应用结合，又能支撑起复杂的分布式系统；

**Elastic-job**：来自当当网，基于 Quartz 开发，是一个具有完整定时任务处理流程，并且支持分布式的定时任务调度解决方案；

**xxl-job**：来自大众点评，同样也是基于 Quartz 开发，是一个轻量级的分布式任务调度平台。简单易用，国内使用很广泛。

> 另外，唯品会也有一个定时任务平台 ——Saturn，是对 Elastic-job 进行的二次开发。

通过上面的介绍，我们知道这些分布式的定时任务平台，都是基于 Quartz 的基础上进行的扩展。Quartz 算得上是 Java 定时任务届的标准了。



# 3. Spring Boot 整合定时任务

上面介绍了很多关于定时任务的内容，接下来我们就动手实践一把。我们选择 Spring Task 与 Spring Boot 结合来实现一个定时任务的小实例。

在 Spring Boot 中使用定时任务，与使用其他技术一样，还是一如既往的简单方便。要开始定时任务功能，我们需要用到三个注解 ——@EnableScheduling、@Scheduled 和 @Component。

@EnableScheduling 用来开启定时任务功能，放在工程的主类上；@Scheduled 用来设定任务的执行规则，放在具体的定时任务方法上； @Component 我们已经很熟悉了，就是将类标记为一个被 Spring 管理的功能组件，放在包含有定时任务方法的类上。

Spring Task 有三种模式，分别是：fixedDelay、cron 和 fixedRate。话不多说，我们先看代码：

```java
@Slf4j
@Component
public class TimeTask {

    private int[] people = {9000,2000,3000,1000};

    private int count = 0;

    @Scheduled(fixedDelay = 5000)
    public void fixedDelayTask() throws InterruptedException {
        if (count < 4) {
            int timeConsuming = people[count];
            log.info("fixedDelayTask-----第 {} 个人开始如厕，耗时：{}ms",count+1, timeConsuming);
            Thread.sleep(timeConsuming);
            count++;
        }
    }
    
    @Scheduled(cron = "0/5 * * * * ? ")
    public void cronTask() throws InterruptedException {
        if (count < 4) {
            int timeConsuming = people[count];
            log.info("cronTask-----第 {} 个人开始如厕，耗时：{}ms",count+1, timeConsuming);
            Thread.sleep(timeConsuming);
            count++;
        }
    }
    
    @Scheduled(fixedRate = 5000)
    public void fixedRateTask() throws InterruptedException {
        if (count < 4) {
            int timeConsuming = people[count];
            log.info("fixedRateTask-----第 {} 个人开始如厕，耗时：{}ms",count+1, timeConsuming);
            Thread.sleep(timeConsuming);
            count++;
        }
    }

}
```

这三种模式的用法都很简单，使用方式也很类似。那么它们究竟有什么不同呢？下面我们通过一个五星级豪华公测的故事来说明一下。



## 3.1 故事背景

有四个人排队去一个五星级的豪华公共厕所如厕，每个人如厕需要的时间如下：

- 第一个人 9 秒钟
- 第二个人 2 秒钟
- 第三个人 3 秒钟
- 第四个人 1 秒钟

从第一个人开始如厕进行计时。



## 3.2 场景一 ——fixedDelay

日志输出：

```
2019-12-09 23:30:08.685  INFO : fixedDelayTask-----第 1 个人开始如厕，耗时：9000ms
2019-12-09 23:30:22.688  INFO : fixedDelayTask-----第 2 个人开始如厕，耗时：2000ms
2019-12-09 23:30:29.691  INFO : fixedDelayTask-----第 3 个人开始如厕，耗时：3000ms
2019-12-09 23:30:37.693  INFO : fixedDelayTask-----第 4 个人开始如厕，耗时：1000ms
```

一个人用完厕所后，保洁需要花费 5 秒钟的时间打扫卫生。那么：

1. 第一个人在第 0 秒时，即 23:30:08 时开始如厕，9 秒后结束，保洁用 5 秒钟打扫；
2. 第二个人在第 14 秒（9+5）时，即 23:30:22 开始如厕，2 秒后结束，保洁用 5 秒钟打扫；
3. 第三个人在第 21 秒（14+2+5）时，即 23:30:29 开始如厕，3 秒后结束，保洁用 5 秒钟打扫；
4. 第四个人在第 29 秒 （21+3+5）时，即 23:30:37 开始如厕，1 秒后结束…



## 3.3 场景二 ——cron

日志输出：

```
2019-12-09 23:33:05.002  INFO : cronTask-----第 1 个人开始如厕，耗时：9000ms
2019-12-09 23:33:15.002  INFO : cronTask-----第 2 个人开始如厕，耗时：2000ms
2019-12-09 23:33:20.001  INFO : cronTask-----第 3 个人开始如厕，耗时：3000ms
2019-12-09 23:33:25.001  INFO : cronTask-----第 4 个人开始如厕，耗时：1000ms
```

通过严谨的科学分析，发现在秒数为 5 的整数倍时如厕体验更佳，所以只有当前时间秒数为 5 的整数倍时才可以进入。并且，五星级豪华公测升级设备，可以在如厕完成的瞬间将测试打扫干净，因此不再需要保洁，也提升了厕所利用率。那么：

1. 第一个人在 23:33:05 时开始如厕，9 秒后（23:33:14）结束，下一个如厕吉时为 23:33:15；
2. 第二个人在 23:33:15 时开始如厕，2 秒后（23:33:17）结束，下一个如厕吉时为 23:33:20；
3. 第三个人在 23:33:20 时开始如厕，3 秒后（23:33:23）结束，下一个如厕吉时为 23:33:25；
4. 第四个人在 23:33:25 时开始如厕，1 秒后（23:33:26）结束…



## 3.4 场景三 ——fixedRate

日志输出：

```
2019-12-09 23:34:21.763  INFO : fixedRateTask-----第 1 个人开始如厕，耗时：9000ms
2019-12-09 23:34:30.764  INFO : fixedRateTask-----第 2 个人开始如厕，耗时：2000ms
2019-12-09 23:34:32.767  INFO : fixedRateTask-----第 3 个人开始如厕，耗时：3000ms
2019-12-09 23:34:36.764  INFO : fixedRateTask-----第 4 个人开始如厕，耗时：1000ms
```

管理人员发现以上方案还有优化的空间，厕所利用率还可以进一步提升。管理员按照大数据分析结果（人均如厕耗时 5 秒）提前排好如厕计划，但是有一个规则：当实际时间晚于计划时间时施行无缝如厕，早于计划时间则需要等待到达计划时间方可如厕。那么：

如厕计划：

1. 第一个人：第 0 秒进入
2. 第二个人：第 5 秒进入
3. 第三个人：第 10 秒进入
4. 第四个人：第 15 秒进入

根据故事背景中每个人如厕时间，实际情况如下：

1. 第一个人在第 0 秒时，即 23:34:21 时开始如厕，9 秒后结束，超时，第二个人无缝如厕；
2. 第二个人在第 9 秒（0+9）时，即 23:34:30 开始如厕，2 秒后结束，超时，第三个人无缝如厕；
3. 第三个人在第 11 秒（9+2）时，即 23:34:32 开始如厕，3 秒后结束，未超时，第四个人按计划如厕；
4. 第四个人在第 15 秒 （9+2+3+1）时，即 23:34:36 开始如厕，1 秒后结束…



# 4. Cron 表达式

以上三种模式中，cron 模式最为灵活，可以应对更多的情况。下面简单介绍一下 cron 表达式，一个 cron 表达式总共有 7 个元素，分别如下：

| 时间单位 | 是否必填 | 取值范围                              | 通配符                   |
| :------- | :------- | :------------------------------------ | :----------------------- |
| 秒       | 是       | 0-59 的整数                           | , - * / 四个字符         |
| 分       | 是       | 0-59 的整数                           | , - * / 四个字符         |
| 时       | 是       | 0-23 的整数                           | , - * / 四个字符         |
| 日       | 是       | 1-31 的整数（需要考虑该月的具体天数） | ,- * ? / L W C 八个字符  |
| 月       | 是       | 1~12 的整数或者 JAN-DEC               | , - * / 四个字符         |
| 周       | 是       | 1~7 的整数或者 SUN-SAT （1=SUN）      | , - * ? / L C # 八个字符 |
| 年       | 否       | 1970~2099                             | , - * / 四个字符         |

表达式的规则不需要刻意去记，需要的时候使用借助图形化工具生成即可 ——[cron 生成器](https://qqe2.com/cron)。



# 5. 总结

OK，这一小节我们一起学习了 Java 中的定时任务，以及在 Spring Boot 中开启定时任务。并通过一个小故事讲解了 Spring Task 的三种定时模式。这种单机版的定时任务适合简单的任务处理，当我们需要处理更多更复杂的任务时，就需要借助我们文章中提到的分布式定时任务调度平台啦。通过单机版的学习小试牛刀，为以后上手分布式版打下基础，真正用到的时候会更加的得心应手。最后，希望你喜欢这个五星级豪华公厕的小故事。

[23 天有不测风云，人有旦夕祸福——异常处理](http://www.imooc.com/read/75/article/1819)[25 彻底搞定秒杀系统](http://www.imooc.com/read/75/article/1821)

精选留言 1

欢迎在这里发表留言，作者筛选后可公开显示

- [慕慕童鞋](http://www.imooc.com/u/8954842/articles)

  Druid 真的很强大呀

   0

  回复

  2020-06-25

  - [刘水镜](http://www.imooc.com/u/8840839/articles)

    回复[慕慕童鞋](http://www.imooc.com/u/8954842/articles)

    非常强大。

    回复

    2020-06-28 20:25:23

 

千学不如一看，千看不如一练

 