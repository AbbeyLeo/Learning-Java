# 算法与数据结构



1\哈希 

1\hashset存的数是有序的吗?

哈希



![image-20200722185049635](assets/image-20200722185049635.png)



# 哈希

## ● 请谈一谈，hashCode() 和equals() 方法的重要性体现在什么地方？

考察点：JAVA哈希表

### 参考回答：

Java中的HashMap使用hashCode()和equals()方法来确定键值对的索引，当根据键获取值的时候也会用到这两个方法。如果没有正确的实现这两个方法，两个不同的键可能会有相同的hash值，因此，可能会被集合认为是相等的。而且，这两个方法也用来发现重复元素。所以这两个方法的实现对HashMap的精确性和正确性是至关重要的。

## ● 请说一说，Java中的HashMap的工作原理是什么？

考察点：JAVA哈希表

参考回答：

HashMap类有一个叫做Entry的内部类。这个Entry类包含了key-value作为实例变量。 每当往hashmap里面存放key-value对的时候，都会为它们实例化一个Entry对象，这个Entry对象就会存储在前面提到的Entry数组table中。Entry具体存在table的那个位置是 根据key的hashcode()方法计算出来的hash值（来决定）。

第二个问题Entry那里说的是错的，我看了源码。
table数组的声明是
transient Node<K,V>[] table 
Entry类不存放数据，存数据的是静态内部类Node。
Entry只有在调用entrySet()时才有数据。
发表于 2020-03-11 11:29:30回复(2)赞(2)举报
牛客876087286号 ：1.7 与 1.8 的区别
2020-03-15 22:00:22回复赞(2)
被神选中的孩子 ：1.8之后是node 1.7是entry

Hashset怎么会是无序的呢，我测试的时候如果是int类型直接就把数据排好序了

发表于 2020-06-17 12:15:52[回复(1)](javascript:void(0);)[赞(0)](javascript:void(0);)[举报](javascript:void(0);)

[牛客850784545号](https://www.nowcoder.com/profile/850784545) ：

集合中的有序是添加元素的顺序与输出的顺序一致，还真是可爱![img](assets/6658561_1571454654067_FB5C81ED3A220004B71069645F112867.png)

## ● 介绍一下，什么是hashmap?

考察点：哈希表

### 参考回答：

HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。

HashMap是一个散列表 它存储的内容是键值对 key-value 映射 

HashMap 继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口。
HashMap 的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。此外，HashMap中的映射不是有序的。

HashMap 的实例有两个参数影响其性能：“初始容量” 和 “加载因子”。容量 是哈希表中桶的数量，初始容量 只是哈希表在创建时的容量。加载因子 是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。
通常，默认加载因子是 0.75, 这是在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，但同时也增加了查询成本（在大多数 HashMap 类的操作中，包括 get 和 put 操作，都反映了这一点）。在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少 rehash 操作次数。如果初始容量大于最大条目数除以加载因子，则不会发生 rehash 操作。

hashmap共有4个构造函数：

// 默认构造函数。HashMap()

// 指定“容量大小”的构造函数

HashMap(int capacity)

// 指定“容量大小”和“加载因子”的构造函数

HashMap(int capacity, float loadFactor)

// 包含“子Map”的构造函数

HashMap(Map<? extends K, ? extends V> map)

## ● 讲一讲，如何构造一致性 哈希算法。

考察点：哈希算法

### 参考回答：

先构造一个长度为232的整数环（这个环被称为一致性Hash环），根据节点名称的Hash值（其分布为[0, 232-1]）将服务器节点放置在这个Hash环上，然后根据数据的Key值计算得到其Hash值（其分布也为[0, 232-1]），接着在Hash环上顺时针查找距离这个Key值的Hash值最近的服务器节点，完成Key到服务器的映射查找。

这种算法解决了普通余数Hash算法伸缩性差的问题，可以保证在上线、下线服务器的情况下尽量有多的请求命中原来路由到的服务器。

## ● 请问，Object作为HashMap的key的话，对Object有什么要求吗？

考察点：哈希表

### 参考回答：

要求Object中hashcode不能变。

## ● 请问 hashset 存的数是有序的吗？

考察点：哈希

### 参考回答：

Hashset是无序的。



# 树

## ● TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？

考察点：Tree

### 参考回答：

TreeSet要求存放的对象所属的类必须实现Comparable接口，该接口提供了比较元素的compareTo()方法，当插入元素时会回调该方法比较元素的大小。TreeMap要求存放的键值对映射的键必须实现Comparable接口从而根据键对元素进行排序。Collections工具类的sort方法有两种重载的形式，第一种要求传入的待排序容器中存放的对象比较实现Comparable接口以实现元素的比较；第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator接口的子类型（需要重写compare方法实现元素的比较），相当于一个临时定义的排序规则，其实就是通过接口注入比较元素大小的算法，也是对回调模式的应用（Java中对函数式编程的支持）。

代码示例：

```java
public class
Student implements Comparable<Student> {
     private String
name;        // 姓名
     private int
age;            // 年龄
     public Student(String name, int age) {
         this.name = name;
         this.age = age;
     }
     @Override
     public String toString() {
         return "Student [name=" +
name + ", age=" + age + "]";
     }
     @Override
     public int compareTo(Student o) {
         return this.age - o.age; // 比较年龄(年龄的升序)
     }
 }
 import java.util.Set;
 import java.util.TreeSet;
 class Test01 {
     public static void main(String[] args) {
         Set<Student> set = new
TreeSet<>();     // Java 7
     }
 }
 import java.util.Set;
 import java.util.TreeSet;
 class Test01 {
     public static void main(String[] args) {
         Set<Student> set = new
TreeSet<>();     // Java 7的钻石语法(构造器后面的尖括号中不需要写类型)
         set.add(new Student("Hao
LUO", 33));
         set.add(new Student("XJ
WANG", 32));
         set.add(new Student("Bruce
LEE", 60));
         set.add(new Student("Bob
YANG", 22));
  
         for(Student stu : set) {
             
System.out.println(stu);
         }
 //     
         set.add(new Student("Hao
LUO", 33));
         set.add(new Student("XJ
WANG", 32));
         set.add(new Student("Bruce
LEE", 60));
         set.add(new Student("Bob
YANG", 22));
         for(Student stu : set) {
             
System.out.println(stu);
         }
 //      输出结果: 
 //      Student [name=Bob YANG, age=22]
 //      Student [name=XJ WANG, age=32]
 //      Student [name=Hao LUO, age=33]
 //      Student [name=Bruce LEE, age=60]
     }
 }
 //      Student [name=Bob YANG, age=22]
 //      Student [name=XJ WANG, age=32]
 //      Student [name=Hao LUO, age=33]
 //      Student [name=Bruce LEE, age=60]
     }
 }

```



```
public` `class``Student ``implements` `Comparable {``   ``private` `String``name;    ``// 姓名``   ``private` `int``age;      ``// 年龄``   ``public` `Student(String name, ``int` `age) {``     ``this``.name = name;``     ``this``.age = age;``   ``}``   ``@Override``   ``public` `String toString() {``     ``return` `"Student [name="` `+``name + ``", age="` `+ age + ``"]"``;``   ``}``   ``@Override``   ``public` `int` `compareTo(Student o) {``     ``return` `this``.age - o.age; ``// 比较年龄(年龄的升序)``   ``}`` ``}`` ``import` `java.util.Set;`` ``import` `java.util.TreeSet;`` ``class` `Test01 {``   ``public` `static` `void` `main(String[] args) {``     ``Set set = ``new``TreeSet<>();   ``// Java 7``   ``}`` ``}`` ``import` `java.util.Set;`` ``import` `java.util.TreeSet;`` ``class` `Test01 {``   ``public` `static` `void` `main(String[] args) {``     ``Set set = ``new``TreeSet<>();   ``// Java 7的钻石语法(构造器后面的尖括号中不需要写类型)``     ``set.add(``new` `Student("Hao``LUO", ``33``));``     ``set.add(``new` `Student("XJ``WANG", ``32``));``     ``set.add(``new` `Student("Bruce``LEE", ``60``));``     ``set.add(``new` `Student("Bob``YANG", ``22``));`` ` `     ``for``(Student stu : set) {``      ` `System.out.println(stu);``     ``}`` ``//   ``     ``set.add(``new` `Student("Hao``LUO", ``33``));``     ``set.add(``new` `Student("XJ``WANG", ``32``));``     ``set.add(``new` `Student("Bruce``LEE", ``60``));``     ``set.add(``new` `Student("Bob``YANG", ``22``));``     ``for``(Student stu : set) {``      ` `System.out.println(stu);``     ``}`` ``//   输出结果: `` ``//   Student [name=Bob YANG, age=22]`` ``//   Student [name=XJ WANG, age=32]`` ``//   Student [name=Hao LUO, age=33]`` ``//   Student [name=Bruce LEE, age=60]``   ``}`` ``}`` ``//   Student [name=Bob YANG, age=22]`` ``//   Student [name=XJ WANG, age=32]`` ``//   Student [name=Hao LUO, age=33]`` ``//   Student [name=Bruce LEE, age=60]``   ``}`` ``}
```



## ● 如何打印二叉树每层的节点？

考察点：二叉树

### 参考回答：

实现代码：

```
import``java.util.ArrayList;``import``java.util.Scanner;``public` `class` `Main``{``  ``// 定义节点``  ``class` `Node{``    ``int``val;``    ``Node``left;``    ``Node``right;``    ``public``Node(``int` `val) {``      ``this``.val = val;``    ``}``  ``}``  ` `  ``public` `ArrayList gzy; ``// 保存根左右的序列``  ``public` `ArrayList zgy; ``// 保存左跟右的序列``  ``public` `ArrayList pack;    ``// 保存已经排好的节点``  ` `  ``public` `static` `void` `main(String[] args) {``    ``Main``main = ``new` `Main();``    ``main.getResult();``    ` `  ``}``  ` `  ``public` `void` `getResult() {``    ``//``init``    ``Scanner``scanner = ``new` `Scanner(System.in);``    ``int``count = scanner.nextInt();``    ``gzy``= ``new` `ArrayList<>();``    ``zgy``= ``new` `ArrayList<>();``    ``for``(``int``i = ``0``; i < count; i++) {``      ``gzy.add(scanner.nextInt());``    ``}``    ``for``(``int``j = ``0``; j < count; j++) {``      ``zgy.add(scanner.nextInt());``    ``}``    ``pack``= ``new` `ArrayList<>();    ``// 已经还原的节点``    ` `    ``//``exception``    ``if``(count``== ``1``) {``      ``System.out.println(gzy.get(``0``));``      ``return``;``    ``}``    ``// 构造最左侧节点的二叉树``    ``Node``node = ``new` `Node(gzy.get(``0``));``    ``pack.add(node);``    ``int``index1 = ``1``;   ``// 根左右的下标``    ``Node``tmp = node;``    ``while``(gzy.get(index1)``!= zgy.get(``0``)) {   ``// 如果没访问到最左边的叶子节点,继续还原最左侧二叉树``      ``tmp.left = ``new` `Node(gzy.get(index1++));``      ``tmp = tmp.left;``      ``pack.add(tmp);``    ``}``    ``tmp.left``= ``new` `Node(gzy.get(index1++));``    ``pack.add(tmp.left);``    ` `    ``// 加入剩余的节点完善二叉树``    ``for``(``int``k = index1; k < gzy.size(); k++) {``      ``fillErCS(gzy.get(k));``    ``}``    ` `    ``// 层次遍历``    ``ArrayList``res = ``new` `ArrayList<>();``    ``res.add(node);``    ``int``num = ``0``;``    ``while``(res.size()``!= num) {``      ``System.out.print(res.get(num).val + "``");``      ``if``(res.get(num).left != ``null``) {``        ``res.add(res.get(num).left);``      ``}``      ``if``(res.get(num).right != ``null``) {``        ``res.add(res.get(num).right);``      ``}``      ``num++;``    ``}``  ``}``  ` `  ``// 将值为val的节点加入二叉树``  ``private` `void` `fillErCS(``int` `val) {``    ``int``index = zgy.indexOf(val);``    ``// 每一个遍历的节点都是val节点的根或者在其左边``    ``for``(``int``i = index-``1``; i >= ``0``; i--) {``      ``if``(findNode(zgy.get(i)) != ``null``) { ``// 找到待插入节点的根节点或者其左边的节点``        ``Node``node = findNode(zgy.get(i));``        ``insert(node,``val);``        ``break``;``      ``}    ``    ``}``  ``}``  ` `  ``// 将节点val插入二叉树``  ``private` `void` `insert(Node node, ``int` `val) {``    ``if``(zgy.indexOf(node.val)``> zgy.indexOf(val)) { ``// node在待插入节点的右边``      ``if``(node.left == ``null``) {``        ``node.left``= ``new` `Node(val);``        ``pack.add(node.left);``        ``return``;``      ``}``      ``insert(node.left, val);``    ``}``else``{   ``//``node在待插入节点的左边或是其根``      ``if``(node.right == ``null``) {``        ``node.right``= ``new` `Node(val);``        ``pack.add(node.right);``        ``return``;``      ``}``      ``insert(node.right, val);``    ``}``  ``}``  ``// 根据val找到pack里的节点``  ``private` `Node findNode(``int` `val) {``    ``for``(Node``node : pack) {``      ``if``(node.val == val) {``        ``return``node;``      ``}``    ``}``    ``return``null``;``  ``}``}
```



## ● 如何知道二叉树的深度？

考察点：二叉树

### 参考回答：

实现二叉树的深度方式有两种，递归以及非递归。

①递归实现：

为了求树的深度，可以先求其左子树的深度和右子树的深度，可以用递归实现，递归的出口就是节点为空。返回值为0；

②非递归实现：

利用层次遍历的算法，设置变量level记录当前节点所在的层数，设置变量last指向当前层的最后一个节点，当处理完当前层的最后一个节点，让level指向+1操作。设置变量cur记录当前层已经访问的节点的个数，当cur等于last时，表示该层访问结束。

层次遍历在求树的宽度、输出某一层节点，某一层节点个数，每一层节点个数都可以采取类似的算法。

树的宽度：在树的深度算法基础上，加一个记录访问过的层节点个数最多的变量max,在访问每层前max与last比较，如果max比较大，max不变，如果max小于last，把last赋值给max;

代码解释：

```
import``java.util.LinkedList;``public` `class` `Deep``{``  ``//递归实现1`` ``public` `int` `findDeep(BiTree root)`` ``{``   ``int``deep = ``0``;``   ` `if``(root != ``null``)``   ``{``     ``int` `lchilddeep = findDeep(root.left);``     ``int` `rchilddeep = findDeep(root.right);``     ``deep = lchilddeep > rchilddeep ?``lchilddeep + ``1` `: rchilddeep + ``1``;``   ``}``   ` `return` `deep;`` ``}`` ` ` ` ` ``//递归实现2`` ``public` `int` `findDeep1(BiTree root)`` ``{``  ` `   ` `if``(root == ``null``)``   ``{``     ``return` `0``;``   ``}``   ``else``   ``{``    ``int``lchilddeep = findDeep1(root.left);``//求左子树的深度``    ``int``rchilddeep = findDeep1(root.left);``//求右子树的深度``   ` `return` `lchilddeep > rchilddeep ? lchilddeep + ``1` `: rchilddeep + ``1``;``//左子树和右子树深度较大的那个加一等于整个树的深度``   ``}`` ``}`` ``//非递归实现`` ``public` `int` `findDeep2(BiTree root)`` ``{``   ``if``(root == ``null``)``     ``return` `0``;``  ` `   ``BiTree current = ``null``;``   ``LinkedList queue = ``new``LinkedList();``   ``queue.offer(root);``   ``int``cur,last;``   ``int``level = ``0``;``   ``while``(!queue.isEmpty())``   ``{``     ``cur = ``0``;``//记录本层已经遍历的节点个数``     ``last = queue.size();``//当遍历完当前层以后，队列里元素全是下一层的元素，队列的长度是这一层的节点的个数``     ``while``(cur < last)``//当还没有遍历到本层最后一个节点时循环``     ``{``       ``current = queue.poll();``//出队一个元素``       ``cur++;``       ``//把当前节点的左右节点入队（如果存在的话）``       ``if``(current.left != ``null``)``       ``{``         ``queue.offer(current.left);``       ``}``       ``if``(current.right != ``null``)``       ``{``         ``queue.offer(current.right);``       ``}``     ``}``     ``level++;``//每遍历完一层level+1``   ``}``   ``return` `level;`` ``}`` ``public` `static` `void` `main(String[] args)`` ``{``  ``BiTree root = BiTree.buildTree();``  ``Deep deep = ``new` `Deep();``  ``System.out.println(deep.findDeep(root));``  ``System.out.println(deep.findDeep1(root));``  ``System.out.println(deep.findDeep2(root)); `` ``}``}
```



## ● 二叉树任意两个节点之间路径的最大长度

考察点：树

### 参考回答：

```
int` `maxDist(Tree``root) { ``  ``//如果树是空的，则返回0 ``  ``if``(root == NULL) ``    ``return` `0``; ``  ``if``(root->left != NULL) { ``    ``root->lm = maxDist(root->left) +``1``; ``  ``} ``  ``if``(root->right != NULL) ``    ``root->rm = maxDist(root->right) +``1``; ``  ``//如果以该节点为根的子树中有最大的距离，那就更新最大距离 ``  ``int` `sum = root->rm + root->lm; ``  ``if``(sum > max) { ``    ``max = sum; ``  ``} `` ` `  ``return` `root->rm > root->lm ?``root->rm : root->lm; ``} 
```



## ● 算法题：二叉树层序遍历，进一步提问：要求每层打印出一个换行符

考察点：二叉树

### 参考回答：

```
public``List> levelOrder(TreeNode root) {``    ``List> res =``new` `ArrayList>();``    ``LinkedList queue = ``new``LinkedList();``    ``if` `(root == ``null``) {``      ``return` `res;``    ``}``    ``queue.offer(root);``    ``while` `(queue.size() != ``0``) {``      ``List l = ``new``ArrayList();``      ``int` `size = queue.size();``      ``for` `(``int` `i = ``0``; i < size; i++) {``        ``TreeNode temp = queue.poll();``        ``l.add(temp.val);``        ``if` `(temp.left != ``null``) {``          ``queue.offer(temp.left);``        ``}``        ``if` `(temp.right != ``null``) {``          ``queue.offer(temp.right);``        ``}``      ``}``      ``res.add(l);``    ``}``    ``return` `res;``}
```



## ● 怎么求一个二叉树的深度?手撕代码?

考察点：二叉树

### 参考回答：

```
public` `int``maxDepth(TreeNode root) {``    ``if` `(root == ``null``) {``      ``return` `0``;``    ``}``    ``int` `left = maxDepth(root.left);``    ``int` `right = maxDepth(root.right);``    ``int` `bigger = Math.max(left, right);``    ``return` `bigger + ``1``;``  ``}
```



## ● 请你说一下，B+树和B-树？

考察点：树

### 参考回答：

b+树的中间节点不保存数据，所以磁盘页能容纳更多节点元素，更“矮胖”；

b+树查询必须查找到叶子节点，b树只要匹配到即可不用管元素位置，因此b+树查找更稳定（并不慢）；

对于范围查找来说，b+树只需遍历叶子节点链表即可，b树却需要重复地中序遍历。

[上一节](https://www.nowcoder.com/tutorial/94/39faa7647b624c4e8818993f48cce094)[下一节>](https://www.nowcoder.com/tutorial/94/7617c7f36d014488b1fcdf879c0f7751)

- [讨论](javascript:void(0);)

[评论](javascript:void(0);)

[![可是那然后呢.头像](assets/130272271_1538200647872_7C2C60506876716CCF0E706DB13D4511.png)](https://www.nowcoder.com/profile/130272271)

[可是那然后呢.](https://www.nowcoder.com/profile/130272271)1#

代码的排版什么乱七八糟的

发表于 2019-07-03 14:09:25[回复(0)](javascript:void(0);)[赞(31)](javascript:void(0);)

[![请叫我达文西头像](assets/335444011_1535372995100_7C2C60506876716CCF0E706DB13D4511.png)](https://www.nowcoder.com/profile/335444011)

[请叫我达文西](https://www.nowcoder.com/profile/335444011)2#

 importjava.util.Set;

 importjava.util.TreeSet;

 classTest01 {

   publicstaticvoidmain(String[] args) {

​     Set<Student> set = new

TreeSet<>();   // Java 7

   }

 }

 importjava.util.Set;

 importjava.util.TreeSet;

 classTest01 {

   publicstaticvoidmain(String[] args) {

​     Set<Student> set = new

TreeSet<>();   // Java 7的钻石语法(构造器后面的尖括号中不需要写类型)

这重复了吧，代码展示那块可以往右边拉长啊都挤在一起了

发表于 2019-11-02 15:05:33[回复(0)](javascript:void(0);)[赞(0)](javascript:void(0);)

[![铖201909042041615头像](assets/113321128_1567600896831_605475850F555A9A1D76953CFB3E39A6.png)](https://www.nowcoder.com/profile/113321128)

[铖201909042041615](https://www.nowcoder.com/profile/113321128)3#

什么鬼排版

发表于 2020-06-21 12:26:54