**第2章 集合**

第2章 集合

- 05 ArrayList 源码解析和设计思路
- 06 LinkedList 源码解析
- 07 List 源码会问哪些面试题
- 08 HashMap 源码解析
- 09 TreeMap 和 LinkedHashMap 核心源码解析
- 10 Map源码会问哪些面试题
- 11 HashSet、TreeSet 源码解析
- 12 彰显细节：看集合源码对我们实际工作的帮助和应用
- 13 差异对比：集合在 Java 7 和 8 有何不同和改进
- 14 简化工作：Guava Lists Maps 实际工作运用和源码

第2章 集合

# 05 ArrayList 源码解析和设计思路

05 ArrayList 源码解析和设计思路

更新时间：2019-11-26 09:44:51

![img](https://img1.mukewang.com/5d6355860001b65c06400359.jpg)

![img](https://www.imooc.com/static/img/column/bg-l.png)![img](https://www.imooc.com/static/img/column/bg-r.png)

耐心和恒心总会得到报酬的。

——爱因斯坦



## 引导语

ArrayList 我们几乎每天都会使用到，但真正面试的时候，发现还是有不少人对源码细节说不清楚，给面试官留下比较差的印象，本小节就和大家一起看看面试中和 ArrayList 相关的源码。



## 1 整体架构

ArrayList 整体架构比较简单，就是一个数组结构，比较简单，如下图：
![图片描述](https://img.mukewang.com/5d5fc5f80001e20e15080238.png)图中展示是长度为 10 的数组，从 1 开始计数，index 表示数组的下标，从 0 开始计数，elementData 表示数组本身，源码中除了这两个概念，还有以下三个基本概念：

- DEFAULT_CAPACITY 表示数组的初始大小，默认是 10，这个数字要记住；
- size 表示当前数组的大小，类型 int，没有使用 volatile 修饰，非线程安全的；
- modCount 统计当前数组被修改的版本次数，数组结构有变动，就会 +1。

**类注释**

看源码，首先要看类注释，我们看看类注释上面都说了什么，如下：

- 允许 put null 值，会自动扩容；
- size、isEmpty、get、set、add 等方法时间复杂度都是 O (1)；
- 是非线程安全的，多线程情况下，推荐使用线程安全类：Collections#synchronizedList；
- 增强 for 循环，或者使用迭代器迭代过程中，如果数组大小被改变，会快速失败，抛出异常。

除了上述注释中提到的 4 点，初始化、扩容的本质、迭代器等问题也经常被问，接下来我们从源码出发，一一解析。



## 2 源码解析



### 2.1 初始化

我们有三种初始化办法：无参数直接初始化、指定大小初始化、指定初始数据初始化，源码如下：

```java
private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};

//无参数直接初始化，数组大小为空
public ArrayList() {
    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
}

//指定初始数据初始化
public ArrayList(Collection<? extends E> c) {
    //elementData 是保存数组的容器，默认为 null
    elementData = c.toArray();
    //如果给定的集合（c）数据有值
    if ((size = elementData.length) != 0) {
        // c.toArray might (incorrectly) not return Object[] (see 6260652)
        //如果集合元素类型不是 Object 类型，我们会转成 Object
        if (elementData.getClass() != Object[].class) {
            elementData = Arrays.copyOf(elementData, size, Object[].class);
        }
    } else {
        // 给定集合（c）无值，则默认空数组
        this.elementData = EMPTY_ELEMENTDATA;
    }
}
```

除了源码的中文注释，我们补充两点：

1：ArrayList 无参构造器初始化时，默认大小是空数组，并不是大家常说的 10，10 是在第一次 add 的时候扩容的数组值。

2：指定初始数据初始化时，我们发现一个这样子的注释 see 6260652，这是 Java 的一个 bug，意思是当给定集合内的元素不是 Object 类型时，我们会转化成 Object 的类型。一般情况下都不会触发此 bug，只有在下列场景下才会触发：ArrayList 初始化之后（ArrayList 元素非 Object 类型），再次调用 toArray 方法，得到 Object 数组，并且往 Object 数组赋值时，才会触发此 bug，代码和原因如图：
![图片描述](https://img.mukewang.com/5d5fc6100001109518100714.png)官方查看文档地址：https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6260652，问题在 Java 9 中被解决。



### 2.2 新增和扩容实现

新增就是往数组中添加元素，主要分成两步：

- 判断是否需要扩容，如果需要执行扩容操作；
- 直接赋值。

两步源码体现如下：

```java
public boolean add(E e) {
  //确保数组大小是否足够，不够执行扩容，size 为当前数组的大小
  ensureCapacityInternal(size + 1);  // Increments modCount!!
  //直接赋值，线程不安全的
  elementData[size++] = e;
  return true;
}
```

我们先看下扩容（ensureCapacityInternal）的源码：

```java
private void ensureCapacityInternal(int minCapacity) {
  //如果初始化数组大小时，有给定初始值，以给定的大小为准，不走 if 逻辑
  if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
    minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
  }
  //确保容积足够
  ensureExplicitCapacity(minCapacity);
}
private void ensureExplicitCapacity(int minCapacity) {
  //记录数组被修改
  modCount++;
  // 如果我们期望的最小容量大于目前数组的长度，那么就扩容
  if (minCapacity - elementData.length > 0)
    grow(minCapacity);
}
//扩容，并把现有数据拷贝到新的数组里面去
private void grow(int minCapacity) {
  int oldCapacity = elementData.length;
  // oldCapacity >> 1 是把 oldCapacity 除以 2 的意思
  int newCapacity = oldCapacity + (oldCapacity >> 1);

  // 如果扩容后的值 < 我们的期望值，扩容后的值就等于我们的期望值
  if (newCapacity - minCapacity < 0)
    newCapacity = minCapacity;

  // 如果扩容后的值 > jvm 所能分配的数组的最大值，那么就用 Integer 的最大值
  if (newCapacity - MAX_ARRAY_SIZE > 0)
    newCapacity = hugeCapacity(minCapacity);
 
  // 通过复制进行扩容
  elementData = Arrays.copyOf(elementData, newCapacity);
}
```

注解应该比较详细，我们需要注意的四点是：

- 扩容的规则并不是翻倍，是原来容量大小 + 容量大小的一半，直白来说，扩容后的大小是原来容量的 1.5 倍；
- ArrayList 中的数组的最大值是 Integer.MAX_VALUE，超过这个值，JVM 就不会给数组分配内存空间了。
- 新增时，并没有对值进行严格的校验，所以 ArrayList 是允许 null 值的。

从新增和扩容源码中，下面这点值得我们借鉴：

- 源码在扩容的时候，有数组大小溢出意识，就是说扩容后数组的大小下界不能小于 0，上界不能大于 Integer 的最大值，这种意识我们可以学习。

扩容完成之后，赋值是非常简单的，直接往数组上添加元素即可：elementData [size++] = e。也正是通过这种简单赋值，没有任何锁控制，所以这里的操作是线程不安全的，对于新增和扩容的实现，画了一个动图，如下：
![图片描述](https://img.mukewang.com/5d5fc62e000112c203600240.gif)



### 2.3 扩容的本质

扩容是通过这行代码来实现的：`Arrays.copyOf(elementData, newCapacity);`，这行代码描述的本质是数组之间的拷贝，扩容是会先新建一个符合我们预期容量的新数组，然后把老数组的数据拷贝过去，我们通过 System.arraycopy 方法进行拷贝，此方法是 native 的方法，源码如下：

```java
/**
 * @param src     被拷贝的数组
 * @param srcPos  从数组那里开始
 * @param dest    目标数组
 * @param destPos 从目标数组那个索引位置开始拷贝
 * @param length  拷贝的长度 
 * 此方法是没有返回值的，通过 dest 的引用进行传值
 */
public static native void arraycopy(Object src, int srcPos,
                                    Object dest, int destPos,
                                    int length);
```

我们可以通过下面这行代码进行调用，newElementData 表示新的数组：

```java
System.arraycopy(elementData, 0, newElementData, 0,Math.min(elementData.length,newCapacity))
```



### 2.4 删除

ArrayList 删除元素有很多种方式，比如根据数组索引删除、根据值删除或批量删除等等，原理和思路都差不多，我们选取根据值删除方式来进行源码说明：

```java
public boolean remove(Object o) {
  // 如果要删除的值是 null，找到第一个值是 null 的删除
  if (o == null) {
    for (int index = 0; index < size; index++)
      if (elementData[index] == null) {
        fastRemove(index);
        return true;
      }
  } else {
    // 如果要删除的值不为 null，找到第一个和要删除的值相等的删除
    for (int index = 0; index < size; index++)
      // 这里是根据  equals 来判断值相等的，相等后再根据索引位置进行删除
      if (o.equals(elementData[index])) {
        fastRemove(index);
        return true;
      }
  }
  return false;
}
```

我们需要注意的两点是：

- 新增的时候是没有对 null 进行校验的，所以删除的时候也是允许删除 null 值的；
- 找到值在数组中的索引位置，是通过 equals 来判断的，如果数组元素不是基本类型，需要我们关注 equals 的具体实现。

上面代码已经找到要删除元素的索引位置了，下面代码是根据索引位置进行元素的删除：

```java
private void fastRemove(int index) {
  // 记录数组的结构要发生变动了
  modCount++;
  // numMoved 表示删除 index 位置的元素后，需要从 index 后移动多少个元素到前面去
  // 减 1 的原因，是因为 size 从 1 开始算起，index 从 0开始算起
  int numMoved = size - index - 1;
  if (numMoved > 0)
    // 从 index +1 位置开始被拷贝，拷贝的起始位置是 index，长度是 numMoved
    System.arraycopy(elementData, index+1, elementData, index, numMoved);
  //数组最后一个位置赋值 null，帮助 GC
  elementData[--size] = null;
}
```

从源码中，我们可以看出，某一个元素被删除后，为了维护数组结构，我们都会把数组后面的元素往前移动，下面动图也演示了其过程：
![图片描述](https://img.mukewang.com/5d5fc643000142a403600240.gif)



### 2.5 迭代器

如果要自己实现迭代器，实现 java.util.Iterator 类就好了，ArrayList 也是这样做的，我们来看下迭代器的几个总要的参数：

```java
int cursor;// 迭代过程中，下一个元素的位置，默认从 0 开始。
int lastRet = -1; // 新增场景：表示上一次迭代过程中，索引的位置；删除场景：为 -1。
int expectedModCount = modCount;// expectedModCount 表示迭代过程中，期望的版本号；modCount 表示数组实际的版本号。
```

迭代器一般来说有三个方法：

- hasNext 还有没有值可以迭代
- next 如果有值可以迭代，迭代的值是多少
- remove 删除当前迭代的值

我们来分别看下三个方法的源码：

**hasNext**

```java
public boolean hasNext() {
  return cursor != size;//cursor 表示下一个元素的位置，size 表示实际大小，如果两者相等，说明已经没有元素可以迭代了，如果不等，说明还可以迭代
}
```

**next**

```java
public E next() {
  //迭代过程中，判断版本号有无被修改，有被修改，抛 ConcurrentModificationException 异常
  checkForComodification();
  //本次迭代过程中，元素的索引位置
  int i = cursor;
  if (i >= size)
    throw new NoSuchElementException();
  Object[] elementData = ArrayList.this.elementData;
  if (i >= elementData.length)
    throw new ConcurrentModificationException();
  // 下一次迭代时，元素的位置，为下一次迭代做准备
  cursor = i + 1;
  // 返回元素值
  return (E) elementData[lastRet = i];
}
// 版本号比较
final void checkForComodification() {
  if (modCount != expectedModCount)
    throw new ConcurrentModificationException();
}
```

从源码中可以看到，next 方法就干了两件事情，第一是检验能不能继续迭代，第二是找到迭代的值，并为下一次迭代做准备（cursor+1）。

**remove**

```java
public void remove() {
  // 如果上一次操作时，数组的位置已经小于 0 了，说明数组已经被删除完了
  if (lastRet < 0)
    throw new IllegalStateException();
  //迭代过程中，判断版本号有无被修改，有被修改，抛 ConcurrentModificationException 异常
  checkForComodification();

  try {
    ArrayList.this.remove(lastRet);
    cursor = lastRet;
    // -1 表示元素已经被删除，这里也防止重复删除
    lastRet = -1;
    // 删除元素时 modCount 的值已经发生变化，在此赋值给 expectedModCount
    // 这样下次迭代时，两者的值是一致的了
    expectedModCount = modCount;
  } catch (IndexOutOfBoundsException ex) {
    throw new ConcurrentModificationException();
  }
}
```

这里我们需要注意的两点是：

- lastRet = -1 的操作目的，是防止重复删除操作
- 删除元素成功，数组当前 modCount 就会发生变化，这里会把 expectedModCount 重新赋值，下次迭代时两者的值就会一致了



### 2.6 时间复杂度

从我们上面新增或删除方法的源码解析，对数组元素的操作，只需要根据数组索引，直接新增和删除，所以时间复杂度是 O (1)。



### 2.7 线程安全

我们需要强调的是，只有当 ArrayList 作为共享变量时，才会有线程安全问题，当 ArrayList 是方法内的局部变量时，是没有线程安全的问题的。

ArrayList 有线程安全问题的本质，是因为 ArrayList 自身的 elementData、size、modConut 在进行各种操作时，都没有加锁，而且这些变量的类型并非是可见（volatile）的，所以如果多个线程对这些变量进行操作时，可能会有值被覆盖的情况。

类注释中推荐我们使用 Collections#synchronizedList 来保证线程安全，SynchronizedList 是通过在每个方法上面加上锁来实现，虽然实现了线程安全，但是性能大大降低，具体实现源码：

```java
public boolean add(E e) {
    synchronized (mutex) {// synchronized 是一种轻量锁，mutex 表示一个当前 SynchronizedList
        return c.add(e);
    }
}
```



## 总结

本文从 ArrayList 整体架构出发，落地到初始化、新增、扩容、删除、迭代等核心源码实现，我们发现 ArrayList 其实就是围绕底层数组结构，各个 API 都是对数组的操作进行封装，让使用者无需感知底层实现，只需关注如何使用即可。

[04 Arrays、Collections、Objects 常用方法源码解析](https://www.imooc.com/read/47/article/846)[06 LinkedList 源码解析](https://www.imooc.com/read/47/article/848)

精选留言 33

欢迎在这里发表留言，作者筛选后可公开显示

- [youcai35](https://www.imooc.com/u/7109637/articles)

  ArrayList testBatchInsert 调换单个循环和批量循环时间顺序显示结果刚好相反，单独放入到两个方法执行，显示结果差距不是很大，希望老师能够抽时间答疑解惑

   1

  回复

  2020-01-06

- [慕运维8132720](https://www.imooc.com/u/7945317/articles)

  arraylist 在初始化的时候，有两个构造函数。一个无参，一个有参。 我有个问题，无参的时候给了一个空数组；有参情况下，参数为 0 的时候，也是给空数组。 但是代码里面设置的两个空数组，为何不用同一个呢？

   0

  回复

  2019-12-17

  - [JueYingCoder](https://www.imooc.com/u/195732/articles)

    回复[慕运维8132720](https://www.imooc.com/u/7945317/articles)

    为什么有两个空数组，看源码注释 /** * Shared empty array instance used for default sized empty instances. We * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when * first element is added. */ private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};

    回复

    2020-01-07 18:23:15

- [萌萌萌唬](https://www.imooc.com/u/6366873/articles)

  private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;这个 -8 是为什么？

   1

  回复

  2019-12-07

- [所相虚妄](https://www.imooc.com/u/7839242/articles)

  synchronized 是一种轻量锁 。。。 synchronized 不是重量锁么。。。

   1

  回复

  2019-12-07

  - [qq_铂协成员_0](https://www.imooc.com/u/6969428/articles)

    回复[所相虚妄](https://www.imooc.com/u/7839242/articles)

    jdk 1.6 优化了，之前是重量锁

    回复

    2019-12-25 21:18:17

- [凉凉那个凉凉](https://www.imooc.com/u/3162691/articles)

  迭代器的意义是什么？迭代器中的功能用for循环也完全都能简单实现吧

   1

  回复

  2019-12-05

  - [所相虚妄](https://www.imooc.com/u/7839242/articles)

    回复[凉凉那个凉凉](https://www.imooc.com/u/3162691/articles)

    foreach增强就是靠着迭代器实现的。 迭代器里还有安全的remove方法。

    回复

    2019-12-07 01:37:12

  - [萌萌萌唬](https://www.imooc.com/u/6366873/articles)

    回复[凉凉那个凉凉](https://www.imooc.com/u/3162691/articles)

    迭代器是一种同一的集合调用机制，调用方式都一样的，就如同接口一样，有一个统一的如口

    回复

    2019-12-07 15:58:32

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[凉凉那个凉凉](https://www.imooc.com/u/3162691/articles)

    下面几个同学回答的都非常好，我理解这可能就是一种抽象的思想，比如我们想要 List 循环时，我们给 List 写 for 循环，想要 Set 循环时，我们给 Set 写 for 循环，如果再来 Map 呢？这时候我们会发现这些循环基本都是重复代码，而且还有一些坑在里面，这时候我们就可以把循环这种行为抽象成迭代器，这样也方便容器的扩展，比如以后新建一个容器后，只要容器实现了迭代器的规范，自然就拥有的了迭代的功能，这就是我们平时工作中经常要到的方法论：先复制粘贴，然后再把公用的抽象，最后经过验证后，把抽象的接口提供给其他程序使用。

    回复

    2019-12-08 13:41:07

- [洗衣粉1](https://www.imooc.com/u/2930191/articles)

  老师，elementData设置成了transient，那ArrayList是怎么把元素序列化的呢？

   1

  回复

  2019-11-02

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[洗衣粉1](https://www.imooc.com/u/2930191/articles)

    同学你好，这个问题其实自己 debug 一下基本就能发现问题，多多 debug。 和序列化工具关系很大，我用的是阿里的 fastjson 进行序列化，debug 在 com.alibaba.fastjson.serializer.ListSerializer 68行左右，会把 List 里面每个值拿出来 append 到 SerializeWriter(可以理解成 StringBuffer的缓冲区) 上，最后输出一定格式的字符串，如果是其他序列化工具的话，可能又是其他的方式了，transient 关键字用途是好的，但序列化方式很多，两者没有太大的关系。

    回复

    2019-11-04 10:44:10

  - [所相虚妄](https://www.imooc.com/u/7839242/articles)

    回复[洗衣粉1](https://www.imooc.com/u/2930191/articles)

    他自己实现了那个接口啊

    回复

    2019-11-05 12:39:26

  - [wwwwwwei](https://www.imooc.com/u/2423625/articles)

    回复[洗衣粉1](https://www.imooc.com/u/2930191/articles)

    ArrayList里面的readObject和writeObject方法了解一下？？

    回复

    2019-11-16 11:30:53

- [Sicimike](https://www.imooc.com/u/3395084/articles)

  大佬，ArrayList中存储数据的数组为啥是Object[]，而不是E[]。是因为泛型在1.5才引入，而ArrayList在1.2就有了吗？

   0

  回复

  2019-10-28

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[Sicimike](https://www.imooc.com/u/3395084/articles)

    你分析的很有道理的。

    回复

    2019-10-31 12:55:27

  - [少为](https://www.imooc.com/u/5795443/articles)

    回复[Sicimike](https://www.imooc.com/u/3395084/articles)

    也许还有另外一个原因，Java是不支持创建泛型数组的 。 当然可以创建Object数组然后强转为E[]。

    回复

    2019-11-20 19:31:58

- [树上有_云](https://www.imooc.com/u/3526435/articles)

  size 不是当前数组的大小吧，而是元素的个数

   0

  回复

  2019-10-24

  - [凉凉那个凉凉](https://www.imooc.com/u/3162691/articles)

    回复[树上有_云](https://www.imooc.com/u/3526435/articles)

    是的 在所有的列表中都有Capacity 和 size 两个字段 Capacity是指容量 size 是指目前列表中元素个数

    回复

    2019-12-05 21:48:36

- [南船座](https://www.imooc.com/u/3583322/articles)

  int oldCapacity = elementData.length; // oldCapacity >> 1 是把 oldCapacity 除以 2 的意思 int newCapacity = oldCapacity + (oldCapacity >> 1); // 如果扩容后的值 < 我们的期望值，扩容后的值就等于我们的期望值 if (newCapacity - minCapacity < 0) newCapacity = minCapacity; newCapacity已经是oldCapacity除以2再加上oldCapacity了 那无论如何都是不存在的newCapacity小于oldCapacity if (newCapacity - minCapacity < 0) newCapacity = minCapacity; 为什么还要这么写？

   1

  回复

  2019-10-21

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[南船座](https://www.imooc.com/u/3583322/articles)

    同学你好，你可以看下 allAll 方法，这个方法引起的扩容，minCapacity 有可能非常大，甚至大于 minCapacity，就会出现 newCapacity - minCapacity 的情况。

    回复

    2019-10-21 22:03:54

  - [魅影劲](https://www.imooc.com/u/4768694/articles)

    回复[南船座](https://www.imooc.com/u/3583322/articles)

    参考07节List源码会问那些问面试 1.2.3 就有这种CASE

    回复

    2019-11-18 16:12:47

- [喵喵喵111](https://www.imooc.com/u/7563198/articles)

  向末尾插入数据的时候，确实是o（1），如果刚好在需要扩容的临界点进行添加和删除，那么不就是o(n)了么

   2

  回复

  2019-10-19

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[喵喵喵111](https://www.imooc.com/u/7563198/articles)

    是的，正好碰到扩容时候是的。

    回复

    2019-10-21 22:00:13

  - [魅影劲](https://www.imooc.com/u/4768694/articles)

    回复[喵喵喵111](https://www.imooc.com/u/7563198/articles)

    根据均摊时间复杂度分析,当我们添加到最后一个元素时，如果此时再往里添加一个元素，那么就将进行数组的扩容操作。这次扩容的算法复杂度为O(n),此时我们就要用到均摊复杂度分析法，前面n次操作耗费时间总共为n,第n+1次操作耗费时间为n,相当于执行n+1次操作耗费的时间为2n,那么平均来看，我们每次操作其实耗费的时间为2，他仍然是一个O(1)级别的算法。在这里我把一次线性操作(第n+1次)的复杂度均摊到前面n次操作中。

    回复

    2019-11-18 15:23:12

  - [喵喵喵111](https://www.imooc.com/u/7563198/articles)

    回复[魅影劲](https://www.imooc.com/u/4768694/articles)

    那如果我在扩容以后立马缩容。就在这个临界点来回添加删除，那时间复杂度不就变成了on了么

    回复

    2019-11-18 16:36:02

  点击展开后面 2 条

- [喵喵喵111](https://www.imooc.com/u/7563198/articles)

  老师，如果数组刚好处于扩容的临界点，这时候进行数组的增加，再减少，每次的复杂度都会为o(n)，并不是所说的o(1)呀

   2

  回复

  2019-10-19

  - [dengweiqiang](https://www.imooc.com/u/1964095/articles)

    回复[喵喵喵111](https://www.imooc.com/u/7563198/articles)

    ArrayList根本就没有缩容这回事情啊，你remove数据，只是移动数据并没有改变数组的大小，所以只有扩容，没有缩容

    回复

    2019-12-10 23:10:14

- [大胖晴](https://www.imooc.com/u/5171712/articles)

  老师，想问您一个问题: 就是我们担心的并发下的数据安全问题，有2个概念想跟老师确认下，1、如果不是操作数据库的数据 是那些共享数据 ，此时并发下，多个线程操作它就会存在线程安全问题， 然后如果是在方法内，并发的情况下，多个线程去操作方法内的变量，就不会出现线程安全问题，此时相当于每个线程操作的其实是自己内存里面的东西; 2、第二个的话就是操作数据库中的数据 那么是不是我们想控制线程执行的顺序，来保证数据的安全，一方面是要加上事务去管理， 另外的话可能要一些数据库的锁 , 如 for update排他锁这些，来实现我们的需要； 3、所以java层面的如sychronized(轻量锁)等 和 数据事务锁其实是2个概念吧，一个是Java层面的，一个是数据库层面的，2者并没有啥联系， 所以，老师，请教您一下，我分析的概念对嘛？

   1

  回复

  2019-10-18

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[大胖晴](https://www.imooc.com/u/5171712/articles)

    分析对的哈，不过我们很少使用 for update 锁，数据库资源本来就很紧张，使用数据库会加剧数据库资源紧张的局面，一般我们都用分布式 redis 锁 + 数据库版本号来解决并发请求的问题。

    回复

    2019-10-19 10:40:34

  - [大胖晴](https://www.imooc.com/u/5171712/articles)

    回复

    [文贺](https://www.imooc.com/u/8062574/articles)

    懂了，谢谢老师，哈哈

    回复

    2019-10-19 13:56:44

- [威先森](https://www.imooc.com/u/6261517/articles)

  迭代器中remove方法不能单独调用的，必须先调用next方法才能给lastRet变量赋值。好像场景正常也都是先next取出值，满足条件才remove的，源码的设计真的是返璞归真

   1

  回复

  2019-10-12

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[威先森](https://www.imooc.com/u/6261517/articles)

    是的，remove 方法有校验的。

    回复

    2019-10-14 12:45:51

- [Doubj](https://www.imooc.com/u/7851285/articles)

  老师，2.7有个疑问。当ArrayList是方法内的局部变量时，是没有线程安全的问题的，但我在学JVM内存模型中有学到对象实例都是存在线程共享的JAVA堆中的，修改的都是同一个对象实例，这样也没有线程安全问题吗？或者说老师能具体举一下具体情境ArrayList下线程安全的例子吗？

   1

  回复

  2019-10-08

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[Doubj](https://www.imooc.com/u/7851285/articles)

    同学你好，方法中的局部变量是肯定没有安全的问题的，除非你把局部变量用引用传值给多个子线程。 方法中的局部变量是属于每个线程栈，线程栈之间都是隔离的，所以不会共享资源，也不会有线程安全问题，论证的话，也很简单，你看高并发的互联网公司，方法中的局部变量使用时从不加锁，也不考虑其线程安全就清楚了哈。 具体场景你看下 《18 场景集合：并发 List、Map 的应用场景》这章，其中的 flowMap 是共享变量，有线程安全的问题。

    回复

    2019-10-08 19:21:32

  - [Doubj](https://www.imooc.com/u/7851285/articles)

    回复

    [文贺](https://www.imooc.com/u/8062574/articles)

    明白了~谢谢老师:)

    回复

    2019-10-09 10:31:49

- [鹏飞天下](https://www.imooc.com/u/1010756/articles)

  ArrayList删除元素的时间复杂度怎么能是O（1）呢？他不是有元素的移动吗？

   2

  回复

  2019-09-25

  - [Secondary4010867](https://www.imooc.com/u/4010867/articles)

    回复[鹏飞天下](https://www.imooc.com/u/1010756/articles)

    应该是O(n)吧

    回复

    2019-09-26 07:44:47

  - [SodaGreen_](https://www.imooc.com/u/5409387/articles)

    回复[鹏飞天下](https://www.imooc.com/u/1010756/articles)

    我也觉得老师讲错了吧这块，还有如果扩容的话，要copy数组，怎么会是o（1）<br />

    回复

    2019-09-28 06:10:20

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[鹏飞天下](https://www.imooc.com/u/1010756/articles)

    同学你好，这个在下面的回复中有提到哈，文中的表达是：只需要根据数组索引，直接新增和删除，所以时间复杂度是 O (1)，说的是可以直接根据数组的索引，找到数组的位置，这个时间复杂度是 O (1)。

    回复

    2019-10-08 11:50:33

  点击展开后面 2 条

- [licly](https://www.imooc.com/u/8096709/articles)

  3、还是newCapacity方法 if (minCapacity < 0) // overflow throw new OutOfMemoryError(); 这种情况是Integer循环回去了吗，比如到达Integer.MAX_VALUE，继续增加，就会变成负数 4、既然jvm只能分配MAX_ARRAY_SIZE个长度，那hugeCapacity(int minCapacity)方法中为什么又做了 (minCapacity > MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE这样的判断 本来想一次贴代码来着，结果留言有字数限制，问题还分了两次提问，所以代码就不贴了，麻烦老师了

   1

  回复

  2019-09-16

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[licly](https://www.imooc.com/u/8096709/articles)

    3：不是循环回去了，Integer.MAX_VALUE 的值是 2147483647，继续 +1 就会变成 -2147483648。 4：Integer.MAX_VALUE 是 int 类型的大小限制，不是 JVM 限制，判断只是正常的业务校验哈。

    回复

    2019-09-17 18:50:55

  - [licly](https://www.imooc.com/u/8096709/articles)

    回复

    [文贺](https://www.imooc.com/u/8062574/articles)

    第四个问题：那ArrayList的最大长度就是Integer.MAX_VALUE，不是MAX_ARRAY_SIZE吧，这样理解对吗

    回复

    2019-09-17 21:44:16

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[licly](https://www.imooc.com/u/8096709/articles)

    是的，最大能到 Integer.MAX_VALUE

    回复

    2019-09-18 21:28:00

  点击展开后面 6 条

- [licly](https://www.imooc.com/u/8096709/articles)

  老师，请教几个问题： 1.9中 1、grow方法【line241~243】为什么要将size+1呢 代码： private Object[] grow() { return grow(size + 1); } 2、newCapacity方法中【line254~268】 if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA)，这种情况下minCapacity肯定是1呀，Math.max(DEFAULT_CAPACITY, minCapacity)这行代码使用max方法的作用是什么，感觉完全可以不用呀

   1

  回复

  2019-09-16

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[licly](https://www.imooc.com/u/8096709/articles)

    第一个问题，你说的源码我完全找不到哈。第二个问题，当使用入参数是 Collection&lt;? extends E&gt; c 的构造器的时候，minCapacity 不一定是 1哦。

    回复

    2019-09-17 18:41:29

  - [licly](https://www.imooc.com/u/8096709/articles)

    回复

    [文贺](https://www.imooc.com/u/8062574/articles)

    第二个问题：满足if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA)这个条件的只有无参构造的list吧，如果是指定元素的构造public ArrayList(Collection&lt;? extends E&gt; c) ，elementData是不满足这个条件的

    回复

    2019-09-17 21:42:35

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[licly](https://www.imooc.com/u/8096709/articles)

    你好 同学，是的哈。

    回复

    2019-09-18 21:24:38

- [power_cheng4342740](https://www.imooc.com/u/4342740/articles)

  钻个牛角尖: 在使用迭代器或增强for循环时, 如果数组大小被改变未必会抛异常.比如在迭代器中使用迭代器的remove()方法, 或在增强for循环中增删元素后就结束了当前循环

   4

  回复

  2019-09-12

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[power_cheng4342740](https://www.imooc.com/u/4342740/articles)

    很棒哈，是的，看场景的，这个在 《List 源码会问哪些面试题》中有详细描述。

    回复

    2019-09-12 18:59:08

  - [贰零一贰](https://www.imooc.com/u/2232970/articles)

    回复[power_cheng4342740](https://www.imooc.com/u/4342740/articles)

    哈哈 看评论又学到一招！

    回复

    2019-09-16 19:04:48

- [power_cheng4342740](https://www.imooc.com/u/4342740/articles)

  准确的说成员变量size并不是表示当前数组的大小, 它表示的是当前集合元素的个数.举个例子:第一次向集合中插入一个元素后, 数组大小为10, 而size值为1

   0

  回复

  2019-09-12

- [和尚码代码](https://www.imooc.com/u/7388288/articles)

  在GitHub中，文章源代码 ArrayListDemo中testBatchInsert 注释没有修改，应该是单个新增和批量新增

   0

  回复

  2019-09-10

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[和尚码代码](https://www.imooc.com/u/7388288/articles)

    收到，demo 注释已修改，代码已提交。

    回复

    2019-09-11 12:37:10

  - [zky](https://www.imooc.com/u/1997951/articles)

    回复[和尚码代码](https://www.imooc.com/u/7388288/articles)

    请问github源码 在哪里可以找到呢？ url路径是啥呢

    回复

    2019-09-13 18:37:36

- [qq_蔡骚哥_0](https://www.imooc.com/u/6746843/articles)

  老师厉害哦，学到很多。

   2

  回复

  2019-09-07

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[qq_蔡骚哥_0](https://www.imooc.com/u/6746843/articles)

    感谢，你也可以的哈。

    回复

    2019-09-08 10:05:30

- [weixin_慕哥3371281](https://www.imooc.com/u/8105561/articles)

  内容细致，条理也比较清晰，真心不错。

   2

  回复

  2019-09-05

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[weixin_慕哥3371281](https://www.imooc.com/u/8105561/articles)

    感谢支持，你的支持是对文贺最大的鼓励。

    回复

    2019-09-06 12:49:47

- [慕设计6098684](https://www.imooc.com/u/6524787/articles)

  「初始化时，如果你给定的大小 < 10，那么初始化大小是按照 10 计算的，并不是你给定的值；」 代码备注改了，总结没改噢

   0

  回复

  2019-09-03

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[慕设计6098684](https://www.imooc.com/u/6524787/articles)

    好的，收到，已订正。

    回复

    2019-09-04 14:16:48

- [慕沐3552275](https://www.imooc.com/u/6849459/articles)

  "所以当你在初始化数组大小时，如果你给定的初始化大小是 4，其实还是拿着 10 去计算的"这个地方不太理解，这部分的if条件是elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA。如果给定初始化大小的话那么elementData就不会是DEFAULTCAPACITY_EMPTY_ELEMENTDATA了。

   3

  回复

  2019-09-02

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[慕沐3552275](https://www.imooc.com/u/6849459/articles)

    火眼金睛，感谢，已订正，快微信联系我，给你发个大红包。

    回复

    2019-09-03 09:39:21

- [langlangliu](https://www.imooc.com/u/2781999/articles)

  这里似乎是不对的 【如果你给定的初始化大小是 4，其实还是拿着 10 去计算的】 文档内的代码: 【【【 private void ensureCapacityInternal(int minCapacity) { //如果是空数组，就从最小容量和默认容量10之间取最大值 //所以当你在初始化数组大小时，如果你给定的初始化大小是 4，其实还是拿着 10 去计算的 if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); } ...省略... } 】】】 这里如果初始化大小为4, 上面的if不会执行(此时 elementData = new Object[4]), 之后扩容还是到6, 9, 14...

   1

  回复

  2019-09-02

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[langlangliu](https://www.imooc.com/u/2781999/articles)

    火眼金睛，感谢，已订正，快微信联系我，给你发个大红包。

    回复

    2019-09-03 09:39:18

- [用户1148542](https://www.imooc.com/u/1148542/articles)

  如果我构造函数中传递的参数是4 this.elementData = new Object[initialCapacity]; 而这个时候size 值不应该变成4么 只是上面的数组里面存储的都是null而已

   1

  回复

  2019-09-01

  - [慕沐3552275](https://www.imooc.com/u/6849459/articles)

    回复[用户1148542](https://www.imooc.com/u/1148542/articles)

    size是0，数组长度是4，是两个概念吧

    回复

    2019-09-02 12:45:28

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[用户1148542](https://www.imooc.com/u/1148542/articles)

    initialCapacity 标识初始化容量大小。size 是实际大小，是两个概念哈。

    回复

    2019-09-02 13:23:46

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[慕沐3552275](https://www.imooc.com/u/6849459/articles)

    棒，你说的是对的哈。

    回复

    2019-09-02 13:23:55

- [小森森的森](https://www.imooc.com/u/6267911/articles)

  老师，没有看懂这段代码，为什么要!= Object[].class? if (elementData.getClass() != Object[].class) { elementData = Arrays.copyOf(elementData, size, Object[].class); }

   0

  回复

  2019-08-28

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[小森森的森](https://www.imooc.com/u/6267911/articles)

    这是因为 elementData 是个 Object 的数组哈。但入参的 Collection&lt;? extends E&gt; c 却不定是 Object 的数组，所以需要转化下。

    回复

    2019-08-31 09:05:39

- [wsdevotion](https://www.imooc.com/u/2584699/articles)

  请问什么时候能更新完呀

   0

  回复

  2019-08-28

  - [初一](https://www.imooc.com/u/7789740/articles)

    回复[wsdevotion](https://www.imooc.com/u/2584699/articles)

    同学你好 本专栏是每周二、周四进行更新,感谢支持 ^^

    回复

    2019-09-02 15:48:24

- [慕粉2112063460](https://www.imooc.com/u/4901550/articles)

  04章，是不是还没发布？

   0

  回复

  2019-08-28

  - [初一](https://www.imooc.com/u/7789740/articles)

    回复[慕粉2112063460](https://www.imooc.com/u/4901550/articles)

    是的 明天更新^^

    回复

    2019-08-28 16:49:52

- [道临](https://www.imooc.com/u/3120165/articles)

  老师，remove时后面的元素不是都向前移吗，最坏不应该是O(n)级复杂度吗，为什么文中说是O(1)

   1

  回复

  2019-08-28

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[道临](https://www.imooc.com/u/3120165/articles)

    文中说的是查找到要操作的数据的时间复杂度哈，根据索引位置直接定位数据。

    回复

    2019-08-28 22:48:34

  - [慕神9346227](https://www.imooc.com/u/7808597/articles)

    回复[道临](https://www.imooc.com/u/3120165/articles)

    我也这么觉得，插入和删除应该是O(n)吧

    回复

    2019-09-04 14:20:48

  - [小明同学爱思考](https://www.imooc.com/u/1864581/articles)

    回复

    [文贺](https://www.imooc.com/u/8062574/articles)

    但是文中表述不是这样的

    回复

    2019-09-05 09:19:29

  点击展开后面 1 条

- [Gitcommit](https://www.imooc.com/u/5054459/articles)

  初始化那边是不是少了一个指定大小初始化的 public ArrayList(int initialCapacity) { if (initialCapacity > 0) { this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) { this.elementData = EMPTY_ELEMENTDATA; } else { throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity);

   0

  回复

  2019-08-28

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[Gitcommit](https://www.imooc.com/u/5054459/articles)

    棒，篇幅有限哈，选取了部分。

    回复

    2019-08-28 22:50:36

- [蓝山帝景](https://www.imooc.com/u/6798227/articles)

  正在准备面试中，刷下源码对于技术面还可以放心一点，还挺全面的，工作中经常用到的知识点都能了解到

   1

  回复

  2019-08-27

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[蓝山帝景](https://www.imooc.com/u/6798227/articles)

    嗯嗯，基本都是工作中常用的点，希望你面试成功，平步青云。

    回复

    2019-08-27 19:18:03

- [富国沪深](https://www.imooc.com/u/6798226/articles)

  一直对于各个底层的实现很好奇，我觉得线程池、线程、集合、队列现在用的很多，看着老师这门课程写的很实用了，学到了 打卡~~

   1

  回复

  2019-08-27

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[富国沪深](https://www.imooc.com/u/6798226/articles)

    一起加油，共同进步。

    回复

    2019-08-28 22:51:09

 

千学不如一看，千看不如一练

 

# 06 LinkedList 源码解析

06 LinkedList 源码解析

更新时间：2019-11-26 09:44:59

![img](https://img4.mukewang.com/5d63560c0001044d06400359.jpg)

![img](https://www.imooc.com/static/img/column/bg-l.png)![img](https://www.imooc.com/static/img/column/bg-r.png)

智慧，不是死的默念，而是生的沉思。

——斯宾诺莎



## 引导语

LinkedList 适用于集合元素先入先出和先入后出的场景，在队列源码中被频繁使用，面试也经常问到，本小节让我们通过源码来加深对 LinkedList 的了解。



## 1 整体架构

LinkedList 底层数据结构是一个双向链表，整体结构如下图所示：
![图片描述](https://img.mukewang.com/5d5fc67a0001f59212400288.png)上图代表了一个双向链表结构，链表中的每个节点都可以向前或者向后追溯，我们有几个概念如下：

- 链表每个节点我们叫做 Node，Node 有 prev 属性，代表前一个节点的位置，next 属性，代表后一个节点的位置；
- first 是双向链表的头节点，它的前一个节点是 null。
- last 是双向链表的尾节点，它的后一个节点是 null；
- 当链表中没有数据时，first 和 last 是同一个节点，前后指向都是 null；
- 因为是个双向链表，只要机器内存足够强大，是没有大小限制的。

链表中的元素叫做 Node，我们看下 Node 的组成部分：

```java
private static class Node<E> {
    E item;// 节点值
    Node<E> next; // 指向的下一个节点
    Node<E> prev; // 指向的前一个节点

    // 初始化参数顺序分别是：前一个节点、本身节点值、后一个节点
    Node(Node<E> prev, E element, Node<E> next) {
        this.item = element;
        this.next = next;
        this.prev = prev;
    }
}
```



## 2 源码解析



### 2.1 追加（新增）

追加节点时，我们可以选择追加到链表头部，还是追加到链表尾部，add 方法默认是从尾部开始追加，addFirst 方法是从头部开始追加，我们分别来看下两种不同的追加方式：

**从尾部追加（add）**

```java
// 从尾部开始追加节点
void linkLast(E e) {
    // 把尾节点数据暂存
    final Node<E> l = last;
    // 新建新的节点，初始化入参含义：
    // l 是新节点的前一个节点，当前值是尾节点值
    // e 表示当前新增节点，当前新增节点后一个节点是 null
    final Node<E> newNode = new Node<>(l, e, null);
    // 新建节点追加到尾部
    last = newNode;
    //如果链表为空（l 是尾节点，尾节点为空，链表即空），头部和尾部是同一个节点，都是新建的节点
    if (l == null)
        first = newNode;![图片描述](//img.mukewang.com/5d5fc69600013e4803600240.gif)
    //否则把前尾节点的下一个节点，指向当前尾节点。
    else
        l.next = newNode;
    //大小和版本更改
    size++;
    modCount++;
}
```

从源码上来看，尾部追加节点比较简单，只需要简单地把指向位置修改下即可，我们做个动图来描述下整个过程：
![图片描述](https://img.mukewang.com/5d5fc6a300013e4803600240.gif)
**从头部追加（addFirst）**

```java
// 从头部追加
private void linkFirst(E e) {
    // 头节点赋值给临时变量
    final Node<E> f = first;
    // 新建节点，前一个节点指向null，e 是新建节点，f 是新建节点的下一个节点，目前值是头节点的值
    final Node<E> newNode = new Node<>(null, e, f);
    // 新建节点成为头节点
    first = newNode;
    // 头节点为空，就是链表为空，头尾节点是一个节点
    if (f == null)
        last = newNode;
    //上一个头节点的前一个节点指向当前节点
    else
        f.prev = newNode;
    size++;
    modCount++;
}
```

头部追加节点和尾部追加节点非常类似，只是前者是移动头节点的 prev 指向，后者是移动尾节点的 next 指向。



### 2.2 节点删除

节点删除的方式和追加类似，我们可以选择从头部删除，也可以选择从尾部删除，删除操作会把节点的值，前后指向节点都置为 null，帮助 GC 进行回收。

**从头部删除**

```java
//从头删除节点 f 是链表头节点
private E unlinkFirst(Node<E> f) {
    // 拿出头节点的值，作为方法的返回值
    final E element = f.item;
    // 拿出头节点的下一个节点
    final Node<E> next = f.next;
    //帮助 GC 回收头节点
    f.item = null;
    f.next = null;
    // 头节点的下一个节点成为头节点
    first = next;
    //如果 next 为空，表明链表为空
    if (next == null)
        last = null;
    //链表不为空，头节点的前一个节点指向 null
    else
        next.prev = null;
    //修改链表大小和版本
    size--;
    modCount++;
    return element;
}
```

从尾部删除节点代码也是类似的，就不贴了。

**从源码中我们可以了解到，链表结构的节点新增、删除都非常简单，仅仅把前后节点的指向修改下就好了，所以 LinkedList 新增和删除速度很快。**



### 2.3 节点查询

链表查询某一个节点是比较慢的，需要挨个循环查找才行，我们看看 LinkedList 的源码是如何寻找节点的：

```java
// 根据链表索引位置查询节点
Node<E> node(int index) {
    // 如果 index 处于队列的前半部分，从头开始找，size >> 1 是 size 除以 2 的意思。
    if (index < (size >> 1)) {
        Node<E> x = first;
        // 直到 for 循环到 index 的前一个 node 停止
        for (int i = 0; i < index; i++)
            x = x.next;
        return x;
    } else {// 如果 index 处于队列的后半部分，从尾开始找
        Node<E> x = last;
        // 直到 for 循环到 index 的后一个 node 停止
        for (int i = size - 1; i > index; i--)
            x = x.prev;
        return x;
    }
}
```

从源码中我们可以发现，LinkedList 并没有采用从头循环到尾的做法，而是采取了简单二分法，首先看看 index 是在链表的前半部分，还是后半部分。如果是前半部分，就从头开始寻找，反之亦然。通过这种方式，使循环的次数至少降低了一半，提高了查找的性能，这种思想值得我们借鉴。



### 2.4 方法对比

LinkedList 实现了 Queue 接口，在新增、删除、查询等方面增加了很多新的方法，这些方法在平时特别容易混淆，在链表为空的情况下，返回值也不太一样，我们列一个表格，方便大家记录：

| 方法含义 | 返回异常  | 返回特殊值 | 底层实现                                         |
| :------- | :-------- | :--------- | :----------------------------------------------- |
| 新增     | add(e)    | offer(e)   | 底层实现相同                                     |
| 删除     | remove()  | poll(e)    | 链表为空时，remove 会抛出异常，poll 返回 null。  |
| 查找     | element() | peek()     | 链表为空时，element 会抛出异常，peek 返回 null。 |

PS：Queue 接口注释建议 add 方法操作失败时抛出异常，但 LinkedList 实现的 add 方法一直返回 true。
LinkedList 也实现了 Deque 接口，对新增、删除和查找都提供从头开始，还是从尾开始两种方向的方法，比如 remove 方法，Deque 提供了 removeFirst 和 removeLast 两种方向的使用方式，但当链表为空时的表现都和 remove 方法一样，都会抛出异常。



### 2.5 迭代器

因为 LinkedList 要实现双向的迭代访问，所以我们使用 Iterator 接口肯定不行了，因为 Iterator 只支持从头到尾的访问。Java 新增了一个迭代接口，叫做：ListIterator，这个接口提供了向前和向后的迭代方法，如下所示：

| 迭代顺序         | 方法                                 |
| :--------------- | :----------------------------------- |
| 从尾到头迭代方法 | hasPrevious、previous、previousIndex |
| 从头到尾迭代方法 | hasNext、next、nextIndex             |

LinkedList 实现了 ListIterator 接口，如下图所示：

```java
// 双向迭代器
private class ListItr implements ListIterator<E> {
    private Node<E> lastReturned;//上一次执行 next() 或者 previos() 方法时的节点位置
    private Node<E> next;//下一个节点
    private int nextIndex;//下一个节点的位置
    //expectedModCount：期望版本号；modCount：目前最新版本号
    private int expectedModCount = modCount;
    …………
}
```

我们先来看下从头到尾方向的迭代：

```java
// 判断还有没有下一个元素
public boolean hasNext() {
    return nextIndex < size;// 下一个节点的索引小于链表的大小，就有
}

// 取下一个元素
public E next() {
    //检查期望版本号有无发生变化
    checkForComodification();
    if (!hasNext())//再次检查
        throw new NoSuchElementException();
    // next 是当前节点，在上一次执行 next() 方法时被赋值的。
    // 第一次执行时，是在初始化迭代器的时候，next 被赋值的
    lastReturned = next;
    // next 是下一个节点了，为下次迭代做准备
    next = next.next;
    nextIndex++;
    return lastReturned.item;
}
```

上述源码的思路就是直接取当前节点的下一个节点，而从尾到头迭代稍微复杂一点，如下：

```java
// 如果上次节点索引位置大于 0，就还有节点可以迭代
public boolean hasPrevious() {
    return nextIndex > 0;
}
// 取前一个节点
public E previous() {
    checkForComodification();
    if (!hasPrevious())
        throw new NoSuchElementException();
    // next 为空场景：1:说明是第一次迭代，取尾节点(last);2:上一次操作把尾节点删除掉了
    // next 不为空场景：说明已经发生过迭代了，直接取前一个节点即可(next.prev)
    lastReturned = next = (next == null) ? last : next.prev;
    // 索引位置变化
    nextIndex--;
    return lastReturned.item;
}
```

这里复杂点体现在需要判断 next 不为空和为空的场景，代码注释中有详细的描述。

**迭代器删除**

LinkedList 在删除元素时，也推荐通过迭代器进行删除，删除过程如下：

```java
public void remove() {
    checkForComodification();
    // lastReturned 是本次迭代需要删除的值，分以下空和非空两种情况：
    // lastReturned 为空，说明调用者没有主动执行过 next() 或者 previos()，直接报错
    // lastReturned 不为空，是在上次执行 next() 或者 previos()方法时赋的值
    if (lastReturned == null)
        throw new IllegalStateException();
    Node<E> lastNext = lastReturned.next;
    //删除当前节点
    unlink(lastReturned);
    // next == lastReturned 的场景分析：从尾到头递归顺序，并且是第一次迭代，并且要删除最后一个元素的情况下
    // 这种情况下，previous() 方法里面设置了 lastReturned = next = last,所以 next 和 lastReturned会相等
    if (next == lastReturned)
        // 这时候 lastReturned 是尾节点，lastNext 是 null，所以 next 也是 null，这样在 previous() 执行时，发现 next 是 null，就会把尾节点赋值给 next
        next = lastNext;
    else
        nextIndex--;
    lastReturned = null;
    expectedModCount++;
}
```



## 总结

LinkedList 适用于要求有顺序、并且会按照顺序进行迭代的场景，主要是依赖于底层的链表结构，在面试中的频率还是蛮高的，相信理清楚上面的源码后，应对面试应该没有问题。

[05 ArrayList 源码解析和设计思路](https://www.imooc.com/read/47/article/847)[07 List 源码会问哪些面试题](https://www.imooc.com/read/47/article/849)

精选留言 15

欢迎在这里发表留言，作者筛选后可公开显示

- [随风绽放](https://www.imooc.com/u/4764432/articles)

  LinkedList 并没有采用从头循环到尾的做法，而是采取了简单二分法，我的问题是：为什么不再次进行优化呢，明显这个二分离最优还很远。

   0

  回复

  1天前

- [冯乐哥哥](https://www.imooc.com/u/4178685/articles)

  老师 我发现linkedList的迭代器有个坑啊 那个参数index是从1开始的 我开始看总以为是0开始的 就一直理解不了previous()方法判断是否为null的两种情况的第一种情况。哈哈哈

   1

  回复

  2020-01-17

- [萌萌萌唬](https://www.imooc.com/u/6366873/articles)

  源码 linkLast方法，fianl修饰的l、 newNode，为什么要用final修饰，感觉没有必要吧？

   0

  回复

  2019-12-30

- [rq_conquer](https://www.imooc.com/u/2930120/articles)

  有一个问题，LinkedList的add我看源码只返回true，老师说的add失败返回false是从哪里来的，是我看漏了什么吗？

   0

  回复

  2019-10-16

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[rq_conquer](https://www.imooc.com/u/2930120/articles)

    感谢提醒，你是对的，已订正了，谢谢。

    回复

    2019-10-17 19:14:46

- [威先森](https://www.imooc.com/u/6261517/articles)

  问题：调用next()方法时，next变量为什么有值？ 原因：当调用list.iterator()生成迭代器的时候，都会调用LinkeList继承的AbstractSequentialList的iterator()方法，iterator()方法则会调用AbstractSequentialList父类的listIterator()方法，listIterator()方法会调用listIterator(final int index)，由于LinkedList重写了listIterator(final int index)，所以最后调用链又回到LikedList中了，LinkedList中的listIterator方法默认调用有参构造new了ListItr这个类，在构造方法中给next和nextIndex都赋值了，老师分析的应该是对的吧，有问题希望老师指正出来

   0

  回复

  2019-10-13

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[威先森](https://www.imooc.com/u/6261517/articles)

    是的，没问题，给你点赞。

    回复

    2019-10-14 12:45:35

- [风舞炫动](https://www.imooc.com/u/6409329/articles)

  老师可否对2.4方法对比表格中的方法给出demo，有点理解不了，空链表指的不是直接new 出来的吗？add也不会抛出异常呀，还有element()、poll()、peek()这些方法也是没有参数的呀（问的low的话别介意，实在是有点看不懂，(#^.^#)）

   0

  回复

  2019-10-10

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[风舞炫动](https://www.imooc.com/u/6409329/articles)

    感谢提醒，问题很好，我写的不好，我重新修改了下，谢谢。

    回复

    2019-10-11 19:43:36

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复

    [文贺](https://www.imooc.com/u/8062574/articles)

    麻烦同学再看看，能否看懂了。

    回复

    2019-10-11 19:44:26

  - [风舞炫动](https://www.imooc.com/u/6409329/articles)

    回复

    [文贺](https://www.imooc.com/u/8062574/articles)

    明 白 啦 ， 谢 谢 老 师

    回复

    2019-10-12 11:00:19

- [汤圆](https://www.imooc.com/u/169005/articles)

  请老师更快点啊请老师更快点啊

   1

  回复

  2019-09-14

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[汤圆](https://www.imooc.com/u/169005/articles)

    努力努力努力，加油加油加油。

    回复

    2019-10-11 19:13:29

- [大胖晴](https://www.imooc.com/u/5171712/articles)

  看完了这个LinkedList源码解析之后，真的是处处都是数据结构和算法,辛亏链表看过了，要不然感觉看着一脸懵逼,看来数据结构还得带着看了;

   1

  回复

  2019-09-10

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[大胖晴](https://www.imooc.com/u/5171712/articles)

    哈哈，集合中的确是有很多数据结构，但对数据结构大体了解的话，再看源码应该都还好吧，看源码可以先扫过，看看这坨代码大体是干啥的，了解下整体架构，然后再慢慢深入，实在还是看不懂，建议多多 debug，debug 很奇妙，不懂的代码，debug 一下全都明白。

    回复

    2019-09-10 19:15:56

- [慕神9346227](https://www.imooc.com/u/7808597/articles)

  表格里是抛出异常还是跑出异常

   0

  回复

  2019-09-04

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[慕神9346227](https://www.imooc.com/u/7808597/articles)

    谢谢，错别字已订正。

    回复

    2019-09-05 17:42:07

- [慕神4112825](https://www.imooc.com/u/7092371/articles)

  这么长时间了为啥还不更新啊

   0

  回复

  2019-09-01

  - [初一](https://www.imooc.com/u/7789740/articles)

    回复[慕神4112825](https://www.imooc.com/u/7092371/articles)

    同学你好，本专栏是每周二、周四更新的呦^ ^ 感谢支持

    回复

    2019-09-02 10:29:42

- [Elylic](https://www.imooc.com/u/3417562/articles)

  非常好的专栏！！第一次订阅！感觉超棒！

   4

  回复

  2019-08-30

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[Elylic](https://www.imooc.com/u/3417562/articles)

    感谢支持，一起进步。

    回复

    2019-09-03 16:02:04

- [慕虎6508060](https://www.imooc.com/u/7658413/articles)

  从前往后的迭代中，第一次使用Next，next为空的话怎么lastReturned也为空，怎么继续迭代呀

   1

  回复

  2019-08-29

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[慕虎6508060](https://www.imooc.com/u/7658413/articles)

    第一次迭代的时候 next 不为空哈，LinkedList 的 listIterator 方法有无参的，也有有参数的，无参数的底层默认传0的，有参数的方法如下，index 代表第一次迭代的位置。 public ListIterator listIterator(int index) { checkPositionIndex(index); return new ListItr(index); } ListItr 初始化的时候，会给 next 赋值的，next 肯定不为空，但 lastReturned 是空的

    回复

    2019-08-30 20:29:22

- [慕虎6508060](https://www.imooc.com/u/7658413/articles)

  想问一下linkedLis的双向迭代，从前往后迭代的过程中next和lastReturned的初始情况是空吗

   0

  回复

  2019-08-29

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[慕虎6508060](https://www.imooc.com/u/7658413/articles)

    lastReturned为空，但 next 不为空，原因见上一条回复

    回复

    2019-08-30 20:29:55

- [窝兔与草](https://www.imooc.com/u/4649530/articles)

  请问老师，更新速度是怎样的呢？

   0

  回复

  2019-08-28

  - [初一](https://www.imooc.com/u/7789740/articles)

    回复[窝兔与草](https://www.imooc.com/u/4649530/articles)

    同学你好 ,本专栏目前于每周二、周四更新，欢迎订阅哦^^

    回复

    2019-08-28 12:27:40

- [九州编程](https://www.imooc.com/u/6798230/articles)

  对于初中级程序员线程，集合，数据结构是非常重要的

   0

  回复

  2019-08-27

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[九州编程](https://www.imooc.com/u/6798230/articles)

    有道理的，Java 源码中处处可见数据结构和算法。

    回复

    2019-08-27 19:19:46

 

千学不如一看，千看不如一练

 

# 07 List 源码会问哪些面试题

07 List 源码会问哪些面试题

更新时间：2019-11-26 09:45:05

![img](https://img3.mukewang.com/5d6356ee0001924006400359.jpg)

![img](https://www.imooc.com/static/img/column/bg-l.png)![img](https://www.imooc.com/static/img/column/bg-r.png)

勤学如春起之苗，不见其增，日有所长。

——陶潜



## 引导语

List 作为工作中最常见的集合类型，在面试过程中，也是经常会被问到各种各样的面试题，一般来说，只要你看过源码，心中对 List 的总体结构和细节有所了解的话，基本问题都不大。



## 1 面试题



### 1.1 说说你自己对 ArrayList 的理解？

很多面试官喜欢这样子开头，考察面试同学对 ArrayList 有没有总结经验，介于 ArrayList 内容很多，建议先回答总体架构，再从某个细节出发作为突破口，比如这样：
ArrayList 底层数据结构是个数组，其 API 都做了一层对数组底层访问的封装，比如说 add 方法的过程是……（这里可以引用我们在 ArrayList 源码解析中 add 的过程）。

一般面试官看你回答得井井有条，并且没啥漏洞的话，基本就不会深究了，这样面试的主动权就掌握在自己手里面了，如果你回答得支支吾吾，那么面试官可能就会开启自己面试的套路了。

说说你自己对 LinkedList 的理解也是同样套路。



### 1.2 扩容类问题

#### 1.2.1 ArrayList 无参数构造器构造，现在 add 一个值进去，此时数组的大小是多少，下一次扩容前最大可用大小是多少？

答：此处数组的大小是 1，下一次扩容前最大可用大小是 10，因为 ArrayList 第一次扩容时，是有默认值的，默认值是 10，在第一次 add 一个值进去时，数组的可用大小被扩容到 10 了。

#### 1.2.2 如果我连续往 list 里面新增值，增加到第 11 个的时候，数组的大小是多少？

答：这里的考查点就是扩容的公式，当增加到 11 的时候，此时我们希望数组的大小为 11，但实际上数组的最大容量只有 10，不够了就需要扩容，扩容的公式是：oldCapacity + (oldCapacity>> 1)，oldCapacity 表示数组现有大小，目前场景计算公式是：10 + 10 ／2 = 15，然后我们发现 15 已经够用了，所以数组的大小会被扩容到 15。

#### 1.2.3 数组初始化，被加入一个值后，如果我使用 addAll 方法，一下子加入 15 个值，那么最终数组的大小是多少？

答：第一题中我们已经计算出来数组在加入一个值后，实际大小是 1，最大可用大小是 10 ，现在需要一下子加入 15 个值，那我们期望数组的大小值就是 16，此时数组最大可用大小只有 10，明显不够，需要扩容，扩容后的大小是：10 + 10 ／2 = 15，这时候发现扩容后的大小仍然不到我们期望的值 16，这时候源码中有一种策略如下：

```java
// newCapacity 本次扩容的大小，minCapacity 我们期望的数组最小大小
// 如果扩容后的值 < 我们的期望值，我们的期望值就等于本次扩容的大小
if (newCapacity - minCapacity < 0)
    newCapacity = minCapacity;
```

所以最终数组扩容后的大小为 16。

#### 1.2.4 现在我有一个很大的数组需要拷贝，原数组大小是 5k，请问如何快速拷贝？

答：因为原数组比较大，如果新建新数组的时候，不指定数组大小的话，就会频繁扩容，频繁扩容就会有大量拷贝的工作，造成拷贝的性能低下，所以回答说新建数组时，指定新数组的大小为 5k 即可。

#### 1.2.5 为什么说扩容会消耗性能？

答：扩容底层使用的是 System.arraycopy 方法，会把原数组的数据全部拷贝到新数组上，所以性能消耗比较严重。

#### 1.2.6 源码扩容过程有什么值得借鉴的地方？

答：有两点：

- 是扩容的思想值得学习，通过自动扩容的方式，让使用者不用关心底层数据结构的变化，封装得很好，1.5 倍的扩容速度，可以让扩容速度在前期缓慢上升，在后期增速较快，大部分工作中要求数组的值并不是很大，所以前期增长缓慢有利于节省资源，在后期增速较快时，也可快速扩容。
- 扩容过程中，有数组大小溢出的意识，比如要求扩容后的数组大小，不能小于 0，不能大于 Integer 的最大值。

这两点在我们平时设计和写代码时都可以借鉴。



### 2 删除类问题

#### 2.1 有一个 ArrayList，数据是 2、3、3、3、4，中间有三个 3，现在我通过 for (int i=0;i<list.size ();i++) 的方式，想把值是 3 的元素删除，请问可以删除干净么？最终删除的结果是什么，为什么？删除代码如下：

```java
List<String> list = new ArrayList<String>() {{
  add("2");
  add("3");
  add("3");
  add("3");
  add("4");
}};
for (int i = 0; i < list.size(); i++) {
  if (list.get(i).equals("3")) {
    list.remove(i);
  }
}
```

答：不能删除干净，最终删除的结果是 2、3、4，有一个 3 删除不掉，原因我们看下图：
![图片描述](https://img.mukewang.com/5d5fc748000129db13361068.png)从图中我们可以看到，每次删除一个元素后，该元素后面的元素就会往前移动，而此时循环的 i 在不断地增长，最终会使每次删除 3 的后一个 3 被遗漏，导致删除不掉。

#### 2.2 还是上面的 ArrayList 数组，我们通过增强 for 循环进行删除，可以么？

答：不可以，会报错。因为增强 for 循环过程其实调用的就是迭代器的 next () 方法，当你调用 list#remove () 方法进行删除时，modCount 的值会 +1，而这时候迭代器中的 expectedModCount 的值却没有变，导致在迭代器下次执行 next () 方法时，expectedModCount != modCount 就会报 ConcurrentModificationException 的错误。

#### 2.3 还是上面的数组，如果删除时使用 Iterator.remove () 方法可以删除么，为什么？

答：可以的，因为 Iterator.remove () 方法在执行的过程中，会把最新的 modCount 赋值给 expectedModCount，这样在下次循环过程中，modCount 和 expectedModCount 两者就会相等。

#### 2.4 以上三个问题对于 LinkedList 也是同样的结果么？

答：是的，虽然 LinkedList 底层结构是双向链表，但对于上述三个问题，结果和 ArrayList 是一致的。



### 3 对比类问题

#### 3.1 ArrayList 和 LinkedList 有何不同？

答：可以先从底层数据结构开始说起，然后以某一个方法为突破口深入，比如：最大的不同是两者底层的数据结构不同，ArrayList 底层是数组，LinkedList 底层是双向链表，两者的数据结构不同也导致了操作的 API 实现有所差异，拿新增实现来说，ArrayList 会先计算并决定是否扩容，然后把新增的数据直接赋值到数组上，而 LinkedList 仅仅只需要改变插入节点和其前后节点的指向位置关系即可。

#### 3.2 ArrayList 和 LinkedList 应用场景有何不同

答：ArrayList 更适合于快速的查找匹配，不适合频繁新增删除，像工作中经常会对元素进行匹配查询的场景比较合适，LinkedList 更适合于经常新增和删除，对查询反而很少的场景。

#### 3.3 ArrayList 和 LinkedList 两者有没有最大容量

答：ArrayList 有最大容量的，为 Integer 的最大值，大于这个值 JVM 是不会为数组分配内存空间的，LinkedList 底层是双向链表，理论上可以无限大。但源码中，LinkedList 实际大小用的是 int 类型，这也说明了 LinkedList 不能超过 Integer 的最大值，不然会溢出。

#### 3.4 ArrayList 和 LinkedList 是如何对 null 值进行处理的

答：ArrayList 允许 null 值新增，也允许 null 值删除。删除 null 值时，是从头开始，找到第一值是 null 的元素删除；LinkedList 新增删除时对 null 值没有特殊校验，是允许新增和删除的。

#### 3.5 ArrayList 和 LinedList 是线程安全的么，为什么？

答：当两者作为非共享变量时，比如说仅仅是在方法里面的局部变量时，是没有线程安全问题的，只有当两者是共享变量时，才会有线程安全问题。主要的问题点在于多线程环境下，所有线程任何时刻都可对数组和链表进行操作，这会导致值被覆盖，甚至混乱的情况。

如果有线程安全问题，在迭代的过程中，会频繁报 ConcurrentModificationException 的错误，意思是在我当前循环的过程中，数组或链表的结构被其它线程修改了。

#### 3.6 如何解决线程安全问题？

Java 源码中推荐使用 Collections#synchronizedList 进行解决，Collections#synchronizedList 的返回值是 List 的每个方法都加了 synchronized 锁，保证了在同一时刻，数组和链表只会被一个线程所修改，或者采用 CopyOnWriteArrayList 并发 List 来解决，这个类我们后面会说。



### 4 其它类型题目

#### 4.1 你能描述下双向链表么？

答：如果和面试官面对面沟通的话，你可以去画一下，可以把 《LinkedList 源码解析》中的 LinkedList 的结构画出来，如果是电话面试，可以这么描述：双向链表中双向的意思是说前后节点之间互相有引用，链表的节点我们称为 Node。Node 有三个属性组成：其前一个节点，本身节点的值，其下一个节点，假设 A、B 节点相邻，A 节点的下一个节点就是 B，B 节点的上一个节点就是 A，两者互相引用，在链表的头部节点，我们称为头节点。头节点的前一个节点是 null，尾部称为尾节点，尾节点的后一个节点是 null，如果链表数据为空的话，头尾节点是同一个节点，本身是 null，指向前后节点的值也是 null。

#### 4.2 描述下双向链表的新增和删除

答：如果是面对面沟通，最好可以直接画图，如果是电话面试，可以这么描述：

新增：我们可以选择从链表头新增，也可以选择从链表尾新增，如果是从链表尾新增的话，直接把当前节点追加到尾节点之后，本身节点自动变为尾节点。

删除：把删除节点的后一个节点的 prev 指向其前一个节点，把删除节点的前一个节点的 next 指向其后一个节点，最后把删除的节点置为 null 即可。



## 总结

List 在工作中经常遇到，熟读源码不仅仅是为了应对面试，也为了在工作中使用起来得心应手，如果想更深入了解 List，可以看一遍 ArrayList 源码之后，自己重新实现一个 List。这样的话，就会对 List 底层的数据结构和操作细节理解更深。

[06 LinkedList 源码解析](https://www.imooc.com/read/47/article/848)[08 HashMap 源码解析](https://www.imooc.com/read/47/article/850)

精选留言 23

欢迎在这里发表留言，作者筛选后可公开显示

- [慕妹7164721](https://www.imooc.com/u/7578965/articles)

  看错方法了，addAll是另一个方法

   0

  回复

  4天前

- [慕妹7164721](https://www.imooc.com/u/7578965/articles)

  1.2.3 数组初始化，被加入一个值后，如果我使用 addAll 方法，一下子加入 15 个值，实际上addAll方法底层是调用add方法，所以当调用到第16个时候，element.length=15，所以扩容肯定4 int newCapacity = oldCapacity + (oldCapacity >> 1); newCapacity肯定是22啊，怎么会是16？

   0

  回复

  4天前

- [qq_阿坤_54119986](https://www.imooc.com/u/4119986/articles)

  我的理解是在 add 需要分 2 中情况： 1. 第一次添加数据，需要扩容数组之前，数组大小是 0 。 2. 第一次扩容完了之后，数组大小默认值 10，当扩容完了之后 element (size++) = e, 那么此时，数组长度为 10，只有第一个索引对应的值有数据，其它有为 null, 当然，此时的 ArrayList 长度也为 1。 我跟着源码 debug 也验证了我的判断。

   0

  回复

  2019-12-17

- [Aegon_Targaryen](https://www.imooc.com/u/4701609/articles)

  其实要删干净很简单啊，直接 while(list.remove(elem));

   0

  回复

  2019-11-29

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[Aegon_Targaryen](https://www.imooc.com/u/4701609/articles)

    很有道理，给你点赞。

    回复

    2019-11-30 13:12:58

- [慕粉4318313](https://www.imooc.com/u/4318313/articles)

  老师你好，链表可以从指定位置插入吗

   0

  回复

  2019-10-28

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[慕粉4318313](https://www.imooc.com/u/4318313/articles)

    可以的哈，add 方法可以指定插入的位置的。

    回复

    2019-10-31 12:52:01

- [威先森](https://www.imooc.com/u/6261517/articles)

  2.3使用iterator迭代删除能把3都删除，因为在iterator的remove方法中，删除元素后，又将指针指回上一次的位置了。next方法中将cursor变量+1，remove里面--cursor了，所以迭代器能把3删除干净。

   2

  回复

  2019-10-14

  - [慕粉3445147](https://www.imooc.com/u/3445147/articles)

    回复[威先森](https://www.imooc.com/u/6261517/articles)

    测试了下,是可以的!

    回复

    2019-10-22 15:18:34

  - [Qolome](https://www.imooc.com/u/5740395/articles)

    回复[慕粉3445147](https://www.imooc.com/u/3445147/articles)

    for (String string : list) { list.remove(string) } 老师说的是这种情况

    回复

    2019-12-06 11:52:19

- [音殿](https://www.imooc.com/u/4730658/articles)

  请教一下上面所说的arrayList 无参构造 第一次add一个进去 此时数组长度是1 然后add的时候就是第一次扩容的时候 第一次扩容默认值是10 就是说现在还可以add9个值进去的意思 请问我理解的对吗？

   0

  回复

  2019-10-11

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[音殿](https://www.imooc.com/u/4730658/articles)

    同学你好，是的是的。

    回复

    2019-10-12 18:49:56

- [buxingshi](https://www.imooc.com/u/2752183/articles)

  严格来说，2.2 用增强for循环为删除元素，可以删一次，因为第一次删除之前modCount还未改变。

   0

  回复

  2019-09-24

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[buxingshi](https://www.imooc.com/u/2752183/articles)

    不好意思同学，漏掉了你的留言，有且仅当 list 大小是2时，第一次删除时才会通过，其余的都会报错哈，场景有丢丢极限。

    回复

    2019-10-12 19:10:00

- [Seed2009](https://www.imooc.com/u/5660937/articles)

  3.3 里一个LinkedList拼错了，无伤大雅

   0

  回复

  2019-09-22

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[Seed2009](https://www.imooc.com/u/5660937/articles)

    谢谢同学提醒，3.3 中木有找到拼错的单词呢。

    回复

    2019-09-23 10:45:59

- [licly](https://www.imooc.com/u/8096709/articles)

  老师，这里说的不太全面。如果是顺序插入的话，ArrayList是比linkedlist快的，即调用无参的add方法；linkedlist只有随机插入的时候可能快于ArrayList，即调用add(int index, E element)方法插入，这个可能因素决定于ArrayList移动的元素个数。一般情况下，都是使用add（）无参方法，所以ArrayList使用的多。

   0

  回复

  2019-09-20

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[licly](https://www.imooc.com/u/8096709/articles)

    是的，add 方法有两个，我们基本用的是无参的 add

    回复

    2019-09-23 10:44:52

- [ADC之父](https://www.imooc.com/u/5654817/articles)

  纠正一点，ArrayList并不擅长查询O(n)，而是根据索引随机读写O(1)。

   0

  回复

  2019-09-19

  - [小明12345](https://www.imooc.com/u/3588260/articles)

    回复[ADC之父](https://www.imooc.com/u/5654817/articles)

    arraylist为什么不擅长查询？

    回复

    2019-11-11 17:52:16

- [温柔的微笑](https://www.imooc.com/u/4036519/articles)

  老师您好我有个问题：当指定addAll操作时，源码中会将参数集合调用toArray方法，此时内存复制一个新的数组吗，这样内部占用就会加倍

   1

  回复

  2019-09-18

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[温柔的微笑](https://www.imooc.com/u/4036519/articles)

    toArray() 底层使用的是 Arrays 的 copyOf 方法，底层会返回新的数组。 如果可以预见 addAll 的集合特别大，可以进行分段插入，防止一次性 addAll 耗时久的话，引起 JVM 的 full gc。日常工作中，一般来说，无需担忧这个问题哈，主要是因为 addAll 执行很快，在 addAll 执行完成之后，数组很快就会被 jvm 回收掉了。

    回复

    2019-09-18 21:12:20

- [bb111323](https://www.imooc.com/u/5803138/articles)

  您好，我想问一下那个ArrayList无产构造后，add一个值，此时list的size为1，但对于存储数据的数组为什么长度是1，不应该是10吗？ 数组的长度和可用大小难道不是一个概念吗？

   1

  回复

  2019-09-13

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[bb111323](https://www.imooc.com/u/5803138/articles)

    文章没有描述过数组的长度是1哈，一般List 大小有两种称呼方式，第一种就是直接叫做数组的大小，指的是数组实际有多少个的元素，就是源码中的 size，第二种叫做数组的可用大小，或数组的最大可用大小，或数组的容量，就是源码中的 capacity。

    回复

    2019-09-15 09:53:59

- [大胖晴](https://www.imooc.com/u/5171712/articles)

  老师，我想问下，5k初始化的话，是不是放的字节的大小，5 * 1024 * 8嘛?

   0

  回复

  2019-09-10

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[大胖晴](https://www.imooc.com/u/5171712/articles)

    5k 是数组的大小哈，数组里面是一个一个的元素哈，不是字节哦

    回复

    2019-09-11 12:33:28

- [qq_阿坤_54119986](https://www.imooc.com/u/4119986/articles)

  老师讲解得真的太棒了，很仔细，先通过源码分析，最后源码结合面试题来讲解，确实不错，一看就明白了。这个专题是永久的吧？不会删除什么得？

   0

  回复

  2019-09-10

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[qq_阿坤_54119986](https://www.imooc.com/u/4119986/articles)

    谢谢肯定，永久的哈。

    回复

    2019-09-11 12:32:57

  - [qq_阿坤_54119986](https://www.imooc.com/u/4119986/articles)

    回复

    [文贺](https://www.imooc.com/u/8062574/articles)

    好的，谢谢老师！

    回复

    2019-09-12 22:04:34

- [鹏飞天下](https://www.imooc.com/u/1010756/articles)

  老师数据初始化大小我知道咋弄，到时怎样初始化5k这个大小呢，5k是指5千个，还是5k的大小？

   0

  回复

  2019-09-09

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[鹏飞天下](https://www.imooc.com/u/1010756/articles)

    new 的时候，通过构造器传进去就好了，就是底层数组的最大容量。

    回复

    2019-09-10 14:03:15

  - [ADC之父](https://www.imooc.com/u/5654817/articles)

    回复[鹏飞天下](https://www.imooc.com/u/1010756/articles)

    直接说5000个元素就好了，非要装逼说5k产生歧义

    回复

    2019-09-19 09:22:18

- [慕侠9072379](https://www.imooc.com/u/7931020/articles)

  现在我有一个很大的数组需要拷贝，原数组大小是 5k，请问如何快速拷贝？

   0

  回复

  2019-09-09

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[慕侠9072379](https://www.imooc.com/u/7931020/articles)

    1：直接使用 addAll。2：使用 add+for 循环，但初始化的时候给定 5k 的容量。

    回复

    2019-09-09 19:19:50

- [liuyiyan](https://www.imooc.com/u/2175910/articles)

  2.1删除那题，每次循环list.size（）的大小都在减小吧？老师

   0

  回复

  2019-09-07

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[liuyiyan](https://www.imooc.com/u/2175910/articles)

    是的，size() 方法底层直接返回的 size，size 表示数组实际的大小。

    回复

    2019-09-08 10:04:50

- [Ding_Y](https://www.imooc.com/u/2970884/articles)

  很棒

   0

  回复

  2019-09-04

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[Ding_Y](https://www.imooc.com/u/2970884/articles)

    感谢同学支持，谢谢。

    回复

    2019-09-05 06:16:38

- [慕丝4329561](https://www.imooc.com/u/7832962/articles)

  扩容后，之前的数组是直接gc回收了，还是还在堆内存中。

   0

  回复

  2019-09-01

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[慕丝4329561](https://www.imooc.com/u/7832962/articles)

    这个主要看回收机制，一般来说没有引用指向原来的数组，就会被回收，在扩容源码中并没有显示把原来的数组置为 null，所以如果外部也没有对原来数组的引用的话，就会回收。

    回复

    2019-09-04 09:17:51

- [LK90](https://www.imooc.com/u/3679728/articles)

  挺好的，讲的蛮细的，就是不太过瘾，希望可以出第二期，把juc的源码拉出来讲一讲，老师很用心，辛苦了。

   0

  回复

  2019-09-01

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[LK90](https://www.imooc.com/u/3679728/articles)

    谢谢，我们从第三章就开始说并发集合，队列，线程池，锁的源码和应用了哦。

    回复

    2019-09-04 09:13:43

- [qq_坏猫先生_0](https://www.imooc.com/u/6279569/articles)

  1.2.4拷贝大数组的那个题。为什么会频繁扩容呢？1.2.3刚说了当我第一次扩容1.5倍之后发现还是不够的话会直接阔成指定的大小啊，为什么会频繁扩容呢？

   6

  回复

  2019-08-28

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[qq_坏猫先生_0](https://www.imooc.com/u/6279569/articles)

    1.2.3 说的是 addAll 方法，addAll 可以保证只扩容一次。 1.2.4 主要说的是我们平时在数据拷贝时，可能有的同学这么写： List list = new ArrayList (); for (int i = 0; i &lt; 5000; i++) { list.add(i); } 这时候，随着 add 方法的执行，就会不断扩容，此时我们建议在初始化 list 的时候，指定容量，像这样：List list = new ArrayList (5000);这样的话，即使我使用的是单个 add 方法，在添加的过程中，一次都不会扩容。 不仅仅是 List 是这样，Map 也是这样哦。 说的两个不同的方法哈。

    回复

    2019-08-28 22:27:38

- [天天世纪](https://www.imooc.com/u/6798231/articles)

  期待老师多讲些面试常问到的题目。

   1

  回复

  2019-08-27

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[天天世纪](https://www.imooc.com/u/6798231/articles)

    哈哈，这些就是面试中常问的题哈，我想你应该已经会了。

    回复

    2019-08-27 19:20:40

 

千学不如一看，千看不如一练

 

# 08 HashMap 源码解析

08 HashMap 源码解析

更新时间：2019-09-27 12:52:38

![img](https://img1.mukewang.com/5d63579e000121c606400359.jpg)

![img](https://www.imooc.com/static/img/column/bg-l.png)![img](https://www.imooc.com/static/img/column/bg-r.png)

自信和希望是青年的特权。

——大仲马



## 引导语

HashMap 源码很长，面试的问题也非常多，但这些面试问题，基本都是从源码中衍生出来的，所以我们只需要弄清楚其底层实现原理，回答这些问题就会游刃有余。



## 1 整体架构

HashMap 底层的数据结构主要是：数组 + 链表 + 红黑树。其中当链表的长度大于等于 8 时，链表会转化成红黑树，当红黑树的大小小于等于 6 时，红黑树会转化成链表，整体的数据结构如下：
![图片描述](https://img.mukewang.com/5d5fc7cc0001ec3211040928.png)图中左边竖着的是 HashMap 的数组结构，数组的元素可能是单个 Node，也可能是个链表，也可能是个红黑树，比如数组下标索引为 2 的位置就是一个链表，下标索引为 9 的位置对应的就是红黑树，具体细节我们下文再说。



### 1.1 类注释

从 HashMap 的类注释中，我们可以得到如下信息：

- 允许 null 值，不同于 HashTable ，是线程不安全的；
- load factor（影响因子） 默认值是 0.75， 是均衡了时间和空间损耗算出来的值，较高的值会减少空间开销（扩容减少，数组大小增长速度变慢），但增加了查找成本（hash 冲突增加，链表长度变长），不扩容的条件：数组容量 > 需要的数组大小 /load factor；
- 如果有很多数据需要储存到 HashMap 中，建议 HashMap 的容量一开始就设置成足够的大小，这样可以防止在其过程中不断的扩容，影响性能；
- HashMap 是非线程安全的，我们可以自己在外部加锁，或者通过 Collections#synchronizedMap 来实现线程安全，Collections#synchronizedMap 的实现是在每个方法上加上了 synchronized 锁；
- 在迭代过程中，如果 HashMap 的结构被修改，会快速失败。



### 1.2 常见属性

```java
 //初始容量为 16
 static final int DEFAULT_INITIAL_CAPACITY = 1 << 4;

 //最大容量
 static final int MAXIMUM_CAPACITY = 1 << 30;

 //负载因子默认值
 static final float DEFAULT_LOAD_FACTOR = 0.75f;
 
 //桶上的链表长度大于等于8时，链表转化成红黑树
 static final int TREEIFY_THRESHOLD = 8;

 //桶上的红黑树大小小于等于6时，红黑树转化成链表
 static final int UNTREEIFY_THRESHOLD = 6;

 //当数组容量大于 64 时，链表才会转化成红黑树
 static final int MIN_TREEIFY_CAPACITY = 64;

 //记录迭代过程中 HashMap 结构是否发生变化，如果有变化，迭代时会 fail-fast
 transient int modCount;

 //HashMap 的实际大小，可能不准(因为当你拿到这个值的时候，可能又发生了变化)
 transient int size;

 //存放数据的数组
 transient Node<K,V>[] table;

 // 扩容的门槛，有两种情况
 // 如果初始化时，给定数组大小的话，通过 tableSizeFor 方法计算，数组大小永远接近于 2 的幂次方，比如你给定初始化大小 19，实际上初始化大小为 32，为 2 的 5 次方。
 // 如果是通过 resize 方法进行扩容，大小 = 数组容量 * 0.75
 int threshold;

 //链表的节点
 static class Node<K,V> implements Map.Entry<K,V> {
 
 //红黑树的节点
 static final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> {
```



## 2 新增

新增 key，value 大概的步骤如下：

1. 空数组有无初始化，没有的话初始化；
2. 如果通过 key 的 hash 能够直接找到值，跳转到 6，否则到 3；
3. 如果 hash 冲突，两种解决方案：链表 or 红黑树；
4. 如果是链表，递归循环，把新元素追加到队尾；
5. 如果是红黑树，调用红黑树新增的方法；
6. 通过 2、4、5 将新元素追加成功，再根据 onlyIfAbsent 判断是否需要覆盖；
7. 判断是否需要扩容，需要扩容进行扩容，结束。

我们来画一张示意图来描述下：
![图片描述](https://img.mukewang.com/5d5fc7e200016af809121188.jpg)代码细节如下：

```java
// 入参 hash：通过 hash 算法计算出来的值。
// 入参 onlyIfAbsent：false 表示即使 key 已经存在了，仍然会用新值覆盖原来的值，默认为 false
final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
               boolean evict) {
    // n 表示数组的长度，i 为数组索引下标，p 为 i 下标位置的 Node 值
    Node<K,V>[] tab; Node<K,V> p; int n, i;
    //如果数组为空，使用 resize 方法初始化
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;
    // 如果当前索引位置是空的，直接生成新的节点在当前索引位置上
    if ((p = tab[i = (n - 1) & hash]) == null)
        tab[i] = newNode(hash, key, value, null);
    // 如果当前索引位置有值的处理方法，即我们常说的如何解决 hash 冲突
    else {
        // e 当前节点的临时变量
        Node<K,V> e; K k;
        // 如果 key 的 hash 和值都相等，直接把当前下标位置的 Node 值赋值给临时变量
        if (p.hash == hash &&
            ((k = p.key) == key || (key != null && key.equals(k))))
            e = p;
        // 如果是红黑树，使用红黑树的方式新增
        else if (p instanceof TreeNode)
            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
        // 是个链表，把新节点放到链表的尾端
        else {
            // 自旋
            for (int binCount = 0; ; ++binCount) {
                // e = p.next 表示从头开始，遍历链表
                // p.next == null 表明 p 是链表的尾节点
                if ((e = p.next) == null) {
                    // 把新节点放到链表的尾部 
                    p.next = newNode(hash, key, value, null);
                    // 当链表的长度大于等于 8 时，链表转红黑树
                    if (binCount >= TREEIFY_THRESHOLD - 1)
                        treeifyBin(tab, hash);
                    break;
                }
                // 链表遍历过程中，发现有元素和新增的元素相等，结束循环
                if (e.hash == hash &&
                    ((k = e.key) == key || (key != null && key.equals(k))))
                    break;
                //更改循环的当前元素，使 p 在遍历过程中，一直往后移动。
                p = e;
            }
        }
        // 说明新节点的新增位置已经找到了
        if (e != null) {
            V oldValue = e.value;
            // 当 onlyIfAbsent 为 false 时，才会覆盖值 
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            afterNodeAccess(e);
            // 返回老值
            return oldValue;
        }
    }
    // 记录 HashMap 的数据结构发生了变化
    ++modCount;
    //如果 HashMap 的实际大小大于扩容的门槛，开始扩容
    if (++size > threshold)
        resize();
    afterNodeInsertion(evict);
    return null;
}
```

新增的流程上面应该已经表示很清楚了，接下来我们来看看链表和红黑树新增的细节：



### 2.1 链表的新增

链表的新增比较简单，就是把当前节点追加到链表的尾部，和 LinkedList 的追加实现一样的。

当链表长度大于等于 8 时，此时的链表就会转化成红黑树，转化的方法是：treeifyBin，此方法有一个判断，当链表长度大于等于 8，并且整个数组大小大于 64 时，才会转成红黑树，当数组大小小于 64 时，只会触发扩容，不会转化成红黑树，转化成红黑树的过程也比较简单，具体转化的过程源码可以去 github：https://github.com/luanqiu/java8 上面去查看。

可能面试的时候，有人问你为什么是 8，这个答案在源码中注释有说，中文翻译过来大概的意思是：

链表查询的时间复杂度是 O (n)，红黑树的查询复杂度是 O (log (n))。在链表数据不多的时候，使用链表进行遍历也比较快，只有当链表数据比较多的时候，才会转化成红黑树，但红黑树需要的占用空间是链表的 2 倍，考虑到转化时间和空间损耗，所以我们需要定义出转化的边界值。

在考虑设计 8 这个值的时候，我们参考了泊松分布概率函数，由泊松分布中得出结论，链表各个长度的命中概率为：

```java
* 0:    0.60653066
* 1:    0.30326533
* 2:    0.07581633
* 3:    0.01263606
* 4:    0.00157952
* 5:    0.00015795
* 6:    0.00001316
* 7:    0.00000094
* 8:    0.00000006
```

意思是，当链表的长度是 8 的时候，出现的概率是 0.00000006，不到千万分之一，所以说正常情况下，链表的长度不可能到达 8 ，而一旦到达 8 时，肯定是 hash 算法出了问题，所以在这种情况下，为了让 HashMap 仍然有较高的查询性能，所以让链表转化成红黑树，我们正常写代码，使用 HashMap 时，几乎不会碰到链表转化成红黑树的情况，毕竟概念只有千万分之一。



### 2.2 红黑树新增节点过程

1. 首先判断新增的节点在红黑树上是不是已经存在，判断手段有如下两种：

   1.1. 如果节点没有实现 Comparable 接口，使用 equals 进行判断；

   1.2. 如果节点自己实现了 Comparable 接口，使用 compareTo 进行判断。

2. 新增的节点如果已经在红黑树上，直接返回；不在的话，判断新增节点是在当前节点的左边还是右边，左边值小，右边值大；

3. 自旋递归 1 和 2 步，直到当前节点的左边或者右边的节点为空时，停止自旋，当前节点即为我们新增节点的父节点；

4. 把新增节点放到当前节点的左边或右边为空的地方，并于当前节点建立父子节点关系；

5. 进行着色和旋转，结束。

具体源码如下：

```java
//入参 h：key 的hash值
final TreeNode<K,V> putTreeVal(HashMap<K,V> map, Node<K,V>[] tab,
                               int h, K k, V v) {
    Class<?> kc = null;
    boolean searched = false;
    //找到根节点
    TreeNode<K,V> root = (parent != null) ? root() : this;
    //自旋
    for (TreeNode<K,V> p = root;;) {
        int dir, ph; K pk;
        // p hash 值大于 h，说明 p 在 h 的右边
        if ((ph = p.hash) > h)
            dir = -1;
        // p hash 值小于 h，说明 p 在 h 的左边
        else if (ph < h)
            dir = 1;
        //要放进去key在当前树中已经存在了(equals来判断)
        else if ((pk = p.key) == k || (k != null && k.equals(pk)))
            return p;
        //自己实现的Comparable的话，不能用hashcode比较了，需要用compareTo
        else if ((kc == null &&
                  //得到key的Class类型，如果key没有实现Comparable就是null
                  (kc = comparableClassFor(k)) == null) ||
                  //当前节点pk和入参k不等
                 (dir = compareComparables(kc, k, pk)) == 0) {
            if (!searched) {
                TreeNode<K,V> q, ch;
                searched = true;
                if (((ch = p.left) != null &&
                     (q = ch.find(h, k, kc)) != null) ||
                    ((ch = p.right) != null &&
                     (q = ch.find(h, k, kc)) != null))
                    return q;
            }
            dir = tieBreakOrder(k, pk);
        }

        TreeNode<K,V> xp = p;
        //找到和当前hashcode值相近的节点(当前节点的左右子节点其中一个为空即可)
        if ((p = (dir <= 0) ? p.left : p.right) == null) {
            Node<K,V> xpn = xp.next;
            //生成新的节点
            TreeNode<K,V> x = map.newTreeNode(h, k, v, xpn);
            //把新节点放在当前子节点为空的位置上
            if (dir <= 0)
                xp.left = x;
            else
                xp.right = x;
            //当前节点和新节点建立父子，前后关系
            xp.next = x;
            x.parent = x.prev = xp;
            if (xpn != null)
                ((TreeNode<K,V>)xpn).prev = x;
            //balanceInsertion 对红黑树进行着色或旋转，以达到更多的查找效率，着色或旋转的几种场景如下
            //着色：新节点总是为红色；如果新节点的父亲是黑色，则不需要重新着色；如果父亲是红色，那么必须通过重新着色或者旋转的方法，再次达到红黑树的5个约束条件
            //旋转： 父亲是红色，叔叔是黑色时，进行旋转
            //如果当前节点是父亲的右节点，则进行左旋
            //如果当前节点是父亲的左节点，则进行右旋
          
            //moveRootToFront 方法是把算出来的root放到根节点上
            moveRootToFront(tab, balanceInsertion(root, x));
            return null;
        }
    }
}
```

红黑树的新增，要求大家对红黑树的数据结构有一定的了解。面试的时候，一般只会问到新增节点到红黑树上大概是什么样的一个过程，着色和旋转的细节不会问，因为很难说清楚，但我们要清楚着色指的是给红黑树的节点着上红色或黑色，旋转是为了让红黑树更加平衡，提高查询的效率，总的来说都是为了满足红黑树的 5 个原则：

1. 节点是红色或黑色
2. 根是黑色
3. 所有叶子都是黑色
4. 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点
5. 从每个叶子到根的所有路径上不能有两个连续的红色节点



## 3 查找

HashMap 的查找主要分为以下三步：

- 根据 hash 算法定位数组的索引位置，equals 判断当前节点是否是我们需要寻找的 key，是的话直接返回，不是的话往下。
- 判断当前节点有无 next 节点，有的话判断是链表类型，还是红黑树类型。
- 分别走链表和红黑树不同类型的查找方法。

链表查找的关键代码是：

```java
// 采用自旋方式从链表中查找 key，e 初始为为链表的头节点
do {
    // 如果当前节点 hash 等于 key 的 hash，并且 equals 相等，当前节点就是我们要找的节点
    // 当 hash 冲突时，同一个 hash 值上是一个链表的时候，我们是通过 equals 方法来比较 key 是否相等的
    if (e.hash == hash &&
        ((k = e.key) == key || (key != null && key.equals(k))))
        return e;
    // 否则，把当前节点的下一个节点拿出来继续寻找
} while ((e = e.next) != null);
```

红黑树查找的代码很多，我们大概说下思路，实际步骤比较复杂，可以去 github 上面去查看源码：

1. 从根节点递归查找；
2. 根据 hashcode，比较查找节点，左边节点，右边节点之间的大小，根本红黑树左小右大的特性进行判断；
3. 判断查找节点在第 2 步有无定位节点位置，有的话返回，没有的话重复 2，3 两步；
4. 一直自旋到定位到节点位置为止。

如果红黑树比较平衡的话，每次查找的次数就是树的深度。



## 总结

HashMap 的内容虽然较多，但大多数 api 都只是对数组 + 链表 + 红黑树这种数据结构进行封装而已，本小节我们从新增和查找两个角度进行了源码的深入分析，分析了是如何对数组、链表和红黑树进行操作的。想了解更多，可以前往 github 上查看更多源码。

[07 List 源码会问哪些面试题](https://www.imooc.com/read/47/article/849)[09 TreeMap 和 LinkedHashMap 核心源码解析](https://www.imooc.com/read/47/article/851)

精选留言 30

欢迎在这里发表留言，作者筛选后可公开显示

- [懂渊](https://www.imooc.com/u/1368837/articles)

  很清晰了，那个hash图画着很好，一看就懂，是我目前看过写着最明白的

   2

  回复

  2020-01-09

- [qq_起风了_90](https://www.imooc.com/u/4215153/articles)

  老师，怎么debug扩容过程啊，我在hashmap的构造函数里面都给定了负载因子和容量，但程序运行的过程，没有体现出扩容啊。

   1

  回复

  2019-12-07

- [allen平凡之路](https://www.imooc.com/u/487406/articles)

  数组下标从0开始吧，文中写错了吧

   1

  回复

  2019-12-02

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[allen平凡之路](https://www.imooc.com/u/487406/articles)

    同学你好，具体是哪里有误呢？数组下标从0开始是常识哈，HashMap 计算数组下标主要是通过 Hash 算法计算出的哈，不一定从 0 开始有值。

    回复

    2019-12-08 13:21:51

  - [慕粉2313086611](https://www.imooc.com/u/4087024/articles)

    回复

    [文贺](https://www.imooc.com/u/8062574/articles)

    他说的是上面图下的“从数组下标索引为2 和 为9” 那一部分，如果从0开始计算，则是下标为1和下标为8，分别为链表和树

    回复

    2020-01-11 21:31:40

- [qq_起风了_90](https://www.imooc.com/u/4215153/articles)

  老师，resize的过程中，这段代码： // 原索引 if ((e.hash & oldCap) == 0) { if (loTail == null) loHead = e; else loTail.next = e; loTail = e; } 中的e.hash & oldCap==0，就判断是原索引，不是应是新索引吗，

   1

  回复

  2019-11-30

- [阿岑XD](https://www.imooc.com/u/7683173/articles)

  老师 链表中的值应该如何去取

   1

  回复

  2019-11-27

  - [qq_起风了_90](https://www.imooc.com/u/4215153/articles)

    回复[阿岑XD](https://www.imooc.com/u/7683173/articles)

    同问

    回复

    2019-11-29 08:08:43

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[阿岑XD](https://www.imooc.com/u/7683173/articles)

    递归遍历寻找，可以参考 getTreeNode 方法

    回复

    2019-11-30 13:23:42

- [AntChenxi](https://www.imooc.com/u/6107561/articles)

  老师，文档里面怎么都不讲tableSizeFor、resize等等这些方法呢？

   1

  回复

  2019-11-25

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[AntChenxi](https://www.imooc.com/u/6107561/articles)

    源码注释很早就提交了，github 上有的，文章的篇幅有限。

    回复

    2019-11-30 13:20:41

  - [凉凉那个凉凉](https://www.imooc.com/u/3162691/articles)

    回复

    [文贺](https://www.imooc.com/u/8062574/articles)

    github 地址哪里有？

    回复

    2019-12-06 11:15:27

- [慕先生9458666](https://www.imooc.com/u/6519848/articles)

  老师，能不能讲讲hashMap 的扩容 resize

   1

  回复

  2019-11-25

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[慕先生9458666](https://www.imooc.com/u/6519848/articles)

    源码注释很早就提交了，github 上有的，文章的篇幅有限。

    回复

    2019-11-30 13:20:38

- [慕村6418685](https://www.imooc.com/u/8135530/articles)

  看起来有些难懂，尤其是源码

   1

  回复

  2019-11-23

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[慕村6418685](https://www.imooc.com/u/8135530/articles)

    同学你说的很有道理，如果仅仅是看的话，估计永远都看不懂，动起手吧，debug！

    回复

    2019-11-30 13:24:19

- [大LOVE辉](https://www.imooc.com/u/2851044/articles)

  不覆盖，就不插入了吗？？e就没用了呢？

   1

  回复

  2019-11-22

- [大LOVE辉](https://www.imooc.com/u/2851044/articles)

  老师，在插入的时候，是不是没有对应哈西情况下，就插入到数组下面呢？？

   1

  回复

  2019-11-22

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[大LOVE辉](https://www.imooc.com/u/2851044/articles)

    没有太看明白问题哈，这个可以看一下 put 方法的过程，可以下载源码看下注释，很详细的

    回复

    2019-11-23 16:35:22

  - [大LOVE辉](https://www.imooc.com/u/2851044/articles)

    回复

    [文贺](https://www.imooc.com/u/8062574/articles)

    老师这个问题我看明白了，还有第二个问题：是不是数据的数量是一直在记录，比如有30个值插入进来，其中有九个哈希冲突，这个咋办呢，是扩容吗，扩容后重新排列？不可以用转红黑树的情况，因为他64还没到。

    回复

    2019-11-23 16:42:16

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[大LOVE辉](https://www.imooc.com/u/2851044/articles)

    如果你使用 HashMap 的API 的话，这种场景几乎不可能出现，因为 HashMap 自带的算法的 Hash 冲突概念很小哈。如果是自己写的 Hash 算法，建议修改下算法。 假设你这种场景出现在 JDK 的 HashMap 中，按照源码来说，小于 64 时，链表会扩容，而不转化成红黑树。

    回复

    2019-11-23 16:47:50

  点击展开后面 1 条

- [qq_呀个呸的_0](https://www.imooc.com/u/5127696/articles)

  老师您好，看第一张图片中写道 链表长度小于6时，红黑树转换成链表，这就不大理解？ 如果从红黑树转换成链表，是在哪个方法中调用的呢？举个例子：比如移除元素时，在remove()方法里有对应的检测，然后进行一个转换，但是我也没找到呢？请老师讲解一下吧，这是面试中问到的

   1

  回复

  2019-11-16

  - [payzul](https://www.imooc.com/u/2886145/articles)

    回复[qq_呀个呸的_0](https://www.imooc.com/u/5127696/articles)

    在split方法中，这个方法只有在resize方法里被调用的。

    回复

    2019-11-18 14:16:11

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[qq_呀个呸的_0](https://www.imooc.com/u/5127696/articles)

    remove 方法里面是没有这个的，是在 resize 方法里面，看源码的时候，可以根据UNTREEIFY_THRESHOLD快速定位到源码位置。

    回复

    2019-11-23 16:33:56

- [qq_呀个呸的_0](https://www.imooc.com/u/5127696/articles)

  请问老师，往haspmap放数据时，取的hash值对数组长度取模为零的，是放到table[0]么？concurrenthashmap中是如何实现size的，是否安全呢？求解答

   1

  回复

  2019-11-13

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[qq_呀个呸的_0](https://www.imooc.com/u/5127696/articles)

    是的，通过 hash 算法计算出数组的索引下标，如果是0的话，就表示在 table 的0 的索引下标处。 ConcurrentHashMap 安全可以参考 ConcurrentHashMap小节

    回复

    2019-11-17 10:43:01

- [修兮666](https://www.imooc.com/u/5361855/articles)

  hash桶能解释下吗？ 桶里存放是是什么哪,一直没搞明白

   1

  回复

  2019-10-30

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[修兮666](https://www.imooc.com/u/5361855/articles)

    桶简单理解，就是数组的某一个索引位置(具体谁先用这个词的没有追踪到，我学习 Java 的时候大家已经在用这个词了)，根据不同情况会放三种东西：某一个值(看MAP的泛型是啥就是啥)，一个链表，一个红黑树。。

    回复

    2019-10-31 10:56:17

- [爱新觉罗小凡](https://www.imooc.com/u/5436884/articles)

  老师，想问下1.2常见属性中最后一个红黑树的节点，jdk8中定义了，Node parent，left，right和prev，想问下这个prev是干嘛的，三个指针不是就够了嘛

   1

  回复

  2019-10-25

- [为了angular耻辱上线](https://www.imooc.com/u/6958824/articles)

  我写了一个hashmap，没有设置初始值。然后当我put第一个值的时候，我发现hashmap的容量格子中，已经有诸如【"file:///D:/basetools/Java/jdk1.8/jre/lib/ext/jaccess.jar" 】这样的jar包被填充为key。且每个位置是不一样的。这是为什么呢？

   2

  回复

  2019-10-24

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[为了angular耻辱上线](https://www.imooc.com/u/6958824/articles)

    同学你好，断点打早了，测试类启动的时候，自己也会用到HashMap 的，你等到运行到测试代码之后，再去 HashMap 中打断点。

    回复

    2019-10-24 20:29:29

  - [为了angular耻辱上线](https://www.imooc.com/u/6958824/articles)

    回复

    [文贺](https://www.imooc.com/u/8062574/articles)

    迷惑，为什么我之前的手机版都完全看不到您的回复，也没有消息推送。今天在电脑版才看到了一堆回复···哎。谢谢作者大大回答。

    回复

    2020-01-21 17:18:51

- [威先森](https://www.imooc.com/u/6261517/articles)

  老师，在新增流程图那边，找到数组新增的位置，位置上如果是空的，应该就把新增的值赋值给当前数组元素吧，不用再先赋值给零时变量e，最后再判断是否能修改吧？

   1

  回复

  2019-10-23

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[威先森](https://www.imooc.com/u/6261517/articles)

    嗯嗯，是的，你是对的。

    回复

    2019-10-24 20:38:05

- [音殿](https://www.imooc.com/u/4730658/articles)

  老师 我思路有点乱 是不是这样 1.刚刚开始的时候是key存放在数组里面 然后这个数组是不连续的 是根据key查出对应的hash值 然后存放到对应的数组索引上 然后value就是链表或者 红黑树结构 根据长度不同来选择不同的存储结构对吧？ 2.如果上一条理解正确 那么key 然后value是一个长度为6的ArrayList进去 那么结构是怎样的？ 3.hash冲突的时候 比如那个hash已有一个List的值 然后我又放进一个List 就是说变成了链表形式 存放了两个List 不知我理解的正常吗？

   1

  回复

  2019-10-23

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[音殿](https://www.imooc.com/u/4730658/articles)

    同学你好，我感觉你的确有丢丢乱哈，第一个是根据类型来选择不同的结构，不是长度哈。第二个长度是6的话，就是一个链表哈，第三个其实我有点点没有看懂问题，只有一个 List。 多多 debug，我相信你可以的，我第一次看源码的时候也很乱，都是 debug 顺的。

    回复

    2019-10-24 20:37:32

- [风舞炫动](https://www.imooc.com/u/6409329/articles)

  有没有红黑树的扫盲篇

   1

  回复

  2019-10-21

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[风舞炫动](https://www.imooc.com/u/6409329/articles)

    算法导论 第三版 13章节，有介绍红黑树，比较系统完整。

    回复

    2019-10-23 12:53:49

  - [风舞炫动](https://www.imooc.com/u/6409329/articles)

    回复

    [文贺](https://www.imooc.com/u/8062574/articles)

    好 的 ， 谢 谢 老 师

    回复

    2019-10-24 16:11:15

- [风舞炫动](https://www.imooc.com/u/6409329/articles)

  应该是大于等于64吧

   1

  回复

  2019-10-21

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[风舞炫动](https://www.imooc.com/u/6409329/articles)

    是的，你说的对，大于等于

    回复

    2019-10-23 12:50:41

- [licly](https://www.imooc.com/u/8096709/articles)

  老师，keySet和entrySet是怎么有的值呢，我没有找到赋值的地方，但是他确实是有值的

   1

  回复

  2019-09-24

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[licly](https://www.imooc.com/u/8096709/articles)

    keySet 和 entrySet 返回的是 Set，你用 Set 的时候，会从 HashMap 中取值。

    回复

    2019-09-25 14:58:26

  - [licly](https://www.imooc.com/u/8096709/articles)

    回复

    [文贺](https://www.imooc.com/u/8062574/articles)

    public Set keySet() { Set ks = keySet; if (ks == null) { ks = new KeySet(); keySet = ks; } return ks; } 这个是keyset源码，进入if (ks == null) 时，ks 为null，但是ks = new KeySet();这行代码执行完，ks就有了值，这里不太理解是怎么有值的

    回复

    2019-09-29 10:51:58

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[licly](https://www.imooc.com/u/8096709/articles)

    只有用的时候才有值哈，你能看到值，是因为 debug 的时候，HashMap 的 toString 方法会调用 entryKey 方法。

    回复

    2019-09-29 19:20:58

  点击展开后面 2 条

- [licly](https://www.imooc.com/u/8096709/articles)

  某一个位置链表长度=8，但是这时候capacity小于64，此时不会变为红黑树，而是进行扩容。极端情况下，如果扩容后该位置链表长度还是8，只能是下次put才能变为红黑树，或者继续扩容。也就是说，hashmap是有可能存在链表长度超过8，但是没有变为红黑树的情况的，这样理解对吗

   0

  回复

  2019-09-24

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[licly](https://www.imooc.com/u/8096709/articles)

    是的，但是概念是千万分之一

    回复

    2019-09-25 14:55:51

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复

    [文贺](https://www.imooc.com/u/8062574/articles)

    出现 8 个的概念是千万分之一

    回复

    2019-09-25 14:56:09

- [licly](https://www.imooc.com/u/8096709/articles)

  老师，resize方法中，if（oldCap > 0）分支中， else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY && oldCap >= DEFAULT_INITIAL_CAPACITY) 判断，为什么要有oldCap >= DEFAULT_INITIAL_CAPACITY这个条件，不满足这个条件的情况是指定初始容量，并且小于16，比如4、8等。这里oldCap等于4或8的时候，为什么不直接double threshold，而是要在下面通过if (newThr == 0) 判断后，进行赋值。这里不太理解，请老师说明一下

   1

  回复

  2019-09-24

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[licly](https://www.imooc.com/u/8096709/articles)

    Map map = new HashMap&lt;&gt;(1);map.put("1","1") 你可以 debug 下这行代码，如果按照你的想法，第一次put 的时候，容量是1，但 threshold 是2了哈。

    回复

    2019-09-25 14:52:06

- [_Guess](https://www.imooc.com/u/5686573/articles)

  2.1中概念应该是概率

   1

  回复

  2019-09-12

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[_Guess](https://www.imooc.com/u/5686573/articles)

    感谢提醒，已更正。。

    回复

    2019-09-27 12:53:17

- [_Guess](https://www.imooc.com/u/5686573/articles)

  1.1中，“不扩容的条件”写错了吗？

   1

  回复

  2019-09-12

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[_Guess](https://www.imooc.com/u/5686573/articles)

    对的哈。数组容量*0.75 &gt; 需要的数组大小，就不扩容，也就是 数组容量&gt;需要的数组大小/0.75

    回复

    2019-09-12 18:55:43

- [和尚码代码](https://www.imooc.com/u/7388288/articles)

  为什么文章里有些源码讲解和GitHub源码里一些讲解不一样啊

   1

  回复

  2019-09-11

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[和尚码代码](https://www.imooc.com/u/7388288/articles)

    文章对源码做了一些修饰，篇幅有限，有时位置有所移动，有时不是特别关键的代码会省略，文章发布之后，新增改动的源码注释也是同步不过来的哈。

    回复

    2019-09-11 17:55:38

- [孙DONG](https://www.imooc.com/u/2370644/articles)

  老师，辛苦讲下扩容为啥是2的幂次方呢？知道好处是减少哈希冲突，但不知道为啥能减少哈希冲突…

   1

  回复

  2019-09-11

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[孙DONG](https://www.imooc.com/u/2370644/articles)

    2 的幂次方，主要是为了满足 (hash%n)= （n-1）&amp; hash 这个公式，计算机计算 &amp; 速度更快哈，你可以进群 @我一下，或者直接加我微信，我画了一个 hash 算法的图，比较完整，我发给你，回复发不了图片。

    回复

    2019-09-11 12:44:24

- [最怕认真](https://www.imooc.com/u/1899708/articles)

  老师，能不能加一些数据结构和算法的基础学习啊，红黑树是什么都不知道

   2

  回复

  2019-09-09

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[最怕认真](https://www.imooc.com/u/1899708/articles)

    咱们课程一共48节，内容很多，在说数据结构时，都会画一些大概的图出来，阅读源码的时候这些就够了哈，不会把算法说的特别深，至于特别细的算法可以参考《算法导论》，红黑树在其第三部分十三章节有详细描述。谢谢

    回复

    2019-09-09 14:31:37

- [qq_踏彐寻梅_03702812](https://www.imooc.com/u/3702812/articles)

  想问一下这是jdk1.7还是jdk1.8.想知道一下1.8是怎么解决hashmap并发有可能出现环的问题

   1

  回复

  2019-09-08

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[qq_踏彐寻梅_03702812](https://www.imooc.com/u/3702812/articles)

    jdk8 哈，原因从代码上说： // loHead 表示老值,老值的意思是扩容后，该链表中计算出索引位置不变的元素 // hiHead 表示新值，新值的意思是扩容后，计算出索引位置发生变化的元素 // 举个例子，数组大小是 8 ，在数组索引位置是 1 的地方挂着两个值，两个值的 hashcode 是9和33。 // 当数组发生扩容时，新数组的大小是 16，此时 hashcode 是 33 的值计算出来的数组索引位置仍然是 1，我们称为老值 // hashcode 是 9 的值计算出来的数组索引位置是 9，就发生了变化，我们称为新值。

    回复

    2019-09-09 15:47:42

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[qq_踏彐寻梅_03702812](https://www.imooc.com/u/3702812/articles)

    本来准备贴代码的，发现代码贴了全部乱掉了，代码注释已经上传了，可以拉一下代码，HashMap 的 resize 方法，大概 1360~1400 行的位置

    回复

    2019-09-09 15:50:18

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[qq_踏彐寻梅_03702812](https://www.imooc.com/u/3702812/articles)

    可以参考这个手记：https://www.imooc.com/article/292199

    回复

    2019-09-10 11:11:32

- [倾听落叶](https://www.imooc.com/u/2985877/articles)

  两个疑问，源码putVal方法 if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); binCount从0开始，代表的是链表的操作次数,而TREEIFY_THRESHOLD 为8 这样的话不是应该链表长度大于等于8树化吗 为什么是当链表的长度大于 8 时，链表转红黑树? 还有源码split方法中 if (lc <= UNTREEIFY_THRESHOLD) tab[index] = loHead.untreeify(map); lc是红黑树大小,这里应该是桶上的红黑树大小小于等于6时，红黑树转化成链表 为什么是桶上的红黑树大小小于6时，红黑树转化成链表?

   1

  回复

  2019-09-04

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[倾听落叶](https://www.imooc.com/u/2985877/articles)

    你说的很对，不知道为啥我没有加上等于二字，已经修改了，谢谢。

    回复

    2019-09-05 17:44:42

- [Gitcommit](https://www.imooc.com/u/5054459/articles)

  通过key的hash能直接找到值 跳转到6 而图中的意思是通过key找不到当前的值 为空,进而进行赋值 这与上述的文字描述不是冲突吗

   1

  回复

  2019-09-03

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[Gitcommit](https://www.imooc.com/u/5054459/articles)

    描述一致的哈，你看下图中为空和不为空是两条分拆哦，分拆就是对应着描述 2。

    回复

    2019-09-03 20:25:06

  - [慕神9346227](https://www.imooc.com/u/7808597/articles)

    回复

    [文贺](https://www.imooc.com/u/8062574/articles)

    那个图上是不是没有画出key不存在直接生成新的节点的逻辑

    回复

    2019-09-09 19:55:13

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[慕神9346227](https://www.imooc.com/u/7808597/articles)

    图中当前值为空，就包含了你说的逻辑。

    回复

    2019-09-10 06:18:57

  - [慕神9346227](https://www.imooc.com/u/7808597/articles)

    回复

    [文贺](https://www.imooc.com/u/8062574/articles)

    if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); 这段逻辑并没有临时变量e的参与啊

    回复

    2019-09-10 09:49:54

 

千学不如一看，千看不如一练

 

# 09 TreeMap 和 LinkedHashMap 核心源码解析

09 TreeMap 和 LinkedHashMap 核心源码解析

更新时间：2019-09-05 10:15:03

![img](https://img2.sycdn.imooc.com/5d706f650001a05206400359.jpg)

![img](https://www.imooc.com/static/img/column/bg-l.png)![img](https://www.imooc.com/static/img/column/bg-r.png)

人的影响短暂而微弱，书的影响则广泛而深远。

——普希金



### 引导语

在熟悉 HashMap 之后，本小节我们来看下 TreeMap 和 LinkedHashMap，看看 TreeMap 是如何根据 key 进行排序的，LinkedHashMap 是如何用两种策略进行访问的。



### 1 知识储备

在了解 TreeMap 之前，我们来看下日常工作中排序的两种方式，作为我们学习的基础储备，两种方式的代码如下：

```java
public class TreeMapDemo {

  @Data
  // DTO 为我们排序的对象
  class DTO implements Comparable<DTO> {
    private Integer id;
    public DTO(Integer id) {
      this.id = id;
    }

    @Override
    public int compareTo(DTO o) {
      //默认从小到大排序
      return id - o.getId();
    }
  }

  @Test
  public void testTwoComparable() {
    // 第一种排序，从小到大排序，实现 Comparable 的 compareTo 方法进行排序
    List<DTO> list = new ArrayList<>();
    for (int i = 5; i > 0; i--) {
      list.add(new DTO(i));
    }
    Collections.sort(list);
    log.info(JSON.toJSONString(list));

    // 第二种排序，从大到小排序，利用外部排序器 Comparator 进行排序
    Comparator comparator = (Comparator<DTO>) (o1, o2) -> o2.getId() - o1.getId();
    List<DTO> list2 = new ArrayList<>();
    for (int i = 5; i > 0; i--) {
      list2.add(new DTO(i));
    }
    Collections.sort(list,comparator);
    log.info(JSON.toJSONString(list2));
  }
}
```

第一种排序输出的结果从小到大，结果是：[{“id”:1},{“id”:2},{“id”:3},{“id”:4},{“id”:5}]；

第二种输出的结果恰好相反，结果是：[{“id”:5},{“id”:4},{“id”:3},{“id”:2},{“id”:1}]。

以上两种就是分别通过 Comparable 和 Comparator 两者进行排序的方式，而 TreeMap 利用的也是此原理，从而实现了对 key 的排序，我们一起来看下。



### 2 TreeMap 整体架构

TreeMap 底层的数据结构就是红黑树，和 HashMap 的红黑树结构一样。

不同的是，TreeMap 利用了红黑树左节点小，右节点大的性质，根据 key 进行排序，使每个元素能够插入到红黑树大小适当的位置，维护了 key 的大小关系，适用于 key 需要排序的场景。

因为底层使用的是平衡红黑树的结构，所以 containsKey、get、put、remove 等方法的时间复杂度都是 log(n)。

#### 2.1 属性

TreeMap 常见的属性有：

```java
//比较器，如果外部有传进来 Comparator 比较器，首先用外部的
//如果外部比较器为空，则使用 key 自己实现的 Comparable#compareTo 方法
//比较手段和上面日常工作中的比较 demo 是一致的
private final Comparator<? super K> comparator;

//红黑树的根节点
private transient Entry<K,V> root;

//红黑树的已有元素大小
private transient int size = 0;

//树结构变化的版本号，用于迭代过程中的快速失败场景
private transient int modCount = 0;

//红黑树的节点
static final class Entry<K,V> implements Map.Entry<K,V> {}
```

#### 2.2 新增节点

我们来看下 TreeMap 新增节点的步骤：

1. 判断红黑树的节点是否为空，为空的话，新增的节点直接作为根节点，代码如下：

   ```java
   Entry<K,V> t = root;
   //红黑树根节点为空，直接新建
   if (t == null) {
       // compare 方法限制了 key 不能为 null
       compare(key, key); // type (and possibly null) check
       // 成为根节点
       root = new Entry<>(key, value, null);
       size = 1;
       modCount++;
       return null;
   }
   ```

2. 根据红黑树左小右大的特性，进行判断，找到应该新增节点的父节点，代码如下：

   ```java
   Comparator<? super K> cpr = comparator;
   if (cpr != null) {
       //自旋找到 key 应该新增的位置，就是应该挂载那个节点的头上
       do {
           //一次循环结束时，parent 就是上次比过的对象
           parent = t;
           // 通过 compare 来比较 key 的大小
           cmp = cpr.compare(key, t.key);
           //key 小于 t，把 t 左边的值赋予 t，因为红黑树左边的值比较小，循环再比
           if (cmp < 0)
               t = t.left;
           //key 大于 t，把 t 右边的值赋予 t，因为红黑树右边的值比较大，循环再比
           else if (cmp > 0)
               t = t.right;
           //如果相等的话，直接覆盖原值
           else
               return t.setValue(value);
           // t 为空，说明已经到叶子节点了
       } while (t != null);
   }
   ```

3. 在父节点的左边或右边插入新增节点，代码如下：

   ```java
   //cmp 代表最后一次对比的大小，小于 0 ，代表 e 在上一节点的左边
   if (cmp < 0)
       parent.left = e;
   //cmp 代表最后一次对比的大小，大于 0 ，代表 e 在上一节点的右边，相等的情况第二步已经处理了。
   else
       parent.right = e;
   ```

4. 着色旋转，达到平衡，结束。

从源码中，我们可以看到：

1. 新增节点时，就是利用了红黑树左小右大的特性，从根节点不断往下查找，直到找到节点是 null 为止，节点为 null 说明到达了叶子结点；
2. 查找过程中，发现 key 值已经存在，直接覆盖；
3. TreeMap 是禁止 key 是 null 值的。

类似的，TreeMap 查找也是类似的原理，有兴趣的同学可以去 github 上面去查看源码。

#### 2.3 小结

TreeMap 相对来说比较简单，红黑树和 HashMap 比较类似，比较关键的是通过 compare 来比较 key 的大小，然后利用红黑树左小右大的特性，为每个 key 找到自己的位置，从而维护了 key 的大小排序顺序。



### 3 LinkedHashMap 整体架构

HashMap 是无序的，TreeMap 可以按照 key 进行排序，那有木有 Map 是可以维护插入的顺序的呢？接下来我们一起来看下 LinkedHashMap。

LinkedHashMap 本身是继承 HashMap 的，所以它拥有 HashMap 的所有特性，再此基础上，还提供了两大特性：

- 按照插入顺序进行访问；
- 实现了访问最少最先删除功能，其目的是把很久都没有访问的 key 自动删除。

接着我们来看下上述两大特性。

#### 3.1 按照插入顺序访问

##### 3.1.1 LinkedHashMap 链表结构

我们看下 LinkedHashMap 新增了哪些属性，以达到了链表结构的：

```java
// 链表头
transient LinkedHashMap.Entry<K,V> head;

// 链表尾
transient LinkedHashMap.Entry<K,V> tail;

// 继承 Node，为数组的每个元素增加了 before 和 after 属性
static class Entry<K,V> extends HashMap.Node<K,V> {
    Entry<K,V> before, after;
    Entry(int hash, K key, V value, Node<K,V> next) {
        super(hash, key, value, next);
    }
}

// 控制两种访问模式的字段，默认 false
// true 按照访问顺序，会把经常访问的 key 放到队尾
// false 按照插入顺序提供访问
final boolean accessOrder;
```

从上述 Map 新增的属性可以看到，LinkedHashMap 的数据结构很像是把 LinkedList 的每个元素换成了 HashMap 的 Node，像是两者的结合体，也正是因为增加了这些结构，从而能把 Map 的元素都串联起来，形成一个链表，而链表就可以保证顺序了，就可以维护元素插入进来的顺序。

##### 3.1.2 如何按照顺序新增

LinkedHashMap 初始化时，默认 accessOrder 为 false，就是会按照插入顺序提供访问，插入方法使用的是父类 HashMap 的 put 方法，不过覆写了 put 方法执行中调用的 newNode/newTreeNode 和 afterNodeAccess 方法。

newNode/newTreeNode 方法，控制新增节点追加到链表的尾部，这样每次新节点都追加到尾部，即可保证插入顺序了，我们以 newNode 源码为例：

```java
// 新增节点，并追加到链表的尾部
Node<K,V> newNode(int hash, K key, V value, Node<K,V> e) {
    // 新增节点
    LinkedHashMap.Entry<K,V> p =
        new LinkedHashMap.Entry<K,V>(hash, key, value, e);
    // 追加到链表的尾部
    linkNodeLast(p);
    return p;
}
// link at the end of list
private void linkNodeLast(LinkedHashMap.Entry<K,V> p) {
    LinkedHashMap.Entry<K,V> last = tail;
    // 新增节点等于位节点
    tail = p;
    // last 为空，说明链表为空，首尾节点相等
    if (last == null)
        head = p;
    // 链表有数据，直接建立新增节点和上个尾节点之间的前后关系即可
    else {
        p.before = last;
        last.after = p;
    }
}
```

LinkedHashMap 通过新增头节点、尾节点，给每个节点增加 before、after 属性，每次新增时，都把节点追加到尾节点等手段，在新增的时候，就已经维护了按照插入顺序的链表结构了。

##### 3.1.3 按照顺序访问

LinkedHashMap 只提供了单向访问，即按照插入的顺序从头到尾进行访问，不能像 LinkedList 那样可以双向访问。

我们主要通过迭代器进行访问，迭代器初始化的时候，默认从头节点开始访问，在迭代的过程中，不断访问当前节点的 after 节点即可。

Map 对 key、value 和 entity（节点） 都提供出了迭代的方法，假设我们需要迭代 entity，就可使用 `LinkedHashMap.entrySet().iterator()` 这种写法直接返回 LinkedHashIterator ，LinkedHashIterator 是迭代器，我们调用迭代器的 nextNode 方法就可以得到下一个节点，迭代器的源码如下：

```java
// 初始化时，默认从头节点开始访问
LinkedHashIterator() {
    // 头节点作为第一个访问的节点
    next = head;
    expectedModCount = modCount;
    current = null;
}

final LinkedHashMap.Entry<K,V> nextNode() {
    LinkedHashMap.Entry<K,V> e = next;
    if (modCount != expectedModCount)// 校验
        throw new ConcurrentModificationException();
    if (e == null)
        throw new NoSuchElementException();
    current = e;
    next = e.after; // 通过链表的 after 结构，找到下一个迭代的节点
    return e;
}
```

在新增节点时，我们就已经维护了元素之间的插入顺序了，所以迭代访问时非常简单，只需要不断的访问当前节点的下一个节点即可。

#### 3.2 访问最少删除策略

##### 3.2.1 demo

这种策略也叫做 LRU（Least recently used,最近最少使用），大概的意思就是经常访问的元素会被追加到队尾，这样不经常访问的数据自然就靠近队头，然后我们可以通过设置删除策略，比如当 Map 元素个数大于多少时，把头节点删除，我们写个 demo 方便大家理解。demo 如下，完整代码可到 github 上查看：

```java
public void testAccessOrder() {
  // 新建 LinkedHashMap
  LinkedHashMap<Integer, Integer> map = new LinkedHashMap<Integer, Integer>(4,0.75f,true) {
    {
      put(10, 10);
      put(9, 9);
      put(20, 20);
      put(1, 1);
    }

    @Override
    // 覆写了删除策略的方法，我们设定当节点个数大于 3 时，就开始删除头节点
    protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {
      return size() > 3;
    }
  };

  log.info("初始化：{}",JSON.toJSONString(map));
  Assert.assertNotNull(map.get(9));
  log.info("map.get(9)：{}",JSON.toJSONString(map));
  Assert.assertNotNull(map.get(20));
  log.info("map.get(20)：{}",JSON.toJSONString(map));

}
```

打印出来的结果如下：

```java
初始化：{9:9,20:20,1:1}
map.get(9)：{20:20,1:1,9:9}
map.get(20)：{1:1,9:9,20:20}
```

可以看到，map 初始化的时候，我们放进去四个元素，但结果只有三个元素，10 不见了，这个主要是因为我们覆写了 removeEldestEntry 方法，我们实现了如果 map 中元素个数大于 3 时，我们就把队头的元素删除，当 put(1, 1) 执行的时候，正好把队头的 10 删除，这个体现了达到我们设定的删除策略时，会自动的删除头节点。

当我们调用 map.get(9) 方法时，元素 9 移动到队尾，调用 map.get(20) 方法时， 元素 20 被移动到队尾，这个体现了经常被访问的节点会被移动到队尾。

这个例子就很好的说明了访问最少删除策略，接下来我们看下原理。

##### 3.2.2 元素被转移到队尾

我们先来看下为什么 get 时，元素会被移动到队尾：

```java
public V get(Object key) {
    Node<K,V> e;
    // 调用 HashMap  get 方法
    if ((e = getNode(hash(key), key)) == null)
        return null;
    // 如果设置了 LRU 策略
    if (accessOrder)
    // 这个方法把当前 key 移动到队尾
        afterNodeAccess(e);
    return e.value;
}
```

从上述源码中，可以看到，通过 afterNodeAccess 方法把当前访问节点移动到了队尾，其实不仅仅是 get 方法，执行 getOrDefault、compute、computeIfAbsent、computeIfPresent、merge 方法时，也会这么做，通过不断的把经常访问的节点移动到队尾，那么靠近队头的节点，自然就是很少被访问的元素了。

##### 3.2.3 删除策略

上述 demo 我们在执行 put 方法时，发现队头元素被删除了，LinkedHashMap 本身是没有 put 方法实现的，调用的是 HashMap 的 put 方法，但 LinkedHashMap 实现了 put 方法中的调用 afterNodeInsertion 方法，这个方式实现了删除，我们看下源码：

```java
// 删除很少被访问的元素，被 HashMap 的 put 方法所调用
void afterNodeInsertion(boolean evict) { 
    // 得到元素头节点
    LinkedHashMap.Entry<K,V> first;
    // removeEldestEntry 来控制删除策略，如果队列不为空，并且删除策略允许删除的情况下，删除头节点
    if (evict && (first = head) != null && removeEldestEntry(first)) {
        K key = first.key;
        // removeNode 删除头节点
        removeNode(hash(key), key, null, false, true);
    }
}
```

#### 3.3 小结

LinkedHashMap 提供了两个很有意思的功能：按照插入顺序访问和删除最少访问元素策略，简单地通过链表的结构就实现了，设计得非常巧妙。



### 总结

本小节主要说了 TreeMap 和 LinkedHashMap 的的数据结构，分析了两者的核心内容源码，我们发现两者充分利用了底层数据结构的特性，TreeMap 利用了红黑树左小右大的特性进行排序，LinkedHashMap 在 HashMap 的基础上简单地加了链表结构，就形成了节点的顺序，非常巧妙，很有意思，大家可以在看源码的过程中，可以多想想设计思路，说不定会有不一样的感悟。

[08 HashMap 源码解析](https://www.imooc.com/read/47/article/850)[10 Map源码会问哪些面试题](https://www.imooc.com/read/47/article/852)

精选留言 5

欢迎在这里发表留言，作者筛选后可公开显示

- [风舞炫动](https://www.imooc.com/u/6409329/articles)

  3.1.2 LinkedHashMap.Entry last = tail; // 新增节点等于位节点 tail = p; 这块应该是尾结点等于新增节点才对吧

   0

  回复

  2019-11-05

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[风舞炫动](https://www.imooc.com/u/6409329/articles)

    同学你好，tail 是尾结点，p 是新增节点，tail = p，所以是新增节点等于尾结点，意思是新增节点给尾结点赋值的意思哈。

    回复

    2019-11-05 20:43:07

- [licly](https://www.imooc.com/u/8096709/articles)

  问题：LinkedHashMap中afterNodeInsertion方法中 if (evict && (first = head) != null && removeEldestEntry(first)) 这个条件里面removeEldestEntry(first)始终返回的false，所以afterNodeInsertion这个方法调用了也是没有效果的，那该方法的意义是什么呢？

   0

  回复

  2019-10-03

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[licly](https://www.imooc.com/u/8096709/articles)

    同学你好，你看下3.2.1，是留给子类去实现的。

    回复

    2019-10-08 19:13:11

- [慕码人6169125](https://www.imooc.com/u/6612138/articles)

  感觉TreeMap的整体架构那边写的有点问题，“不同的是TreeMap利用了红黑树左节点小，右节点大的性质”，其实HashMap在putValTree方法里面也有用到这个性质。其实这两个结构最大的区别应该是TreeMap真的是一棵完整的树不存在数组，而HashMap还是存在数组结构

   0

  回复

  2019-09-17

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[慕码人6169125](https://www.imooc.com/u/6612138/articles)

    主要想说明一下 TreeMap 底层是如何利用红黑树实现 key 的排序的，并把这种能力直接通过 API 暴露了出来，HashMap 虽然也有红黑树，但却无法提供这种能力。你说的没错，TreeMap 是没有数组，TreeMap 和 HashMap 相比，差异的太多了，没有数组，也没有链表，各个方法都不同，这样是说不完的，我们主要想基于 TreeMap 已有的能力，来对比下两个 API 利用红黑树之后的结果是啥，给使用者带来什么不同的感受。

    回复

    2019-09-18 21:22:46

  - [慕码人6169125](https://www.imooc.com/u/6612138/articles)

    回复

    [文贺](https://www.imooc.com/u/8062574/articles)

    哦哦，理解老师要表达的意思啦

    回复

    2019-09-19 10:19:34

  - [大LOVE辉](https://www.imooc.com/u/2851044/articles)

    回复

    [文贺](https://www.imooc.com/u/8062574/articles)

    我找了半天，想找到数组有没有，就看到这了。。谢谢

    回复

    2019-11-22 09:37:56

- [Amy楠](https://www.imooc.com/u/7258333/articles)

  为什么在初始化时就直接删除了 初始化：{} {"9":9,"20":20,"1":1} 9 map.get(9)：{}{"20":20,"1":1,"9":9} 20 map.get(20)：{}{"1":1,"9":9,"20":20} null map.get(10)：{}{"1":1,"9":9,"20":20}

   1

  回复

  2019-09-10

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[Amy楠](https://www.imooc.com/u/7258333/articles)

    文中有说哈，removeEldestEntry 设置了删除策略

    回复

    2019-09-10 14:01:13

- [Megetood](https://www.imooc.com/u/6784324/articles)

  请问一下什么时候能更新完

   0

  回复

  2019-09-05

  - [初一](https://www.imooc.com/u/7789740/articles)

    回复[Megetood](https://www.imooc.com/u/6784324/articles)

    同学你好 本专栏是每周二、周四进行更新，感谢支持 ^^

    回复

    2019-09-05 14:36:41

 

千学不如一看，千看不如一练

 

# 10 Map源码会问哪些面试题

10 Map源码会问哪些面试题

更新时间：2019-09-10 10:34:08

![img](https://img.mukewang.com/5d7705f00001a59b06400359.jpg)

![img](https://www.imooc.com/static/img/column/bg-l.png)![img](https://www.imooc.com/static/img/column/bg-r.png)

人的一生可能燃烧也可能腐朽，我不能腐朽，我愿意燃烧起来！

——奥斯特洛夫斯基



## 引导语

Map 在面试中，占据了很大一部分的面试题目，其中以 HashMap 为主，这些面试题目有的可以说得清楚，有的很难说清楚，如果是面对面面试的话，建议画一画。



## 1 Map 整体数据结构类问题



### 1.1 说一说 HashMap 底层数据结构

答：HashMap 底层是数组 + 链表 + 红黑树的数据结构，数组的主要作用是方便快速查找，时间复杂度是 O(1)，默认大小是 16，数组的下标索引是通过 key 的 hashcode 计算出来的，数组元素叫做 Node，当多个 key 的 hashcode 一致，但 key 值不同时，单个 Node 就会转化成链表，链表的查询复杂度是 O(n)，当链表的长度大于等于 8 并且数组的大小超过 64 时，链表就会转化成红黑树，红黑树的查询复杂度是 O(log(n))，简单来说，最坏的查询次数相当于红黑树的最大深度。



### 1.2 HashMap、TreeMap、LinkedHashMap 三者有啥相同点，有啥不同点？

答：相同点：

1. 三者在特定的情况下，都会使用红黑树；
2. 底层的 hash 算法相同；
3. 在迭代的过程中，如果 Map 的数据结构被改动，都会报 ConcurrentModificationException 的错误。

不同点：

1. HashMap 数据结构以数组为主，查询非常快，TreeMap 数据结构以红黑树为主，利用了红黑树左小右大的特点，可以实现 key 的排序，LinkedHashMap 在 HashMap 的基础上增加了链表的结构，实现了插入顺序访问和最少访问删除两种策略;
2. 由于三种 Map 底层数据结构的差别，导致了三者的使用场景的不同，TreeMap 适合需要根据 key 进行排序的场景，LinkedHashMap 适合按照插入顺序访问，或需要删除最少访问元素的场景，剩余场景我们使用 HashMap 即可，我们工作中大部分场景基本都在使用 HashMap；
3. 由于三种 map 的底层数据结构的不同，导致上层包装的 api 略有差别。



### 1.3 说一下 Map 的 hash 算法

```java
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
key 在数组中的位置公式：tab[(n - 1) & hash]
```

如上代码是 HashMap 的hash 算法。

这其实是一个数学问题，源码中就是通过以上代码来计算 hash 的，首先计算出 key 的 hashcode，因为 key 是 Object，所以会根据 key 的不同类型进行 hashcode 的计算，接着计算 h ^ (h >>> 16) ，这么做的好处是使大多数场景下，算出来的 hash 值比较分散。

一般来说，hash 值算出来之后，要计算当前 key 在数组中的索引下标位置时，可以采用取模的方式，就是索引下标位置 = hash 值 % 数组大小，这样做的好处，就是可以保证计算出来的索引下标值可以均匀的分布在数组的各个索引位置上，但取模操作对于处理器的计算是比较慢的，数学上有个公式，当 b 是 2 的幂次方时，a % b = a &（b-1），所以此处索引位置的计算公式我们可以更换为： (n-1) & hash。

此问题可以延伸出三个小问题：

1：为什么不用 key % 数组大小，而是需要用 key 的 hash 值 % 数组大小。

答：如果 key 是数字，直接用 key % 数组大小是完全没有问题的，但我们的 key 还有可能是字符串，是复杂对象，这时候用 字符串或复杂对象 % 数组大小是不行的，所以需要先计算出 key 的 hash 值。

2：计算 hash 值时，为什么需要右移 16 位？

答：hash 算法是 h ^ (h >>> 16)，为了使计算出的 hash 值更分散，所以选择先将 h 无符号右移 16 位，然后再于 h 异或时，就能达到 h 的高 16 位和低 16 位都能参与计算，减少了碰撞的可能性。

3：为什么把取模操作换成了 & 操作？

答：key.hashCode() 算出来的 hash 值还不是数组的索引下标，为了随机的计算出索引的下表位置，我们还会用 hash 值和数组大小进行取模，这样子计算出来的索引下标比较均匀分布。

取模操作处理器计算比较慢，处理器对 & 操作就比较擅长，换成了 & 操作，是有数学上证明的支撑，为了提高了处理器处理的速度。

4：为什么提倡数组大小是 2 的幂次方？

答：因为只有大小是 2 的幂次方时，才能使 hash 值 % n(数组大小) == (n-1) & hash 公式成立。



### 1.4 为解决 hash 冲突，大概有哪些办法。

答：1：好的 hash 算法，细问的话复述一下上题的 hash 算法;

2：自动扩容，当数组大小快满的时候，采取自动扩容，可以减少 hash 冲突;

3：hash 冲突发生时，采用链表来解决;

4：hash 冲突严重时，链表会自动转化成红黑树，提高遍历速度。

网上列举的一些其它办法，如开放定址法，尽量不要说，因为这些方法资料很少，实战用过的人更少，如果你没有深入研究的话，面试官让你深入描述一下很难说清楚，反而留下不好的印象，说 HashMap 现有的措施就足够了。



## 2 HashMap 源码细节类问题



### 2.1 HashMap 是如何扩容的？

答：扩容的时机：

1. put 时，发现数组为空，进行初始化扩容，默认扩容大小为 16;
2. put 成功后，发现现有数组大小大于扩容的门阀值时，进行扩容，扩容为老数组大小的 2 倍;

扩容的门阀是 threshold，每次扩容时 threshold 都会被重新计算，门阀值等于数组的大小 * 影响因子（0.75）。

新数组初始化之后，需要将老数组的值拷贝到新数组上，链表和红黑树都有自己拷贝的方法。



### 2.2 hash 冲突时怎么办？

答：hash 冲突指的是 key 值的 hashcode 计算相同，但 key 值不同的情况。

如果桶中元素原本只有一个或已经是链表了，新增元素直接追加到链表尾部；

如果桶中元素已经是链表，并且链表个数大于等于 8 时，此时有两种情况：

1. 如果此时数组大小小于 64，数组再次扩容，链表不会转化成红黑树;
2. 如果数组大小大于 64 时，链表就会转化成红黑树。

这里不仅仅判断链表个数大于等于 8，还判断了数组大小，数组容量小于 64 没有立即转化的原因，猜测主要是因为红黑树占用的空间比链表大很多，转化也比较耗时，所以数组容量小的情况下冲突严重，我们可以先尝试扩容，看看能否通过扩容来解决冲突的问题。



### 2.3 为什么链表个数大于等于 8 时，链表要转化成红黑树了？

答：当链表个数太多了，遍历可能比较耗时，转化成红黑树，可以使遍历的时间复杂度降低，但转化成红黑树，有空间和转化耗时的成本，我们通过泊松分布公式计算，正常情况下，链表个数出现 8 的概念不到千万分之一，所以说正常情况下，链表都不会转化成红黑树，这样设计的目的，是为了防止非正常情况下，比如 hash 算法出了问题时，导致链表个数轻易大于等于 8 时，仍然能够快速遍历。

延伸问题：红黑树什么时候转变成链表。

答：当节点的个数小于等于 6 时，红黑树会自动转化成链表，主要还是考虑红黑树的空间成本问题，当节点个数小于等于 6 时，遍历链表也很快，所以红黑树会重新变成链表。



### 2.4 HashMap 在 put 时，如果数组中已经有了这个 key，我不想把 value 覆盖怎么办？取值时，如果得到的 value 是空时，想返回默认值怎么办？

答：如果数组有了 key，但不想覆盖 value ，可以选择 putIfAbsent 方法，这个方法有个内置变量 onlyIfAbsent，内置是 true ，就不会覆盖，我们平时使用的 put 方法，内置 onlyIfAbsent 为 false，是允许覆盖的。

取值时，如果为空，想返回默认值，可以使用 getOrDefault 方法，方法第一参数为 key，第二个参数为你想返回的默认值，如 map.getOrDefault(“2”,“0”)，当 map 中没有 key 为 2 的值时，会默认返回 0，而不是空。



### 2.5 通过以下代码进行删除，是否可行？

```java
HashMap<String,String > map = Maps.newHashMap();
map.put("1","1");
map.put("2","2");
map.forEach((s, s2) -> map.remove("1"));
```

答：不行，会报错误 ConcurrentModificationException，原因如下图：

![图片描述](https://img.mukewang.com/5d763e330001e64710380560.png)
建议使用迭代器的方式进行删除，原理同 ArrayList 迭代器原理，我们在《List 源码会问那些面试题》中有说到。



### 2.6 描述一下 HashMap get、put 的过程

答：我们在源码解析中有说，可以详细描述下源码的实现路径，说不清楚的话，可以画一画。



## 3 其它 Map 面试题



### 3.1 DTO 作为 Map 的 key 时，有无需要注意的点？

答：DTO 就是一个数据载体，可以看做拥有很多属性的 Java 类，我们可以对这些属性进行 get、set 操作。

看是什么类型的 Map，如果是 HashMap 的话，一定需要覆写 equals 和 hashCode 方法，因为在 get 和 put 的时候，需要通过 equals 方法进行相等的判断；如果是 TreeMap 的话，DTO 需要实现 Comparable 接口，因为 TreeMap 会使用 Comparable 接口进行判断 key 的大小；如果是 LinkedHashMap 的话，和 HashMap 一样的。



### 3.2 LinkedHashMap 中的 LRU 是什么意思，是如何实现的。

答：LRU ，英文全称：Least recently used，中文叫做最近最少访问，在 LinkedHashMap 中，也叫做最少访问删除策略，我们可以通过 removeEldestEntry 方法设定一定的策略，使最少被访问的元素，在适当的时机被删除，原理是在 put 方法执行的最后，LinkedHashMap 会去检查这种策略，如果满足策略，就删除头节点。

保证头节点就是最少访问的元素的原理是：LinkedHashMap 在 get 的时候，都会把当前访问的节点，移动到链表的尾部，慢慢的，就会使头部的节点都是最少被访问的元素。



### 3.3 为什么推荐 TreeMap 的元素最好都实现 Comparable 接口？但 key 是 String 的时候，我们却没有额外的工作呢？

答：因为 TreeMap 的底层就是通过排序来比较两个 key 的大小的，所以推荐 key 实现 Comparable 接口，是为了往你希望的排序顺序上发展， 而 String 本身已经实现了 Comparable 接口，所以使用 String 时，我们不需要额外的工作，不仅仅是 String ，其他包装类型也都实现了 Comparable 接口，如 Long、Double、Short 等等。



## 总结

Map 的面试题主要是 HashMap 为主，会问很多源码方面的东西，TreeMap 和 LinkedHashMap 主要以功能和场景为主，作为加分项。
Map 的面试题型很多，但只要弄懂原理，题目再多变化，回答起来都会比较简单。

[09 TreeMap 和 LinkedHashMap 核心源码解析](https://www.imooc.com/read/47/article/851)[11 HashSet、TreeSet 源码解析](https://www.imooc.com/read/47/article/853)

精选留言 9

欢迎在这里发表留言，作者筛选后可公开显示

- [AroundLe](https://www.imooc.com/u/1098496/articles)

  1.3.4 提倡2的幂次方。这么理解不知道对不对。比如数组大小n是16，根据公式(n-1)&hash。15的二进制是1111，1111&0000是0000。1111&0001是0001。1111&0010是0010。1111&0011是0011。而数组大小是11，10的二进制是1010。1010&0000是0000。1010&0001是0000。1010&0010是0010。1010&0011是0010。由此，如果数组大小是2的幂次方再减1，则位数上都为1，可以无伤保留hash低位，降低了计算出数组下标重复的可能。

   0

  回复

  1天前

- [qq_起风了_90](https://www.imooc.com/u/4215153/articles)

  老师，能写写jdk1.7hashmap的死循环吗？

   0

  回复

  2019-12-04

- [Sicimike](https://www.imooc.com/u/3395084/articles)

  老师，1.2说HashMap、TreeMap、LinkedHashMap底层hash算法相同，但是TreeMap没有用到hash算法吧，因为它没有bucket，无需根据hash(key)去找到索引。

   1

  回复

  2019-11-08

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[Sicimike](https://www.imooc.com/u/3395084/articles)

    你说的很有道理，周一找编辑订正下。

    回复

    2019-11-17 11:10:51

- [qq_踏彐寻梅_03702812](https://www.imooc.com/u/3702812/articles)

  老师。扩容为老数组大小的 2 倍。你确定吗？？不是裸照成2的n次方吗

   0

  回复

  2019-09-14

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[qq_踏彐寻梅_03702812](https://www.imooc.com/u/3702812/articles)

    没有问题哦，你看一仔细看下咱们 HashMap 源码章节，源码中扩容中代码是这么写的：newThr = oldThr &lt;&lt; 1，新数组大小为老数组大小的 2 倍。

    回复

    2019-09-15 09:28:10

  - [qq_踏彐寻梅_03702812](https://www.imooc.com/u/3702812/articles)

    回复[qq_踏彐寻梅_03702812](https://www.imooc.com/u/3702812/articles)

    哦。不好意思，我傻了。

    回复

    2019-09-17 00:35:28

- [shuangyueliao](https://www.imooc.com/u/4898660/articles)

  hashmap小于64是链表，大于等于是转化为红黑树，老师漏了等于

   0

  回复

  2019-09-12

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[shuangyueliao](https://www.imooc.com/u/4898660/articles)

    这个本文 2.2 面试题和 HashMap 源码解析章节多次提到 64 哦，其余地方在说扩容的时候，可能并不会总是带上 64，你说的应该是 2.3 问题，问的是为什么在大于等于 8 时扩容是吧，这时候根据语境，问的是为什么，而不是什么时候，所以我们就无需说 64 哦。

    回复

    2019-09-15 09:26:15

- [一个被女人上过的男人](https://www.imooc.com/u/6320083/articles)

  老师，更新一集concurrenthashmap吧，谢谢

   0

  回复

  2019-09-12

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[一个被女人上过的男人](https://www.imooc.com/u/6320083/articles)

    第三章会说的哈，并发集合类。

    回复

    2019-09-12 12:28:40

- [一个被女人上过的男人](https://www.imooc.com/u/6320083/articles)

  底层实现这个1.7和1.8有区别的啊，我想问哈老师，这个问题面试时要不要给面试官说哈对比呢？![☺️](https://www.imooc.com/static/moco/v1.0/images/face/36x36/263a.png)

   0

  回复

  2019-09-12

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[一个被女人上过的男人](https://www.imooc.com/u/6320083/articles)

    面试官问啥答啥哈，不问就不用说哈，HashMap 1.7 比较简单，问的人现在也比较少了

    回复

    2019-09-12 12:31:07

- [Spring_inthis](https://www.imooc.com/u/6566632/articles)

  章节怎么跟之前简介内容说得得不一样0.0.

   0

  回复

  2019-09-11

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[Spring_inthis](https://www.imooc.com/u/6566632/articles)

    一样的吧，哪里不一样？

    回复

    2019-09-11 17:48:47

- [慕仰0328976](https://www.imooc.com/u/8085349/articles)

  其实想要hash的更加彻底还有很多神奇的算法，比如redis的murmurHash或者DJB HASH算法，但是因为性能差不多最后还是用了效率最高的^（抑或）来解决问题

   0

  回复

  2019-09-10

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[慕仰0328976](https://www.imooc.com/u/8085349/articles)

    有道理的，学了这么多算法，工作中可能一个都用不到。。

    回复

    2019-09-10 13:59:14

 

千学不如一看，千看不如一练

 

# 11 HashSet、TreeSet 源码解析

11 HashSet、TreeSet 源码解析

更新时间：2019-09-16 19:37:35

![img](https://img2.mukewang.com/5d77064e0001864d06400359.jpg)

![img](https://www.imooc.com/static/img/column/bg-l.png)![img](https://www.imooc.com/static/img/column/bg-r.png)

成功的奥秘在于目标的坚定。

——迪斯雷利



## 引导语

HashSet、TreeSet 两个类是在 Map 的基础上组装起来的类，我们学习的侧重点，主要在于 Set 是如何利用 Map 现有的功能，来达成自己的目标的，也就是说如何基于现有的功能进行创新，然后再看看一些改变的小细节是否值得我们学习。



## 1 HashSet



### 1.1 类注释

看源码先看类注释上，我们可以得到的信息有：

1. 底层实现基于 HashMap，所以迭代时不能保证按照插入顺序，或者其它顺序进行迭代；
2. add、remove、contanins、size 等方法的耗时性能，是不会随着数据量的增加而增加的，这个主要跟 HashMap 底层的数组数据结构有关，不管数据量多大，不考虑 hash 冲突的情况下，时间复杂度都是 O (1)；
3. 线程不安全的，如果需要安全请自行加锁，或者使用 Collections.synchronizedSet；
4. 迭代过程中，如果数据结构被改变，会快速失败的，会抛出 ConcurrentModificationException 异常。

我们之前也看过 List、Map 的类注释，我们发现 2、3、4 点信息在类注释中都有提到，所以如果有人问 List、Map、 Set 三者的共同点，那么就可以说 2、3、4 三点。



### 1.2 HashSet 是如何组合 HashMap 的

刚才是从类注释 1 中看到，HashSet 的实现是基于 HashMap 的，在 Java 中，要基于基础类进行创新实现，有两种办法：

- 继承基础类，覆写基础类的方法，比如说继承 HashMap , 覆写其 add 的方法；
- 组合基础类，通过调用基础类的方法，来复用基础类的能力。

HashSet 使用的就是组合 HashMap，其优点如下：

1. 继承表示父子类是同一个事物，而 Set 和 Map 本来就是想表达两种事物，所以继承不妥，而且 Java 语法限制，子类只能继承一个父类，后续难以扩展。
2. 组合更加灵活，可以任意的组合现有的基础类，并且可以在基础类方法的基础上进行扩展、编排等，而且方法命名可以任意命名，无需和基础类的方法名称保持一致。

我们在工作中，如果碰到类似问题，我们的原则也是尽量多用组合，少用继承。

组合就是把 HashMap 当作自己的一个局部变量，以下是 HashSet 的组合实现：

```java
// 把 HashMap 组合进来，key 是 Hashset 的 key，value 是下面的 PRESENT
private transient HashMap<E,Object> map;
// HashMap 中的 value
private static final Object PRESENT = new Object();
```

从这两行代码中，我们可以看出两点：

1. 我们在使用 HashSet 时，比如 add 方法，只有一个入参，但组合的 Map 的 add 方法却有 key，value 两个入参，相对应上 Map 的 key 就是我们 add 的入参，value 就是第二行代码中的 PRESENT，此处设计非常巧妙，用一个默认值 PRESENT 来代替 Map 的 Value；
2. 如果 HashSet 是被共享的，当多个线程访问的时候，就会有线程安全问题，因为在后续的所有操作中，并没有加锁。

HashSet 在以 HashMap 为基础进行实现的时候，首先选择组合的方式，接着使用默认值来代替了 Map 中的 Value 值，设计得非常巧妙，给使用者的体验很好，使用起来简单方便，我们在工作中也可以借鉴这种思想，可以把底层复杂实现包装一下，一些默认实现可以自己吃掉，使吐出去的接口尽量简单好用。

#### 1.2.1 初始化

HashSet 的初始化比较简单，直接 new HashMap 即可，比较有意思的是，当有原始集合数据进行初始化的情况下，会对 HashMap 的初始容量进行计算，源码如下：

```java
// 对 HashMap 的容量进行了计算
public HashSet(Collection<? extends E> c) {
    map = new HashMap<>(Math.max((int) (c.size()/.75f) + 1, 16));
    addAll(c);
}
```

上述代码中：Math.max ((int) (c.size ()/.75f) + 1, 16)，就是对 HashMap 的容量进行了计算，翻译成中文就是 取括号中两个数的最大值（期望的值 / 0.75+1，默认值 16），从计算中，我们可以看出 HashSet 的实现者对 HashMap 的底层实现是非常清楚的，主要体现在两个方面：

1. 和 16 比较大小的意思是说，如果给定 HashMap 初始容量小于 16 ，就按照 HashMap 默认的 16 初始化好了，如果大于 16，就按照给定值初始化。
2. HashMap 扩容的伐值的计算公式是：Map 的容量 * 0.75f，一旦达到阀值就会扩容，此处用 (int) (c.size ()/.75f) + 1 来表示初始化的值，这样使我们期望的大小值正好比扩容的阀值还大 1，就不会扩容，符合 HashMap 扩容的公式。

从简单的构造器中，我们就可以看出要很好的组合 api 接口，并没有那么简单，我们可能需要去了解一下被组合的 api 底层的实现，这样才能用好 api。

同时这种写法，也提供了一种思路给我们，如果有人问你，往 HashMap 拷贝大集合时，如何给 HashMap 初始化大小时，完全可以借鉴这种写法：取最大值（期望的值 / 0.75 + 1，默认值 16）。

至于 HashSet 的其他方法就比较简单了，就是对 Map 的 api 进行了一些包装，如下的 add 方法实现：

```java
public boolean add(E e) {
    // 直接使用 HashMap 的 put 方法，进行一些简单的逻辑判断
    return map.put(e, PRESENT)==null;
}
```

从 add 方法中，我们就可以看到组合的好处，方法的入参、名称、返回值都可以自定义，如果是继承的话就不行了。

#### 1.2.2 小结

HashSet 具体实现值得我们借鉴的地方主要有如下地方，我们平时写代码的时候，完全可以参考参考：

1. 对组合还是继承的分析和把握；
2. 对复杂逻辑进行一些包装，使吐出去的接口尽量简单好用；
3. 组合其他 api 时，尽量多对组合的 api 多些了解，这样才能更好的使用 api；
4. HashMap 初始化大小值的模版公式：取括号内两者的最大值（期望的值 / 0.75+1，默认值 16）。



## 2 TreeSet

TreeSet 大致的结构和 HashSet 相似，底层组合的是 TreeMap，所以继承了 TreeMap key 能够排序的功能，迭代的时候，也可以按照 key 的排序顺序进行迭代，我们主要来看复用 TreeMap 时，复用的两种思路：

#### 2.1 复用 TreeMap 的思路一

场景一： TreeSet 的 add 方法，我们来看下其源码：

```java
public boolean add(E e) {
    return m.put(e, PRESENT)==null;
}
```

可以看到，底层直接使用的是 HashMap 的 put 的能力，直接拿来用就好了。

#### 2.2 复用 TreeMap 的思路二

场景二：需要迭代 TreeSet 中的元素，那应该也是像 add 那样，直接使用 HashMap 已有的迭代能力，比如像下面这样：

```java
// 模仿思路一的方式实现
public Iterator<E> descendingIterator() {
    // 直接使用 HashMap.keySet 的迭代能力
    return m.keySet().iterator();
}
```

这种是思路一的实现方式，TreeSet 组合 TreeMap，直接选择 TreeMap 的底层能力进行包装，但 TreeSet 实际执行的思路却完全相反，我们看源码：

```java
// NavigableSet 接口，定义了迭代的一些规范，和一些取值的特殊方法
// TreeSet 实现了该方法，也就是说 TreeSet 本身已经定义了迭代的规范
public interface NavigableSet<E> extends SortedSet<E> {
    Iterator<E> iterator();
    E lower(E e);
}  
// m.navigableKeySet() 是 TreeMap 写了一个子类实现了 NavigableSet
// 接口，实现了 TreeSet 定义的迭代规范
public Iterator<E> iterator() {
    return m.navigableKeySet().iterator();
}
```

TreeMap 中对 NavigableSet 接口的实现源码截图如下：

![图片描述](https://img.mukewang.com/5d763f6e00018e0114461250.png)从截图中（截图是在 TreeMap 中），我们可以看出 TreeMap 实现了 TreeSet 定义的各种特殊方法。

我们可以看到，这种思路是 TreeSet 定义了接口的规范，TreeMap 负责去实现，实现思路和思路一是相反的。

我们总结下 TreeSet 组合 TreeMap 实现的两种思路：

1. TreeSet 直接使用 TreeMap 的某些功能，自己包装成新的 api。
2. TreeSet 定义自己想要的 api，自己定义接口规范，让 TreeMap 去实现。

方案 1 和 2 的调用关系，都是 TreeSet 调用 TreeMap，但功能的实现关系完全相反，第一种是功能的定义和实现都在 TreeMap，TreeSet 只是简单的调用而已，第二种 TreeSet 把接口定义出来后，让 TreeMap 去实现内部逻辑，TreeSet 负责接口定义，TreeMap 负责具体实现，这样子的话因为接口是 TreeSet 定义的，所以实现一定是 TreeSet 最想要的，TreeSet 甚至都不用包装，可以直接把返回值吐出去都行。

我们思考下这两种复用思路的原因：

1. 像 add 这些简单的方法，我们直接使用的是思路 1，主要是 add 这些方法实现比较简单，没有复杂逻辑，所以 TreeSet 自己实现起来比较简单；
2. 思路 2 主要适用于复杂场景，比如说迭代场景，TreeSet 的场景复杂，比如要能从头开始迭代，比如要能取第一个值，比如要能取最后一个值，再加上 TreeMap 底层结构比较复杂，TreeSet 可能并不清楚 TreeMap 底层的复杂逻辑，这时候让 TreeSet 来实现如此复杂的场景逻辑，TreeSet 就搞不定了，不如接口让 TreeSet 来定义，让 TreeMap 去负责实现，TreeMap 对底层的复杂结构非常清楚，实现起来既准确又简单。

#### 2.3 小结

TreeSet 对 TreeMap 的两种不同复用思路，很重要，在工作中经常会遇到，特别是思路二，比如说 dubbo 的泛化调用，DDD 中的依赖倒置等等，原理都是 TreeSet 第二种的复用思想。



## 3 面试题

HashSet 和 TreeSet 的面试概率比不上 List 和 Map，但只要有机会，并把本文的内容表达出来，绝对是加分项，因为现在 List 和 Map 面试题太多，面试官认为你能答的出来是应该的，但只要你有机会对 HashSet 和 TreeSet 说出本文见解，并且说自己是看源码时领悟到的，绝对肯定是加分项，这些就是你超过面试官预期的惊喜，以下是一些常用的题目：



### 3.1 TreeSet 有用过么，平时都在什么场景下使用？

答：有木有用过如实回答就好了，我们一般都是在需要把元素进行排序的时候使用 TreeSet，使用时需要我们注意元素最好实现 Comparable 接口，这样方便底层的 TreeMap 根据 key 进行排序。



### 3.2 追问，如果我想实现根据 key 的新增顺序进行遍历怎么办？

答：要按照 key 的新增顺序进行遍历，首先想到的应该就是 LinkedHashMap，而 LinkedHashSet 正好是基于 LinkedHashMap 实现的，所以我们可以选择使用 LinkedHashSet。



### 3.3 追问，如果我想对 key 进行去重，有什么好的办法么？

答：我们首先想到的是 TreeSet，TreeSet 底层使用的是 TreeMap，TreeMap 在 put 的时候，如果发现 key 是相同的，会把 value 值进行覆盖，所有不会产生重复的 key ，利用这一特性，使用 TreeSet 正好可以去重。



### 3.4 说说 TreeSet 和 HashSet 两个 Set 的内部实现结构和原理？

答： HashSet 底层对 HashMap 的能力进行封装，比如说 add 方法，是直接使用 HashMap 的 put 方法，比较简单，但在初始化的时候，我看源码有一些感悟：说一下 HashSet 小结的四小点。

TreeSet 主要是对 TreeMap 底层能力进行封装复用，我发现了两种非常有意思的复用思路，重复 TreeSet 两种复用思路。



## 总结

本小节主要说了 Set 源码中两处亮点：

1. HashSet 对组合的 HashMap 类扩容的门阀值的深入了解和设计，值得我们借鉴；
2. TreeSet 对 TreeMap 两种复用思路，值得我们学习，特别是第二种复用思路。

HashSet 和 TreeSet 不会是面试的重点，但通过以上两点，可以让我们给面试官一种精益求精的感觉，成为加分项。

[10 Map源码会问哪些面试题](https://www.imooc.com/read/47/article/852)[12 彰显细节：看集合源码对我们实际工作的帮助和应用](https://www.imooc.com/read/47/article/854)

精选留言 10

欢迎在这里发表留言，作者筛选后可公开显示

- [所相虚妄](https://www.imooc.com/u/7839242/articles)

  这个不是TreeSet负责来定义吧，不是NavigableSet来负责定义的么。。

   0

  回复

  2019-12-07

- [weixin_慕工程5089940](https://www.imooc.com/u/8217835/articles)

  老师我想问一下，关于HashSet的add方法，如果我add一个本身map中存在的键，但是值是null的，根据map的put返回规则，会返回null，根据add方法的逻辑，set会判断添加成功，但实际上map中只是修改了一个键的值，会有这样的情况吗？还是我的理解有问题?

   0

  回复

  2019-10-28

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[weixin_慕工程5089940](https://www.imooc.com/u/8217835/articles)

    HashSet 的 value 是一个固定的值，所以按照你说的场景，Map 里面会找出存在的 key，不会更新 key。

    回复

    2019-10-31 11:15:55

- [慕粉1835158847](https://www.imooc.com/u/4536208/articles)

  追问3.3，HashSet不是也能去重吗

   0

  回复

  2019-10-14

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[慕粉1835158847](https://www.imooc.com/u/4536208/articles)

    是的，也可以哈，没说不可以哈。

    回复

    2019-10-15 13:30:19

- [qq_Ezio_1](https://www.imooc.com/u/4477929/articles)

  老师。面试题在哪找好，刷题顺序是怎样的。这几个月面试处处碰壁，希望老师能给些意见

   0

  回复

  2019-09-18

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[qq_Ezio_1](https://www.imooc.com/u/4477929/articles)

    知乎上可以搜索到大厂面试题，比如搜索阿里面试题，就会出现最新的面试题，另外说一句，刷面试题全靠运气，大厂每年的面试题都和往年不一样，面试的几个关键要素： 1. 运气，问到的都是你会的；2. 有所准备，事先准备几个知识点，是自己深入研究过的，这样可以突出亮点；3. 注意知识点之间的关联，大多人学习的知识都是单点，想孤岛一样，如果你能把知识点关联起来，无疑比大多数人更深入了一步。 最后，相信自己，我也相信你可以的。

    回复

    2019-09-18 21:02:31

  - [qq_Ezio_1](https://www.imooc.com/u/4477929/articles)

    回复

    [文贺](https://www.imooc.com/u/8062574/articles)

    感谢老师的鼓励！！！！

    回复

    2019-09-19 19:36:28

- [monkeyzi](https://www.imooc.com/u/3535380/articles)

  问题3.2有误吧?

   0

  回复

  2019-09-16

- [weixin_慕哥6366500](https://www.imooc.com/u/7958274/articles)

  老师，这什么时候能更新完呀

   0

  回复

  2019-09-14

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[weixin_慕哥6366500](https://www.imooc.com/u/7958274/articles)

    近期计划每周 2 更哈。

    回复

    2019-09-16 19:36:41

- [bb111323](https://www.imooc.com/u/5803138/articles)

  追问的3.2 HashSet不是基于HashMap实现的吗？ HashMap输出无序的，HashSet输出好像也不是按照添加的顺序啊。

   0

  回复

  2019-09-14

- [XsYoung](https://www.imooc.com/u/141590/articles)

  老师，3.2是不是想说的是 LinkedHashSet

   0

  回复

  2019-09-14

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[XsYoung](https://www.imooc.com/u/141590/articles)

    嗯嗯，收到，感谢指正，订正中了。

    回复

    2019-09-16 19:36:19

- [shuangyueliao](https://www.imooc.com/u/4898660/articles)

  不对呀，hashmap的数组大小不是永远是2的倍数吗，所以hashmap数组大小的模板公式不是那么适用

   0

  回复

  2019-09-13

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[shuangyueliao](https://www.imooc.com/u/4898660/articles)

    放心好了，初始化 HashMap 的时候，用这个计算公式绝对没有问题的，即使你传给 HashMap 的值不是 2 的幂次方，HashMap 自己在初始化的时候，也会设置成 2 的幂次方，可以参考HashMap 源码中 tableSizeFor 方法。

    回复

    2019-09-15 09:39:21

- [Elylic](https://www.imooc.com/u/3417562/articles)

  非常实用！！面试必备！！

   0

  回复

  2019-09-12

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[Elylic](https://www.imooc.com/u/3417562/articles)

    嗯嗯，学习！学习！学习！，进步！进步！进步！

    回复

    2019-09-12 19:00:40

 

千学不如一看，千看不如一练

 

# 12 彰显细节：看集合源码对我们实际工作的帮助和应用

12 彰显细节：看集合源码对我们实际工作的帮助和应用

更新时间：2019-09-17 10:19:41

![img](https://img4.mukewang.com/5d8042b200016f3506400359.jpg)

![img](https://www.imooc.com/static/img/column/bg-l.png)![img](https://www.imooc.com/static/img/column/bg-r.png)

劳动是一切知识的源泉。

——陶铸

本节中，我们先跳出源码的视角，来看看集合类的类图，看看在设计层面上，是否有可疑借鉴之处，接着通过源码来找找工作中的集合坑，提前扫雷。



## 1 集合类图

![图片描述](https://img.mukewang.com/5d7ef50d00018a8315460536.png)上图是目前我们已学的集合类图，大概可以看出以下几点：

1. 每个接口做的事情非常明确，比如 Serializable，只负责序列化，Cloneable 只负责拷贝，Map 只负责定义 Map 的接口，整个图看起来虽然接口众多，但职责都很清晰；
2. 复杂功能通过接口的继承来实现，比如 ArrayList 通过实现了 Serializable、Cloneable、RandomAccess、AbstractList、List 等接口，从而拥有了序列化、拷贝、对数组各种操作定义等各种功能；
3. 上述类图只能看见继承的关系，组合的关系还看不出来，比如说 Set 组合封装 Map 的底层能力等。

上述设计的最大好处是，每个接口能力职责单一，众多的接口变成了接口能力的积累，假设我们想再实现一个数据结构类，我们就可以从这些已有的能力接口中，挑选出能满足需求的能力接口，进行一些简单的组装，从而加快开发速度。

这种思想在平时的工作中也经常被使用，我们会把一些通用的代码块抽象出来，沉淀成代码块池，碰到不同的场景的时候，我们就从代码块池中，把我们需要的代码块提取出来，进行简单的编排和组装，从而实现我们需要的场景功能。



## 2 集合工作中一些注意事项



### 2.1 线程安全

我们说集合都是非线程安全的，这里说的非线程安全指的是集合类作为共享变量，被多线程读写的时候，才是不安全的，如果要实现线程安全的集合，在类注释中，JDK 统一推荐我们使用 Collections.synchronized* 类， Collections 帮我们实现了 List、Set、Map 对应的线程安全的方法， 如下图：
![图片描述](https://img.mukewang.com/5d7ef4d400018def13540844.png)图中实现了各种集合类型的线程安全的方法，我们以 synchronizedList 为例，从源码上来看下，Collections 是如何实现线程安全的：

```java
// mutex 就是我们需要锁住的对象
final Object mutex;  
static class SynchronizedList<E>
        extends SynchronizedCollection<E>
        implements List<E> {
        private static final long serialVersionUID = -7754090372962971524L;
        // 这个 List 就是我们需要保证线程安全的类
        final List<E> list;
        SynchronizedList(List<E> list, Object mutex) {
            super(list, mutex);
            this.list = list;
        }
				// 我们可以看到，List 的所有操作都使用了 synchronized 关键字，来进行加锁
				// synchronized 是一种悲观锁，能够保证同一时刻，只能有一个线程能够获得锁
        public E get(int index) {
            synchronized (mutex) {return list.get(index);}
        }
        public E set(int index, E element) {
            synchronized (mutex) {return list.set(index, element);}
        }
        public void add(int index, E element) {
            synchronized (mutex) {list.add(index, element);}
        }
…………
}      
```

从源码中我们可以看到 Collections 是通过 synchronized 关键字给 List 操作数组的方法加上锁，来实现线程安全的。



### 2.2 集合性能

集合的单个操作，一般都没有性能问题，性能问题主要出现的批量操作上。

#### 2.2.1 批量新增

在 List 和 Map 大量数据新增的时候，我们不要使用 for 循环 + add/put 方法新增，这样子会有很大的扩容成本，我们应该尽量使用 addAll 和 putAll 方法进行新增，以 ArrayList 为例写了一个 demo 如下，演示了两种方案的性能对比：

```java
@Test
public void testBatchInsert(){
  // 准备拷贝数据
  ArrayList<Integer> list = new ArrayList<>();
  for(int i=0;i<3000000;i++){
    list.add(i);
  }

  // for 循环 + add
  ArrayList<Integer> list2 = new ArrayList<>();
  long start1 = System.currentTimeMillis();
  for(int i=0;i<list.size();i++){
    list2.add(list.get(i));
  }
  log.info("单个 for 循环新增 300 w 个，耗时{}",System.currentTimeMillis()-start1);

  // 批量新增
  ArrayList<Integer> list3 = new ArrayList<>();
  long start2 = System.currentTimeMillis();
  list3.addAll(list);
  log.info("批量新增 300 w 个，耗时{}",System.currentTimeMillis()-start2);
}
```

最后打印出来的日志为：

16:52:59.865 [main] INFO demo.one.ArrayListDemo - 单个 for 循环新增 300 w 个，耗时1518
16:52:59.880 [main] INFO demo.one.ArrayListDemo - 批量新增 300 w 个，耗时8

可以看到，批量新增方法性能是单个新增方法性能的 189 倍，主要原因在于批量新增，只会扩容一次，大大缩短了运行时间，而单个新增，每次到达扩容阀值时，都会进行扩容，在整个过程中就会不断的扩容，浪费了很多时间，我们来看下批量新增的源码：

```java
public boolean addAll(Collection<? extends E> c) {
  Object[] a = c.toArray();
  int numNew = a.length;
  // 确保容量充足，整个过程只会扩容一次
  ensureCapacityInternal(size + numNew); 
  // 进行数组的拷贝
  System.arraycopy(a, 0, elementData, size, numNew);
  size += numNew;
  return numNew != 0;
}
```

以上是 ArrayList 批量新增的演示，我们可以看到，整个批量新增的过程中，只扩容了一次，HashMap 的 putAll 方法也是如此，整个新增过程只会扩容一次，大大缩短了批量新增的时间，提高了性能。

所以如果有人问你当碰到集合批量拷贝，批量新增场景，如何提高新增性能的时候 ，就可以从目标集合初始化方面应答。

这里也提醒了我们，在容器初始化的时候，最好能给容器赋上初始值，这样可以防止在 put 的过程中不断的扩容，从而缩短时间，上章 HashSet 的源码给我们演示了，给 HashMap 赋初始值的公式为：取括号内两者的最大值（期望的值/0.75+1，默认值 16）。

#### 2.2.2 批量删除

批量删除 ArrayList 提供了 removeAll 的方法，HashMap 没有提供批量删除的方法，我们一起来看下 removeAll 的源码实现，是如何提高性能的：

```java
// 批量删除，removeAll 方法底层调用的是 batchRemove 方法
// complement 参数默认是 false,false 的意思是数组中不包含 c 中数据的节点往头移动
// true 意思是数组中包含 c 中数据的节点往头移动，这个是根据你要删除数据和原数组大小的比例来决定的
// 如果你要删除的数据很多，选择 false 性能更好，当然 removeAll 方法默认就是 false。
private boolean batchRemove(Collection<?> c, boolean complement) {
  final Object[] elementData = this.elementData;
  // r 表示当前循环的位置、w 位置之前都是不需要被删除的数据，w 位置之后都是需要被删除的数据
  int r = 0, w = 0;
  boolean modified = false;
  try {
    // 从 0 位置开始判断，当前数组中元素是不是要被删除的元素，不是的话移到数组头
    for (; r < size; r++)
      if (c.contains(elementData[r]) == complement)
        elementData[w++] = elementData[r];
  } finally {
    // r 和 size 不等，说明在 try 过程中发生了异常，在 r 处断开
    // 把 r 位置之后的数组移动到 w 位置之后(r 位置之后的数组数据都是没有判断过的数据，这样不会影响没有判断的数据，判断过的数据可以被删除)
    if (r != size) {
      System.arraycopy(elementData, r,
                       elementData, w,
                       size - r);
      w += size - r;
    }
    // w != size 说明数组中是有数据需要被删除的
    // 如果 w、size 相等，说明没有数据需要被删除
    if (w != size) {
      // w 之后都是需要删除的数据，赋值为空，帮助 gc。
      for (int i = w; i < size; i++)
        elementData[i] = null;
      modCount += size - w;
      size = w;
      modified = true;
    }
  }
  return modified;
}
```

我们看到 ArrayList 在批量删除时，如果程序执行正常，只有一次 for 循环，如果程序执行异常，才会加一次拷贝，而单个 remove 方法，每次执行的时候都会进行数组的拷贝（当删除的元素正好是数组最后一个元素时除外），当数组越大，需要删除的数据越多时，批量删除的性能会越差，所以在 ArrayList 批量删除时，强烈建议使用 removeAll 方法进行删除。



### 2.3 集合的一些坑

1. 当集合的元素是自定义类时，自定义类强制实现 equals 和 hashCode 方法，并且两个都要实现。

在集合中，除了 TreeMap 和 TreeSet 是通过比较器比较元素大小外，其余的集合类在判断索引位置和相等时，都会使用到 equals 和 hashCode 方法，这个在之前的源码解析中，我们有说到，所以当集合的元素是自定义类时，我们强烈建议覆写 equals 和 hashCode 方法，我们可以直接使用 IDEA 工具覆写这两个方法，非常方便；

1. 所有集合类，在 for 循环进行删除时，如果直接使用集合类的 remove 方法进行删除，都会快速失败，报 ConcurrentModificationException 的错误，所以在任意循环删除的场景下，都建议使用迭代器进行删除；
2. 我们把数组转化成集合时，常使用 Arrays.asList(array)，这个方法有两个坑，代码演示坑为：

```java
public void testArrayToList(){
  Integer[] array = new Integer[]{1,2,3,4,5,6};
  List<Integer> list = Arrays.asList(array);

  // 坑1：修改数组的值，会直接影响原 list
  log.info("数组被修改之前，集合第一个元素为：{}",list.get(0));
  array[0] = 10;
  log.info("数组被修改之前，集合第一个元素为：{}",list.get(0));

  // 坑2：使用 add、remove 等操作 list 的方法时，
  // 会报 UnsupportedOperationException 异常
  list.add(7);
}
坑 1：数组被修改后，会直接影响到新 List 的值。
坑 2：不能对新 List 进行 add、remove 等操作，否则运行时会报 UnsupportedOperationException 错误。
```

我们来看下 Arrays.asList 的源码实现，就能知道问题所在了，源码如下图：

![图片描述](https://img.mukewang.com/5d7ef4ad0001a58020880820.png)从上图中，我们可以发现，Arrays.asList 方法返回的 List 并不是 java.util.ArrayList，而是自己内部的一个静态类，该静态类直接持有数组的引用，并且没有实现 add、remove 等方法，这些就是坑 1 和 2 的原因。

1. 集合 List 转化成数组，我们通常使用 toArray 这个方法，这个方法很危险，稍微不注意，就踩进大坑，我们示例代码如下：

```java
  public void testListToArray(){
    List<Integer> list = new ArrayList<Integer>(){{
      add(1);
      add(2);
      add(3);
      add(4);
    }};

    // 下面这行被注释的代码这么写是无法转化成数组的，无参 toArray 返回的是 Object[],
    // 无法向下转化成 List<Integer>，编译都无法通过
    // List<Integer> list2 = list.toArray();

    // 演示有参 toArray 方法，数组大小不够时，得到数组为 null 情况
    Integer[] array0 = new Integer[2];
    list.toArray(array0);
    log.info("toArray 数组大小不够，array0 数组[0] 值是{},数组[1] 值是{},",array0[0],array0[1]);
		
    // 演示数组初始化大小正好，正好转化成数组
    Integer[] array1 = new Integer[list.size()];
    list.toArray(array1);
    log.info("toArray 数组大小正好，array1 数组[3] 值是{}",array1[3]);

    // 演示数组初始化大小大于实际所需大小，也可以转化成数组
    Integer[] array2 = new Integer[list.size()+2];
    list.toArray(array2);
    log.info("toArray 数组大小多了，array2 数组[3] 值是{}，数组[4] 值是{}",array2[3],array2[4]);
  }
19:33:07.687 [main] INFO demo.one.ArrayListDemo - toArray 数组大小不够，array0 数组[0] 值是null,数组[1] 值是null,
19:33:07.697 [main] INFO demo.one.ArrayListDemo - toArray 数组大小正好，array1 数组[3] 值是4
19:33:07.697 [main] INFO demo.one.ArrayListDemo - toArray 数组大小多了，array2 数组[3] 值是4，数组[4] 值是null
```

toArray 的无参方法，无法强转成具体类型，这个编译的时候，就会有提醒，我们一般都会去使用带有参数的 toArray 方法，这时就有一个坑，如果参数数组的大小不够，这时候返回的数组值竟然是空，上述代码中的 array0 的返回值就体现了这点，但我们去看 toArray 源码，发现源码中返回的是 4 个大小值的数据，返回的并不是空，源码如下：

```java
// List 转化成数组
public <T> T[] toArray(T[] a) {
  // 如果数组长度不够，按照 List 的大小进行拷贝，return 的时候返回的都是正确的数组
  if (a.length < size)
    // Make a new array of a's runtime type, but my contents:
    return (T[]) Arrays.copyOf(elementData, size, a.getClass());
  System.arraycopy(elementData, 0, a, 0, size);
  // 数组长度大于 List 大小的，赋值为 null
  if (a.length > size)
    a[size] = null;
  return a;
}
```

从源码中，我们丝毫看不出为什么 array0 的元素值为什么是 null，最后我们去看方法的注释，发现是这样子描述的：

```java
If the list fits in the specified array, it is returned therein.  Otherwise, a new array is
 allocated with the runtime type of the specified array and the size of this list。
```

翻译过来的意思就是说：如果返回的数组大小和申明的数组大小一致，那么就会正常返回，否则，一个新数组就会被分配返回。

所以我们在使用有参 toArray 方法时，申明的数组大小一定要大于等于 List 的大小，如果小于的话，你会得到一个空数组。



## 3 总结

本小节，我们详细描述了集合的线程安全、性能优化和日常工作中一些坑，这些问题我们在工作中经常会碰到，稍不留神就会引发线上故障，面试的时候也经常会通过这些问题，来考察大家的工作经验，所以阅读本章时，建议大家自己动手试一试，加深印象。

[11 HashSet、TreeSet 源码解析](https://www.imooc.com/read/47/article/853)[13 差异对比：集合在 Java 7 和 8 有何不同和改进](https://www.imooc.com/read/47/article/855)

精选留言 6

欢迎在这里发表留言，作者筛选后可公开显示

- [风舞炫动](https://www.imooc.com/u/6409329/articles)

  亲手debug完才理解了为什么数组值小于list时，数组值为null。 还有一个问题就是通过Arrays.asList得到的ArrayList其实是Arrays内部自己实现的，跟ArrayList.class 的ArrayList可以理解为没有啥关系对吧。之前一直认为是同一个ArrayList

   0

  回复

  2019-11-20

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[风舞炫动](https://www.imooc.com/u/6409329/articles)

    是的，两个 List 是不同的。

    回复

    2019-11-23 16:41:36

- [Sicimike](https://www.imooc.com/u/3395084/articles)

  public T[] toArray(T[] a)方法有返回值。使用该方法时，即使传入的数组长度小于list长度，返回值也是正确的。

   0

  回复

  2019-11-12

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[Sicimike](https://www.imooc.com/u/3395084/articles)

    同学你理解有误哈，可以 debug 下，如果数组长度小于 list 的实际大小，是无法返回正确的值的哈。

    回复

    2019-11-17 10:50:39

- [慕盖茨4571687](https://www.imooc.com/u/6882674/articles)

  final Object[] elementData = this.elementData; 老师我想问一下 这行代码把list存放的数组赋值给一个临时变量，底下代码一直操作这个临时变量也没操作原来的数组呀？

   0

  回复

  2019-10-17

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[慕盖茨4571687](https://www.imooc.com/u/6882674/articles)

    两者指向的引用都是 ArrayList 的数组哈，所以操作就像操作底层数组一样。

    回复

    2019-10-17 19:07:56

- [Elylic](https://www.imooc.com/u/3417562/articles)

  // 坑1：修改数组的值，会直接影响原 list log.info("数组被修改之前，集合第一个元素为：{}",list.get(0)); array[0] = 10; log.info("数组被修改之前，集合第一个元素为：{}",list.get(0)); 这里第二个log应该是“数组被修改之后”吧！

   0

  回复

  2019-09-19

- [slvayf](https://www.imooc.com/u/2077521/articles)

  老师好，请问学习专栏和网络上其他视频课程的时候，真正高效的学习方式是什么？记笔记的过程重要吗？（感觉很少会回头再看，只有常用的东西会记住，那些已经理解并自己写了demo的，不常用就会慢慢忘掉，只能回想起自己学过）

   3

  回复

  2019-09-18

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[slvayf](https://www.imooc.com/u/2077521/articles)

    你说的很对，不常用的，过段时间就会忘记，所以重复温习很重要哈，你做的笔记正好是你温习的最快简捷，重复温习很重要哈，没有什么捷径的。

    回复

    2019-09-18 20:46:28

- [蜗牛Baby](https://www.imooc.com/u/5639642/articles)

  顶一个，一直在追，老师别停?

   3

  回复

  2019-09-18

 

千学不如一看，千看不如一练

# 13 差异对比：集合在 Java 7 和 8 有何不同和改进

13 差异对比：集合在 Java 7 和 8 有何不同和改进

更新时间：2019-09-19 09:39:16

![img](https://img.mukewang.com/5d80433f0001c03c06400359.jpg)

![img](https://www.imooc.com/static/img/column/bg-l.png)![img](https://www.imooc.com/static/img/column/bg-r.png)

时间像海绵里的水，只要你愿意挤，总还是有的。

——鲁迅

## 引导语

Java 8 在 Java 7 的基础上，做了一些改进和优化，但我们在平时工作中，或者直接升级到 Java 8 的过程中，我们好像无需做任何兼容逻辑，那么 Java 8 底层是如何处理的呢，在改进的同时，是如何优雅兼容 Java 老版本，让使用者无需感知，接下来我们通过对比 Java 7 和 8 的差异，来展示 Java 8 是如何优雅升级的。

## 1 通用区别

## 1.1 所有集合都新增了forEach 方法

List、Set、Map 在 Java 8 版本中都增加了 forEach 的方法，方法的入参是 Consumer，Consumer 是一个函数式接口，可以简单理解成允许一个入参，但没有返回值的函数式接口，我们以 ArrayList 的 forEach 的源码为例，来看下方法是如何实现的 ：

```java
@Override
public void forEach(Consumer<? super E> action) {
  // 判断非空
  Objects.requireNonNull(action);
  // modCount的原始值被拷贝
  final int expectedModCount = modCount;
  final E[] elementData = (E[]) this.elementData;
  final int size = this.size;
  // 每次循环都会判断数组有没有被修改，一旦被修改，停止循环
  for (int i=0; modCount == expectedModCount && i < size; i++) {
    // 执行循环内容，action 代表我们要干的事情
    action.accept(elementData[i]);
  }
  // 数组如果被修改了，抛异常
  if (modCount != expectedModCount) {
    throw new ConcurrentModificationException();
  }
}
```

从这段源码中，很容易产生两个问题：

1、action.accept 到底是个啥？

action.accept 就是你在 for 循环中要干的事情，你可以进行任何事情，比如我们打印一句话，如下：

```java
public void testForEach(){
  List<Integer> list = new ArrayList<Integer>(){{
    add(1);
    add(3);
    add(2);
    add(4);
  }};
  // value 是每次循环的入参，就是 list 中的每个元素
  list.forEach( value->log.info("当前值为：{}",value));
}
输出为：
当前值为：1
当前值为：3
当前值为：2
当前值为：4
```

log.info(“当前值为：{}”,value) 就是我们要干的事情，就是 action。

2.、forEach 方法上打了 @Override 注解，说明该方法是被继承实现的，该方法是被定义在 Iterable 接口上的，Java 7 和 8 的 ArrayList 都实现了该接口，但我们在 Java 7 的 ArrayList 并没有发现有实现该方法，编译器也木有报错，这个主要是因为 Iterable 接口的 forEach 方法被加上了 default 关键字，这个关键字只会出现在接口类中，被该关键字修饰的方法无需强制要求子类继承，但需要自己实现默认实现，我们看下源码：
![图片描述](https://img.mukewang.com/5d70798d00010b6111940364.png)
不仅仅是 forEach 这一个方法是这么干的，List、Set、Map 接口中很多新增的方法都是这么干的，通过 default 关键字，可以让 Java 7 的集合子类无需实现 Java 8 中新增的方法。

如果想在接口中新增一个方法，但又不想子类强制实现该方法时，可以给该方法加上 default 关键字，这个在实际工作中，也经常使用到，算是重构的小技巧吧。

## 1.2 List 区别

### 1.2.1 ArrayList

1. ArrayList 无参初始化时，Java 7 是直接初始化 10 的大小，Java 8 去掉了这个逻辑，初始化时是空数组，在第一次 add 时才开始按照 10 进行扩容，下图是源码的差异对比图：
   ![图片描述](https://img.mukewang.com/5d7079470001ebfd20080254.png)List 其它方面 java7 和 8 并没有改动。

## 1.3 Map 区别

### 1.3.1 HashMap

1. 和 ArrayList 一样，Java 8 中 HashMap 在无参构造器中，丢弃了 Java 7 中直接把数组初始化 16 的做法，而是采用在第一次新增的时候，才开始扩容数组大小；
2. hash 算法计算公式不同，Java 8 的 hash 算法更加简单，代码更加简洁；
3. Java 8 的 HashMap 增加了红黑树的数据结构，这个是 Java 7 中没有的，Java 7 只有数组 + 链表的结构，Java 8 中提出了数组 + 链表 + 红黑树的结构，一般 key 是 Java 的 API 时，比如说 String 这些 hashcode 实现很好的 API，很少出现链表转化成红黑树的情况，因为 String 这些 API 的 hash 算法够好了，只有当 key 是我们自定义的类，而且我们覆写的 hashcode 算法非常糟糕时，才会真正使用到红黑树，提高我们的检索速度。

也是因为 Java 8 新增了红黑树，所以几乎所有操作数组的方法的实现，都发生了变动，比如说 put、remove 等操作，可以说 Java 8 的 HashMap 几乎重写了一遍，所以 Java 7 的很多问题都被 Java 8 解决了，比如扩容时极小概率死锁，丢失数据等等。

1. 新增了一些好用的方法，比如 getOrDefault，我们看下源码，非常简单：

```java
// 如果 key 对应的值不存在，返回期望的默认值 defaultValue
public V getOrDefault(Object key, V defaultValue) {
    Node<K,V> e;
    return (e = getNode(hash(key), key)) == null ? defaultValue : e.value;
}
```

还有 putIfAbsent(K key, V value) 方法，意思是，如果 map 中存在 key 了，那么 value 就不会覆盖，如果不存在 key ，新增成功。

还有 compute 方法，意思是允许我们把 key 和 value 的值进行计算后，再 put 到 map 中，为防止 key 值不存在造成未知错误，map 还提供了 computeIfPresent 方法，表示只有在 key 存在的时候，才执行计算，demo 如下：

```java
  @Test
  public void compute(){
    HashMap<Integer,Integer> map = Maps.newHashMap();
    map.put(10,10);
    log.info("compute 之前值为：{}",map.get(10));
    map.compute(10,(key,value) -> key * value);
    log.info("compute 之后值为：{}",map.get(10));
    // 还原测试值
    map.put(10,10);

    // 如果为 11 的 key 不存在的话，需要注意 value 为空的情况，下面这行代码就会报空指针
    //  map.compute(11,(key,value) -> key * value);
    
    // 为了防止 key 不存在时导致的未知异常，我们一般有两种办法
    // 1：自己判断空指针
    map.compute(11,(key,value) -> null == value ? null : key * value);
    // 2：computeIfPresent 方法里面判断
    map.computeIfPresent(11,(key,value) -> key * value);
    log.info("computeIfPresent 之后值为：{}",map.get(11));
  }
结果是：
compute 之前值为：10
compute 之后值为：100
computeIfPresent 之后值为：null（这个结果中，可以看出，使用 computeIfPresent 避免了空指针）
```

上述 Java 8 新增的几种方法非常好用，在实际工作中，可以大大减少我们的代码量，computeIfPresent 的源码就不贴了，有兴趣可以去 github 上面查看，主要的实现原理如下：

- 找到 key 对应的老值，会分别从数组、链表、红黑树中找；
- 根据 key 和老值进行计算，得到新值；
- 用新值替换掉老值，可能是普通替换、链表替换或红黑树替换。

#### 1.3.2 LinkedHashMap

由于 Java 8 的底层数据有变动，导致 HashMap 操作数据的方法几乎重写，也使 LinkedHashMap 的实现名称上有所差异，原理上都相同，我们看下面的图，左边是 Java 7，右边是 Java 8。
![图片描述](https://img.mukewang.com/5d7078fe0001a6b724721322.png)从图中，我们发现 LinkedHashMap 的方法名有所修改，底层的实现逻辑其实都差不多的。

## 1.4 其他区别

### 1.4.1 Arrays 提供了很多 parallel 开头的方法。

Java 8 的 Arrays 提供了一些 parallel 开头的方法，这些方法支持并行的计算，在数据量大的时候，会充分利用 CPU ，提高计算效率，比如说 parallelSort 方法，方法底层有判断，只有数据量大于 8192 时，才会真正走并行的实现，在实际的实验中，并行计算的确能够快速的提高计算速度。

## 1.5 面试题

1. Java 8 在 List、Map 接口上新增了很多方法，为什么 Java 7 中这些接口的实现者不需要强制实现这些方法呢？

答：主要是因为这些新增的方法被 default 关键字修饰了，default 一旦修饰接口上的方法，我们需要在接口的方法中写默认实现，并且子类无需强制实现这些方法，所以 Java 7 接口的实现者无需感知。

1. Java 8 中有新增很多实用的方法，你在平时工作中有使用过么？

答：有的，比如说 getOrDefault、putIfAbsent、computeIfPresent 方法等等，具体使用细节参考上文。

1. 说说 computeIfPresent 方法的使用姿势？

答：computeIfPresent 是可以对 key 和 value 进行计算后，把计算的结果重新赋值给 key，并且如果 key 不存在时，不会报空指针，会返回 null 值。

1. Java 8 集合新增了 forEach 方法，和普通的 for 循环有啥不同？

答：新增的 forEach 方法的入参是函数式的接口，比如说 Consumer 和 BiConsumer，这样子做的好处就是封装了 for 循环的代码，让使用者只需关注实现每次循环的业务逻辑，简化了重复的 for 循环代码，使代码更加简洁，普通的 for 循环，每次都需要写重复的 for 循环代码，forEach 把这种重复的计算逻辑吃掉了，使用起来更加方便。

1. HashMap 8 和 7 有啥区别？

答：HashMap 8 和 7 的差别太大了，新增了红黑树，修改了底层数据逻辑，修改了 hash 算法，几乎所有底层数组变动的方法都重写了一遍，可以说 Java 8 的 HashMap 几乎重新了一遍。

## 总结

总体来说，List 方面是小改动，HashMap 几乎重写了一套，所有的集合都新增了函数式的方法，比如说 forEach，也新增了很多好用的函数，比如说 getOrDefault，这些函数可以大大减少我们的代码量，让我们把关注点聚焦在业务逻辑的实现上，这其实是一种思想，把繁琐重复的计算逻辑抽取出来，从计算逻辑中扩展出业务逻辑的口子，让使用者只专心关注业务逻辑的实现即可。

想要了解更多差异，也可直接前往 JDK 8 新特性查看，地址为：http://openjdk.java.net/projects/jdk8/features#103。

[12 彰显细节：看集合源码对我们实际工作的帮助和应用](https://www.imooc.com/read/47/article/854)[14 简化工作：Guava Lists Maps 实际工作运用和源码](https://www.imooc.com/read/47/article/856)

精选留言 3

欢迎在这里发表留言，作者筛选后可公开显示

- [和尚码代码](https://www.imooc.com/u/7388288/articles)

  太难了，看完又没了，焦急的等待

   1

  回复

  2019-09-20

- [qq_Ezio_1](https://www.imooc.com/u/4477929/articles)

  老师 这节看到lambda表达式，专栏后期会有java8特性讲解吗

   0

  回复

  2019-09-19

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[qq_Ezio_1](https://www.imooc.com/u/4477929/articles)

    有的，第八章专门说 Lambda，和大家一起如何看 Lambda 的源码和使用。

    回复

    2019-09-20 14:04:02

- [qq_Ezio_1](https://www.imooc.com/u/4477929/articles)

  老师 这个log是哪个包的类。找半天找不到，专栏源码可以共享吗

   0

  回复

  2019-09-19

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[qq_Ezio_1](https://www.imooc.com/u/4477929/articles)

    idea 装一个 lombok 的插件就好了。源码在第三小节有贴出来： 源码解析：https://github.com/luanqiu/java8 文章 demo：https://github.com/luanqiu/java8_demo

    回复

    2019-09-20 14:06:02

  - [qq_Ezio_1](https://www.imooc.com/u/4477929/articles)

    回复

    [文贺](https://www.imooc.com/u/8062574/articles)

    链接打开404.。。。。

    回复

    2019-09-21 16:17:55

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[qq_Ezio_1](https://www.imooc.com/u/4477929/articles)

    没有问题的哈，麻烦你检查下网址输入是否有误哦，可以把 404 的网址贴出来哈。

    回复

    2019-09-22 16:43:52

 

千学不如一看，千看不如一练

 

# 14 简化工作：Guava Lists Maps 实际工作运用和源码

14 简化工作：Guava Lists Maps 实际工作运用和源码

更新时间：2019-09-24 10:32:00

![img](https://img1.mukewang.com/5d80435b0001bcad06400359.jpg)

![img](https://www.imooc.com/static/img/column/bg-l.png)![img](https://www.imooc.com/static/img/column/bg-r.png)

如果不想在世界上虚度一生，那就要学习一辈子。

——高尔基



## 引导语

在日常工作中，我们经常会使用一些三方的 API 来简化我们的工作，Guava 就是其中一种，Guava 是 Google 开源的技术框架，使用率高，社区活跃度也很高。

本小节我们从工作中对 Guava 集合的使用入手，然后深入的看下其底层的实现，最后总结其设计思想，感兴趣的同学也可以下载源码学习，GitHub 地址：https://github.com/google/guava，源码中 guava 的文件夹为其源码。



## 1 运用工厂模式进行初始化

在集合类初始化方面，Guava 比 Java 原生的 API 更加好用，还发明了很多新的功能，比如说在 JDK 7 之前，我们新建集合类时，声明和初始化都必须写上泛型说明，像这样：`List<泛型> list = new ArrayList<泛型>();` ， JDK 7 之后有所改变，我们只需要在声明处写上泛型说明，像这样：`List<泛型> list = new ArrayList<>();`。

Guava 提供了更加方便的使用姿势，采用了工厂模式，把集合创建的逻辑交给了工厂，开发者无需关注工厂底层是如何创建的，只需要关心，工厂能产生什么，代码于是变成了这样：`List<泛型> list = Lists.newArrayList();`，Lists 就是 Guava 提供出来的，方便操作 List 的工具类。

这种写法其实就是一种简单的工厂模式，只需要定义好工厂的入参和出参，就能对外隐藏其内部的创建逻辑，提供更加方便的使用体验。

当然除了 Lists，Guava 还提供了很多其他实用工具，如 Maps、Sets，接下来我们分别来看下这些常用工具的使用和原理。



## 2 Lists



### 2.1 初始化

Lists 最大的功能是能帮助我们进行 List 的初始化，比如我们刚说的 newArrayList 这种：

```java
List<String> list = Lists.newArrayList();
public static <E> ArrayList<E> newArrayList() {
  return new ArrayList<>();
}
// 这种底层是帮助我们写好了泛型，E 代表泛型，表示当前返回的泛型类型和声明的一致即可，在编译的时候，会把泛型 E 转化成我们声明的 String。
```

如果你清楚 List 的大小，我们也可以这样做：

```java
// 可以预估 list 的大小为 20
List<String> list = Lists.newArrayListWithCapacity(20);
// 不太肯定 list 大小是多少，但期望是大小是 20 上下。
List<String> list = Lists.newArrayListWithExpectedSize(20);
```

newArrayListWithCapacity(20) 方法内部实现是：`new ArrayList<>(20);`，而 newArrayListWithExpectedSize 方法内部实现是对 List 大小有一个计算公式的，计算公式为：`5L + arraySize + (arraySize / 10)` ，arraySize 表示传进来的值，公式简化下就是 5 + 11/10 * arraySize，因为这个方法表示期望的大小，所以这里取的约是期望值的十分之十一，比传进来的值约大十分之一，所以根据 20 最终计算出来的值是 27。

Lists 在初始化的时候，还支持传迭代器的入参（只适合小数据量的迭代器的入参），源码如下：

```java
public static <E> ArrayList<E> newArrayList(Iterator<? extends E> elements) {
  ArrayList<E> list = newArrayList();
  // addAll 方法底层其实通过迭代器进行 for 循环添加
  Iterators.addAll(list, elements);
  return list;
}
```

从 Lists 对 List 初始化进行包装的底层源码来看，底层源码非常简单的，但我们还是愿意使用这种方式的包装，主要是因为这种工厂模式的包装，使我们的使用姿势更加优雅，使用起来更加方便。



### 2.2 分组和反转排序

除了初始化之外，Lists 还提供了两个比较实用的功能，分组和反转排序功能，我们分别来演示一下：

```java
// 演示反转排序
public void testReverse(){
  List<String> list = new ArrayList<String>(){{
    add("10");
    add("20");
    add("30");
    add("40");
  }};
  log.info("反转之前："+JSON.toJSONString(list));
  list = Lists.reverse(list);
  log.info("反转之后："+JSON.toJSONString(list));
}
// 打印出来的结果为：
反转之前：["10","20","30","40"]
反转之后：["40","30","20","10"]
```

reverse 方法底层实现非常巧妙，底层覆写了 List 原生的 get(index) 方法，会把传进来的 index 进行 (size - 1) - index 的计算，使计算得到的索引位置和 index 位置正好相反，这样当我们 get 时，数组索引位置的 index 已经是相反的位置了，达到了反转排序的效果，其实底层并没有进行反转排序，只是在计算相反的索引位置，通过计算相反的索引位置这样简单的设计，得到了反转排序的效果，很精妙。

在工作中，有时候我们需要把一个大的 list 进行切分，然后再把每份丢给线程池去运行，最后将每份运行的结果汇总，Lists 工具类就提供了一个对 list 进行切分分组的方法，演示 demo 如下：

```java
// 分组
public void testPartition(){
  List<String> list = new ArrayList<String>(){{
    add("10");
    add("20");
    add("30");
    add("40");
  }};
  log.info("分组之前："+JSON.toJSONString(list));
   List<List<String>> list2 = Lists.partition(list,3);
  log.info("分组之后："+JSON.toJSONString(list2));
}
输出结果为：
分组之前：["10","20","30","40"]
分组之后：[["10","20","30"],["40"]]
```

partition 方法的第二个参数的意思，你想让分组后的 List 包含几个元素，这个方法的底层实现其实就是 subList 方法。

有一点需要我们注意的是这两个方法返回的 List 并不是 ArrayList，是自定义的 List，所以对于 ArrayList 的有些功能可能并不支持，使用的时候最好能看下源码，看看底层有无支持。



### 2.3 小结

Lists 上述的方法大大的方便了我们进行开发，简化了使用姿势，但其内部实现却非常简单巧妙，比如说 reverse 方法可以输出相反排序的 List，但底层并没有实现排序，只是计算了索引位置的相反值而已，这点值得我们学习。



## 3 Maps



### 3.1 初始化

Maps 也是有着各种初始化 Map 的各种方法，原理不说了，和 Lists 类似，我们演示下如何使用：

```java
Map<String,String> hashMap = Maps.newHashMap();
Map<String,String> linkedHashMap = Maps.newLinkedHashMap();
// 这里 Map 的初始化大小公式和 HashSet 初始化公式类似，还记得 HashSet 初始化 HashMap 时，经典的计算初始大小的公式么：取最大值（期望的值 / 0.75 + 1，默认值 16），newHashMapWithExpectedSize 方法底层也是这么算的初始化大小的
Map<String,String> withExpectedSizeHashMap = Maps.newHashMapWithExpectedSize(20);
```



### 3.2 difference

Maps 提供了一个特别有趣也很实用的方法：difference，此方法的目的是比较两个 Map 的差异，入参就是两个 Map，比较之后能够返回四种差异：

1. 左边 Map 独有 key。
2. 右边 Map 独有 key。
3. 左右边 Map 都有 key，并且 value 相等。
4. 左右边 Map 都有 key，但是 value 不等。

我们用代码来演示一下：

```java
// ImmutableMap.of 也是 Guava 提供初始化 Map 的方法，入参格式为 k1,v1,k2,v2,k3,v3……
Map<String,String> leftMap = ImmutableMap.of("1","1","2","2","3","3");
Map<String,String> rightMap = ImmutableMap.of("2","2","3","30","4","4");
MapDifference difference = Maps.difference(leftMap, rightMap);
log.info("左边 map 独有 key：{}",difference.entriesOnlyOnLeft());
log.info("右边 map 独有 key：{}",difference.entriesOnlyOnRight());
log.info("左右边 map 都有 key，并且 value 相等：{}",difference.entriesInCommon());
log.info("左右边 map 都有 key，但 value 不等：{}",difference.entriesDiffering());
最后打印结果为：
左边 map 独有 key：{1=1}
右边 map 独有 key：{4=4}
左右边 map 都有 key，并且 value 相等：{2=2}
左右边 map 都有 key，但 value 不等：{3=(3, 30)}
```

从这个 demo 我们可以看到此方法的强大威力，我们在工作中经常遇到 Map 或者 List 间比较差异的任务，我们就可以直接使用该方法进行对比，List 可以先转化成 Map。

而且 difference 底层的实现也算是最优的实现了，只需要循环一遍，就可得到上述四种差异结果，源码解析如下：

```java
// 对比两个 map 的差异
private static <K, V> void doDifference(
    Map<? extends K, ? extends V> left,
    Map<? extends K, ? extends V> right,
    Equivalence<? super V> valueEquivalence,
    // key 只在左边 map 出现
    Map<K, V> onlyOnLeft,
    // key 只在右边 map 出现，调用 doDifference 方法前已经包含了全部右边的值
    Map<K, V> onlyOnRight,
    // key 在左右 map 中都出现过，并且 value 都相等
    Map<K, V> onBoth,
    // key 在左右 map 中都出现过，但 value 不等
    Map<K, MapDifference.ValueDifference<V>> differences) {
  // 以左边 map 为基准进行循环
  for (Entry<? extends K, ? extends V> entry : left.entrySet()) {
    K leftKey = entry.getKey();
    V leftValue = entry.getValue();
    // 右边 map 包含左边的 key
    if (right.containsKey(leftKey)) {
      // onlyOnRight 已经包含全部右边的值 所以需要删除当前 key
      V rightValue = onlyOnRight.remove(leftKey);
      // key 相等，并且 value 值也相等
      if (valueEquivalence.equivalent(leftValue, rightValue)) {
        onBoth.put(leftKey, leftValue);
      // key 相等，但 value 值不等
      } else {
        differences.put(leftKey, ValueDifferenceImpl.create(leftValue, rightValue));
      }
    // 右边 map 不包含左边的 key，就是左边 map 独有的 key
    } else {
      onlyOnLeft.put(leftKey, leftValue);
    }
  }
}
```

这是一种比较优秀的，快速比对的算法，可以好好看下上面的源码，然后把这种算法背下来，或者自己再次实现一次。

Sets 的使用方式和 Lists 和 Maps 很类似，没有太大的亮点，我们就不说了。



## 4 总结

这一小节主要都是实战内容，在实际工作中可以用起来。

在 Guava 对集合的设计中，有两个大点是非常值得我们学习的：

1. Lists、Maps 的出现给我们提供了更方便的使用姿势和方法，我们在实际工作中，如果碰到特别繁琐，或者特别难用的 API，我们也可以进行一些包装，使更好用，这个是属于在解决目前的痛点的问题上进行创新，是非常值得提倡的一件事情，往往可以帮助你拿到更好的绩效。
2. 如果有人问你，List 或者 Map 高效的差异排序算法，完全可以参考 Maps.difference 的内部实现，该方法只使用了一次循环，就可得到所有的相同或不同结果，这种算法在我们工作中也经常被使用。

了解更多，可以直接前往 Guava 的代码库查看：https://github.com/google/guava

[13 差异对比：集合在 Java 7 和 8 有何不同和改进](https://www.imooc.com/read/47/article/855)[15 CopyOnWriteArrayList 源码解析和设计思路](https://www.imooc.com/read/47/article/857)

精选留言 2

欢迎在这里发表留言，作者筛选后可公开显示

- [南门祥老大](https://www.imooc.com/u/7918623/articles)

  不错不错

   0

  回复

  2019-12-09

- [937587592](https://www.imooc.com/u/135874/articles)

  讲解的很好，简明扼要！！

   0

  回复

  2019-12-03

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[937587592](https://www.imooc.com/u/135874/articles)

    同学你好，感谢点评。

    回复

    2019-12-08 13:53:26

 

千学不如一看，千看不如一练