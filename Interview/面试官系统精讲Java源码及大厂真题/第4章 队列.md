**第4章 队列**第4章 队列

- 19 LinkedBlockingQueue 源码解析
- 20 SynchronousQueue 源码解析
- 21 DelayQueue 源码解析
- 22 ArrayBlockingQueue 源码解析
- 23 队列在源码方面的面试题
- 24 举一反三：队列在 Java 其它源码中的应用
- 25 整体设计：队列设计思想、工作中使用场景
- 26 惊叹面试官：由浅入深手写队列

第4章 队列

# 19 LinkedBlockingQueue 源码解析

19 LinkedBlockingQueue 源码解析

更新时间：2019-10-11 17:02:21

![img](https://img2.mukewang.com/5d91984400013fbc06400359.jpg)

![img](https://www.imooc.com/static/img/column/bg-l.png)![img](https://www.imooc.com/static/img/column/bg-r.png)

从不浪费时间的人，没有工夫抱怨时间不够。

——杰弗逊



## 引导语

说到队列，大家的反应可能是我从来都没有用过，应该是不重要的 API 吧。如果这么想，那就大错特错了，我们平时使用到的线程池、读写锁、消息队列等等技术和框架，底层原理都是队列，所以我们万万不可轻视队列，队列是很多高级 API 的基础，学好队列，对自己深入 Java 学习非常重要。

本文主要以 LinkedBlockingQueue 队列为例，详细描述一下底层具体的实现。



## 1 整体架构

LinkedBlockingQueue 中文叫做链表阻塞队列，这个命名很好，从命名上就知道其底层数据结构是链表，并且队列是可阻塞的。接下来，我们就从整体结构上看看 LinkedBlockingQueue。



### 1.1 类图

首先我们来看下 LinkedBlockingQueue 类图，如下：
![图片描述](https://img.mukewang.com/5d9db50c00011ed210740736.png)从类图中，我们大概可以看出两条路径：

1. AbstractQueue -> AbstractCollection -> Collection ->Iterable 这条路径依赖，主要是想复用 Collection 和 迭代器的一些操作，这些我们在说集合的时候，都知道这些类是干什么，能干什么，就不细说了；
2. BlockingQueue -> Queue -> Collection，BlockingQueue 和 Queue 是新出来的两个接口，我们重点说一下。

Queue 是最基础的接口，几乎所有的队列实现类都会实现这个接口，该接口定义出了队列的三大类操作：

新增操作：

1. add 队列满的时候抛出异常；
2. offer 队列满的时候返回 false。

查看并删除操作：

1. remove 队列空的时候抛异常；
2. poll 队列空的时候返回 null。

只查看不删除操作：

1. element 队列空的时候抛异常；
2. peek 队列空的时候返回 null。

一共 6 种方法，除了以上分类方法，也可以分成两类：

1. 遇到队列满或空的时候，抛异常，如 add、remove、element；
2. 遇到队列满或空的时候，返回特殊值，如 offer、poll、peek。

实际上，这些都比较难记忆。每次需要使用的时候，我都会看会源码，才能想起这个方法是抛异常还是返回特殊值。

BlockingQueue 在 Queue 的基础上加上了阻塞的概念，比如一直阻塞，还是阻塞一段时间。为了方便记忆，我们画一个表格，如下：

|                         | 抛异常  | 特殊值           | 一直阻塞 | 阻塞一段时间               |
| :---------------------- | :------ | :--------------- | :------- | :------------------------- |
| 新增操作–队列满         | add     | offer 返回 false | put      | offer 过超时时间返回 false |
| 查看并删除操作–队列空   | remove  | poll 返回 null   | take     | poll 过超时时间返回 null   |
| 只查看不删除操作–队列空 | element | peek 返回 null   | 暂无     | 暂无                       |

PS: remove 方法，BlockingQueue 类注释中定义的是抛异常，但 LinkedBlockingQueue 中 remove 方法实际是返回 false。
从表格中可以看到，在新增和查看并删除两大类操作上，BlockingQueue 增加了阻塞的功能，而且可以选择一直阻塞，或者阻塞一段时间后，返回特殊值。



### 1.2 类注释

我们看看从 LinkedBlockingQueue 的类注释中能得到那些信息：

1. 基于链表的阻塞队列，其底层的数据结构是链表；
2. 链表维护先入先出队列，新元素被放在队尾，获取元素从队头部拿；
3. 链表大小在初始化的时候可以设置，默认是 Integer 的最大值；
4. 可以使用 Collection 和 Iterator 两个接口的所有操作，因为实现了两者的接口。



### 1.3 内部构成

LinkedBlockingQueue 内部构成简单来说，分成三个部分：链表存储 + 锁 + 迭代器，我们来看下源码。

```java
// 链表结构 begin
//链表的元素
static class Node<E> {
    E item;

    //当前元素的下一个，为空表示当前节点是最后一个
    Node<E> next;

    Node(E x) { item = x; }
}

//链表的容量，默认 Integer.MAX_VALUE
private final int capacity;

//链表已有元素大小，使用 AtomicInteger，所以是线程安全的
private final AtomicInteger count = new AtomicInteger();

//链表头
transient Node<E> head;

//链表尾
private transient Node<E> last;
// 链表结构 end

// 锁 begin
//take 时的锁
private final ReentrantLock takeLock = new ReentrantLock();

// take 的条件队列，condition 可以简单理解为基于 ASQ 同步机制建立的条件队列
private final Condition notEmpty = takeLock.newCondition();

// put 时的锁，设计两把锁的目的，主要为了 take 和 put 可以同时进行
private final ReentrantLock putLock = new ReentrantLock();

// put 的条件队列
private final Condition notFull = putLock.newCondition();
// 锁 end

// 迭代器 
// 实现了自己的迭代器
private class Itr implements Iterator<E> {
………………
}
```

从代码上来看，结构是非常清晰的，三种结构各司其职：

1. 链表的作用是为了保存当前节点，节点中的数据可以是任意东西，是一个泛型，比如说队列被应用到线程池时，节点就是线程，比如队列被应用到消息队列中，节点就是消息，节点的含义主要看队列被使用的场景；
2. 锁有 take 锁和 put 锁，是为了保证队列操作时的线程安全，设计两种锁，是为了 take 和 put 两种操作可以同时进行，互不影响。



### 1.4 初始化

初始化有三种方式：

1. 指定链表容量大小；
2. 不指定链表容量大小，默认是 Integer 的最大值；
3. 对已有集合数据进行初始化。

源码如下：

```java
// 不指定容量，默认 Integer 的最大值
public LinkedBlockingQueue() {
    this(Integer.MAX_VALUE);
}
// 指定链表容量大小，链表头尾相等，节点值（item）都是 null
public LinkedBlockingQueue(int capacity) {
    if (capacity <= 0) throw new IllegalArgumentException();
    this.capacity = capacity;
    last = head = new Node<E>(null);
}

// 已有集合数据进行初始化
public LinkedBlockingQueue(Collection<? extends E> c) {
    this(Integer.MAX_VALUE);
    final ReentrantLock putLock = this.putLock;
    putLock.lock(); // Never contended, but necessary for visibility
    try {
        int n = 0;
        for (E e : c) {
            // 集合内的元素不能为空
            if (e == null)
                throw new NullPointerException();
            // capacity 代表链表的大小，在这里是 Integer 的最大值
            // 如果集合类的大小大于 Integer 的最大值，就会报错
            // 其实这个判断完全可以放在 for 循环外面，这样可以减少 Integer 的最大值次循环(最坏情况)
            if (n == capacity)
                throw new IllegalStateException("Queue full");
            enqueue(new Node<E>(e));
            ++n;
        }
        count.set(n);
    } finally {
        putLock.unlock();
    }
}
```

对于初始化源码，我们说明两点：

1. 初始化时，容量大小是不会影响性能的，只影响在后面的使用，因为初始化队列太小，容易导致没有放多少就会报队列已满的错误；
2. 在对给定集合数据进行初始化时，源码给了一个不优雅的示范，我们不反对在每次 for 循环的时候，都去检查当前链表的大小是否超过容量，但我们希望在 for 循环开始之前就做一步这样的工作。举个列子，给定集合大小是 1 w，链表大小是 9k，按照现在代码实现，只能在 for 循环 9k 次时才能发现，原来给定集合的大小已经大于链表大小了，导致 9k 次循环都是在浪费资源，还不如在 for 循环之前就 check 一次，如果 1w > 9k，直接报错即可。



## 2 阻塞新增

新增有多种方法，如：add、put、offer，三者的区别上文有说。我们拿 put 方法为例，put 方法在碰到队列满的时候，会一直阻塞下去，直到队列不满时，并且自己被唤醒时，才会继续去执行，源码如下：

```java
// 把e新增到队列的尾部。
// 如果有可以新增的空间的话，直接新增成功，否则当前线程陷入等待
public void put(E e) throws InterruptedException {
    // e 为空，抛出异常
    if (e == null) throw new NullPointerException();
    // 预先设置 c 为 -1，约定负数为新增失败
    int c = -1;
    Node<E> node = new Node<E>(e);
    final ReentrantLock putLock = this.putLock;
    final AtomicInteger count = this.count;
    // 设置可中断锁
    putLock.lockInterruptibly();
    try {
        // 队列满了
        // 当前线程阻塞，等待其他线程的唤醒(其他线程 take 成功后就会唤醒此处被阻塞的线程)
        while (count.get() == capacity) {
            // await 无限等待
            notFull.await();
        }

        // 队列没有满，直接新增到队列的尾部
        enqueue(node);

        // 新增计数赋值,注意这里 getAndIncrement 返回的是旧值
        // 这里的 c 是比真实的 count 小 1 的
        c = count.getAndIncrement();

        // 如果链表现在的大小 小于链表的容量，说明队列未满
        // 可以尝试唤醒一个 put 的等待线程
        if (c + 1 < capacity)
            notFull.signal();

    } finally {
        // 释放锁
        putLock.unlock();
    }
    // c==0，代表队列里面有一个元素
    // 会尝试唤醒一个take的等待线程
    if (c == 0)
        signalNotEmpty();
}
// 入队，把新元素放到队尾
private void enqueue(Node<E> node) {
    last = last.next = node;
}
```

从源码中我们可以总结以下几点：

1. 往队列新增数据，第一步是上锁，所以新增数据是线程安全的；
2. 队列新增数据，简单的追加到链表的尾部即可；
3. 新增时，如果队列满了，当前线程是会被阻塞的，阻塞的底层使用是锁的能力，底层实现其它也和队列相关，原理我们在锁章节会说到；
4. 新增数据成功后，在适当时机，会唤起 put 的等待线程（队列不满时），或者 take 的等待线程（队列不为空时），这样保证队列一旦满足 put 或者 take 条件时，立马就能唤起阻塞线程，继续运行，保证了唤起的时机不被浪费。

以上就是 put 方法的原理，至于 offer 方法阻塞超过一端时间后，仍未成功，就会直接返回默认值的实现，和 put 方法相比只修改了几行代码，如下截图：

![图片描述](https://img.mukewang.com/5d9db53e000110c724481374.png)



## 3 阻塞删除

删除的方法也很多，我们主要看两个关键问题：

1. 删除的原理是怎样的；
2. 查看并删除和只查看不删除两种的区别是如何实现的。

首先我们来看第一个问题，我们以 take 方法为例，说明一下查看并删除的底层源码：

```java
// 阻塞拿数据
public E take() throws InterruptedException {
    E x;
    // 默认负数，代表失败
    int c = -1;
    // count 代表当前链表数据的真实大小
    final AtomicInteger count = this.count;
    final ReentrantLock takeLock = this.takeLock;
    takeLock.lockInterruptibly();
    try {
        // 空队列时，阻塞，等待其他线程唤醒
        while (count.get() == 0) {
            notEmpty.await();
        }
        // 非空队列，从队列的头部拿一个出来
        x = dequeue();
        // 减一计算，注意 getAndDecrement 返回的值是旧值
        // c 比真实的 count 大1
        c = count.getAndDecrement();
        
        // 如果队列里面有值，从 take 的等待线程里面唤醒一个。
        // 意思是队列里面有值啦,唤醒之前被阻塞的线程
        if (c > 1)
            notEmpty.signal();
    } finally {
        // 释放锁
        takeLock.unlock();
    }
    // 如果队列空闲还剩下一个，尝试从 put 的等待线程中唤醒一个
    if (c == capacity)
        signalNotFull();
    return x;
}
// 队头中取数据
private E dequeue() {
    Node<E> h = head;
    Node<E> first = h.next;
    h.next = h; // help GC
    head = first;
    E x = first.item;
    first.item = null;// 头节点指向 null，删除
    return x;
}
```

整体流程和 put 很相似，都是先上锁，然后从队列的头部拿出数据，如果队列为空，会一直阻塞到队列有值为止。

而查看不删除元素更加简单，直接把队列头的数据拿出来即可，我们以 peek 为例，源码如下：

```java
// 查看并不删除元素，如果队列为空，返回 null
public E peek() {
    // count 代表队列实际大小，队列为空，直接返回 null
    if (count.get() == 0)
        return null;
    final ReentrantLock takeLock = this.takeLock;
    takeLock.lock();
    try {
        // 拿到队列头
        Node<E> first = head.next;
        // 判断队列头是否为空，并返回
        if (first == null)
            return null;
        else
            return first.item;
    } finally {
        takeLock.unlock();
    }
}
```

可以看出，查看并删除，和查看不删除两者从队头拿数据的逻辑不太一致，从而导致一个会删除，一个不会删除队头数据。



## 4 总结

本文通过 LinkedBlockingQueue 的源码，来介绍了下链表队列，当队列满和空的场景下，新增和删除数据时，队列有啥变化。

队列本身就是一个阻塞工具，我们可以把这个工具应用到各种阻塞场景中，比如说队列应用到线程池，当线程池跑满时，我们把新的请求都放到阻塞队列中等待；队列应用到消息队列，当消费者处理能力有限时，我们可以把消息放到队列中等待，让消费者慢慢消费；每应用到一个新的场景中，都是一个新的技术工具，所以学好队列，用处很大。

[18 场景集合：并发 List、Map的应用场景](https://www.imooc.com/read/47/article/860)[20 SynchronousQueue 源码解析](https://www.imooc.com/read/47/article/862)

精选留言 10

欢迎在这里发表留言，作者筛选后可公开显示

- [慕粉2311555628](https://www.imooc.com/u/5072744/articles)

  // c==0，代表队列里面有一个元素 // 会尝试唤醒一个take的等待线程 if (c == 0) signalNotEmpty(); } 老师，你好，对这段代码不是很理解，为什么要到只剩下一个才去唤醒take线程，不应该是if(c>=0) 么，还有下面的 删除逻辑 要到c==capacity 才去唤醒put线程 ，这是为什么啊

   0

  回复

  2020-01-20

- [记住没有](https://www.imooc.com/u/2307261/articles)

  老师h.next = h; 这行代码是让h节点脱离链表，如果h.next=null的话，是不是就相当把first设置为null,后面就代码就会报错。

   0

  回复

  2020-01-10

- [慕村6418685](https://www.imooc.com/u/8135530/articles)

  老师开一门视频课吧，专门讲java源码

   3

  回复

  2019-12-26

- [慕尼黑7546459](https://www.imooc.com/u/5289346/articles)

  老师，关于出队方法dequeue()的 h.next = h; // help GC 这行代码，为什么不能h.next = null，自己查了下，网上解释说是为了区分是被task了还是队列已结束，但是还是不太理解，麻烦老师帮解释一下，谢谢![🙏](https://www.imooc.com/static/moco/v1.0/images/face/36x36/1f64f.png)

   0

  回复

  2019-12-06

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[慕尼黑7546459](https://www.imooc.com/u/5289346/articles)

    同学你好，h.next = h 主要使 h 节点被孤立，和链表没有任何引用关系，dequeue 方法的倒数第二行 first.item = null，这个就是使 h 的 item 变为 null，帮助回收。因为h 是在链表中，所有需要操作这两步。h.next = null 是不行的，这样做的话，后面的代码会报空指针哈。

    回复

    2019-12-08 13:09:20

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[慕尼黑7546459](https://www.imooc.com/u/5289346/articles)

    你可以在 h.next = h 这一行 debug 一下，然后再 watch 里面使 h.next = null。

    回复

    2019-12-08 13:09:57

- [qq_Ezio_1](https://www.imooc.com/u/4477929/articles)

  老师 之前那个微信交流群我没进

   0

  回复

  2019-11-08

  - [初一](https://www.imooc.com/u/7789740/articles)

    回复[qq_Ezio_1](https://www.imooc.com/u/4477929/articles)

    你先加我微信吧 any97501，我邀请你进微信群。

    回复

    2019-11-08 11:08:20

- [student19](https://www.imooc.com/u/4491380/articles)

  队列在多节点项目不适合吧，只能是单节点项目吧，实际项目用的不多吧

   0

  回复

  2019-11-05

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[student19](https://www.imooc.com/u/4491380/articles)

    多节点项目指的是？队列实际工作中还是有一些场景可以用的，我们在 25 中有说，平时简单业务开发中的确用的不多，因为需要用的地方，JDK 底层线程池，锁，公司的中间件都帮我包装好了。

    回复

    2019-11-07 10:50:11

- [煮沧海](https://www.imooc.com/u/8087757/articles)

  老师，有个小疑惑没理解透，希望得到您的提示下。 删除头结点并返回调用dequeue()方法，删除first节点的方法难道不是将first.next = head.next吗，为什么将first.item = null就表示删除了？

   0

  回复

  2019-10-31

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[煮沧海](https://www.imooc.com/u/8087757/articles)

    // 取出头节点 Node h = head; // 头节点的下一个节点为 first Node first = h.next; // 使 h 的下一个节点指向自己 h.next = h; // help GC // 给链表头赋值 head = first; // 取出链表头值 E x = first.item; // 旧头节点指向 null，帮助 GC first.item = null; // 返回旧头节点值 return x; 整个方法是这样的，我加了注释，你在看看哈

    回复

    2019-10-31 19:46:24

  - [煮沧海](https://www.imooc.com/u/8087757/articles)

    回复

    [文贺](https://www.imooc.com/u/8062574/articles)

    老师你看，问题就出现了。 一开始链表： head.. first.. last。 然后head. next =head，变成了 head.. head.. first.. last。head从指向first变成指向head，但是后面那个head的next还是指向first啊。我理解的这里是不是欠缺了什么？ 然后head =first，变成了first.. head.. first.. last。 最后取出first头，最后置为Null。 老师求指教，感激不尽。

    回复

    2019-10-31 20:35:58

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[煮沧海](https://www.imooc.com/u/8087757/articles)

    同学你好，变成head..head..first..tail这里就不对了，是没有两个head的，的确能看出你比较纠结，我也经历过和你一样的阶段，有两种办法1：拿出纸笔画一画，2：尝试 debug 一下，如果你只是看的话，估计会很晕，帮你写好了 debug的代码，你跟 take 方法进去看看： LinkedBlockingQueue queue = new LinkedBlockingQueue(2); queue.add("nihao"); queue.add("nihao2"); String s = (String) queue.take(); System.out.println(s);

    回复

    2019-11-04 10:31:46

- [玩名堂s](https://www.imooc.com/u/2005934/articles)

  put方法中: while (count.get() == capacity) { // await 无限等待 notFull.await(); } 这里的检查是否“满”的操作为什么是while不是if呢?

   1

  回复

  2019-10-19

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[玩名堂s](https://www.imooc.com/u/2005934/articles)

    同学你好，在队列满的情况下，代码会在 notFull.await() 这一行阻塞住，如果有其他线程从队列中拿数据了，此时队列被唤醒，是从 notFull.await() 这行代码处被唤醒，接着继续执行，这时会再次走 while 循环，再次校验队列是不是满的，如果不是满的，就会继续往下走。 写 while 不写 if 的原因，就在于再次校验队列是不是满的，因为 Java 线程在很小几率下会虚假唤醒，假如此时 Java 线程被虚假唤醒，再次走 while 循环就能被校验住，个人理解哈。

    回复

    2019-10-21 22:18:13

- [慕码人6169125](https://www.imooc.com/u/6612138/articles)

  Java8里面remove方法返回的是Boolean类型，源码里面写的。最上面的表格这个地方写错了

   0

  回复

  2019-10-11

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[慕码人6169125](https://www.imooc.com/u/6612138/articles)

    同学你好，感谢提醒，已加了一个 PS，看 BlockingQueue 类注释画的表格，没注意 LinkedBlockingQueue 的实现不同，已在表格下加了备注。

    回复

    2019-10-11 17:09:09

- [慕设计5408150](https://www.imooc.com/u/6947751/articles)

  老师我们源码的github是什么

   0

  回复

  2019-10-10

  - [初一](https://www.imooc.com/u/7789740/articles)

    回复[慕设计5408150](https://www.imooc.com/u/6947751/articles)

    源码解析：https://github.com/luanqiu/java8 文章 demo：https://github.com/luanqiu/java8_demo

    回复

    2019-10-11 09:56:04

 

千学不如一看，千看不如一练

# 20 SynchronousQueue 源码解析

20 SynchronousQueue 源码解析

更新时间：2019-10-15 11:19:50

![img](https://img.mukewang.com/5da483310001d01f06400359.jpg)

![img](https://www.imooc.com/static/img/column/bg-l.png)![img](https://www.imooc.com/static/img/column/bg-r.png)

只有在那崎岖的小路上不畏艰险奋勇攀登的人,才有希望达到光辉的顶点。

——马克思



## 引导语

SynchronousQueue 是比较独特的队列，其本身是没有容量大小，比如我放一个数据到队列中，我是不能够立马返回的，我必须等待别人把我放进去的数据消费掉了，才能够返回。SynchronousQueue 在消息队列技术中间件中被大量使用，本文就来从底层实现来看下 SynchronousQueue 到底是如何做到的。



## 1 整体架构

SynchronousQueue 的整体设计比较抽象，在内部抽象出了两种算法实现，一种是先入先出的队列，一种是后入先出的堆栈，两种算法被两个内部类实现，而直接对外的 put，take 方法的实现就非常简单，都是直接调用两个内部类的 transfer 方法进行实现，整体的调用关系如下图所示：

![图片描述](https://img.mukewang.com/5da53a4a0001ce6924601406.png)



### 1.1 类注释

源码的类注释往往能给我带来很多疑问和有用的信息，我们来看下类注释都说了什么：

1. 队列不存储数据，所以没有大小，也无法迭代；
2. 插入操作的返回必须等待另一个线程完成对应数据的删除操作，反之亦然；
3. 队列由两种数据结构组成，分别是后入先出的堆栈和先入先出的队列，堆栈是非公平的，队列是公平的。

看到类注释，大家是不是有一些疑问，比如第二点是如何做到的？堆栈又是如何实现的呢？接下来我们一点一点揭晓。



### 1.2 类图

SynchronousQueue 整体类图和 LinkedBlockingQueue 相似，都是实现了 BlockingQueue 接口，但因为其不储存数据结构，有一些方法是没有实现的，比如说 isEmpty、size、contains、remove 和迭代等方法，这些方法都是默认实现，如下截图：

![图片描述](https://img.mukewang.com/5da53a3e0001e3c213841432.png)



### 1.3 结构细节

SynchronousQueue 底层结构和其它队列完全不同，有着独特的两种数据结构：队列和堆栈，我们一起来看下数据结构：

```java
    // 堆栈和队列共同的接口
    // 负责执行 put or take
    abstract static class Transferer<E> {
        // e 为空的，会直接返回特殊值，不为空会传递给消费者
        // timed 为 true，说明会有超时时间
        abstract E transfer(E e, boolean timed, long nanos);
    }

    // 堆栈 后入先出 非公平
    // Scherer-Scott 算法
    static final class TransferStack<E> extends Transferer<E> {
    }

    // 队列 先入先出 公平
    static final class TransferQueue<E> extends Transferer<E> {
    }

    private transient volatile Transferer<E> transferer;

    // 无参构造器默认为非公平的
    public SynchronousQueue(boolean fair) {
        transferer = fair ? new TransferQueue<E>() : new TransferStack<E>();
    }
```

从源码中我们可以得到几点：

1. 堆栈和队列都有一个共同的接口，叫做 Transferer，该接口有个方法：transfer，该方法很神奇，会承担 take 和 put 的双重功能；
2. 在我们初始化的时候，是可以选择是使用堆栈还是队列的，如果你不选择，默认的就是堆栈，类注释中也说明了这一点，堆栈的效率比队列更高。

接下来我们来看下堆栈和队列的具体实现。



## 2 非公平的堆栈



### 2.1 堆栈的结构

首先我们来介绍下堆栈的整体结构，如下：

![图片描述](https://img.mukewang.com/5da53a31000147a007280674.png)

从上图中我们可以看到，我们有一个大的堆栈池，池的开口叫做堆栈头，put 的时候，就往堆栈池中放数据。take 的时候，就从堆栈池中拿数据，两者操作都是在堆栈头上操作数据，从图中可以看到，越靠近堆栈头，数据越新，所以每次 take 的时候，都会拿到堆栈头的最新数据，这就是我们说的后入先出，也就是非公平的。

图中 SNode 就是源码中栈元素的表示，我们看下源码：

```java
static final class SNode {
    // 栈的下一个，就是被当前栈压在下面的栈元素
    volatile SNode next;
    // 节点匹配，用来判断阻塞栈元素能被唤醒的时机
    // 比如我们先执行 take，此时队列中没有数据，take 被阻塞了，栈元素为 SNode1
    // 当有 put 操作时，会把当前 put 的栈元素赋值给 SNode1 的 match 属性，并唤醒 take 操作
    // 当 take 被唤醒，发现 SNode1 的 match 属性有值时，就能拿到 put 进来的数据，从而返回
    volatile SNode match;
    // 栈元素的阻塞是通过线程阻塞来实现的，waiter 为阻塞的线程
    volatile Thread waiter;
    // 未投递的消息，或者未消费的消息
    Object item;             
} 
```



### 2.2 入栈和出栈

入栈指的是使用 put 等方法，把数据放到堆栈池中，出栈指的使用 take 等方法，把数据从堆栈池中拿出来，操作的对象都是堆栈头，虽然两者的一个是从堆栈头拿数据，一个是放数据，但底层实现的方法却是同一个，源码如下：

```java
// transfer 方法思路比较复杂，因为 take 和 put 两个方法都揉在了一起
@SuppressWarnings("unchecked")
E transfer(E e, boolean timed, long nanos) {
    SNode s = null; // constructed/reused as needed
    // e 为空，说明是 take 方法，不为空是 put 方法
    int mode = (e == null) ? REQUEST : DATA;
    // 自旋
    for (;;) {
        // 拿出头节点，有几种情况
        // 1：头节点为空，说明队列中还没有数据
        // 2：头节点不为空，并且是 take 类型的，说明头节点线程正等着拿数据。
        // 3：头节点不为空，并且是 put 类型的，说明头节点线程正等着放数据。
        SNode h = head;
        // 栈头为空，说明队列中还没有数据。
        // 栈头不为空，并且栈头的类型和本次操作一致，比如都是 put，那么就把
        // 本次 put 操作放到该栈头的前面即可，让本次 put 能够先执行
        if (h == null || h.mode == mode) {  // empty or same-mode
            // 设置了超时时间，并且 e 进栈或者出栈要超时了，
            // 就会丢弃本次操作，返回 null 值。
            // 如果栈头此时被取消了，丢弃栈头，取下一个节点继续消费
            if (timed && nanos <= 0) {      // can't wait
                // 栈头操作被取消
                if (h != null && h.isCancelled())
                    // 丢弃栈头，把栈头后一个元素作为栈头
                    casHead(h, h.next);     // pop cancelled node
                //栈头是空的，直接返回 null
                else
                    return null;
            // 没有超时，直接把 e 作为新的栈头
            } else if (casHead(h, s = snode(s, e, h, mode))) {
                // e 等待出栈，一种是空队列 take，一种是 put
                SNode m = awaitFulfill(s, timed, nanos);
                if (m == s) {               // wait was cancelled
                    clean(s);
                    return null;
                }
                // 本来 s 是栈头的，现在 s 不是栈头了，s 后面又来了一个数，把新的数据作为栈头
                if ((h = head) != null && h.next == s)
                    casHead(h, s.next);     // help s's fulfiller
                return (E) ((mode == REQUEST) ? m.item : s.item);
            }
        // 栈头正在等待其他线程 put 或 take
        // 比如栈头正在阻塞，并且是 put 类型，而此次操作正好是 take 类型，走此处
        } else if (!isFulfilling(h.mode)) { // try to fulfill
            // 栈头已经被取消，把下一个元素作为栈头
            if (h.isCancelled())            // already cancelled
                casHead(h, h.next);         // pop and retry
            // snode 方法第三个参数 h 代表栈头，赋值给 s 的 next 属性
            else if (casHead(h, s=snode(s, e, h, FULFILLING|mode))) {
                for (;;) { // loop until matched or waiters disappear
                    // m 就是栈头，通过上面 snode 方法刚刚赋值
                    SNode m = s.next;       // m is s's match
                    if (m == null) {        // all waiters are gone
                        casHead(s, null);   // pop fulfill node
                        s = null;           // use new node next time
                        break;              // restart main loop
                    }
                    SNode mn = m.next;
                     // tryMatch 非常重要的方法，两个作用：
                     // 1 唤醒被阻塞的栈头 m，2 把当前节点 s 赋值给 m 的 match 属性
                     // 这样栈头 m 被唤醒时，就能从 m.match 中得到本次操作 s
                     // 其中 s.item 记录着本次的操作节点，也就是记录本次操作的数据
                    if (m.tryMatch(s)) {
                        casHead(s, mn);     // pop both s and m
                        return (E) ((mode == REQUEST) ? m.item : s.item);
                    } else                  // lost match
                        s.casNext(m, mn);   // help unlink
                }
            }
        } else {                            // help a fulfiller
            SNode m = h.next;               // m is h's match
            if (m == null)                  // waiter is gone
                casHead(h, null);           // pop fulfilling node
            else {
                SNode mn = m.next;
                if (m.tryMatch(h))          // help match
                    casHead(h, mn);         // pop both h and m
                else                        // lost match
                    h.casNext(m, mn);       // help unlink
            }
        }
    }
}
```

从源码中密密麻麻的注释，我们就可以看出来此方法比较复杂，我们总结一下大概的操作思路：

1. 判断是 put 方法还是 take 方法；
2. 判断栈头数据是否为空，如果为空或者栈头的操作和本次操作一致，是的话走 3，否则走 5；
3. 判断操作有无设置超时时间，如果设置了超时时间并且已经超时，返回 null，否则走 4；
4. 如果栈头为空，把当前操作设置成栈头，或者栈头不为空，但栈头的操作和本次操作相同，也把当前操作设置成栈头，并看看其它线程能否满足自己，不能满足则阻塞自己。比如当前操作是 take，但队列中没有数据，则阻塞自己；
5. 如果栈头已经是阻塞住的，需要别人唤醒的，判断当前操作能否唤醒栈头，可以唤醒走 6，否则走 4；
6. 把自己当作一个节点，赋值到栈头的 match 属性上，并唤醒栈头节点；
7. 栈头被唤醒后，拿到 match 属性，就是把自己唤醒的节点的信息，返回。

在整个过程中，有一个节点阻塞的方法，实现原理如下：

```java
SNode awaitFulfill(SNode s, boolean timed, long nanos) {
    // deadline 死亡时间，如果设置了超时时间的话，死亡时间等于当前时间 + 超时时间，否则就是 0
    final long deadline = timed ? System.nanoTime() + nanos : 0L;
    Thread w = Thread.currentThread();
    // 自旋的次数，如果设置了超时时间，会自旋 32 次，否则自旋 512 次。
    // 比如本次操作是 take 操作，自选次数后，仍没有其他线程 put 数据进来
    // 就会阻塞，有超时时间的，会阻塞固定的时间，否则一致阻塞下去
    int spins = (shouldSpin(s) ?
                 (timed ? maxTimedSpins : maxUntimedSpins) : 0);
    for (;;) {
        // 当前线程有无被打断，如果过了超时时间，当前线程就会被打断
        if (w.isInterrupted())
            s.tryCancel();

        SNode m = s.match;
        if (m != null)
            return m;
        if (timed) {
            nanos = deadline - System.nanoTime();
            // 超时了，取消当前线程的等待操作
            if (nanos <= 0L) {
                s.tryCancel();
                continue;
            }
        }
        // 自选次数减少 1
        if (spins > 0)
            spins = shouldSpin(s) ? (spins-1) : 0;
        // 把当前线程设置成 waiter，主要是通过线程来完成阻塞和唤醒
        else if (s.waiter == null)
            s.waiter = w; // establish waiter so can park next iter
        else if (!timed)
            // 通过 park 进行阻塞，这个我们在锁章节中会说明
            LockSupport.park(this);
        else if (nanos > spinForTimeoutThreshold)
            LockSupport.parkNanos(this, nanos);
    }
}
```

从节点阻塞代码中，我们可以发现，其阻塞的策略，并不是一上来就阻塞住，而是在自旋一定次数后，仍然没有其它线程来满足自己的要求时，才会真正的阻塞住。



## 3 公平的队列

首先我们来看一下队列中的每个元素的组成：

```java
/** 队列头 */
transient volatile QNode head;
/** 队列尾 */
transient volatile QNode tail;

// 队列的元素
static final class QNode {
    // 当前元素的下一个元素
    volatile QNode next;         
    // 当前元素的值，如果当前元素被阻塞住了，等其他线程来唤醒自己时，其他线程
    // 会把自己 set 到 item 里面
    volatile Object item;         // CAS'ed to or from null
    // 可以阻塞住的当前线程
    volatile Thread waiter;       // to control park/unpark
    // true 是 put，false 是 take
    final boolean isData;
}  
```

公平的队列主要使用的是 TransferQueue 内部类的 transfer 方法，我们一起来看下源码：

```java
E transfer(E e, boolean timed, long nanos) {

    QNode s = null; // constructed/reused as needed
    // true 是 put，false 是 get
    boolean isData = (e != null);

    for (;;) {
        // 队列头和尾的临时变量,队列是空的时候，t=h
        QNode t = tail;
        QNode h = head;
        // tail 和 head 没有初始化时，无限循环
        // 虽然这种 continue 非常耗cpu，但感觉不会碰到这种情况
        // 因为 tail 和 head 在 TransferQueue 初始化的时候，就已经被赋值空节点了
        if (t == null || h == null)
            continue;
        // 首尾节点相同，说明是空队列
        // 或者尾节点的操作和当前节点操作一致
        if (h == t || t.isData == isData) {
            QNode tn = t.next;
            // 当 t 不是 tail 时，说明 tail 已经被修改过了
            // 因为 tail 没有被修改的情况下，t 和 tail 必然相等
            // 因为前面刚刚执行赋值操作： t = tail
            if (t != tail)
                continue;
            // 队尾后面的值还不为空，t 还不是队尾，直接把 tn 赋值给 t，这是一步加强校验。
            if (tn != null) {
                advanceTail(t, tn);
                continue;
            }
            //超时直接返回 null
            if (timed && nanos <= 0)        // can't wait
                return null;
            //构造node节点
            if (s == null)
                s = new QNode(e, isData);
            //如果把 e 放到队尾失败，继续递归放进去
            if (!t.casNext(null, s))        // failed to link in
                continue;

            advanceTail(t, s);              // swing tail and wait
            // 阻塞住自己
            Object x = awaitFulfill(s, e, timed, nanos);
            if (x == s) {                   // wait was cancelled
                clean(t, s);
                return null;
            }

            if (!s.isOffList()) {           // not already unlinked
                advanceHead(t, s);          // unlink if head
                if (x != null)              // and forget fields
                    s.item = s;
                s.waiter = null;
            }
            return (x != null) ? (E)x : e;
        // 队列不为空，并且当前操作和队尾不一致
        // 也就是说当前操作是队尾是对应的操作
        // 比如说队尾是因为 take 被阻塞的，那么当前操作必然是 put
        } else {                            // complementary-mode
            // 如果是第一次执行，此处的 m 代表就是 tail
            // 也就是这行代码体现出队列的公平，每次操作时，从头开始按照顺序进行操作
            QNode m = h.next;               // node to fulfill
            if (t != tail || m == null || h != head)
                continue;                   // inconsistent read

            Object x = m.item;
            if (isData == (x != null) ||    // m already fulfilled
                x == m ||                   // m cancelled
                // m 代表栈头
                // 这里把当前的操作值赋值给阻塞住的 m 的 item 属性
                // 这样 m 被释放时，就可得到此次操作的值
                !m.casItem(x, e)) {         // lost CAS
                advanceHead(h, m);          // dequeue and retry
                continue;
            }
            // 当前操作放到队头
            advanceHead(h, m);              // successfully fulfilled
            // 释放队头阻塞节点
            LockSupport.unpark(m.waiter);
            return (x != null) ? (E)x : e;
        }
    }
}
```

源码比较复杂，我们需要搞清楚的是，线程被阻塞住后，当前线程是如何把自己的数据传给阻塞线程的。为了方便说明，我们假设线程 1 往队列中 take 数据 ，被阻塞住了，变成阻塞线程 A ，然后线程 2 开始往队列中 put 数据 B，大致的流程是这样的：

1. 线程 1 从队列中拿数据，发现队列中没有数据，于是被阻塞，成为 A ；
2. 线程 2 往队尾 put 数据，会从队尾往前找到第一个被阻塞的节点，假设此时能找到的就是节点 A，然后线程 B 把将 put 的数据放到节点 A 的 item 属性里面，并唤醒线程 1；
3. 线程 1 被唤醒后，就能从 A.item 里面拿到线程 2 put 的数据了，线程 1 成功返回。

从这个过程中，我们能看出公平主要体现在，每次 put 数据的时候，都 put 到队尾上，而每次拿数据时，并不是直接从堆头拿数据，而是从队尾往前寻找第一个被阻塞的线程，这样就会按照顺序释放被阻塞的线程。



## 4 总结

SynchronousQueue 源码比较复杂，建议大家进行源码的 debug 来学习源码，为大家准备了调试类：SynchronousQueueDemo，大家可以下载源码自己调试一下，这样学起来应该会更加轻松一点。

[19 LinkedBlockingQueue 源码解析](https://www.imooc.com/read/47/article/861)[21 DelayQueue 源码解析](https://www.imooc.com/read/47/article/863)

精选留言 8

欢迎在这里发表留言，作者筛选后可公开显示

- [Sivel](https://www.imooc.com/u/5230667/articles)

  具体怎么理解自旋

   0

  回复

  2019-12-25

- [慕粉1127139674](https://www.imooc.com/u/5039812/articles)

  老师 这个SynchronousQueue的debug demo在哪里？？？

   0

  回复

  2019-12-21

- [所相虚妄](https://www.imooc.com/u/7839242/articles)

  老师能不能说一下，这个数据都应用场景是啥？

   0

  回复

  2019-12-09

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[所相虚妄](https://www.imooc.com/u/7839242/articles)

    消息中间件中会用到，消息中间件为了保证消息可以快速的推送给消费者，一般会采用推拉两种模式，推就是服务端把消息推送给客户端，拉就是客户端主动的向服务端拉取数据，在拉的过程中，如果服务端没有数据，拉的请求会一直等待，一直等到服务端有数据后立马返回，这个拉的原理和 SynchronousQueue 就很相似

    回复

    2019-12-16 17:57:20

- [慕粉1150563265](https://www.imooc.com/u/4872901/articles)

  是有容量大小的吧，只不过他的同步机制，促使线程，需要同步等待。等待的线程会保存到队列或者堆栈中

   0

  回复

  2019-11-29

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[慕粉1150563265](https://www.imooc.com/u/4872901/articles)

    没有容量大小，size() 方法返回的永远是 0

    回复

    2019-11-30 13:07:09

- [为了angular耻辱上线](https://www.imooc.com/u/6958824/articles)

  怎么感觉总结transfer方法的那一段写错了···

   1

  回复

  2019-11-29

- [大LOVE辉](https://www.imooc.com/u/2851044/articles)

  老师,好像和源码不太一样,源码比较麻烦...

   1

  回复

  2019-11-27

- [慕斯卡0137221](https://www.imooc.com/u/7803551/articles)

  总结之前的话得重新梳理下吧，尤其是线程和节点两个之间的关系，感觉有点乱啊

   2

  回复

  2019-11-22

- [licly](https://www.imooc.com/u/8096709/articles)

  老师，transfer方法中，else if (!isFulfilling(h.mode)) --> else if (casHead(h, s=snode(s, e, h, FULFILLING|mode))) --> for死循环中，if (m == null)这种情况什么时候会发生呀，感觉走到这一步，应该不是空的，有点懵，SynchronousQueue这个类太难理解了

   0

  回复

  2019-10-18

 

千学不如一看，千看不如一练

# 21 DelayQueue 源码解析

21 DelayQueue 源码解析

更新时间：2019-10-17 10:46:05

![img](https://img.mukewang.com/5da48351000134cb06400359.jpg)

![img](https://www.imooc.com/static/img/column/bg-l.png)![img](https://www.imooc.com/static/img/column/bg-r.png)

如果不想在世界上虚度一生，那就要学习一辈子。

——高尔基



## 引导语

之前我们说的阻塞队列，都是资源足够时立马执行。本章我们说的队列比较特殊，是一种延迟队列，意思是延迟执行，并且可以设置延迟多久之后执行，比如设置过 5 秒钟之后再执行，在一些延迟执行的场景被大量使用，比如说延迟对账等等。



## 1 整体设计

DelayQueue 延迟队列底层使用的是锁的能力，比如说要在当前时间往后延迟 5 秒执行，那么当前线程就会沉睡 5 秒，等 5 秒后线程被唤醒时，如果能获取到资源的话，线程即可立马执行。原理上似乎很简单，但内部实现却很复杂，有很多难点，比如当运行资源不够，多个线程同时被唤醒时，如何排队等待？比如说在何时阻塞？何时开始执行等等？接下来我们从源码角度来看下是如何实现的。



### 1.1 类注释

类注释上比较简单，只说了三个概念：

1. 队列中元素将在过期时被执行，越靠近队头，越早过期；
2. 未过期的元素不能够被 take；
3. 不允许空元素。

这三个概念，其实就是三个问题，下文我们会一一看下这三点是如何实现的。



### 1.2 类图

DelayQueue 的类图和之前的队列一样，不多说，关键是 DelayQueue 类上是有泛型的，如下：

```java
public class DelayQueue<E extends Delayed> extends AbstractQueue<E>
    implements BlockingQueue<E> {
```

从泛型中可以看出，DelayQueue 中的元素必须是 Delayed 的子类，Delayed 是表达延迟能力的关键接口，其继承了 Comparable 接口，并定义了还剩多久过期的方法，如下：

```java
public interface Delayed extends Comparable<Delayed> {
    long getDelay(TimeUnit unit);
}
```

也就是说 DelayQueue 队列中的元素必须是实现 Delayed 接口和 Comparable 接口的，并覆写了 getDelay 方法和 compareTo 的方法才行，不然在编译时，编译器就会提醒我们元素必须强制实现 Delayed 接口。

除此之外 DelayQueue 还大量使用了 PriorityQueue 队列的大量功能，这个和 SynchronousQueue 队列很像，大量复用了其它基础类的逻辑，代码示例如下：

![图片描述](https://img.mukewang.com/5da56dcc0001306c13701376.png)PriorityQueue 中文叫做优先级队列，在此处的作用就是可以根据过期时间做优先级排序，让先过期的可以先执行，用来实现类注释中的第一点。

这里的复用的思想还是蛮重要的，我们在源码中经常会遇到这种思想，比如说 LinkedHashMap 复用 HashMap 的能力，Set 复用 Map 的能力，还有此处的 DelayQueue 复用 PriorityQueue 的能力。小结一下，如果想要复用需要做到哪些：

1. 需要把能遇见可复用的功能尽量抽象，并开放出可扩展的地方，比如说 HashMap 在操作数组的方法中，都给 LinkedHashMap 开放出很多 after 开头的方法，便于 LinkedHashMap 进行排序、删除等等；
2. 采用组合或继承两种手段进行复用，比如 LinkedHashMap 采用的继承、 Set 和 DelayQueue 采用的组合，组合的意思就是把可复用的类给依赖进来。



## 2 演示

为了方便大家理解，写了一个演示的 demo，演示了一下：

```java
public class DelayQueueDemo {
	// 队列消息的生产者
  static class Product implements Runnable {
    private final BlockingQueue queue;
    public Product(BlockingQueue queue) {
      this.queue = queue;
    }
    
    @Override
    public void run() {
      try {
        log.info("begin put");
        long beginTime = System.currentTimeMillis();
        queue.put(new DelayedDTO(System.currentTimeMillis() + 2000L,beginTime));//延迟 2 秒执行
        queue.put(new DelayedDTO(System.currentTimeMillis() + 5000L,beginTime));//延迟 5 秒执行
        queue.put(new DelayedDTO(System.currentTimeMillis() + 1000L * 10,beginTime));//延迟 10 秒执行
        log.info("end put");
      } catch (InterruptedException e) {
        log.error("" + e);
      }
    }
  }
	// 队列的消费者
  static class Consumer implements Runnable {
    private final BlockingQueue queue;
    public Consumer(BlockingQueue queue) {
      this.queue = queue;
    }

    @Override
    public void run() {
      try {
        log.info("Consumer begin");
        ((DelayedDTO) queue.take()).run();
        ((DelayedDTO) queue.take()).run();
        ((DelayedDTO) queue.take()).run();
        log.info("Consumer end");
      } catch (InterruptedException e) {
        log.error("" + e);
      }
    }
  }

  @Data
  // 队列元素，实现了 Delayed 接口
  static class DelayedDTO implements Delayed {
    Long s;
    Long beginTime;
    public DelayedDTO(Long s,Long beginTime) {
      this.s = s;
      this.beginTime =beginTime;
    }

    @Override
    public long getDelay(TimeUnit unit) {
      return unit.convert(s - System.currentTimeMillis(), TimeUnit.MILLISECONDS);
    }

    @Override
    public int compareTo(Delayed o) {
      return (int) (this.getDelay(TimeUnit.MILLISECONDS) - o.getDelay(TimeUnit.MILLISECONDS));
    }

    public void run(){
      log.info("现在已经过了{}秒钟",(System.currentTimeMillis() - beginTime)/1000);
    }
  }
	// demo 运行入口
  public static void main(String[] args) throws InterruptedException {
    BlockingQueue q = new DelayQueue();
    DelayQueueDemo.Product p = new DelayQueueDemo.Product(q);
    DelayQueueDemo.Consumer c = new DelayQueueDemo.Consumer(q);
    new Thread(c).start();
    new Thread(p).start();
  }
}
打印出来的结果如下：
06:57:50.544 [Thread-0] Consumer begin
06:57:50.544 [Thread-1] begin put
06:57:50.551 [Thread-1] end put
06:57:52.554 [Thread-0] 延迟了2秒钟才执行
06:57:55.555 [Thread-0] 延迟了5秒钟才执行
06:58:00.555 [Thread-0] 延迟了10秒钟才执行
06:58:00.556 [Thread-0] Consumer end
```

写这个代码的目的主要想演示一下延迟执行的例子，我们大概的思路是：

1. 新建队列的元素，如 DelayedDTO，必须实现 Delayed 接口，我们在 getDelay 方法中实现了现在离过期时间还剩多久的方法。
2. 定义队列元素的生产者，和消费者，对应着代码中的 Product 和 Consumer。
3. 对生产者和消费者就行初始化和管理，对应着我们的 main 方法。

虽然这只是一个简单的 demo，但实际工作中，我们使用 DelayQueue 基本上就是这种思想，只不过写代码的时候会更加通用和周全，接下来我们来看下 DelayQueue 是如何实现 put 和 take 的。



## 3 放数据

我们以 put 为例，put 调用的是 offer 的方法，offer 的源码如下：

```java
public boolean offer(E e) {
    final ReentrantLock lock = this.lock;
    // 上锁
    lock.lock();
    try {
        // 使用 PriorityQueue 的扩容，排序等能力
        q.offer(e);
        // 如果恰好刚放进去的元素正好在队列头
        // 立马唤醒 take 的阻塞线程，执行 take 操作
        // 如果元素需要延迟执行的话，可以使其更快的沉睡计时
        if (q.peek() == e) {
            leader = null;
            available.signal();
        }
        return true;
    } finally {
        // 释放锁
        lock.unlock();
    }
}
```

可以看到其实底层使用到的是 PriorityQueue 的 offer 方法，我们来看下：

```java
// 新增元素
public boolean offer(E e) {
    // 如果是空元素的话，抛异常
    if (e == null)
        throw new NullPointerException();
    modCount++;
    int i = size;
    // 队列实际大小大于容量时，进行扩容
    // 扩容策略是：如果老容量小于 64，2 倍扩容，如果大于 64，50 % 扩容
    if (i >= queue.length)
        grow(i + 1);
    size = i + 1;
    // 如果队列为空，当前元素正好处于队头
    if (i == 0)
        queue[0] = e;
    else
    // 如果队列不为空，需要根据优先级进行排序
        siftUp(i, e);
    return true;
}
// 按照从小到大的顺序排列
    private void siftUpComparable(int k, E x) {
        Comparable<? super E> key = (Comparable<? super E>) x;
        // k 是当前队列实际大小的位置
        while (k > 0) {
            // 对 k 进行减倍
            int parent = (k - 1) >>> 1;
            Object e = queue[parent];
            // 如果 x 比 e 大，退出，把 x 放在 k 位置上
            if (key.compareTo((E) e) >= 0)
                break;
            // x 比 e 小，继续循环，直到找到 x 比队列中元素大的位置
            queue[k] = e;
            k = parent;
        }
        queue[k] = key;
    }
```

可以看到，PriorityQueue 的 offer 方法主要做了三件事情：

1. 对新增元素进行判空；
2. 对队列进行扩容，扩容策略和集合的扩容策略很相近；
3. 根据元素的 compareTo 方法进行排序，我们希望最终排序的结果是从小到大的，因为我们想让队头的都是过期的数据，我们需要在 compareTo 方法里面实现：通过每个元素的过期时间进行排序，如下：

```java
(int) (this.getDelay(TimeUnit.MILLISECONDS) - o.getDelay(TimeUnit.MILLISECONDS));
```

这样便可实现越快过期的元素越能排到队头。

可以看到，新增数据时，只是使用到了 compareTo 方法，来对队列中的元素进行排序，接下来我们看下，取数据时，是如何操作的。



## 4 拿数据

取数据时，如果发现有元素的过期时间到了，就能拿出数据来，如果没有过期元素，那么线程就会一直阻塞，我们以 take 为例子，来看一下核心源码：

```java
for (;;) {
    // 从队头中拿数据出来
    E first = q.peek();
    // 如果为空，说明队列中，没有数据，阻塞住
    if (first == null)
        available.await();
    else {
        // 获取队头数据的过期时间
        long delay = first.getDelay(NANOSECONDS);
        // 如果过期了，直接返回队头数据
        if (delay <= 0)
            return q.poll();
        // 引用置为 null ，便于 gc，这样可以让线程等待时，回收 first 变量
        first = null;
        // leader 不为空的话，表示当前队列元素之前已经被设置过阻塞时间了
        // 直接阻塞当前线程等待。
        if (leader != null)
            available.await();
        else {
          // 之前没有设置过阻塞时间，按照一定的时间进行阻塞
            Thread thisThread = Thread.currentThread();
            leader = thisThread;
            try {
                // 进行阻塞
                available.awaitNanos(delay);
            } finally {
                if (leader == thisThread)
                    leader = null;
            }
        }
    }
}
```

可以看到阻塞等待的功能底层使用的是锁的能力，这个我们在后面章节中会说到。

以上演示的 take 方法是会无限阻塞，直到队头的过期时间到了才会返回，如果不想无限阻塞，可以尝试 poll 方法，设置超时时间，在超时时间内，队头元素还没有过期的话，就会返回 null。



## 5 总结

DelayQueue 是非常有意思的队列，底层使用了排序和超时阻塞实现了延迟队列，排序使用的是 PriorityQueue 排序能力，超时阻塞使用得是锁的等待能力，可以看出 DelayQueue 其实就是为了满足延迟执行的场景，在已有 API 的基础上进行了封装，我们在工作中，可以学习这种思想，对已有的功能能复用的尽量复用，减少开发的工作量。

[20 SynchronousQueue 源码解析](https://www.imooc.com/read/47/article/862)[22 ArrayBlockingQueue 源码解析](https://www.imooc.com/read/47/article/864)

精选留言 1

欢迎在这里发表留言，作者筛选后可公开显示

- [慕盖茨4571687](https://www.imooc.com/u/6882674/articles)

  对key减倍应该怎么理解

   0

  回复

  2019-11-06

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[慕盖茨4571687](https://www.imooc.com/u/6882674/articles)

    同学你好，可以简单理解成二分查找法

    回复

    2019-11-07 10:47:44

 

千学不如一看，千看不如一练

 

# 22 ArrayBlockingQueue 源码解析

22 ArrayBlockingQueue 源码解析

更新时间：2019-11-07 10:48:29

![img](https://img3.mukewang.com/5da483730001b51b06400359.jpg)

![img](https://www.imooc.com/static/img/column/bg-l.png)![img](https://www.imooc.com/static/img/column/bg-r.png)

耐心和恒心总会得到报酬的。

——爱因斯坦



### 引导语

本小节我们来介绍本章最后一个队列：ArrayBlockingQueue。按照字面翻译，中文叫做数组阻塞队列，从名称上看，我们就比较清楚此阻塞队列底层使用的是数组。一说到数组，大家可能会想到 ArrayList 和 HashMap，举新增场景来说 ArrayList 通过 size ++ 找到新增的数组下标位置，HashMap 通过 hash 算法计算出下标位置，那么 ArrayBlockingQueue 是不是也是这两种方法呢？都不是，ArrayBlockingQueue 使用的是一种非常奇妙的方式，我们一起拭目以待。

全文为了方便说明，队头的说法就是数组头，队尾的说法就是数组尾。



### 1 整体架构

我们从类注释上可以得到一些有用的信息：

#### 1.1 类注释

1. 有界的阻塞数组，容量一旦创建，后续大小无法修改；
2. 元素是有顺序的，按照先入先出进行排序，从队尾插入数据数据，从队头拿数据；
3. 队列满时，往队列中 put 数据会被阻塞，队列空时，往队列中拿数据也会被阻塞。

从类注释上可以看出 ArrayBlockingQueue 和一般的数组结构的类不太一样，是不能够动态扩容的，如果队列满了或者空时，take 和 put 都会被阻塞。



### 1.2 数据结构

```java
// 队列存放在 object 的数组里面
// 数组大小必须在初始化的时候手动设置，没有默认大小
final Object[] items;

// 下次拿数据的时候的索引位置
int takeIndex;

// 下次放数据的索引位置
int putIndex;

// 当前已有元素的大小
int count;

// 可重入的锁
final ReentrantLock lock;

// take的队列
private final Condition notEmpty;

// put的队列
private final Condition notFull;
```

以上代码有两个关键的字段，takeIndex 和 putIndex，分别表示下次拿数据和放数据的索引位置。所以说在新增数据和拿数据时，都无需计算，就能知道应该新增到什么位置，应该从什么位置拿数据。



### 2 初始化

初始化时，有两个重要的参数：数组的大小、是否是公平，源码如下：

```java
public ArrayBlockingQueue(int capacity, boolean fair) {
    if (capacity <= 0)
        throw new IllegalArgumentException();
    this.items = new Object[capacity];
    lock = new ReentrantLock(fair);
    // 队列不为空 Condition，在 put 成功时使用
    notEmpty = lock.newCondition();
    // 队列不满 Condition，在 take 成功时使用
    notFull =  lock.newCondition();
}
```

从源码中我们可以看出，第二个参数是否公平，主要用于读写锁是否公平，如果是公平锁，那么在锁竞争时，就会按照先来先到的顺序，如果是非公平锁，锁竞争时随机的。

对于锁公平和非公平，我们举个例子：比如说现在队列是满的，还有很多线程执行 put 操作，必然会有很多线程阻塞等待，当有其它线程执行 take 时，会唤醒等待的线程，如果是公平锁，会按照阻塞等待的先后顺序，依次唤醒阻塞的线程，如果是非公平锁，会随机唤醒沉睡的线程。

所以说队列满很多线程执行 put 操作时，如果是公平锁，数组元素新增的顺序就是阻塞线程被释放的先后顺序，是有顺序的，而非公平锁，由于阻塞线程被释放的顺序是随机的，所以元素插入到数组的顺序也就不会按照插入的顺序了。

队列空时，也是一样的道理。

ArrayBlockingQueue 通过锁的公平和非公平，轻松实现了数组元素的插入顺序的问题。如果要实现这个功能，你会怎么做呢？会想到利用锁的功能么？其实这种思想我们在文中多次提到，当我们需要完成一件事情时，首先看看已有的 API 能不能满足，如果可以的话，通过继承和组合的方式来实现，ArrayBlockingQueue 就是组合了锁的功能。

初始化时，如果给定了原始数据的话，一定要注意原始数据的大小一定要小于队列的容量，否则会抛异常，如下图所示：

![图片描述](https://img.mukewang.com/5da9962c0001338b13541200.png)
我们写了一个 demo，报错如下：

![图片描述](https://img.mukewang.com/5da9963b00018d9022401200.png)



### 3 新增数据

数据新增都会按照 putIndex 的位置进行新增，源码如下：

```java
// 新增，如果队列满，无限阻塞
public void put(E e) throws InterruptedException {
    // 元素不能为空
    checkNotNull(e);
    final ReentrantLock lock = this.lock;
    lock.lockInterruptibly();
    try {
        // 队列如果是满的，就无限等待
        // 一直等待队列中有数据被拿走时，自己被唤醒
        while (count == items.length)
            notFull.await();
        enqueue(e);
    } finally {
        lock.unlock();
    }
}

private void enqueue(E x) {
    // assert lock.getHoldCount() == 1; 同一时刻只能一个线程进行操作此方法
    // assert items[putIndex] == null;
    final Object[] items = this.items;
    // putIndex 为本次插入的位置
    items[putIndex] = x;
    // ++ putIndex 计算下次插入的位置
    // 如果下次插入的位置，正好等于队尾，下次插入就从 0 开始
    if (++putIndex == items.length)
        putIndex = 0;
    count++;
    // 唤醒因为队列空导致的等待线程
    notEmpty.signal();
}
```

从源码中，我们可以看出，其实新增就两种情况：

1. 本次新增的位置居中，直接新增，下图演示的是 putIndex 在数组下标为 5 的位置，还不到队尾，那么可以直接新增，计算下次新增的位置应该是 6；
   ![图片描述](https://img.mukewang.com/5da996520001b78412100296.png)
2. 新增的位置到队尾了，那么下次新增时就要从头开始了，示意图如下：
   ![图片描述](https://img.mukewang.com/5dc385f60001236510260354.png)

上面这张图演示的就是这行代码：`if (++putIndex == items.length) putIndex = 0;`

可以看到当新增到队尾时，下次新增会重新从队头重新开始。



### 4 拿数据

拿数据都是从队头开始拿数据，源码如下：

```java
public E take() throws InterruptedException {
    final ReentrantLock lock = this.lock;
    lock.lockInterruptibly();
    try {
        // 如果队列为空，无限等待
        // 直到队列中有数据被 put 后，自己被唤醒
        while (count == 0)
            notEmpty.await();
        // 从队列中拿数据
        return dequeue();
    } finally {
        lock.unlock();
    }
}

private E dequeue() {
    final Object[] items = this.items;
    // takeIndex 代表本次拿数据的位置，是上一次拿数据时计算好的
    E x = (E) items[takeIndex];
    // 帮助 gc
    items[takeIndex] = null;
    // ++ takeIndex 计算下次拿数据的位置
    // 如果正好等于队尾的话，下次就从 0 开始拿数据
    if (++takeIndex == items.length)
        takeIndex = 0;
    // 队列实际大小减 1
    count--;
    if (itrs != null)
        itrs.elementDequeued();
    // 唤醒被队列满所阻塞的线程
    notFull.signal();
    return x;
}
```

从源码中可以看出，每次拿数据的位置就是 takeIndex 的位置，在找到本次该拿的数据之后，会把 takeIndex 加 1，计算下次拿数据时的索引位置，有个特殊情况是，如果本次拿数据的位置已经是队尾了，那么下次拿数据的位置就要从头开始，就是从 0 开始了。



### 5 删除数据

删除数据很有意思，我们一起来看下核心源码：

```java
// 一共有两种情况：
// 1：删除位置和 takeIndex 的关系：删除位置和 takeIndex 一样，比如 takeIndex 是 2， 而要删除的位置正好也是 2，那么就把位置 2 的数据置为 null ,并重新计算 takeIndex 为 3。
// 2：找到要删除元素的下一个，计算删除元素和 putIndex 的关系
// 如果下一个元素不是 putIndex，就把下一个元素往前移动一位
// 如果下一个元素是 putIndex，把 putIndex 的值修改成删除的位置
void removeAt(final int removeIndex) {
    final Object[] items = this.items;
    // 情况1 如果删除位置正好等于下次要拿数据的位置
    if (removeIndex == takeIndex) {
        // 下次要拿数据的位置直接置空
        items[takeIndex] = null;
        // 要拿数据的位置往后移动一位
        if (++takeIndex == items.length)
            takeIndex = 0;
        // 当前数组的大小减一
        count--;
        if (itrs != null)
            itrs.elementDequeued();
    // 情况 2
    } else {
        final int putIndex = this.putIndex;
        for (int i = removeIndex;;) {
            // 找到要删除元素的下一个
            int next = i + 1;
            if (next == items.length)
                next = 0;
            // 下一个元素不是 putIndex
            if (next != putIndex) {
                // 下一个元素往前移动一位
                items[i] = items[next];
                i = next;
            // 下一个元素是 putIndex
            } else {
                // 删除元素
                items[i] = null;
                // 下次放元素时，应该从本次删除的元素放
                this.putIndex = i;
                break;
            }
        }
        count--;
        if (itrs != null)
            itrs.removedAt(removeIndex);
    }
    notFull.signal();
}
```

删除数据的情况比较复杂，一共有两种情况，第一种情况是 takeIndex == removeIndex，我们画个示意图来看下处理方式：

![图片描述](https://img.mukewang.com/5da9967c0001f1a112600970.png)
第二种情况又分两种：

1. 如果 removeIndex + 1 != putIndex 的话，就把下一个元素往前移动一位，示意图如下：
   ![图片描述](https://img.mukewang.com/5da996880001782712280958.png)
2. 如果 removeIndex + 1 == putIndex 的话，就把 putIndex 的值修改成删除的位置，示意图如下：

![图片描述](https://img.mukewang.com/5da9969c0001254d12300940.png)

ArrayBlockingQueue 的删除方法其实还蛮复杂的，需要考虑到很多特殊的场景。



### 6 总结

ArrayBlockingQueue 底层是有界的数组，整体来说，和其它队列差别不多，需要注意的是，当 takeIndex、putIndex 到队尾的时候，都会重新从 0 开始循环，这点是比较特殊的，在我们学习源码时，需要特别注意。

[21 DelayQueue 源码解析](https://www.imooc.com/read/47/article/863)[23 队列在源码方面的面试题](https://www.imooc.com/read/47/article/865)

精选留言 3

欢迎在这里发表留言，作者筛选后可公开显示

- [Sicimike](https://www.imooc.com/u/3395084/articles)

  老师，我两个疑问。 第一个是构造方法ArrayBlockingQueue(int capacity, boolean fair, Collection<? extends E> c)中有一行注释“Lock only for visibility, not mutual exclusion”（第282行）是说ReentrantLock可以保证可见性吗？但是happens-before原则中的lock原则不是仅仅指synchronized吗？ 第二个是removeAt方法为什么不用加锁？

   0

  回复

  2019-12-09

- [北京_鲁班七号](https://www.imooc.com/u/5556647/articles)

  老师你好，这可不可以理解为ArrayBlockingQueue是一种循环队列，通过维护队首、队尾的指针，来优化插入、删除，从而使时间复杂度为O(1)

   0

  回复

  2019-11-29

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[北京_鲁班七号](https://www.imooc.com/u/5556647/articles)

    是的，主要是因为有 takeIndex，putIndex，removeIndex 三个变量在维护位置

    回复

    2019-11-30 12:54:05

- [慕粉3445147](https://www.imooc.com/u/3445147/articles)

  新增数据章节.."唤醒因为队列空,所以等待的线程"错别字hhh

   0

  回复

  2019-11-06

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[慕粉3445147](https://www.imooc.com/u/3445147/articles)

    谢谢，已收到，语句可能不好理解，已经更改描述了

    回复

    2019-11-17 10:56:02

 

千学不如一看，千看不如一练

 

# 23 队列在源码方面的面试题

23 队列在源码方面的面试题

更新时间：2019-10-22 10:29:12

![img](https://img1.mukewang.com/5dae691a0001a05206400359.jpg)

![img](https://www.imooc.com/static/img/column/bg-l.png)![img](https://www.imooc.com/static/img/column/bg-r.png)

人要有毅力，否则将一事无成。

——居里夫人

## 引导语

队列在源码方面的面试题，一般面试官会从锁，线程池等知识点作为问题入口，慢慢的问到队列，由于锁、线程池咱们还没有学习到，所以本章就直奔主题，从队列入手，看看队列都有哪些面试题（队列种类很多，本文在说队列的通用特征时，都是在说其大部分队列的通用特征，如有某种队列特征不符，不在一一说明）。

## 1 面试题

### 1.1 说说你对队列的理解，队列和集合的区别。

答：对队列的理解：

1. 首先队列本身也是个容器，底层也会有不同的数据结构，比如 LinkedBlockingQueue 是底层是链表结构，所以可以维持先入先出的顺序，比如 DelayQueue 底层可以是队列或堆栈，所以可以保证先入先出，或者先入后出的顺序等等，底层的数据结构不同，也造成了操作实现不同；
2. 部分队列（比如 LinkedBlockingQueue ）提供了暂时存储的功能，我们可以往队列里面放数据，同时也可以从队列里面拿数据，两者可以同时进行；
3. 队列把生产数据的一方和消费数据的一方进行解耦，生产者只管生产，消费者只管消费，两者之间没有必然联系，队列就像生产者和消费者之间的数据通道一样，如 LinkedBlockingQueue；
4. 队列还可以对消费者和生产者进行管理，比如队列满了，有生产者还在不停投递数据时，队列可以使生产者阻塞住，让其不再能投递，比如队列空时，有消费者过来拿数据时，队列可以让消费者 hodler 住，等有数据时，唤醒消费者，让消费者拿数据返回，如 ArrayBlockingQueue；
5. 队列还提供阻塞的功能，比如我们从队列拿数据，但队列中没有数据时，线程会一直阻塞到队列有数据可拿时才返回。

队列和集合的区别：

1. 和集合的相同点，队列（部分例外）和集合都提供了数据存储的功能，底层的储存数据结构是有些相似的，比如说 LinkedBlockingQueue 和 LinkedHashMap 底层都使用的是链表，ArrayBlockingQueue 和 ArrayList 底层使用的都是数组。

2. 和集合的区别：

   2.1 部分队列和部分集合底层的存储结构很相似的，但两者为了完成不同的事情，提供的 API 和其底层的操作实现是不同的。

   2.2 队列提供了阻塞的功能，能对消费者和生产者进行简单的管理，队列空时，会阻塞消费者，有其他线程进行 put 操作后，会唤醒阻塞的消费者，让消费者拿数据进行消费，队列满时亦然。

   2.3 解耦了生产者和消费者，队列就像是生产者和消费者之间的管道一样，生产者只管往里面丢，消费者只管不断消费，两者之间互不关心。

### 1.2 哪些队列具有阻塞的功能，大概是如何阻塞的？

答：队列主要提供了两种阻塞功能，如下：

1. LinkedBlockingQueue 链表阻塞队列和 ArrayBlockingQueue 数组阻塞队列是一类，前者容量是 Integer 的最大值，后者数组大小固定，两个阻塞队列都可以指定容量大小，当队列满时，如果有线程 put 数据，线程会阻塞住，直到有其他线程进行消费数据后，才会唤醒阻塞线程继续 put，当队列空时，如果有线程 take 数据，线程会阻塞到队列不空时，继续 take。
2. SynchronousQueue 同步队列，当线程 put 时，必须有对应线程把数据消费掉，put 线程才能返回，当线程 take 时，需要有对应线程进行 put 数据时，take 才能返回，反之则阻塞，举个例子，线程 A put 数据 A1 到队列中了，此时并没有任何的消费者，线程 A 就无法返回，会阻塞住，直到有线程消费掉数据 A1 时，线程 A 才能返回。

### 1.3 底层是如何实现阻塞的？

答：队列本身并没有实现阻塞的功能，而是利用 Condition 的等待唤醒机制，阻塞底层实现就是更改线程的状态为沉睡，细节我们在锁小节会说到。

### 1.4 LinkedBlockingQueue 和 ArrayBlockingQueue 有啥区别。

答：相同点：

1. 两者的阻塞机制大体相同，比如在队列满、空时，线程都会阻塞住。

不同点：

1. LinkedBlockingQueue 底层是链表结构，容量默认是 Interge 的最大值，ArrayBlockingQueue 底层是数组，容量必须在初始化时指定。
2. 两者的底层结构不同，所以 take、put、remove 的底层实现也就不同。

### 1.5 往队列里面 put 数据是线程安全的么？为什么？

答：是线程安全的，在 put 之前，队列会自动加锁，put 完成之后，锁会自动释放，保证了同一时刻只会有一个线程能操作队列的数据，以 LinkedBlockingQueue 为例子，put 时，会加 put 锁，并只对队尾 tail 进行操作，take 时，会加 take 锁，并只对队头 head 进行操作，remove 时，会同时加 put 和 take 锁，所以各种操作都是线程安全的，我们工作中可以放心使用。

### 1.6 take 的时候也会加锁么？既然 put 和 take 都会加锁，是不是同一时间只能运行其中一个方法。

答：1：是的，take 时也会加锁的，像 LinkedBlockingQueue 在执行 take 方法时，在拿数据的同时，会把当前数据删除掉，就改变了链表的数据结构，所以需要加锁来保证线程安全。

2：这个需要看情况而言，对于 LinkedBlockingQueue 来说，队列的 put 和 take 都会加锁，但两者的锁是不一样的，所以两者互不影响，可以同时进行的，对于 ArrayBlockingQueue 而言，put 和 take 是同一个锁，所以同一时刻只能运行一个方法。

### 1.7 工作中经常使用队列的 put、take 方法有什么危害，如何避免。

答：当队列满时，使用 put 方法，会一直阻塞到队列不满为止。

当队列空时，使用 take 方法，会一直阻塞到队列有数据为止。

两个方法都是无限（永远、没有超时时间的意思）阻塞的方法，容易使得线程全部都阻塞住，大流量时，导致机器无线程可用，所以建议在流量大时，使用 offer 和 poll 方法来代替两者，我们只需要设置好超时阻塞时间，这两个方法如果在超时时间外，还没有得到数据的话，就会返回默认值（LinkedBlockingQueue 为例），这样就不会导致流量大时，所有的线程都阻塞住了。

这个也是生产事故常常发生的原因之一，尝试用 put 和 take 方法，在平时自测中根本无法发现，对源码不熟悉的同学也不会意识到会有问题，当线上大流量打进来时，很有可能会发生故障，所以我们平时工作中使用队列时，需要谨慎再谨慎。

### 1.8 把数据放入队列中后，有木有办法让队列过一会儿再执行？

答：可以的，DelayQueue 提供了这种机制，可以设置一段时间之后再执行，该队列有个唯一的缺点，就是数据保存在内存中，在重启和断电的时候，数据容易丢失，所以定时的时间我们都不会设置很久，一般都是几秒内，如果定时的时间需要设置很久的话，可以考虑采取延迟队列中间件（这种中间件对数据会进行持久化，不怕断电的发生）进行实现。

### 1.9 DelayQueue 对元素有什么要求么，我把 String 放到队列中去可以么？

答：DelayQueue 要求元素必须实现 Delayed 接口，Delayed 本身又实现了 Comparable 接口，Delayed 接口的作用是定义还剩下多久就会超时，给使用者定制超时时间的，Comparable 接口主要用于对元素之间的超时时间进行排序的，两者结合，就可以让越快过期的元素能够排在前面。

所以把 String 放到 DelayQueue 中是不行的，编译都无法通过，DelayQueue 类在定义的时候，是有泛型定义的，泛型类型必须是 Delayed 接口的子类才行。

### 1.10 DelayQueue 如何让快过期的元素先执行的？

答：DelayQueue 中的元素都实现 Delayed 和 Comparable 接口的，其内部会使用 Comparable 的 compareTo 方法进行排序，我们可以利用这个功能，在 compareTo 方法中实现过期时间和当前时间的差，这样越快过期的元素，计算出来的差值就会越小，就会越先被执行。

### 1.11 如何查看 SynchronousQueue 队列的大小？

答：此题是个陷进题，题目首先设定了 SynchronousQueue 是可以查看大小的，实际上 SynchronousQueue 本身是没有容量的，所以也无法查看其容量的大小，其内部的 size 方法都是写死的返回 0。

### 1.12 SynchronousQueue 底层有几种数据结构，两者有何不同？

答：底层有两种数据结构，分别是队列和堆栈。

两者不同点：

1. 队列维护了先入先出的顺序，所以最先进去队列的元素会最先被消费，我们称为公平的，而堆栈则是先入后出的顺序，最先进入堆栈中的数据可能会最后才会被消费，我们称为不公平的。
2. 两者的数据结构不同，导致其 take 和 put 方法有所差别，具体的可以看 《 SynchronousQueue 源码解析 》章节。

### 1.13 假设 SynchronousQueue 底层使用的是堆栈，线程 1 执行 take 操作阻塞住了，然后有线程 2 执行 put 操作，问此时线程 2 是如何把 put 的数据传递给 take 的？

答：这是一个好问题，也是理解 SynchronousQueue 的核心问题。

首先线程 1 被阻塞住，此时堆栈头就是线程 1 了，此时线程 2 执行 put 操作，会把 put 的数据赋值给堆栈头的 match 属性，并唤醒线程 1，线程 1 被唤醒后，拿到堆栈头中的 match 属性，就能够拿到 put 的数据了。

严格上说并不是 put 操作直接把数据传递给了 take，而是 put 操作改变了堆栈头的数据，从而 take 可以从堆栈头上直接拿到数据，堆栈头是 take 和 put 操作之间的沟通媒介。

### 1.14 如果想使用固定大小的队列，有几种队列可以选择，有何不同？

答：可以使用 LinkedBlockingQueue 和 ArrayBlockingQueue 两种队列。

前者是链表，后者是数组，链表新增时，只要建立起新增数据和链尾数据之间的关联即可，数组新增时，需要考虑到索引的位置（takeIndex 和 putIndex 分别记录着下次拿数据、放数据的索引位置），如果增加到了数组最后一个位置，下次就要重头开始新增。

### 1.15 ArrayBlockingQueue 可以动态扩容么？用到数组最后一个位置时怎么办？

答：不可以的，虽然 ArrayBlockingQueue 底层是数组，但不能够动态扩容的。

假设 put 操作用到了数组的最后一个位置，那么下次 put 就需要从数组 0 的位置重新开始了。

假设 take 操作用到数组的最后一个位置，那么下次 take 的时候也会从数组 0 的位置重新开始。

### 1.16 ArrayBlockingQueue take 和 put 都是怎么找到索引位置的？是利用 hash 算法计算得到的么？

答：ArrayBlockingQueue 有两个属性，为 takeIndex 和 putIndex，分别标识下次 take 和 put 的位置，每次 take 和 put 完成之后，都会往后加一，虽然底层是数组，但和 HashMap 不同，并不是通过 hash 算法计算得到的。

## 2 总结

队列是锁、线程池等复杂 API 的基础，很多面试官都会在问这些 API 时冷不防的问你队列的知识，如果你回答不好，面试官可能会认为你仅仅是用过锁和线程池，但却对其底层的原理和实现了解的不够全面，所以说队列还是蛮重要的，但队列的源码比较复杂，建议大家可以尝试 debug 的方式来理解源码。

[22 ArrayBlockingQueue 源码解析](https://www.imooc.com/read/47/article/864)[24 举一反三：队列在 Java 其它源码中的应用](https://www.imooc.com/read/47/article/866)

精选留言 1

欢迎在这里发表留言，作者筛选后可公开显示

- [慕码人6169125](https://www.imooc.com/u/6612138/articles)

  老师，1.1的第一条是不是打错了哦？DelayQueue内部的q是PriorityQueue对象，PriorityQueue的源码好像底层是数组哦。SynchronousQueue底层是两种数据结构

   0

  回复

  2019-10-24

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[慕码人6169125](https://www.imooc.com/u/6612138/articles)

    谢谢，你是对的，正在修改中。

    回复

    2019-10-24 20:42:06

 

千学不如一看，千看不如一练

# 24 举一反三：队列在 Java 其它源码中的应用

24 举一反三：队列在 Java 其它源码中的应用

更新时间：2019-10-24 12:03:24

![img](https://img2.mukewang.com/5db10f4a0001be1e06400359.jpg)

![img](https://www.imooc.com/static/img/column/bg-l.png)![img](https://www.imooc.com/static/img/column/bg-r.png)

世上无难事,只要肯登攀。

——毛泽东



## 引导语

队列除了提供 API 供开发者使用外，自身也和 Java 中其他 API 紧密结合，比如线程池和锁，线程池直接使用了队列的 API，锁借鉴了队列的思想，重新实现了队列，线程池和锁都是我们工作中经常使用的 API，也是面试官常问的 API，队列在两者的实现上发挥着至关重要的作用，接下来我们一起来看下。



## 1 队列和线程池的结合



### 1.1 队列在线程池中的作用

线程池大家应该都使用过，比如我们想新建一个固定大小的线程池，并让运行的线程打印一句话出来，我们会这么写代码：

```java
ExecutorService executorService = Executors.newFixedThreadPool(10);
// submit 是提交任务的意思
// Thread.currentThread() 得到当前线程
executorService.submit(() -> System.out.println(Thread.currentThread().getName() + " is run"));
// 打印结果(我们打印出了当前线程的名字)：
pool-1-thread-1 is run
```

代码中的 Executors 是并发的工具类，主要是为了帮助我们更方便的构造线程池的，其中 newFixedThreadPool 方法表示会构造出固定大小的线程池，我们给的入参是 10，代表线程池最大可以构造 10 个线程出来。

在实际的工作中，我们对流量的大小是无法控制的，这里我们设定的最大是 10 个线程，但如果一下子来了 100 个请求，这时候 10 个线程肯定是忙不过来了，那么剩余的 90 个请求怎么办呢？

这时候就需要队列出马了，我们会把线程无法消化的数据放到队列中去，让数据在队列中排队，等线程有能力消费了，再从队列中拿出来慢慢去消费。

我们画一个图释义一下：

![图片描述](https://img.mukewang.com/5db11ff30001cf3511460486.png)
上图右边表示 10 个线程正在全力消费请求，左边表示剩余请求正在队列中排队，等待消费。

由此可见，队列在线程池中占有很重要的地位，当线程池中的线程忙不过来的时候，请求都可以在队列中等待，从而慢慢地消费。

接下来我们来看下，线程池到底用到了那几种队列类型，分别起的什么作用。



### 1.1 线程池中使用到的队列的类型

#### 1.1.1 LinkedBlockingQueue 队列的使用

刚刚我们说的 newFixedThreadPool 是一种固定大小的线程池，意思是当线程池初始化好后，线程池里面的线程大小是不会变的了（线程池默认设置是不会回收核心线程数的），我们来看下 newFixedThreadPool 的源码：

```java
// ThreadPoolExecutor 初始化时，第一个参数表示 coreSize，第二个参数是 maxSize，coreSize == maxSize,
// 表示线程池初始化时，线程大小已固定，所以叫做固定(Fixed)线程池。 
public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue<Runnable>());
}
```

源码中可以看到初始化了 ThreadPoolExecutor，ThreadPoolExecutor 是线程池的 API，我们在线程池章节会细说，它的第五个构造参数就是队列，线程池根据场景会选择不同的队列，此处使用的是 LinkedBlockingQueue，并且是默认参数的 Queue，这说明此阻塞队列的最大容量是 Integer 的最大值，也就是说当线程池的处理能力有限时，阻塞队列中最大可以存放 Integer 最大值个任务。

但我们在实际工作中，常常不建议直接使用 newFixedThreadPool，主要是因为其使用的是 LinkedBlockingQueue 的默认构造器，队列容量太大了，在要求实时响应的请求中，队列容量太大往往危害也很大。

比如说我们用上述的线程池，线程 10 个，队列是 Integer 的最大值，当并发流量很大时，比如来了 1w/qps 请求，这时候 10 个线程根本消费不完，就会有很多请求被阻塞在队列中，虽然 10 个线程仍然在不断地消费，但需要消费完队列中的所有数据是需要时间的，假设需要 3 秒才能全部消费完，而这些实时请求都是有超时时间的，默认超时时间是 2 秒，当时间到达 2 秒时，请求已经超时了，返回报错，可这时候队列中的任务还有很多都在等待消费呢，即使后来消费完成，也无法返回给调用方了。

以上情况就会造成，调用方看到接口是超时报错返回的，但服务端的任务其实还在排队执行，过了 3 秒后，服务端的任务可能都会执行成功，但调用方已经无法感知了，调用方再次调用时，就会发现其实这笔请求已经成功了。

如果调用方是从页面发起的，那么体验就会更差，页面上第一次调用页面报错，用户重新刷新页面时，页面显示上次的请求已经成功了，这个就是很不好的体验了。

所以我们希望队列的大小不要设置成那么大，可以根据实际的消费情况来设置队列的大小，这样就可以保证在接口超时前，队列中排队的请求可以执行完。

场景比较复杂，为了方便理解，我们画了一个图，把整个流程释义一下：
![图片描述](https://img.mukewang.com/5db120020001e74f15260518.png)

这种问题，在实际工作中已经属于非常严重的生产事故了，我们使用时一定要小心。

和 newFixedThreadPool 相同的是，newSingleThreadExecutor 方法底层使用的也是 LinkedBlockingQueue，newSingleThreadExecutor 线程池底层线程只会有一个，这代表着这个线程池一次只能处理一个请求，其余的请求都会在队列中排队等待执行，我们看下 newSingleThreadExecutor 的源码实现：

```java
public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        // 前两个参数规定了这个线程池一次只能消费一个线程
        // 第五个参数使用的是 LinkedBlockingQueue,说明当请求超过单线程消费能力时，就会排队
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>()));
}
```

可以看到，底层使用的也是 LinkedBlockingQueue 的默认参数，也就是说排队的最大值是 Integer 的最大值。

#### 1.1.2 SynchronousQueue 队列

除了 newFixedThreadPool 方法，在线程池新建时，还有其他的几个方法也对应着不同的队列，我们一起来看下 newCachedThreadPool，newCachedThreadPool 底层对应的是 SynchronousQueue 队列，源码如下：

```java
public static ExecutorService newCachedThreadPool() {
    // 第五个参数是 SynchronousQueue
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue<Runnable>());
}
```

SynchronousQueue 队列是没有大小限制的，请求多少队列都能承受的住，可以说这是他的优点，缺点就是每次往队列里面 put 数据时，并不能立马返回，而是需要等待有线程 take 数据之后，才能正常返回，如果请求量大，而消费能力较差时，就会导致大量请求被 hodler 住，必须等到慢慢消费完成之后才能被释放，所以在平时工作使用中也需要慎重。

#### 1.1.3 DelayedWorkQueue

newScheduledThreadPool 代表定时任务线程池，底层源码如下：
![图片描述](https://img.mukewang.com/5db12015000125e222240760.png)

截图从左往右我们可以看到，底层队列使用的是 DelayedWorkQueue 延迟队列，说明线程池底层延时的功能就是 DelayedWorkQueue 队列提供的，新的延迟请求都先到队列中去，延迟时间到了，线程池自然就能从队列中拿出线程进行执行了。

newSingleThreadScheduledExecutor 方法也是和 newScheduledThreadPool 一样的，使用 DelayedWorkQueue 的延迟功能，只不过前者是单个线程执行。



### 1.2 小结

从线程池的源码中，我们可以看到：

1. 队列在线程池的设计中，起着缓冲数据，延迟执行数据的作用，当线程池消费能力有限时，可以让请求进行排队，让线程池可以慢慢消费。
2. 线程池根据不同的场景，选择使用了 DelayedWorkQueue、SynchronousQueue、LinkedBlockingQueue 多种队列，从而实现自己不同的功能，比如使用 DelayedWorkQueue 的延迟功能来实现定时执行线程池。



## 2 队列和锁的结合

我们平时写锁代码的时候都这么写：

```java
ReentrantLock lock = new ReentrantLock();
try{
    lock.lock();
    // do something
}catch(Exception e){
  //throw Exception;
}finally {
    lock.unlock();
}
```

初始化锁 -> 加锁 -> 执行业务逻辑 -> 释放锁，这是正常的流程，但我们知道同一时刻只能有一个线程才能获得锁的，那么此时其他获取不到锁的线程该怎么办呢？

等待，其他获取不到锁的线程，都会到一个等待队列中去等待，等待锁被释放掉时，再去竞争锁，我们画一个示意图。

![图片描述](https://img.mukewang.com/5db120240001225305480820.png)

图中红色标识的就是同步队列，获取不到锁的线程都会到同步队列中去排队，当锁被释放后，同步队列中的线程就又开始去竞争锁。

可以看出队列在锁中起的作用之一，就是帮助管理获取不到锁的线程，让这些线程可以耐心的等待。

同步队列并没有使用现有的队列的 API 去实现，但底层的结构，思想和目前队列是一致的，所以我们学好队列章节，对理解锁的同步队列，用处非常大。



## 3 总结

队列的数据结构真的很重要，在线程池和锁两个重量级 API 中起着非常重要的作用，我们要非常清楚队列底层的大体的数据结构，了解数据是如何入队的，如何出队的，队列这章也是比较复杂的，建议大家多多 debug，我们 github 上也提供了一些 debug 的 demo，大家可以尝试调试起来。

[23 队列在源码方面的面试题](https://www.imooc.com/read/47/article/865)[25 整体设计：队列设计思想、工作中使用场景](https://www.imooc.com/read/47/article/867)

精选留言 1

欢迎在这里发表留言，作者筛选后可公开显示

- [慕粉3445147](https://www.imooc.com/u/3445147/articles)

  之前面试的时候,面试官问过对于不同的场景使用何种队列,现在回想一下,答得太简单了,也是面试官给面子,里面的想法真的很多啊..

   0

  回复

  2019-11-04

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[慕粉3445147](https://www.imooc.com/u/3445147/articles)

    是滴，这个问题其实比较考察我们对队列的使用经验。

    回复

    2019-11-05 20:31:36

 

千学不如一看，千看不如一练

 

# 25 整体设计：队列设计思想、工作中使用场景

25 整体设计：队列设计思想、工作中使用场景

更新时间：2019-10-31 19:36:53

![img](https://img4.mukewang.com/5db68d030001f1af06400359.jpg)

![img](https://www.imooc.com/static/img/column/bg-l.png)![img](https://www.imooc.com/static/img/column/bg-r.png)

人生太短，要干的事太多，我要争分夺秒。

——爱迪生



### 引导语

本章我们学习了 LinkedBlockingQueue、ArrayBlockingQueue、SynchronousQueue、DelayQueue 四种队列，四种队列底层数据结构各不相同，使用场景也不相同，本章我们从设计思想和使用场景两个大的方向做一些对比和总结。



## 1 设计思想

首先我们画出队列的总体设计图：
![图片描述](https://img.mukewang.com/5db148170001daa312560972.png)

从图中我们可以看出几点：

1. 队列解耦了生产者和消费者，提供了生产者和消费者间关系的多种形式，比如 LinkedBlockingQueue、ArrayBlockingQueue 两种队列就把解耦了生产者和消费者，比如 SynchronousQueue 这种就把生产者和消费者相互对应（生产者的消息被消费者开始消费之后，生产者才能返回，为了方便理解，使用相互对应这个词）；
2. 不同的队列有着不同的数据结构，有链表（LinkedBlockingQueue）、数组（ArrayBlockingQueue）、堆栈（SynchronousQueue）等；
3. 不同的数据结构，决定了入队和出队的姿势是不同的。

接下来我们分别按照这几个方面来总结分析一下。



### 1.1 队列的数据结构

链表结构的队列就是 LinkedBlockingQueue，其特征如下：

1. 初始大小默认是 Integer 的最大值，也可以设置初始大小；
2. 链表元素通过 next 属性关联下一个元素；
3. 新增是从链表的尾部新增，拿是从链表头开始拿。

数组结构的队列是 ArrayBlockingQueue，特征如下：

1. 容量大小是固定的，不能动态扩容；
2. 有 takeIndex 和 putIndex 两个索引记录下次拿和新增的位置；
3. 当 takeIndex 和 putIndex 到达数组的最后一个位置时，下次都是从 0 开始循环。

SynchronousQueue 有着两种数据结构，分别是队列和堆栈，特征如下：

1. 队列保证了先入先出的数据结构，体现了公平性；
2. 堆栈是先入后出的数据结构，是不公平的，但性能高于先入先出。



### 1.2 入队和出队的方式

不同的队列有着不同的数据结构，导致其入队和出队的方式也不同：

1. 链表是入队是直接追加到队尾，出队是从链表头拿数据；
2. 数组是有 takeIndex 和 putIndex 两个索引位置记录下次拿和取的位置，如总体设计图，入队直接指向了 putIndex，出队指向了 takeIndex；
3. 堆栈主要都是围绕栈头进行入栈和出栈的。



### 1.3 生产者和消费者之间的通信机制

从四种队列我们可以看出来生产者和消费者之间有两种通信机制，一种是强关联，一种是无关联。

强关联主要是指 SynchronousQueue 队列，生产者往队列中 put 数据，如果这时候没有消费者消费的话，生产者就会一直阻塞住，是无法返回的；消费者来队列里取数据，如果这时候队列中没有数据，消费者也会一直阻塞住，所以 SynchronousQueue 队列模型中，生产者和消费者是强关联的，如果只有其中一方存在，只会阻塞，是无法传递数据的。

无关联主要是说有数据存储功能的队列，比如说 LinkedBlockingQueue 和 ArrayBlockingQueue，只要队列容器不满，生产者就能放成功，生产者就可以直接返回，和有无消费者一点关系都没有，生产者和消费者完全解耦，通过队列容器的储存功能进行解耦。



## 2 工作中的使用场景

在日常工作中，我们需要根据队列的特征来匹配业务场景，从而决定使用哪种队列，我们总结下各个队列适合使用的场景：



### 2.1 LinkedBlockingQueue

适合对生产的数据大小不定（时高时低），数据量较大的场景，比如说我们在淘宝上买东西，点击下单按钮时，对应着后台的系统叫做下单系统，下单系统会把下单请求都放到一个线程池里面，这时候我们初始化线程池时，一般会选择 LinkedBlockingQueue，并且设置一个合适的大小，此时选择 LinkedBlockingQueue 主要原因在于：在不高于我们设定的阈值内，队列里面的大小可大可小，不会有任何性能损耗，正好符合下单流量的特点，时大时小。

一般工作中，我们大多数都会选择 LinkedBlockingQueue 队列，但会设置 LinkedBlockingQueue 的最大容量，如果初始化时直接使用默认的 Integer 的最大值，当流量很大，而消费者处理能力很差时，大量请求都会在队列中堆积，会大量消耗机器的内存，就会降低机器整体性能甚至引起宕机，一旦宕机，在队列中的数据都会消失，因为队列的数据是保存在内存中的，一旦机器宕机，内存中的数据都会消失的，所以使用 LinkedBlockingQueue 队列时，建议还是要根据日常的流量设置合适的队列的大小。



### 2.2 ArrayBlockingQueue

一般用于生产数据固定的场景，比如说系统每天会进行对账，对账完成之后，会固定的产生 100 条对账结果，因为对账结果固定，我们就可以使用 ArrayBlockingQueue 队列，大小可以设置成 100。



### 2.3 DelayQueue

延迟队列，在工作中经常遇到，主要用于任务不想立马执行，想等待一段时间才执行的场景。

比如说延迟对账，我们在工作中曾经遇到过这样的场景：我们在淘宝上买东西，弹出支付宝付款页面，在我们输入指纹的瞬间，流程主要是前端 -》交易后端 -》支付后端，交易后端调用支付后端主要是为了把我们支付宝的钱划给商家，而交易调用支付的过程中，有小概率的情况，因为网络抖动会发生超时的情况，这时候就需要通过及时的对账来解决这个事情（对账只是解决这个问题的手段之一），我们简单画一个流程图：
![图片描述](https://img.mukewang.com/5db1482c0001d1fd11880618.png)

这是一个真实场景，为了方便描述，已经大大简化了，再说明几点：

1. 交易调用支付的接口，这个接口的作用就是为了把小美的 800 元转给商家小明；
2. 接口调用超时，此时交易系统并不知道 800 有没有成功转给小明，当然想知道的方式有很多，我们选择了对账的方式，对账的目的就是为了知道当前 800 元有没有成功转给小明；
3. 延迟对账的目的，因为支付系统把 800 元转给商家小明也是需要时间的，如果超时之后立马对账，可能转账的动作还在进行中，导致对账的结果不准确，所以需要延迟几秒后再去对账；
4. 对账之后的结果有几种，比如已经成功的把 800 元转给小明了，这时候需要把对账结果告诉交易系统，交易系统更新数据，前端就能够显示转账成功了。

在这个案列中，延迟对账的核心技术就是 DelayQueue，我们大概这么做的：新建对账任务，设置 3 秒之后执行，把任务放到 DelayQueue 中，过了 3 秒之后，就会自动执行对账任务了。

DelayQueue 延迟执行的功能就在这个场景中得到应用。



## 3 总结

我们不会为了阅读源码而读源码，我们读源码的最初目的，是为了提高我们的技术深度，最终目的是为了在不同的场景中，能够选择合适的技术进行落地，本章中解释的一些队列的场景，我们在工作中其实都会遇到，特别是在使用线程池时，使用哪种队列是我们必须思考的一个问题，所以本章先比较了各个队列的适合使用场景，然后举了几个案列进行具体分析，希望大家也能把技术具体落地到实际工作中，使技术推动、辅助业务。

[24 举一反三：队列在 Java 其它源码中的应用](https://www.imooc.com/read/47/article/866)[26 惊叹面试官：由浅入深手写队列](https://www.imooc.com/read/47/article/868)

精选留言 1

欢迎在这里发表留言，作者筛选后可公开显示

- [八卦一百二十八掌](https://www.imooc.com/u/2809885/articles)

  请问在实际开发中，文中讲到的队列使用场景，可以使用消息中间件来解决吗？RocketMQ、Kafka等？如果可以，实际开发中使用本章讲解的队列好还是消息队列好？

   2

  回复

  2019-11-07

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[八卦一百二十八掌](https://www.imooc.com/u/2809885/articles)

    肯定是中间件好，一般中间件能够做到高可用，高性能，高扩展，我们文中只是举一个例子来演示下，实际工作中直接使用中间件就好了，当然中间件的底层 API 也是使用的文中这些队列 API，可能在架构设计上会更加高大尚

    回复

    2019-11-17 11:09:35

 

千学不如一看，千看不如一练

 

# 26 惊叹面试官：由浅入深手写队列

26 惊叹面试官：由浅入深手写队列

更新时间：2019-11-04 10:16:59

![img](https://img1.mukewang.com/5db7a3440001f1af06400359.jpg)

![img](https://www.imooc.com/static/img/column/bg-l.png)![img](https://www.imooc.com/static/img/column/bg-r.png)

人生的价值，并不是用时间，而是用深度去衡量的。

——列夫·托尔斯泰

## 引导语

现在不少大厂面试的时候会要求手写代码，我曾经看过一个大厂面试时，要求在线写代码，题目就是：在不使用 Java 现有队列 API 的情况下，手写出一个队列的实现出来，队列的数据结构，入队和出队方式都自己定义。

这题其实考察的有几个点：

1. 考察你对队列的内部结构熟不熟悉；
2. 考察你定义 API 的功底；
3. 考察写代码的基本功，代码风格。

本章就和大家一起，结合以上几点，手写一个队列出来，一起来熟悉一下思路和过程，完整队列代码见：demo.four.DIYQueue 和 demo.four.DIYQueueDemo

## 1 接口定义

在实现队列之前，我们首先需要定义出队列的接口，就是我们常说的 API，API 是我们队列的门面，定义时主要原则就是简单和好用。

我们这次实现的队列只定义放数据和拿数据两个功能，接口定义如下：

```java
/**
* 定义队列的接口，定义泛型，可以让使用者放任意类型到队列中去
* author  wenhe
* date 2019/9/1
*/
public interface Queue<T> {

  /**
   * 放数据
   * @param item 入参
   * @return true 成功、false 失败
   */
  boolean put(T item);

  /**
   * 拿数据，返回一个泛型值
   * @return
   */
  T take();

  // 队列中元素的基本结构
  class Node<T> {
    // 数据本身
    T item;
    // 下一个元素
    Node<T> next;

    // 构造器
    public Node(T item) {
      this.item = item;
    }
  }
}
```

有几点我们说明下：

1. 定义接口时，一定要写注释，接口的注释，方法的注释等等，这样别人看我们的接口时，会轻松很多‘；
2. 定义接口时，要求命名简洁明了，最好让别人一看见命名就知道这个接口是干啥的，比如我们命名为 Queue，别人一看就清楚这个接口是和队列相关的；
3. 用好泛型，因为我们不清楚放进队列中的到底都是那些值，所以我们使用了泛型 T，表示可以在队列中放任何值；
4. 接口里面无需给方法写上 public 方法，因为接口中的方法默认都是 public 的，你写上编译器也会置灰，如下图：
   ![图片描述](https://img.mukewang.com/5db14faa0001928904140484.png)
5. 我们在接口中定义了基础的元素 Node，这样队列子类如果想用的话，可以直接使用，增加了复用的可能性。

## 2 队列子类实现

接着我们就要开始写子类实现了，我们准备写个最常用的链表数据结构的队列。

### 2.1 数据结构

底层数据结构我们采用链表，一说到链表，大家应该马上就会想到三个关键要素：链表头、链表尾和链表元素，我们也实现了，代码如下：

```java
/**
 * 队列头
 */
private volatile Node<T> head;

/**
 * 队列尾
 */
private volatile Node<T> tail;

/**
 * 自定义队列元素
 */
class DIYNode extends Node<T>{
  public DIYNode(T item) {
    super(item);
  }
}
```

除了这些元素之外，我们还有队列容器的容量大小、队列目前的使用大小、放数据锁、拿数据锁等等，代码如下：

```java
/**
 * 队列的大小，使用 AtomicInteger 来保证其线程安全
 */
private AtomicInteger size = new AtomicInteger(0);

/**
 * 容量
 */
private final Integer capacity;

/**
 * 放数据锁
 */
private ReentrantLock putLock = new ReentrantLock();

/**
 * 拿数据锁
 */
private ReentrantLock takeLock = new ReentrantLock();
```

### 2.2 初始化

我们提供了使用默认容量（Integer 的最大值）和指定容量两种方式，代码如下：

```java
/**
 * 无参数构造器，默认最大容量是 Integer.MAX_VALUE
 */
public DIYQueue() {
  capacity = Integer.MAX_VALUE;
  head = tail = new DIYNode(null);
}

/**
 * 有参数构造器，可以设定容量的大小
 * @param capacity
 */
public DIYQueue(Integer capacity) {
  // 进行边界的校验
  if(null == capacity || capacity < 0){
    throw new IllegalArgumentException();
  }
  this.capacity = capacity;
  head = tail = new DIYNode(null);
}
```

### 2.3 put 方法的实现

```java
public boolean put(T item) {
  // 禁止空数据
  if(null == item){
    return false;
  }
  try{
    // 尝试加锁，500 毫秒未获得锁直接被打断
    boolean lockSuccess = putLock.tryLock(300, TimeUnit.MILLISECONDS);
	if(!lockSuccess){
	  return false;
	}
    // 校验队列大小
    if(size.get() >= capacity){
      log.info("queue is full");
      return false;
    }
    // 追加到队尾
    tail = tail.next = new DIYNode(item);
    // 计数
    size.incrementAndGet();
    return true;
  } catch (InterruptedException e){
    log.info("tryLock 500 timeOut", e);
    return false;
  } catch(Exception e){
    log.error("put error", e);
    return false;
  } finally {
    putLock.unlock();
  }
}
```

put 方法的实现有几点我们需要注意的是：

1. 注意 try catch finally 的节奏，catch 可以捕捉多种类型的异常，我们这里就捕捉了超时异常和未知异常，在 finally 里面一定记得要释放锁，不然锁不会自动释放的，这个一定不能用错，体现了我们代码的准确性；
2. 必要的逻辑检查还是需要的，比如入参是否为空的空指针检查，队列是否满的临界检查，这些检查代码可以体现出我们逻辑的严密性；
3. 在代码的关键地方加上日志和注释，这点也是非常重要的，我们不希望关键逻辑代码注释和日志都没有，不利于阅读代码和排查问题；
4. 注意线程安全，此处实现我们除了加锁之外，对于容量的大小（size）我们选择线程安全的计数类：AtomicInteger，来保证了线程安全；
5. 加锁的时候，我们最好不要使用永远阻塞的方法，我们一定要用带有超时时间的阻塞方法，此处我们设置的超时时间是 300 毫秒，也就是说如果 300 毫秒内还没有获得锁，put 方法直接返回 false，当然时间大小你可以根据情况进行设置；
6. 根据不同的情况设置不同的返回值，put 方法返回的是 false，在发生异常时，我们可以选择返回 false，或者直接抛出异常；
7. put 数据时追加到队尾的，所以我们只需要把新数据转化成 DIYNode，放到队列的尾部即可。

### 2.4 take 方法的实现

take 方法和 put 方法的实现非常类似，只不过 take 是从头部拿取数据，代码实现如下：

```java
public T take() {
  // 队列是空的，返回 null
  if(size.get() == 0){
    return null;
  }
  try {
    // 拿数据我们设置的超时时间更短
    boolean lockSuccess = takeLock.tryLock(200,TimeUnit.MILLISECONDS);
	if(!lockSuccess){
	    throw new RuntimeException("加锁失败");
	}
    // 把头结点的下一个元素拿出来
    Node expectHead = head.next;
    // 把头结点的值拿出来
    T result = head.item;
    // 把头结点的值置为 null，帮助 gc
    head.item = null;
    // 重新设置头结点的值
    head = (DIYNode) expectHead;
    size.decrementAndGet();
    // 返回头结点的值
    return result;
  } catch (InterruptedException e) {
    log.info(" tryLock 200 timeOut",e);
  } catch (Exception e) {
    log.info(" take error ",e);
  }finally {
      takeLock.unlock();
 }
  return null;
}
```

通过以上几步，我们的队列已经写完了，完整代码见：demo.four.DIYQueue。

## 3 测试

API 写好了，接下来我们要针对 API 写一些场景测试和单元测试，我们先写个场景测试，看看 API 能否跑通，代码如下：

```java
@Slf4j
public class DIYQueueDemo {
	// 我们需要测试的队列
  private final static Queue<String> queue = new DIYQueue<>();
	// 生产者
  class Product implements Runnable{
    private final String message;

    public Product(String message) {
      this.message = message;
    }

    @Override
    public void run() {
      try {
        boolean success = queue.put(message);
        if (success) {
          log.info("put {} success", message);
          return;
        }
        log.info("put {} fail", message);
      } catch (Exception e) {
        log.info("put {} fail", message);
      }
    }
  }
	// 消费者
  class Consumer implements Runnable{
    @Override
    public void run() {
      try {
        String message = (String) queue.take();
        log.info("consumer message :{}",message);
      } catch (Exception e) {
        log.info("consumer message fail",e);
      }
    }
  }
	// 场景测试
  @Test
  public void testDIYQueue() throws InterruptedException {
    ThreadPoolExecutor executor =
        new ThreadPoolExecutor(10,10,0,TimeUnit.MILLISECONDS,
                               new LinkedBlockingQueue<>());
    for (int i = 0; i < 1000; i++) {
        // 是偶数的话，就提交一个生产者，奇数的话提交一个消费者
        if(i % 2 == 0){
          executor.submit(new Product(i+""));
          continue;
        }
        executor.submit(new Consumer());
    }
    Thread.sleep(10000);
  }
```

代码测试的场景比较简单，从 0 开始循环到 1000，如果是偶数，就让生产者去生产数据，并放到队列中，如果是奇数，就让消费者去队列中拿数据出来进行消费，运行之后的结果如下：

![图片描述](https://img.mukewang.com/5db14fc70001617f08660711.png)
从显示的结果来看，咱们写的 DIYQueue 没有太大的问题，当然如果想大规模的使用，还需要详细的单元测试和性能测试。

## 4 总结

通过本章的学习，不知道你有没有一种队列很简单的感觉，其实队列本身就很简单，没有想象的那么复杂。

只要我们懂得了队列的基本原理，清楚几种常用的数据结构，手写队列问题其实并不大，你也赶紧来试一试吧。

[25 整体设计：队列设计思想、工作中使用场景](https://www.imooc.com/read/47/article/867)[27 Thread 源码解析](https://www.imooc.com/read/47/article/869)

精选留言 6

欢迎在这里发表留言，作者筛选后可公开显示

- [weixin_慕UI1009709](https://www.imooc.com/u/8291152/articles)

  take的时候第一个 head.iiem肯定null head.next 才是第一个插入的节点 我已经debugg了 而且take之后如果size==0 应该让 tail =head 不然put之后 take的值一直都是null 我是按照文章代码调试得到的结果

   0

  回复

  2020-01-10

- [啊穆](https://www.imooc.com/u/8142766/articles)

  提到的完整代码 在哪里呀

   1

  回复

  2019-11-20

  - [慕桂英0056004](https://www.imooc.com/u/6120812/articles)

    回复[啊穆](https://www.imooc.com/u/8142766/articles)

    同问, 我也是碰到这个问题

    回复

    2019-11-22 15:39:11

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[啊穆](https://www.imooc.com/u/8142766/articles)

    here: https://github.com/luanqiu/java8 https://github.com/luanqiu/java8_demo

    回复

    2019-11-23 16:43:05

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[慕桂英0056004](https://www.imooc.com/u/6120812/articles)

    here: https://github.com/luanqiu/java8 https://github.com/luanqiu/java8_demo

    回复

    2019-11-23 16:43:08

- [前田慶次](https://www.imooc.com/u/5611237/articles)

  老师您好，在初始化队列构造器的操作是不是少了一段头尾节点关联的代码，head.next = tail;否则在take数据的时候程序会出错。

   1

  回复

  2019-11-01

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[前田慶次](https://www.imooc.com/u/5611237/articles)

    同学你好，不会的哈，head = tail = new DIYNode(null);指的是头尾初始化时指向同一个引用，put 时 tail = tail.next = new DIYNode(item); 这行代码，也会修改 head 的值，你可以尝试一下 debug，把 take 方法打一个断点，即不让消费，你会发现 head.next.next.next 都会有很多值，不是像我们看代码时好像为空的感觉。

    回复

    2019-11-04 10:11:51

  - [前田慶次](https://www.imooc.com/u/5611237/articles)

    回复

    [文贺](https://www.imooc.com/u/8062574/articles)

    确实像老师说的那样，之前是因为take时size没有减一，造成加锁时程序报错

    回复

    2019-11-12 14:33:25

- [weixin_bailangning](https://www.imooc.com/u/6874750/articles)

  老师take方法中返回数据前是不是应该有个size大小减一的操作呢，put方法有增加操作，但是没有看到什么地方有减少操作。

   1

  回复

  2019-11-01

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[weixin_bailangning](https://www.imooc.com/u/6874750/articles)

    同学你说的很有道理，是应该加一下。

    回复

    2019-11-04 10:09:03

- [都被占用啦](https://www.imooc.com/u/3683675/articles)

  有处我觉得可能有问题的地方，作者你看下我说的对不对： 1.队列在take的时候，在最后没有fianlly去释放锁，应该和put是一样的，需要手动释放锁。 2.put的时候，应该是300毫秒之后，还没有获取锁，就会直接返回false，这里应该是作者的一个笔误。 麻烦作者看下，谢谢！

   1

  回复

  2019-10-29

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[都被占用啦](https://www.imooc.com/u/3683675/articles)

    你说的很对，已经在修改ing了

    回复

    2019-10-31 13:13:15

- [慕码人6169125](https://www.imooc.com/u/6612138/articles)

  感觉take方法有点不理解。head指针始终指向的是初始化时候建立的item为null的DIYNode。取出的时候result=head.item会得到null的

   1

  回复

  2019-10-29

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[慕码人6169125](https://www.imooc.com/u/6612138/articles)

    不会的哈，有一个 if(size.get() == 0){return null;} 的判断

    回复

    2019-10-31 10:44:00

  - [慕码人6169125](https://www.imooc.com/u/6612138/articles)

    回复

    [文贺](https://www.imooc.com/u/8062574/articles)

    老师，我的意思是您在构造方法中head = tail = new DIYNode(null);初始化head和tail都是指向item为null的节点。在put方法中tail = tail.next = new DIYNode(item);只是将新添加的节点连接到尾部，tail的引用变了，但是head依旧是指向null的节点。 take方法中 Node expectHead = head.next; T result = head.item; result难道不应该是expectedHead的item吗？ head.item = null; 下一步此处应该是expectedHead的item设为null head = (DIYNode) expectHead; 再将expected设为新的head

    回复

    2019-10-31 20:04:44

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[慕码人6169125](https://www.imooc.com/u/6612138/articles)

    同学你好，put 方法虽然只对 tail 进行了操作，但 head.item 不会指向 null ，你 debug 下就会发现，只要 put 能够不断成功，head.next 就会一直有值，take 为空只有一种情况：我们这个 demo 在模拟生产者和消费者的时候是多线程的，会出现生产者生产的速度比消费者慢的情况，只有这种情况下，可能 take 时是null。 take方法中 Node expectHead = head.next; T result = head.item; result难道不应该是expectedHead的item吗？：这个不是的哈，expectHead.item 不是头节点的，是头节点的next的item。 下一步此处应该是expectedHead的item设为null，这个也不是哈，expectedHead 是下次 take 时的头节点，不能置为null。

    回复

    2019-11-04 10:06:11

  - [慕码人6169125](https://www.imooc.com/u/6612138/articles)

    回复

    [文贺](https://www.imooc.com/u/8062574/articles)

    1）初始化head = tail = new DIYNode(null);这里相当于链表的第一个位置是一个dummy节点，size=0。 2）如果老师put进一个值，tail = tail.next = new DIYNode(item); size=size+1；这个时候head还是指向dummy节点，tail则指向的是新插入的节点。 3）此时有消费者调用take方法，Node expectHead = head.next;此时ExpectedHead指向的是刚才新插入的节点，但是T result = head.item;取出的是dummy节点的null值。 我是觉得这个地方有点问题，可能是我比较笨，脑子绕不过弯来

    回复

    2019-11-04 13:19:29

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[慕码人6169125](https://www.imooc.com/u/6612138/articles)

    同学可以尝试 debug 一下，看是得不到答案的哈。

    回复

    2019-11-05 20:38:21

  - [慕码人6169125](https://www.imooc.com/u/6612138/articles)

    回复

    [文贺](https://www.imooc.com/u/8062574/articles)

    好的，老师太有耐心了

    回复

    2019-11-05 23:27:49

  - [weixin_慕工程5089940](https://www.imooc.com/u/8217835/articles)

    回复[慕码人6169125](https://www.imooc.com/u/6612138/articles)

    我和这个同学理解的一样啊，初始化的时候老师把Head对应的头节点赋空了，取得时候还取这个节点，不会是空的吗？

    回复

    2019-11-21 14:42:39

  - [weixin_慕工程5089940](https://www.imooc.com/u/8217835/articles)

    回复[慕码人6169125](https://www.imooc.com/u/6612138/articles)

    或者 先放一个节点，在取一个节点，我对这个代码的理解是取得时候取得是空节点而不是刚开始放的那个节点啊

    回复

    2019-11-21 14:49:00

 

千学不如一看，千看不如一练

 