编码篇

该章会选取手册中一些编码相关的具体知识点，讲述是什么、为什么和怎么落地等。这个过程中将带着大家通过不同的方法进行学习。

第1章 基础

- 01 开篇词：为什么学习本专栏

  最近阅读

- 02 String、Long 源码解析和面试题

- 03 Java 常用关键字理解

- 04 Arrays、Collections、Objects 常用方法源码解析

第1章 基础



# 01 开篇词：为什么学习本专栏




01 开篇词：为什么学习本专栏
更新时间：2019-12-19 13:55:09

![img](http://img.mukewang.com/5db6b8130001dea906400359.jpg)

最聪明的人是最不愿浪费时间的人。
——但丁

你好，我是明明如月，一个重视方法、喜欢思考的 Java 高级开发工程师。

相信很多程序员都希望自己能够找到一些宝典，通过修炼 “打开任督二脉”，从此快速进阶成为高手。《Java 开发手册》1（以下简称《手册》）就是诸多宝典之一，它几乎是每个 Java 工程师人手必备的一本参考指南。该手册包括 编程规约、异常日志、单元测试、安全规约、MySQL 数据库、工程结构、设计规约 7 个部分 ，涵盖了 Java 开发的常见知识点。认真实践该《手册》能够帮助 Java 开发者养成好的编程习惯，帮助企业的开发团队在 Java 开发上更加高效、提高容错性、团队协作更好，并有助于提高代码的质量、降低项目维护的难度。然而很多人会遇到看过就忘，记住却不理解、不会用的困境。

另外在实际的学习和工作中，你是否遇到过如下尴尬：

看《手册》等 Java 技术图书时觉得啥都懂，实战时就忘了；
很多知识点，知其然而不知其所以然，面试时多问你几个为什么就 “靓仔语塞”；
想通过读源码来进阶，但是容易迷失在细节中，总是半途而废；
不重视需求分析，导致开发完成才意识到设计和需求有偏差；
遇到问题时如果无法简单地定位原因，会优先通过百度、请教别人来解决问题；
开发中遇到问题排查耗时很久，方法很原始；
自己开发的项目，每次上线几乎必出 BUG，而有些同事的项目质量则很高，自己却不知道如何才能尽可能地避免。
结合自己学习和工作这么长时间的思考，将出现上述尴尬的原因归结为以下几个原因：

知道很容易，懂很难，很多人把知道当做懂。自认为掌握了就不愿意再深入学习，恰恰错过了彻底掌握该知识的最佳机会；
专业基础不够扎实。 很多人急于求成，只重视解决眼前问题，不能够未雨绸缪，巩固好专业基础，最终导致很多问题” 知其然而不知其所以然 “，排查问题时靠猜、靠问，而不是靠扎实的专业基础之上的推测和验证；
很多人不愿意改变学习方法，学习和培养好的编程习惯，不敢走出舒适区。比如很多人学了很多技术，却从来没有认真仔细阅读过官方文档；比如读源码毫无章法，随心所欲，常常半途而废；
态度决定一切。很多人嘴上说想学好，但是对自己代码要求很低，总是为自己找各种理由不去学更好的方法，不去努力写更优雅的代码；
在学习技术过程中，很多人把脑力劳动当成了体力劳动，把需要思考的问题当做了纯记忆的问题，学习和工作过程中缺乏思考。比如很多人是 “记忆” 经典图书的知识点，而不是理解知识点，导致容易遗忘，不能灵活运用。在学习很多知识点时缺乏思考，没有去搞懂是什么、不明白为什么、不知道如何去做；
没有养成好的解决问题的习惯，排查问题靠猜，而不是思考和验证。也没有主动掌握常见的排查问题的步骤和工具等。
很多人缺乏的不只是好的资料，而是学习的方法。学一样的技术，使用不同的方法，最终学习的效果截然不同。而技术是学不完的，如果没有科学的方法，无法很好地应对层出不穷的新技术。每个人的成长速度是不同的，有的人工作多年，却只有一年的技术经验；而有的人工作一年，却有超越一年的技术经验。造成这种差异的主要原因在于学习能力。

从 Java 新手到高手的进阶过程是一个漫长的爬坑过程。 很多同学遇到 BUG 时由于基础不扎实也没有系统地排查方法，为了解决一个小问题浪费了大把的时间。而且写出的 BUG 太多将直接或间接影响绩效，影响同事、领导对你的印象。

阻碍初学者进步的往往是一叶障目不见泰山的盲目自信，往往是一成不变学习方法。破解上述尴尬的核心在于提高学习和排错能力。

为了解决上面提出诸多尴尬，本专栏的具体应对策略如下：

从学习方法主要切入点，结合源码，Java 语言规范 2 和 Java 虚拟机规范 3 等对《手册》的讲解和补充；
设计者角度思考问题，很多知识点将从设计者视角去思考分析问题，更容易理解问题的根源；
通过对开发中常用的思维导图、流程图和常见 UML 图的讲解，让大家可以 “大战需求分析”，前期明确需求，后期少返工；
通过单元测试、Code Review 等相关知识的学习和运用，促进代码质量的提升
通过独特的学习源码视角，来从正确的角度和方法来学习源码的精髓，反向促进日常的开发；
结合实际的开发经验，给出相关知识点掌握不牢容易造成的坑，给出一些避坑建议。
本专栏大多数章节的结构设计如下：

逻辑特色：采用 2w1h 分析方法，即是什么（what），为什么（why）和如何去做（how）的角度来学习知识；
问题驱动：采用 "5w 思考法"，即不断的追问逐渐思考问题的本质，从而实现知识理解的更加深入；
方法驱动：每节将使用一些学习和解决问题的方法，让大家可以掌握学习的章法；
对比和类比分析：大多数章节会对知识点和类似的知识点进行对比或类比，从而找出知识之间的联系和差异，加深对知识的理解；
坑点解读：讲解知识理解不到位可能造成的坑点，分析趟坑原因并给出避坑建议。
注：本专栏所涉及的 Java 源码均默认为 JDK 8 版本（特殊标注除外）。

技术是学不完的，学习能力和态度才是进阶的关键。作为一个技术人员，只有保持 “Stay Hungry， Stay Foolish” 的心态，才能够保持进取心；只有真正知道哪些才是更有价值的东西，才能真正少走弯路。

希望大家能够通本专栏的学习，改变学习技术的思维意识，从 “学习具体内容” 为主，转变到学习 “学习的方法” 为主；从技术的学习者变为技术的思考者。希望本专栏可以帮助到更多朋友加速技术成长的步伐，做一个更加专业和优秀的 Java 工程师。

参考资料
阿里巴巴与 Java 社区开发者.《 Java 开发手册 1.5.0》华山版. 2019 ↩︎

James Gosling, Bill Joy, Guy Steele, Gilad Bracha, Alex Buckley.《Java Language Specification: Java SE 8 Edition》. 2015 ↩︎

《The Java Virtual Machine Specification Java SE 8 Edition》 ↩︎

02 Integer缓存问题分析
精选留言 9
欢迎在这里发表留言，作者筛选后可公开显示
所相虚妄
《Java Language Specification: Java SE 8 Edition》怎么都是Java规范？不是JVM规范么？
 0回复2019-12-16
jutuco回复所相虚妄
java语言规范跟java虚拟机规范是两码事，一个是语法规则，给程序员看的；一个是虚拟机底层规范，虚拟机厂商甚至可以按照规范自行实现java虚拟机
回复4小时前
慕九州22958251
很棒
 2回复2019-11-27
明明如月回复慕九州22958251
多谢支持，希望对大家有帮助，少走弯路
回复2019-11-28 20:18:55
后居上
老师在群里帮我解答了个问题，过来支持下。
 2回复2019-11-24
慕慕4042121
校招时就请教过明明讲师，看过他分享的经验，相见恨晚，感觉之前的复习不得法浪费了好多时间。 校招拿到了美团、百世 Offer 前来还愿。买一份专栏，再深入学习一下。
 8回复2019-11-17
进阶拿offer
准备找java方向的工作，现在也都是学的知其然不知其所以然，所以尽管到spring，我也只是机械的知道咋用但是不知道为什么，所以心里一点都不踏实。相比于内容，更想学方法。又是一个开始了，希望有所获
 8回复2019-11-03
明明如月回复进阶拿offer
知其然而不知其所以然，主要原因是学习知识，侧重记忆而不是思考，很少思考是什么，为什么的问题，而只是记住了怎么做。 还有一点就是看源码的方法有很多，很多传统的方法容易迷失在细节中，后面源码学习小结会专门讲一些高效的读源码角度和技巧。 只要重视并找对方法，勇敢走出舒适区，一定可以学的更好。
回复2019-11-06 00:22:30
明明如月
大家购买前有啥疑问或者想和其他读者交流可以用base64算法解密以下内容： 5re75Yqg5b6u5L+hICBmZW5neWVsaWFvemhhaSAg5bm255WZ6KiA77ya5Yqg5YWl44CK5omL5YaM44CL6K+m6Kej5LiT5qCP6K+76ICF5Lqk5rWB576k44CC
 8回复2019-11-03
慕圣2554209
今年秋招得到学长的指点，对自己帮助很大。是啊，一定要跳出舒适区，不断学习，才会什么都不怕
 2回复2019-10-31
明明如月回复慕圣2554209
拿到offer是一个新的起点，在工作之前要深入学习工作中能够用到的核心技术栈，掌握工作的技巧，比如如何更好地分析需求，如何写出更优雅的代码等等。在入职之前学好这些，入职之后容易让领导刮目相看。
回复2019-10-31 22:19:32
明明如月回复慕圣2554209
加油，争取在工作中可以表现地更专业，更优秀。
回复2019-10-31 22:22:57
RED_MZ
好好学习，向心中的梦想出发
 2回复2019-10-30
明明如月回复RED_MZ
最怕的是不想学，最怕的是不愿意改变。只要心中有梦想，对编码感兴趣，有追求就一定能学好，希望本专栏能够帮你更快进阶，相信自己加油。
回复2019-10-30 22:14:42
大白白和小鱼鱼
最聪明的人是最不愿浪费时间的人。真的很幸运遇到明明学长，他是一个很用心做技术又乐于分享的人。从他嘴里说出最多的就是如何正确高效学习，以及多问为什么。确实如何思考问题，找到适合学习方法是非常重要的。多看源码，多思考，多总结。感谢学长的帮助，也希望自己也能像学长一样优秀。好好看专栏，并输出思维导图！！
 6回复2019-10-29
明明如月回复大白白和小鱼鱼
从小鱼鱼校招之前很久就认识了，她能够虚心听取建议，学习态度非常认真，给她推荐了一些重点图书，推荐了一些学习的方法，进步很快，最近也拿到了几个不错的offer。 另外希望大家看专栏更重要的是看解决问题的角度和方法，多思考而不是记录。在学习时看专栏前言提到的几个问题一定不要着急往下看，自己先思考（建议可以在云笔记或者白纸上列举一下自己的思考）再看下去进行对比，这样效果更好一些。 加油，一定会有更多收获！
回复举报2019-10-30 22:14:51
qq_阿难云意_0回复明明如月
不错，授人与渔，代码布道狮子

# 02 String、Long 源码解析和面试题

02 String、Long 源码解析和面试题

更新时间：2019-11-26 09:44:44

![img](https://img4.mukewang.com/5d6353210001e30406400359.jpg)

![img](https://www.imooc.com/static/img/column/bg-l.png)![img](https://www.imooc.com/static/img/column/bg-r.png)

劳动是一切知识的源泉。

——陶铸



## 引导语

String 和 Long 大家都很熟悉，本小节主要结合实际的工作场景，来一起看下 String 和 Long 的底层源码实现，看看平时我们使用时，有无需要注意的点，总结一下这些 API 都适用于哪些场景。



## 1 String



### 1.1 不变性

我们常常听人说，HashMap 的 key 建议使用不可变类，比如说 String 这种不可变类。这里说的不可变指的是类值一旦被初始化，就不能再被改变了，如果被修改，将会是新的类，我们写个 demo 来演示一下。

```java
String s ="hello";
s ="world";
```

从代码上来看，s 的值好像被修改了，但从 debug 的日志来看，其实是 s 的内存地址已经被修改了，也就说 s =“world” 这个看似简单的赋值，其实已经把 s 的引用指向了新的 String，debug 的截图显示内存地址已经被修改，两张截图如下：

![图片描述](https://img.mukewang.com/5d5fc04a0001c6a508840096.png)![图片描述](https://img.mukewang.com/5d5fc06400019cc210540090.png)我们从源码上查看一下原因：

```java
public final class String
    implements java.io.Serializable, Comparable<String>, CharSequence {
    /** The value is used for character storage. */
    private final char value[];
}    
```

我们可以看出来两点：

1. String 被 final 修饰，说明 String 类绝不可能被继承了，也就是说任何对 String 的操作方法，都不会被继承覆写；
2. String 中保存数据的是一个 char 的数组 value。我们发现 value 也是被 final 修饰的，也就是说 value 一旦被赋值，内存地址是绝对无法修改的，而且 value 的权限是 private 的，外部绝对访问不到，String 也没有开放出可以对 value 进行赋值的方法，所以说 value 一旦产生，内存地址就根本无法被修改。

以上两点就是 String 不变性的原因，充分利用了 final 关键字的特性，如果你自定义类时，希望也是不可变的，也可以模仿 String 的这两点操作。

因为 String 具有不变性，所以 String 的大多数操作方法，都会返回新的 String，如下面这种写法是不对的：

```java
String str ="hello world !!";
// 这种写法是替换不掉的，必须接受 replace 方法返回的参数才行，这样才行：str = str.replace("l","dd");
str.replace("l","dd");
```



### 1.2 字符串乱码

在生活中，我们经常碰到这样的场景，进行二进制转化操作时，本地测试的都没有问题，到其它环境机器上时，有时会出现字符串乱码的情况，这个主要是因为在二进制转化操作时，并没有强制规定文件编码，而不同的环境默认的文件编码不一致导致的。

我们也写了一个 demo 来模仿一下字符串乱码：

```java
String str  ="nihao 你好 喬亂";
// 字符串转化成 byte 数组
byte[] bytes = str.getBytes("ISO-8859-1");
// byte 数组转化成字符串
String s2 = new String(bytes);
log.info(s2);
// 结果打印为：
nihao ?? ??
```

打印的结果为？？，这就是常见的乱码表现形式。这时候有同学说，是不是我把代码修改成 `String s2 = new String(bytes,"ISO-8859-1");` 就可以了？这是不行的。主要是因为 ISO-8859-1 这种编码对中文的支持有限，导致中文会显示乱码。唯一的解决办法，就是在所有需要用到编码的地方，都统一使用 UTF-8，对于 String 来说，getBytes 和 new String 两个方法都会使用到编码，我们把这两处的编码替换成 UTF-8 后，打印出的结果就正常了。



### 1.3 首字母大小写

如果我们的项目被 Spring 托管的话，有时候我们会通过 `applicationContext.getBean(className);` 这种方式得到 SpringBean，这时 className 必须是要满足首字母小写的，除了该场景，在反射场景下面，我们也经常要使类属性的首字母小写，这时候我们一般都会这么做：

`name.substring(0, 1).toLowerCase() + name.substring(1);`，使用 substring 方法，该方法主要是为了截取字符串连续的一部分，substring 有两个方法：

1. `public String substring(int beginIndex, int endIndex)` beginIndex：开始位置，endIndex：结束位置；
2. `public String substring(int beginIndex)`beginIndex：开始位置，结束位置为文本末尾。

substring 方法的底层使用的是字符数组范围截取的方法 ：`Arrays.copyOfRange(字符数组, 开始位置, 结束位置);` 从字符数组中进行一段范围的拷贝。

相反的，如果要修改成首字母大写，只需要修改成 `name.substring(0, 1).toUpperCase() + name.substring(1)` 即可。



### 1.4 相等判断

我们判断相等有两种办法，equals 和 equalsIgnoreCase。后者判断相等时，会忽略大小写，近期看见一些面试题在问：如果让你写判断两个 String 相等的逻辑，应该如何写，我们来一起看下 equals 的源码，整理一下思路：

```java
public boolean equals(Object anObject) {
    // 判断内存地址是否相同
    if (this == anObject) {
        return true;
    }
    // 待比较的对象是否是 String，如果不是 String，直接返回不相等
    if (anObject instanceof String) {
        String anotherString = (String)anObject;
        int n = value.length;
        // 两个字符串的长度是否相等，不等则直接返回不相等
        if (n == anotherString.value.length) {
            char v1[] = value;
            char v2[] = anotherString.value;
            int i = 0;
            // 依次比较每个字符是否相等，若有一个不等，直接返回不相等
            while (n-- != 0) {
                if (v1[i] != v2[i])
                    return false;
                i++;
            }
            return true;
        }
    }
    return false;
}
```

从 equals 的源码可以看出，逻辑非常清晰，完全是根据 String 底层的结构来编写出相等的代码。这也提供了一种思路给我们：如果有人问如何判断两者是否相等时，我们可以从两者的底层结构出发，这样可以迅速想到一种贴合实际的思路和方法，就像 String 底层的数据结构是 char 的数组一样，判断相等时，就挨个比较 char 数组中的字符是否相等即可。



### 1.5 替换、删除

替换在工作中也经常使用，有 replace 替换所有字符、replaceAll 批量替换字符串、replaceFirst 替换遇到的第一个字符串三种场景。

其中在使用 replace 时需要注意，replace 有两个方法，一个入参是 char，一个入参是 String，前者表示替换所有字符，如：`name.replace('a','b')`，后者表示替换所有字符串，如：`name.replace("a","b")`，两者就是单引号和多引号的区别。

需要注意的是， replace 并不只是替换一个，是替换所有匹配到的字符或字符串哦。

写了一个 demo 演示一下三种场景：

```java
public void testReplace(){
  String str ="hello word !!";
  log.info("替换之前 :{}",str);
  str = str.replace('l','d');
  log.info("替换所有字符 :{}",str);
  str = str.replaceAll("d","l");
  log.info("替换全部 :{}",str);
  str = str.replaceFirst("l","");
  log.info("替换第一个 l :{}",str);
}
//输出的结果是：
替换之前 :hello word !!
替换所有字符 :heddo word !!
替换全部 :hello worl !!
替换第一个 :helo worl !!
```

当然我们想要删除某些字符，也可以使用 replace 方法，把想删除的字符替换成 “” 即可。



### 1.6 拆分和合并

拆分我们使用 split 方法，该方法有两个入参数。第一个参数是我们拆分的标准字符，第二个参数是一个 int 值，叫 limit，来限制我们需要拆分成几个元素。如果 limit 比实际能拆分的个数小，按照 limit 的个数进行拆分，我们演示一个 demo：

```java
String s ="boo:and:foo";
// 我们对 s 进行了各种拆分，演示的代码和结果是：
s.split(":") 结果:["boo","and","foo"]
s.split(":",2) 结果:["boo","and:foo"]
s.split(":",5) 结果:["boo","and","foo"]
s.split(":",-2) 结果:["boo","and","foo"]
s.split("o") 结果:["b","",":and:f"]
s.split("o",2) 结果:["b","o:and:foo"]
```

从演示的结果来看，limit 对拆分的结果，是具有限制作用的，还有就是拆分结果里面不会出现被拆分的字段。

那如果字符串里面有一些空值呢，拆分的结果如下：

```java
String a =",a,,b,";
a.split(",") 结果:["","a","","b"]
```

从拆分结果中，我们可以看到，空值是拆分不掉的，仍然成为结果数组的一员，如果我们想删除空值，只能自己拿到结果后再做操作，但 Guava（Google 开源的技术工具） 提供了一些可靠的工具类，可以帮助我们快速去掉空值，如下：

```java
String a =",a, ,  b  c ,";
// Splitter 是 Guava 提供的 API 
List<String> list = Splitter.on(',')
    .trimResults()// 去掉空格
    .omitEmptyStrings()// 去掉空值
    .splitToList(a);
log.info("Guava 去掉空格的分割方法：{}",JSON.toJSONString(list));
// 打印出的结果为：
["a","b  c"]
```

从打印的结果中，可以看到去掉了空格和空值，这正是我们工作中常常期望的结果，所以推荐使用 Guava 的 API 对字符串进行分割。

合并我们使用 join 方法，此方法是静态的，我们可以直接使用。方法有两个入参，参数一是合并的分隔符，参数二是合并的数据源，数据源支持数组和 List，在使用的时候，我们发现有两个不太方便的地方：

1. 不支持依次 join 多个字符串，比如我们想依次 join 字符串 s 和 s1，如果你这么写的话 `String.join(",",s).join(",",s1)` 最后得到的是 s1 的值，第一次 join 的值被第二次 join 覆盖了；
2. 如果 join 的是一个 List，无法自动过滤掉 null 值。

而 Guava 正好提供了 API，解决上述问题，我们来演示一下：

```java
// 依次 join 多个字符串，Joiner 是 Guava 提供的 API
Joiner joiner = Joiner.on(",").skipNulls();
String result = joiner.join("hello",null,"china");
log.info("依次 join 多个字符串:{}",result);

List<String> list = Lists.newArrayList(new String[]{"hello","china",null});
log.info("自动删除 list 中空值:{}",joiner.join(list));
// 输出的结果为；
依次 join 多个字符串:hello,china
自动删除 list 中空值:hello,china
```

从结果中，我们可以看到 Guava 不仅仅支持多个字符串的合并，还帮助我们去掉了 List 中的空值，这就是我们在工作中常常需要得到的结果。



## 2 Long



### 2.1 缓存

Long 最被我们关注的就是 Long 的缓存问题，Long 自己实现了一种缓存机制，缓存了从 -128 到 127 内的所有 Long 值，如果是这个范围内的 Long 值，就不会初始化，而是从缓存中拿，缓存初始化源码如下：

```java
private static class LongCache {
    private LongCache(){}
    // 缓存，范围从 -128 到 127，+1 是因为有个 0
    static final Long cache[] = new Long[-(-128) + 127 + 1];

    // 容器初始化时，进行加载
    static {
        // 缓存 Long 值，注意这里是 i - 128 ，所以再拿的时候就需要 + 128
        for(int i = 0; i < cache.length; i++)
            cache[i] = new Long(i - 128);
    }
}
```



## 3 面试题



### 3.1 为什么使用 Long 时，大家推荐多使用 valueOf 方法，少使用 parseLong 方法

答：因为 Long 本身有缓存机制，缓存了 -128 到 127 范围内的 Long，valueOf 方法会从缓存中去拿值，如果命中缓存，会减少资源的开销，parseLong 方法就没有这个机制。



### 3.2 如何解决 String 乱码的问题

答：乱码的问题的根源主要是两个：字符集不支持复杂汉字、二进制进行转化时字符集不匹配，所以在 String 乱码时我们可以这么做：

1. 所有可以指定字符集的地方强制指定字符集，比如 new String 和 getBytes 这两个地方；
2. 我们应该使用 UTF-8 这种能完整支持复杂汉字的字符集。



### 3.3 为什么大家都说 String 是不可变的

答：主要是因为 String 和保存数据的 char 数组，都被 final 关键字所修饰，所以是不可变的，具体细节描述可以参考上文。



### 3.4 String 一些常用操作问题，如问如何分割、合并、替换、删除、截取等等问题

答：这些都属于问 String 的基本操作题目，考察我们平时对 String 的使用熟练程度，可以参考上文。



## 总结

String 和 Long 在我们工作中使用频率很高，在面试的过程中，考官也喜欢问一些关于实际操作的问题，来考察我们的使用熟练度，所以本文中列举的一些 demo，大家可以试试手，完整的代码可以去 GitHub 上面去拉取。

[01 开篇词：为什么学习本专栏](https://www.imooc.com/read/47/article/843)[03 Java 常用关键字理解](https://www.imooc.com/read/47/article/845)

精选留言 58

欢迎在这里发表留言，作者筛选后可公开显示

- [yan羽](https://www.imooc.com/u/6765180/articles)

  replace替换所有字符和替换字符串有什么区别

   0

  回复

  1天前

- [Vince_Lin](https://www.imooc.com/u/7200978/articles)

  replace和replaceAll的区别好像有点模凌两可，区别是什么

   0

  回复

  4天前

  - [火星活那么](https://www.imooc.com/u/2064493/articles)

    回复[Vince_Lin](https://www.imooc.com/u/7200978/articles)

    replaceAll支持正则吧<br />

    回复

    3天前

- [calvinsheng](https://www.imooc.com/u/4470896/articles)

  源码地址是？

   0

  回复

  5天前

  - [初一](https://www.imooc.com/u/7789740/articles)

    回复[calvinsheng](https://www.imooc.com/u/4470896/articles)

    同学你好，源码地址在第四节。

    回复

    5天前

- [慕仔7214391](https://www.imooc.com/u/7485583/articles)

  int n = value.length;老师，这个equald源码 的这个value哪里来的

   1

  回复

  2019-12-14

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[慕仔7214391](https://www.imooc.com/u/7485583/articles)

    value 是 String 的 char 的数组哈。

    回复

    2019-12-16 17:33:38

- [走出深坑_爬出井底](https://www.imooc.com/u/8009711/articles)

  1.6拆分与合并： String的join方法无法连续使用，是因为join方法处理的是参数elements中的元素吧，是将elements中的元素合并，他与调用join方法的字符串对象本身是没有任何关系的。

   0

  回复

  2019-12-04

- [甜树果子二号](https://www.imooc.com/u/6374311/articles)

  面试题3.1有疑惑 public static long parseLong(String s);// 返回值是基本数据类型 public static Long valueOf(String s);// 返回的是包装类型 一个方法返回的是基本数据类型，一个方法返回的是包装类型，只基于缓存命中这方面，这两者应该没有可比性吧，真的需要包装类型，也会自动装箱，一样的会命中缓存

   0

  回复

  2019-11-27

  - [qq_阿福_7](https://www.imooc.com/u/5868692/articles)

    回复[甜树果子二号](https://www.imooc.com/u/6374311/articles)

    同意你的说法。 字数你妹。

    回复

    2019-12-04 11:21:01

  - [慕神9346227](https://www.imooc.com/u/7808597/articles)

    回复[甜树果子二号](https://www.imooc.com/u/6374311/articles)

    大概是如果要String-&gt;Long的转换用valueOf会多一个取缓存的优化，这是对装箱的优化

    回复

    2019-12-06 15:56:31

- [Lxiaoyueyue](https://www.imooc.com/u/2850611/articles)

  感觉讲重写equals方法，就只讲了String对象的实现，写的很针对。没有拓展重写equals方法应该遵循的规律，更期待的解答的是，在什么情况用getclass，在什么情况下用instanceof 检测两个对象是否属于同一个类

   0

  回复

  2019-11-25

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[Lxiaoyueyue](https://www.imooc.com/u/2850611/articles)

    equals 覆写的规律和文中 String 中的 equals 方法一样，我是希望通过 String 的 equals 方法给大家提供一种覆写的思路。比如说给你一个对象 DTO，如何覆写 equals 呢？我们可以使用 idea 自带生成 equals 的方法，也可以把依次判断 DTO 的各个属性。至于你说的 getClass，instanceof 属于另外的内容哈，可能不能符合每个读者的口味了。

    回复

    2019-11-30 13:40:59

  - [朱瘦肉](https://www.imooc.com/u/6115724/articles)

    回复[Lxiaoyueyue](https://www.imooc.com/u/2850611/articles)

    instanceof 要求操作对象与类有继承关系

    回复

    15小时前

- [窗下有梧桐](https://www.imooc.com/u/5101563/articles)

  我觉得String的不变性不在于final修饰，因为char[]不属于基本类型，即引用不能改变，但是引用地址的值可以改变。String的不变性应该是由于它底层的源码导致的，每次给String的引用赋值其实是创建了一个新的对象。不知道我这么理解有没有问题

   1

  回复

  2019-11-21

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[窗下有梧桐](https://www.imooc.com/u/5101563/articles)

    你可以用反证法想一下，如果 String 没有 final 修饰会怎么样？

    回复

    2019-11-23 16:37:07

- [qq_慕哥2339582](https://www.imooc.com/u/8238904/articles)

  老师，我想问一下，Integer a = new Integer（12）创建了几个对象，它在内存中的存储过程是怎样的

   0

  回复

  2019-11-02

  - [古卷](https://www.imooc.com/u/6402661/articles)

    回复[qq_慕哥2339582](https://www.imooc.com/u/8238904/articles)

    目测是创建一个对象。

    回复

    2019-11-04 11:56:39

  - [xiaobaicaisss](https://www.imooc.com/u/6700857/articles)

    回复[qq_慕哥2339582](https://www.imooc.com/u/8238904/articles)

    目测是2个，一个在堆，一个在栈

    回复

    2019-11-20 19:45:15

- [qq_慕哥2339582](https://www.imooc.com/u/8238904/articles)

  老师你好，string的常量池和long的缓冲池作用是一样的吗？也能起到一个存储的作用

   0

  回复

  2019-11-01

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[qq_慕哥2339582](https://www.imooc.com/u/8238904/articles)

    同学你好，是的，原理是一样的，但是底层实现机制不同，都是起一个缓存的作用。

    回复

    2019-11-04 10:12:58

- [ChangleAmazing](https://www.imooc.com/u/5585445/articles)

  老师，还是想问下 Long.valueOf(String) 和 Long.parseLong(String) 的问题。 源码中 valueOf 实际上也是调用了 parseLong 之后才走缓存的吧。即使是有缓存，应该会比 parseLong 更慢啊。

   2

  回复

  2019-10-30

- [凉话](https://www.imooc.com/u/1243425/articles)

  static final Long cache[] = new Long[-(-128) + 127 + 1]; 老师这一句话怎么就直接缓存了256个数字

   0

  回复

  2019-10-30

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[凉话](https://www.imooc.com/u/1243425/articles)

    同学你好，cache.length 是 256 哈，其实下面还有代码的： static { for(int i = 0; i &lt; cache.length; i++) cache[i] = new Long(i - 128); }

    回复

    2019-10-31 10:50:59

  - [xiaobaicaisss](https://www.imooc.com/u/6700857/articles)

    回复[凉话](https://www.imooc.com/u/1243425/articles)

    下面那个静态代码块才是真正的缓存数据，类加载的时候静态代码块也运行，相当于把一个游泳池蓄上水，这里就相当于把那个数组里-128到127装满

    回复

    2019-11-20 19:52:09

- [studyHardHard](https://www.imooc.com/u/8081759/articles)

  如果有StringBuffet和StringBuilder，立马下单

   0

  回复

  2019-10-18

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[studyHardHard](https://www.imooc.com/u/8081759/articles)

    同学你好，没有的哈，StringBuffer 和 StringBuilder 比较简单，一个面试题就能说完，难以写成一篇文档，所以我们没有放进课程内容里面，不过有问题可以留言互相交流哈。

    回复

    2019-10-19 10:49:53

  - [studyHardHard](https://www.imooc.com/u/8081759/articles)

    回复

    [文贺](https://www.imooc.com/u/8062574/articles)

    不简单吧，比如3者底层数组的扩容机制有什么不同，线程是否安全，各自的使用场景。还有就是关于String常量池， + 在进行String操作时底层调用的是StringBuilder。还有就是经典的求一段字符串操作创建了几个对象的问题，这些有的写的

    回复

    2019-10-20 09:21:21

  - [慕仙6328494](https://www.imooc.com/u/7573629/articles)

    回复[studyHardHard](https://www.imooc.com/u/8081759/articles)

    ……你这个也太基础了吧 如果真写这些，这个专栏感觉档次下降一般

    回复

    2019-11-20 18:55:24

- [Blue_Fish0323](https://www.imooc.com/u/1110029/articles)

  intern 这个方法的分析没有嘛？还是在后面有？

   0

  回复

  2019-10-17

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[Blue_Fish0323](https://www.imooc.com/u/1110029/articles)

    同学你好，没有的哈，intern 方法几乎没有看见有同学实际用过，但有问题可以交流。

    回复

    2019-10-19 10:47:51

- [yaDONGgua](https://www.imooc.com/u/6769190/articles)

  String s ="boo:and:foo"; s.split("o")； 运行结果是["b","",":and:f"] 为什么不是["b","",":and:f",""] ??

   0

  回复

  2019-10-16

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[yaDONGgua](https://www.imooc.com/u/6769190/articles)

    同学你好，在源码的 2361 while 代码处删除了“”。

    回复

    2019-10-17 19:13:26

- [喵喵喵111](https://www.imooc.com/u/7563198/articles)

  老师，parseint缓存中有没有127啊

   0

  回复

  2019-10-10

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[喵喵喵111](https://www.imooc.com/u/7563198/articles)

    同学你好，parseInt不走缓存哈，你应该想问Integer 缓存的范围是吧，从 -128到127，-128 和 127都包含，源码为：if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; IntegerCache.low 为 -128，IntegerCache.high 为 127

    回复

    2019-10-10 23:09:48

- [大胖晴](https://www.imooc.com/u/5171712/articles)

  使用split函数，去分割字符串oob:ooa:coo,以字符o分割，为啥，显示的是 "","","b:","","a:c" 老师，这里分割后，为啥前面2个连在一起的o可以展示出2个空字符串， 而中间的ooa这一块，只有一个空字符串"",而末尾coo,一个都没有呢，麻烦老师给解答下,谢谢！

   0

  回复

  2019-10-09

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[大胖晴](https://www.imooc.com/u/5171712/articles)

    中间的“”在源码 2339 行被干掉了，最后两个“”在源码 2361 while 循环被干掉了，同学可以自己debug下哈，谢谢。

    回复

    2019-10-11 19:27:35

- [西贝小仙人](https://www.imooc.com/u/6988426/articles)

  idea怎么导入jdk源码，进行debug。然后在源码地方记录笔记

   0

  回复

  2019-10-03

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[西贝小仙人](https://www.imooc.com/u/6988426/articles)

    同学你好，我们在 git上有 jdk源码的项目，可以直接导入到 idea 中，里面都是debug过的注释，第三节评论区应该有地址。debug 的时候，跳转的还是 jdk 的只可读源码。

    回复

    2019-10-04 11:20:29

- [Eric_余浩](https://www.imooc.com/u/3002030/articles)

  请问作者 idea 使用的是那个版本，我使用的是 2018.2.8 版本，在debug 是无法看到String 变量的哈希值。 以至于我只好使用 System.identityHashCode(Object) 来打印出 对象的内存地址。

   0

  回复

  2019-09-29

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[Eric_余浩](https://www.imooc.com/u/3002030/articles)

    你好同学，版本号：2019.02

    回复

    2019-09-29 19:21:45

- [慕婉清3506321](https://www.imooc.com/u/7009480/articles)

  没有微信群哈老师，只有QQ呀

   0

  回复

  2019-09-29

  - [初一](https://www.imooc.com/u/7789740/articles)

    回复[慕婉清3506321](https://www.imooc.com/u/7009480/articles)

    你的微信号多少呀，我来拉你进群^-^

    回复

    2019-09-29 09:44:36

  - [孙DONG](https://www.imooc.com/u/2370644/articles)

    回复[初一](https://www.imooc.com/u/7789740/articles)

    拉我，微信号：SKD1206

    回复

    2019-11-26 23:02:09

  - [阿阿阿阿阿秀](https://www.imooc.com/u/1872429/articles)

    回复[初一](https://www.imooc.com/u/7789740/articles)

    拉我进群，谢谢。。紫薯布丁

    回复

    32分钟前

- [拾灬荒灬者](https://www.imooc.com/u/5658415/articles)

  对比另外一个资料，我有一个小疑惑，string一旦被初始化，其内存地址是无法被修改的，也就是说，初始化时的内存地址指向的那个值，是确定的。即使给对象重新赋值，也是返回一个新的内存地址。问题是，那我在做两个string对象的比较时，假如内存地址不一样，就可以直接返回false,内存地址一样的时候，下面几步的判断验证是为了防止什么情况？因为string对象的底层是char[]也是用final修饰，且其权限是private没有可能被外部访问重新赋值。后面关于是否是同一类型，char[]中的值比较的目的是为了排除什么情况呢？这个地方我知道这么写更严谨，但是这个问题一直没思考清楚。

   0

  回复

  2019-09-24

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[拾灬荒灬者](https://www.imooc.com/u/5658415/articles)

    这个不好意思哈，这个问题到底是啥，没有看懂，你可以贴出你比较纠结的代码哈。

    回复

    2019-09-25 14:10:34

  - [拾灬荒灬者](https://www.imooc.com/u/5658415/articles)

    回复

    [文贺](https://www.imooc.com/u/8062574/articles)

    equals方法判断两个string字符串是否相等。初始化之后，因为其value值是private权限，所以，无法被改变。如果两个string是一样的话，为什么要比完内存地址是否一样还继续后面的。 产生疑问的原因是：string地址是不可被修改的，虽然其value值理论上可以改变，但是string类内部没有提供修改value值的方法，内部也没有对value值进行操作。那equals方法里面比较后面对象是否一致，比较char数组中的每一个值是否相同不就没有必要了吗？所以想问问，后面的是比较是否有必要，其作对比，是为了排除哪种情况？

    回复

    2019-09-25 20:46:26

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[拾灬荒灬者](https://www.imooc.com/u/5658415/articles)

    理解了，我最近理解问题的能力越来越差了，总结一下，你的问题是：为什么 String equals 方法里面用 == 来判断内存地址？ 猜测两个原因：1：这个是 equals 的实现规范(大概5条约定)，判断的时候先用 == 判断，再使用 instanceof 进行具体的判断，IDEA 自动帮我们生成 equals 方法就是这种规范，你可以自己自定义类，然后使用 IDEA 自动帮我们生成 equals 方法的功能，你会发现生成的equals实现就是这种思路。 2："nihao".equals("nihao") 这种写法中，两个字符串的内存地址是一样的，使用 == 即可判断。 总结：equals 实现规范 + "nihao".equals("nihao") ，你在 equals 里面去掉 == 也是木有问题的，ps：这种问题无需纠结哈。

    回复

    2019-09-26 09:31:34

  点击展开后面 3 条

- [qq_电耗子_0](https://www.imooc.com/u/2177358/articles)

  String s ="boo:and:foo"; s.split("o") 结果:["b","",":and:f"] 不明白为何boo会有""，而后面的foo没有""

   2

  回复

  2019-09-24

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[qq_电耗子_0](https://www.imooc.com/u/2177358/articles)

    jDK 8 String 源码 2361~2362 行，有个 while 循环去掉的，同学可以自己 debug 下印象更加深刻。

    回复

    2019-09-25 14:08:00

- [和尚码代码](https://www.imooc.com/u/7388288/articles)

  这几天面试，被问到了，为什么要设计String为不可变对象

   0

  回复

  2019-09-22

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[和尚码代码](https://www.imooc.com/u/7388288/articles)

    这个问题是没有标准答案的，只要你能说出来几点来，基本都可以过，可以从两个方面来回答以下，一个是不可变有哪些好处，第二个源码是如何实现不可变(加分)，不可变的好处：1：方便使用字符串常量池，节省开销。2：不可变避免了引用传值，是线程安全的，如何实现不可变的就是源码中提到的两点。

    回复

    2019-09-23 11:00:43

- [youngDonkey](https://www.imooc.com/u/7312824/articles)

  老师如何理解instanceof 这个关键词？

   0

  回复

  2019-09-19

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[youngDonkey](https://www.imooc.com/u/7312824/articles)

    主要用来判断变量的类型，通常变量都是 Object，然后通过 instanceof 来判断变量的类型是否和我们想要的一致，比如判断变量o 的类型是不是 String：o instanceof String，返回的结果是布尔值，true 表示类型相同，flase 不同

    回复

    2019-09-19 19:41:59

  - [youngDonkey](https://www.imooc.com/u/7312824/articles)

    回复

    [文贺](https://www.imooc.com/u/8062574/articles)

    《JAVA核心技术一卷》中，作者认为当otherObject为检测类子类的时候，使用instanceof不但解决不了问题还有可能会招致一些麻烦，什么情况下会有这种麻烦，而您又怎么看待这个问题？

    回复

    2019-09-20 14:30:25

  - [华珠王健杰](https://www.imooc.com/u/4163033/articles)

    回复[youngDonkey](https://www.imooc.com/u/7312824/articles)

    这里这个instanceof存在的目的是为下面多态的向下转型做准备。如果不使用instanceof判断的话。可能会抛出类转换异常

    回复

    2019-09-24 17:03:57

  点击展开后面 6 条

- [weixin_南宋朝北_0](https://www.imooc.com/u/5187527/articles)

  Long.StringOf(String)再走缓存之前会先去执行parseLong方法，不应该比parseLong（String）更慢吗？ return Long.valueOf(parseLong(s, 10));

   0

  回复

  2019-09-18

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[weixin_南宋朝北_0](https://www.imooc.com/u/5187527/articles)

    见下面运行 demo 哈，有运行示例。

    回复

    2019-09-18 20:43:50

  - [qq_知我者谓我心忧_4](https://www.imooc.com/u/5865002/articles)

    回复[weixin_南宋朝北_0](https://www.imooc.com/u/5187527/articles)

    同问，jdk10版本源码是这样写的

    回复

    2019-09-18 21:05:51

  - [qq_知我者谓我心忧_4](https://www.imooc.com/u/5865002/articles)

    回复[weixin_南宋朝北_0](https://www.imooc.com/u/5187527/articles)

    valueOf(Long l) 的源码用的是缓存，-128 - 127，但是valueOF（String s）是你说的先调用parseLong(s, 10).所以你是不是看错了

    回复

    2019-09-18 21:10:22

  点击展开后面 4 条

- [莨菽菽](https://www.imooc.com/u/4586503/articles)

  equals的源码分析那里是不是有点问题，anotherString.value是点不出来的把，因为是private修饰的，我去试着验证的时候都是报variable has private access

   0

  回复

  2019-09-17

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[莨菽菽](https://www.imooc.com/u/4586503/articles)

    可以的哈，可以看回复中：小明同学爱思考同学的提问哈，已经回答了这个问题。

    回复

    2019-09-17 18:31:53

- [慕九州4198528](https://www.imooc.com/u/6543770/articles)

  问一下这个课程什么时候更新完额

   1

  回复

  2019-09-14

  - [慕九州22958251](https://www.imooc.com/u/6600521/articles)

    回复[慕九州4198528](https://www.imooc.com/u/6543770/articles)

    我也想知道什么时间能更新完成呢？

    回复

    2019-10-08 12:02:44

- [慕仰8481155](https://www.imooc.com/u/8132973/articles)

  关于parseLong与valueOf我的实验结果与老师的结论是相反的，当循环次数足够大时显示，前者总是比后者耗时短，我的循环次数是Integer最大值，并且结论与前后两者的代码位置位置无关。希望老师指正，我是不是有什么误解。

   0

  回复

  2019-09-12

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[慕仰8481155](https://www.imooc.com/u/8132973/articles)

    一般面试官出题，都是根据源码找到一个可以问的点，然后包装一下。此处可以面试的点就是 Long 对 -128 到 127 之间的数字进行了缓存，此处缓存的区间是我们工作中经常用到的区间，所以此处优化是有范围的，验证的时候，最好也在这个区间内验证，具体的验证代码和效果可以见下面的回复。这个面试题也是经常问到的题目哦，能 get 到面试官的点就好了。

    回复

    2019-09-15 09:34:58

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复

    [文贺](https://www.imooc.com/u/8062574/articles)

    如果你的确比较纠结的话，可以 show your code，我们一起来看看。

    回复

    2019-09-15 09:56:55

- [心跳7](https://www.imooc.com/u/3417828/articles)

  写的不错

   0

  回复

  2019-09-11

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[心跳7](https://www.imooc.com/u/3417828/articles)

    感谢支持肯定，持续努力加油中。

    回复

    2019-09-11 17:42:50

- [qq_慕设计3195642](https://www.imooc.com/u/7743713/articles)

  面试题3.1，您想说明的是一个用缓存，一个不用缓存，但是valueOf返回的Long,parseLong返回的long这两个根本就没有可比较性吧。看了您下面写的那个demo,parseLong运行的比较慢是因为它需要将string计算得到一个long类型的值，所以比较耗时，和走不走缓存没有多大关系吧。如果说是走不走缓存的应该拿 valueOf与 new Long()来比较才是合适的。

   1

  回复

  2019-09-09

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[qq_慕设计3195642](https://www.imooc.com/u/7743713/articles)

    可以仔细看下底层实现哈，valueOf(String s) 和 parseLong(String s) 底层实现就是前者走了缓存，后者没有，两者都有字符串转化成 Long 的逻辑哈。你说的这个比较也是一个例子，但在实际工作中不常用的哈。

    回复

    2019-09-10 14:18:38

  - [hetianxing668](https://www.imooc.com/u/234785/articles)

    回复[qq_慕设计3195642](https://www.imooc.com/u/7743713/articles)

    受教了，以后多多分享类似文章。

    回复

    2019-09-11 09:20:35

  - [power_cheng4342740](https://www.imooc.com/u/4342740/articles)

    回复

    [文贺](https://www.imooc.com/u/8062574/articles)

    源码中valueOf(String)和parseLong(String)都是调用parseLong(String, int). parseLong(String)是直接将调用的结果返回, 也就是说这个地方应用了自动装箱,即调用了valueOf(long)方法, 这样看来其实parseLong(String)方法也用到了缓存. Long a = Long.parseLong("100"); Long b = Long.parseLong("100"); System.out.println(a == b); // true

    回复

    2019-09-11 10:04:30

  - [qq_慕哥2339582](https://www.imooc.com/u/8238904/articles)

    回复[power_cheng4342740](https://www.imooc.com/u/4342740/articles)

    同学，为什么parseLong也有缓存的作用啊.

    回复

    2019-11-01 13:01:01

- [呢喃北上](https://www.imooc.com/u/1880706/articles)

  老师怎么进微信群 好像只看到qq

   0

  回复

  2019-09-09

  - [初一](https://www.imooc.com/u/7789740/articles)

    回复[呢喃北上](https://www.imooc.com/u/1880706/articles)

    手机端可以进微信群的

    回复

    2019-09-09 18:35:51

  - [qq_电耗子_0](https://www.imooc.com/u/2177358/articles)

    回复[呢喃北上](https://www.imooc.com/u/1880706/articles)

    哪里有微信的扫码

    回复

    2019-09-24 17:52:29

  - [洗衣粉1](https://www.imooc.com/u/2930191/articles)

    回复[初一](https://www.imooc.com/u/7789740/articles)

    你好，手机端怎么进微信群，没找到

    回复

    2019-09-26 15:17:56

- [慕容课网](https://www.imooc.com/u/3963123/articles)

  老师可以解释下，String s = "hello" 这种字符常量直接赋值，此时的String 是怎么构造出来的吗

   0

  回复

  2019-09-08

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[慕容课网](https://www.imooc.com/u/3963123/articles)

    在编译的时候，就已经确认了如何构造 String，理解这个可能需要一点 JVM 知识，你按照下面的步骤自己运行一下哈。 demo 代码：public final class StringDemo { private String s ="hello";@Test public void say() { System.out.println(s); }}。

    回复

    2019-09-09 14:24:11

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复

    [文贺](https://www.imooc.com/u/8062574/articles)

    然后把这个代码编译一下，找到 StringDemo.class，接着执行 ：javap -verbose StringDemo.class，然后就会出现一长串的信息，你可以找到以下几个东西： 1：Constant pool(常量池) 里面找到 hello。 2：StringDemo() 的 code 里面找到 ldc 和 putfield 两个 jvm 指令，ldc 表示从常量池拿出 hello，做入栈的操作，putfield 表示给 s 赋值。 1 和 2 完成了初始化 StringDemo 类时，对变量 s 赋值 123。 3：接着看 say() 方法里面有个 getfield 指令，表示从拿出变量 s 的值，意思是执行 say() 方法时，通过这个 jvm 指令拿到 hello 值。

    回复

    2019-09-09 14:24:20

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复

    [文贺](https://www.imooc.com/u/8062574/articles)

    总结一下： 1：hello 在编译的时候，就已经确定是放在常量池里面的。 2：String s ="hello" 赋值操作，是在类初始化的时候，通过 ldc 和 putfield 两个 jvm 指令配置完成。 3：如果想要 s 的值，通过 getfield jvm 指令完成。

    回复

    2019-09-09 14:24:27

- [慕码人1304121](https://www.imooc.com/u/8120822/articles)

  String 被 final 修饰，说明 String 类绝不可能被继承了，也就是说任何对 String 的操作方法，都不会被继承覆写；这里的覆写有没有问题，重写吧

   1

  回复

  2019-09-08

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[慕码人1304121](https://www.imooc.com/u/8120822/articles)

    没有问题哦，重写和覆写是同一个意思哦，都是 override 的意思哈，只是叫法不同。

    回复

    2019-09-08 10:02:42

  - [丶zhanwei](https://www.imooc.com/u/6088796/articles)

    回复

    [文贺](https://www.imooc.com/u/8062574/articles)

    0我0额07我哦0是0叵测XP0好

    回复

    2019-09-09 08:33:21

  - [慕勒9548534](https://www.imooc.com/u/7592385/articles)

    回复[丶zhanwei](https://www.imooc.com/u/6088796/articles)

    这是没用utf-8么

    回复

    2019-09-09 18:54:13

- [慕瓜306993](https://www.imooc.com/u/6835837/articles)

  关于面试第一题的 使用包装类Long 更多的使用valueOf而不是使用parseLong 的应用场景 是什么？ valueOf是为了得到基本数据类型，parseLong是为了得到包装类 不应该按具体需求来选择吗？

   1

  回复

  2019-09-06

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[慕瓜306993](https://www.imooc.com/u/6835837/articles)

    文中说的很清楚了哈，主要是根据性能优先哈。

    回复

    2019-09-06 12:47:58

- [最怕认真](https://www.imooc.com/u/1899708/articles)

  不可变，还是理解不够透彻，希望再多说明一下，多画图，值改变和引用地址改变，傻傻分不清啊

   0

  回复

  2019-09-06

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[最怕认真](https://www.imooc.com/u/1899708/articles)

    好的哈，可以进微信群，今天上午群里面还讨论这个问题。

    回复

    2019-09-06 12:48:48

  - [音殿](https://www.imooc.com/u/4730658/articles)

    回复

    [文贺](https://www.imooc.com/u/8062574/articles)

    老师 微信群在哪呀?我怎么找不到

    回复

    2019-10-09 11:42:32

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[音殿](https://www.imooc.com/u/4730658/articles)

    可以加慕课网小姐姐微信：Mukewang666 回复进群口令（四位“字母+数字”组合），即可进群，具体进群口令在那里，你可以问这个微信的小姐姐，谢谢。

    回复

    2019-10-09 13:10:43

- [剑轩](https://www.imooc.com/u/1268748/articles)

  嗯？String为参数时还是使用valueOf，long为参数又没有意义（自动拆装箱）。 public static Long valueOf(String s) throws NumberFormatException { return Long.valueOf(parseLong(s, 10)); }

   0

  回复

  2019-09-05

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[剑轩](https://www.imooc.com/u/1268748/articles)

    没说入参是long哦，是使用 Long 类时，我们尽量多用 valueOf 方法哦。

    回复

    2019-09-05 16:56:18

- [又帅又潇洒](https://www.imooc.com/u/6393421/articles)

  String和其value[]为什么要用final修饰？ String可以说是Java项目中使用频率最高的类不为过，综合考虑到资源性能方面和安全角度等，使用final修饰。比如，在创建String时Jvm会先去常量池寻找已有的缓冲常量，如果String没有被final修饰，这个时候被修改了其值，则可能会导致不可预料的问题。

   1

  回复

  2019-09-04

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[又帅又潇洒](https://www.imooc.com/u/6393421/articles)

    是的，你说的很棒，给你点赞。

    回复

    2019-09-05 16:52:35

- [慕盖茨3494964](https://www.imooc.com/u/6964549/articles)

  方法 Long.valueOf（long类型入参）会从cache中拿。 而Long.valueOf（string类型入参）不会。

   0

  回复

  2019-09-04

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[慕盖茨3494964](https://www.imooc.com/u/6964549/articles)

    两者都会走，入参String 的底层实现：Long.valueOf(parseLong(s, 10));最终还是会走缓存。

    回复

    2019-09-04 14:10:00

- [慕盖茨3494964](https://www.imooc.com/u/6964549/articles)

  s.split("o") 结果:["b","",":and:f"] 这结果。。。确定正确吗？

   0

  回复

  2019-09-04

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[慕盖茨3494964](https://www.imooc.com/u/6964549/articles)

    正确的，你本地跑一边就知道了哈。

    回复

    2019-09-04 14:09:06

- [旧念何挽](https://www.imooc.com/u/274480/articles)

  源码的Github地址可以发送一下吗？

   0

  回复

  2019-09-03

  - [初一](https://www.imooc.com/u/7789740/articles)

    回复[旧念何挽](https://www.imooc.com/u/274480/articles)

    我在第三节文章里有发过链接，你可以去看下

    回复

    2019-09-03 14:26:51

  - [初一](https://www.imooc.com/u/7789740/articles)

    回复[旧念何挽](https://www.imooc.com/u/274480/articles)

    第三节的评论里哟~~

    回复

    2019-09-03 14:28:01

  - [ComputerMan](https://www.imooc.com/u/6578339/articles)

    回复[初一](https://www.imooc.com/u/7789740/articles)

    你好，请问源码的地址是多少呀？

    回复

    2019-12-19 17:10:39

- [鹏飞天下](https://www.imooc.com/u/1010756/articles)

  老师在String里面的equals方法中，有这样 一个判断 n == anotherString.value.length ，我想问antherString他是一个字符串，他的value是私有的，为什么在这里可以直接引用，原理是啥原因呢？

   0

  回复

  2019-09-03

  - [慕粉TYJ](https://www.imooc.com/u/3172107/articles)

    回复[鹏飞天下](https://www.imooc.com/u/1010756/articles)

    java的private修饰符只是类级别的，并不是对象级别的。换句话说。同一个类的不同对象，在类的作用域里是可以互相访问彼此的私有属性的

    回复

    2019-09-03 12:59:40

  - [莨菽菽](https://www.imooc.com/u/4586503/articles)

    回复[慕粉TYJ](https://www.imooc.com/u/3172107/articles)

    你自己写了就知道了，value也是private修饰的，你点value出来报variable has private access

    回复

    2019-09-17 15:10:19

  - [慕粉TYJ](https://www.imooc.com/u/3172107/articles)

    回复[莨菽菽](https://www.imooc.com/u/4586503/articles)

    啥？回复错人了吧同学

    回复

    2019-09-17 15:48:27

- [慕设计6098684](https://www.imooc.com/u/6524787/articles)

  感觉深度不够啊，说实话有点失望，希望后面写的能更深入点吧！

   0

  回复

  2019-09-02

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[慕设计6098684](https://www.imooc.com/u/6524787/articles)

    第一章主要说基础，String、Long 属于 Java 基础部分，也是常问的面试题之一。后面队列、线程池、锁都很复杂。

    回复

    2019-09-02 12:21:21

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[慕设计6098684](https://www.imooc.com/u/6524787/articles)

    String、Long 本身就很简单，第一章就是基础，都不难，主要是因为这些内容在初级面试时有时候会被问道，再就是为整篇课打下基础，越往后，难度会越来越大，特别是到了队列、线程池、锁的章节。咱们整个课程一共48小节，涵盖了整个 Java 核心的源码解析和心得，如果对这小节很熟悉，建议直接跳过，谢谢。

    回复

    2019-09-02 13:20:40

- [迹游](https://www.imooc.com/u/6089857/articles)

  老师那里能下载Guava的jar包，我在网上没找到

   0

  回复

  2019-09-01

  - [有没有没被占用的昵称](https://www.imooc.com/u/4911996/articles)

    回复[迹游](https://www.imooc.com/u/6089857/articles)

    https://mvnrepository.com搜一下就行

    回复

    2019-09-02 10:42:39

- [慕神9346227](https://www.imooc.com/u/7808597/articles)

  老师，阿里巴巴规约要求使用String[] args;写法定义数组，但我看jdk源码还是很多String args[]的写法，到底哪种写法好呢

   0

  回复

  2019-09-01

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[慕神9346227](https://www.imooc.com/u/7808597/articles)

    现在大厂都流行前者，String[] arg0 这样

    回复

    2019-09-02 12:52:57

- [慕神9346227](https://www.imooc.com/u/7808597/articles)

  老师split的结果是前面的空串保留，后面的空串舍弃吗

   3

  回复

  2019-09-01

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[慕神9346227](https://www.imooc.com/u/7808597/articles)

    split 不会舍弃的哈。

    回复

    2019-09-02 13:00:26

  - [慕神9346227](https://www.imooc.com/u/7808597/articles)

    回复

    [文贺](https://www.imooc.com/u/8062574/articles)

    String s ="boo:and:foo"; s.split("o") 如果保留空串结果不应该是:["b","",":and:f",""]吗

    回复

    2019-09-02 19:30:12

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[慕神9346227](https://www.imooc.com/u/7808597/articles)

    哈哈，懂你意思了，是的。

    回复

    2019-09-02 21:59:12

- [慕神9346227](https://www.imooc.com/u/7808597/articles)

  老师replace替换字符串和replaceAll有什么区别？仅仅是replace不支持正则吗？

   0

  回复

  2019-08-31

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[慕神9346227](https://www.imooc.com/u/7808597/articles)

    入参数不同，前者是字符串，后者是字符，只能替换单个字符。 性能也不同，当替换量大时，replace 的性能更优。

    回复

    2019-09-02 13:03:04

  - [慕神9346227](https://www.imooc.com/u/7808597/articles)

    回复

    [文贺](https://www.imooc.com/u/8062574/articles)

    public String replace(CharSequence target, CharSequence replacement) 这个方法不是也能接收字符串吗

    回复

    2019-09-02 19:27:22

  - [慕盖茨3494964](https://www.imooc.com/u/6964549/articles)

    回复[慕神9346227](https://www.imooc.com/u/7808597/articles)

    我靠，我有点儿不敢继续往下看了，很多错的地方，“后者只支持替换字符”？是真的吗？

    回复

    2019-09-04 10:25:45

  点击展开后面 3 条

- [weixin_慕用6148056](https://www.imooc.com/u/7687071/articles)

  git在哪

   0

  回复

  2019-08-31

  - [初一](https://www.imooc.com/u/7789740/articles)

    回复[weixin_慕用6148056](https://www.imooc.com/u/7687071/articles)

    在第三小节的评论里有发，同学可以看下

    回复

    2019-09-02 15:46:34

- [weixin_Fortune_0](https://www.imooc.com/u/5146405/articles)

  不错哈老师，希望老多介绍一些工具类的使用哈，比如commons里面的文件类，字类，io流的操作使用哈，真的很实用，也不用重复造轮子哈，像guava这样子，因为项目中也用很多工具类，真的很好?

   4

  回复

  2019-08-29

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[weixin_Fortune_0](https://www.imooc.com/u/5146405/articles)

    哈哈，Guava 已经成为大厂开发必选的框架之一了哈，基本都在用

    回复

    2019-08-30 20:55:33

  - [邹攀](https://www.imooc.com/u/7931752/articles)

    回复[weixin_Fortune_0](https://www.imooc.com/u/5146405/articles)

    guava确实很好用,谁用谁知道

    回复

    2019-08-31 08:06:44

  - [邹攀](https://www.imooc.com/u/7931752/articles)

    回复

    [文贺](https://www.imooc.com/u/8062574/articles)

    一直想找guava的系统学习资料,老师有推荐的吗

    回复

    2019-08-31 08:07:41

  点击展开后面 2 条

- [小明同学爱思考](https://www.imooc.com/u/1864581/articles)

  3.1 那个问题问的有些奇怪 long parseLong(String s) 将一个string类型的对象转为基本数据类型long，如果转为包裹类型Long，还隐含着自动装箱调用valueOf的操作 Long valueOf(String s) 将一个string对象转为包裹类型Long，源码实现为 Long.valueOf(parseLong(s, 10)) 所以这样看，如果都是将string类型的对象转为包裹类型Long，二者是没有区别的。

   1

  回复

  2019-08-29

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[小明同学爱思考](https://www.imooc.com/u/1864581/articles)

    写了一个测试 demo，parseLong 耗时 17 毫秒，valueOf 耗时 4 毫秒，主要就是因为 Long 的缓存机制，字数限制，demo 见下一个回复：

    回复

    2019-08-30 20:42:36

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复

    [文贺](https://www.imooc.com/u/8062574/articles)

    String s ="100"; long beginTime = System.currentTimeMillis(); for (int i = 0; i &lt; 10000; i++) { Long.parseLong(s); } log.info("parseLong 耗时 {}",System.currentTimeMillis() - beginTime); long beginTime1 = System.currentTimeMillis(); for (int i = 0; i &lt; 10000; i++) { Long.valueOf(s); } log.info("valueOf 耗时 {}",System.currentTimeMillis() - beginTime1);

    回复

    2019-08-30 20:42:40

- [小明同学爱思考](https://www.imooc.com/u/1864581/articles)

  equals方法中有如下实现: char v2[] = anotherString.value; 但value是private的，为什么能直接访问呢？

   6

  回复

  2019-08-29

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[小明同学爱思考](https://www.imooc.com/u/1864581/articles)

    对于 private 修饰符的理解有误哈，被 private 修改的变量是可以在本类中被访问的，即使我访问的并不是当前 String 的 value 值，都是可以的，但一旦你在其他类中，再访问 String 的 value 属性，就不行了。

    回复

    2019-08-30 20:54:17

- [小森森的森](https://www.imooc.com/u/6267911/articles)

  String.replace(char, char) 是不是要比String.replaceAll(String,String)性能要好

   2

  回复

  2019-08-28

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[小森森的森](https://www.imooc.com/u/6267911/articles)

    棒，是的，我写了一个 demo，大约在大于 200 的时候，就可以看出来了，当然你测试可能不是 200(和机器很多因素有关)，主要是因为 replaceAll 底层使用的是 java.util.regex.Matcher 的 replaceAll 方法，数据量大时，比较耗性能。 回复字数限制，测试代码见下一个回复：

    回复

    2019-08-28 22:45:23

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复

    [文贺](https://www.imooc.com/u/8062574/articles)

    StringBuffer strb = new StringBuffer(); int size =1000; for (int i = 0; i &lt; size; i++) strb.append("o"); String s = strb.toString(); String s1 = strb.toString(); long begin = System.currentTimeMillis(); s.replace('o','l'); log.info("循环{}次， replace 耗时{}",size, (System.currentTimeMillis() - begin)); begin = System.currentTimeMillis(); s1.replaceAll("o","l");

    回复

    2019-08-28 22:45:31

  - [小森森的森](https://www.imooc.com/u/6267911/articles)

    回复[小森森的森](https://www.imooc.com/u/6267911/articles)

    谢谢老师

    回复

    2019-08-29 09:12:36

- [慕标1291074](https://www.imooc.com/u/7936288/articles)

  这个课，多久能更完呢，，？ 我都已经追上了

   0

  回复

  2019-08-28

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[慕标1291074](https://www.imooc.com/u/7936288/articles)

    理解能力很强呀，我们每周二，四更新哈。

    回复

    2019-08-28 21:30:04

- [sd1700092](https://www.imooc.com/u/2021504/articles)

  Github链接在哪儿呢？

   0

  回复

  2019-08-28

  - [初一](https://www.imooc.com/u/7789740/articles)

    回复[sd1700092](https://www.imooc.com/u/2021504/articles)

    同学你好 在第三节评论里有Github的链接地址

    回复

    2019-08-28 13:35:33

- [qq_现实点_03300102](https://www.imooc.com/u/3300102/articles)

  大大，我想问个问题，就是String不可变这个明白了，但是是否可以通过反射获取到String的value数组来改变它的值呢？

   3

  回复

  2019-08-28

  - [qq_怼心不悔_0](https://www.imooc.com/u/2062155/articles)

    回复[qq_现实点_03300102](https://www.imooc.com/u/3300102/articles)

    完全可以，我已经尝试过

    回复

    2019-08-28 11:14:28

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[qq_现实点_03300102](https://www.imooc.com/u/3300102/articles)

    可以的哈，但很少有人这么干，demo 如下，你可以运行一下： String str = "hello world"; Class clazz = Class.forName("java.lang.String"); Field field = clazz.getDeclaredField("value"); field.setAccessible(true); // 拿到 string 里面的数组 char[] value = (char[]) field.get(str); log.info("修改之前{}",str); field.set(str,"hello java".toCharArray()); log.info("修改之后{}",str);

    回复

    2019-08-28 13:08:38

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[qq_怼心不悔_0](https://www.imooc.com/u/2062155/articles)

    666，学以致用，给你点赞。

    回复

    2019-08-28 13:09:26

  点击展开后面 2 条

- [weixin_慕九州2021120](https://www.imooc.com/u/3886430/articles)

  是文档的形式展示吗？

   0

  回复

  2019-08-28

  - [初一](https://www.imooc.com/u/7789740/articles)

    回复[weixin_慕九州2021120](https://www.imooc.com/u/3886430/articles)

    是的 专栏是图文形式来展示的

    回复

    2019-08-28 12:32:01

- [慕莱坞8203733](https://www.imooc.com/u/7322103/articles)

  被小公司骗了，这次争取进大厂

   2

  回复

  2019-08-27

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[慕莱坞8203733](https://www.imooc.com/u/7322103/articles)

    肯定可以的哈，相信你！

    回复

    2019-08-28 12:18:15

- [慕神4112825](https://www.imooc.com/u/7092371/articles)

  不错，快点更新哦

   2

  回复

  2019-08-27

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[慕神4112825](https://www.imooc.com/u/7092371/articles)

    感谢支持，正快马加鞭赶稿 ing。

    回复

    2019-08-27 19:15:19

- [三国纷争](https://www.imooc.com/u/6798224/articles)

  非科班出身，做IT两年多了，对于源码也看过一点都没有太系统的阅读过几遍，理解的一直也不深入，希望这次能够理解的更加明白和深刻。

   0

  回复

  2019-08-27

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[三国纷争](https://www.imooc.com/u/6798224/articles)

    非科班同学你好，我身边也有不少转行的同学哈，比如土木的，摄影的，我只能说厉害。 2 年的时间，是时候深刻的学习源码了，一起加油。

    回复

    2019-08-27 19:17:08

 

千学不如一看，千看不如一练

 

# 03 Java 常用关键字理解

03 Java 常用关键字理解

更新时间：2019-08-27 14:25:15

![img](https://img2.mukewang.com/5d6354750001b9da06400359.jpg)

![img](https://www.imooc.com/static/img/column/bg-l.png)![img](https://www.imooc.com/static/img/column/bg-r.png)

世上无难事,只要肯登攀。

——毛泽东



## 引导语

Java 中的关键字很多，大约有 50+，在命名上我们不能和这些关键字冲突的，编译会报错，每个关键字都代表着不同场景下的不同含义，接下来我们挑选 6 个比较重要的关键字，深入学习一下。



## 1 static

意思是静态的、全局的，一旦被修饰，说明被修饰的东西在一定范围内是共享的，谁都可以访问，这时候需要注意并发读写的问题。



### 1.1 修饰的对象

static 只能修饰类变量、方法和方法块。

**当 static 修饰类变量时**，如果该变量是 public 的话，表示该变量任何类都可以直接访问，而且无需初始化类，直接使用 **类名.static 变量** 这种形式访问即可。

这时候我们非常需要注意的一点就是线程安全的问题了，因为当多个线程同时对共享变量进行读写时，很有可能会出现并发问题，如我们定义了：`public static List list = new ArrayList();`这样的共享变量。这个 list 如果同时被多个线程访问的话，就有线程安全的问题，这时候一般有两个解决办法：

1. 把线程不安全的 ArrayList 换成 线程安全的 CopyOnWriteArrayList；
2. 每次访问时，手动加锁。

所以在使用 static 修饰类变量时，如何保证线程安全是我们常常需要考虑的。

**当 static 修饰方法时**，代表该方法和当前类是无关的，任意类都可以直接访问（如果权限是 public 的话）。

有一点需要注意的是，该方法内部只能调用同样被 static 修饰的方法，不能调用普通方法，我们常用的 util 类里面的各种方法，我们比较喜欢用 static 修饰方法，好处就是调用特别方便。

static 方法内部的变量在执行时是没有线程安全问题的。方法执行时，数据运行在栈里面，栈的数据每个线程都是隔离开的，所以不会有线程安全的问题，所以 util 类的各个 static 方法，我们是可以放心使用的。

**当 static 修饰方法块时**，我们叫做静态块，静态块常常用于在类启动之前，初始化一些值，比如：

```java
public static List<String> list = new ArrayList();
// 进行一些初始化的工作
static {
    list.add("1");
}
```

这段代码演示了静态块做一些初始化的工作，但需要注意的是，静态块只能调用同样被 static 修饰的变量，并且 static 的变量需要写在静态块的前面，不然编译也会报错。



### 1.2 初始化时机

对于被 static 修饰的类变量、方法块和静态方法的初始化时机，我们写了一个测试 demo，如下图：
![图片描述](https://img.mukewang.com/5d5fc0be000136a322560976.png)打印出来的结果是：

父类静态变量初始化
父类静态块初始化
子类静态变量初始化
子类静态块初始化
main 方法执行
父类构造器初始化
子类构造器初始化

从结果中，我们可以看出两点：

1. 父类的静态变量和静态块比子类优先初始化；
2. 静态变量和静态块比类构造器优先初始化。

被 static 修饰的方法，在类初始化的时候并不会初始化，只有当自己被调用时，才会被执行。



## 2 final

final 的意思是不变的，一般来说用于以下三种场景：

1. 被 final 修饰的类，表明该类是无法继承的；
2. 被 final 修饰的方法，表明该方法是无法覆写的；
3. 被 final 修饰的变量，说明该变量在声明的时候，就必须初始化完成，而且以后也不能修改其内存地址。

第三点注意下，我们说的是无法修改其内存地址，并没有说无法修改其值。因为对于 List、Map 这些集合类来说，被 final 修饰后，是可以修改其内部值的，但却无法修改其初始化时的内存地址。

例子我们就不举了，1-1 小节 String 的不变性就是一个很好的例子。



## 3 try、catch、finally

这三个关键字常用于我们捕捉异常的一整套流程，try 用来确定代码执行的范围，catch 捕捉可能会发生的异常，finally 用来执行一定要执行的代码块，除了这些，我们还需要清楚，每个地方如果发生异常会怎么办，我们举一个例子来演示一下：

```java
public void testCatchFinally() {
  try {
    log.info("try is run");
    if (true) {
      throw new RuntimeException("try exception");
    }
  } catch (Exception e) {
    log.info("catch is run");
    if (true) {
      throw new RuntimeException("catch exception");
    }
  } finally {
    log.info("finally is run");
  }
}
```

这个代码演示了在 try、catch 中都遇到了异常，代码的执行顺序为：try -> catch -> finally，输出的结果如下：
![图片描述](https://img.mukewang.com/5d5fc0d40001ede717880302.png)可以看到两点：

1. finally 先执行后，再抛出 catch 的异常；
2. 最终捕获的异常是 catch 的异常，try 抛出来的异常已经被 catch 吃掉了，所以当我们遇见 catch 也有可能会抛出异常时，我们可以先打印出 try 的异常，这样 try 的异常在日志中就会有所体现。



## 4 volatile

volatile 的意思是可见的，常用来修饰某个共享变量，意思是当共享变量的值被修改后，会及时通知到其它线程上，其它线程就能知道当前共享变量的值已经被修改了。

我们再说原理之前，先说下基础知识。就是在多核 CPU 下，为了提高效率，线程在拿值时，是直接和 CPU 缓存打交道的，而不是内存。主要是因为 CPU 缓存执行速度更快，比如线程要拿值 C，会直接从 CPU 缓存中拿， CPU 缓存中没有，就会从内存中拿，所以线程读的操作永远都是拿 CPU 缓存的值。

这时候会产生一个问题，CPU 缓存中的值和内存中的值可能并不是时刻都同步，导致线程计算的值可能不是最新的，共享变量的值有可能已经被其它线程所修改了，但此时修改是机器内存的值，CPU 缓存的值还是老的，导致计算会出现问题。

这时候有个机制，就是内存会主动通知 CPU 缓存。当前共享变量的值已经失效了，你需要重新来拉取一份，CPU 缓存就会重新从内存中拿取一份最新的值。

volatile 关键字就会触发这种机制，加了 volatile 关键字的变量，就会被识别成共享变量，内存中值被修改后，会通知到各个 CPU 缓存，使 CPU 缓存中的值也对应被修改，从而保证线程从 CPU 缓存中拿取出来的值是最新的。

我们画了一个图来说明一下：
![图片描述](https://img.mukewang.com/5d5fc0ea000100a312740736.png)从图中我们可以看到，线程 1 和线程 2 一开始都读取了 C 值，CPU 1 和 CPU 2 缓存中也都有了 C 值，然后线程 1 把 C 值修改了，这时候内存的值和 CPU 2 缓存中的 C 值就不等了，内存这时发现 C 值被 volatile 关键字修饰，发现其是共享变量，就会使 CPU 2 缓存中的 C 值状态置为无效，CPU 2 会从内存中重新拉取最新的值，这时候线程 2 再来读取 C 值时，读取的已经是内存中最新的值了。



## 5 transient

transient 关键字我们常用来修饰类变量，意思是当前变量是无需进行序列化的。在序列化时，就会忽略该变量，这些在序列化工具底层，就已经对 transient 进行了支持。



## 6 default

default 关键字一般会用在接口的方法上，意思是对于该接口，子类是无需强制实现的，但自己必须有默认实现，我们举个例子如下：
![图片描述](https://img.mukewang.com/5d5fc4460001f3cb17220650.png)default 关键字被很多源码使用，我们后面会说。



## 7 面试题



### 7.1 如何证明 static 静态变量和类无关？

答：从三个方面就可以看出静态变量和类无关。

1. 我们不需要初始化类就可直接使用静态变量；
2. 我们在类中写个 main 方法运行，即便不写初始化类的代码，静态变量都会自动初始化；
3. 静态变量只会初始化一次，初始化完成之后，不管我再 new 多少个类出来，静态变量都不会再初始化了。

不仅仅是静态变量，静态方法块也和类无关。



### 7.2 常常看见变量和方法被 static 和 final 两个关键字修饰，为什么这么做？

答：这么做有两个目的：

1. 变量和方法于类无关，可以直接使用，使用比较方便；
2. 强调变量内存地址不可变，方法不可继承覆写，强调了方法内部的稳定性。



### 7.3 catch 中发生了未知异常，finally 还会执行么？

答：会的，catch 发生了异常，finally 还会执行的，并且是 finally 执行完成之后，才会抛出 catch 中的异常。

不过 catch 会吃掉 try 中抛出的异常，为了避免这种情况，在一些可以预见 catch 中会发生异常的地方，先把 try 抛出的异常打印出来，这样从日志中就可以看到完整的异常了。



### 7.4 volatile 关键字的作用和原理

答：这个上文说的比较清楚，可以参考上文。



## 总结

Java 的关键字属于比较基础的内容，我们需要清晰明确其含义，才能在后续源码阅读和工作中碰到这些关键字时了然于心，才能明白为什么会在这里使用这样的关键字。比如 String 源码是如何使用 final 关键字达到起不变性的，比如 Java 8 集合中 Map 是如何利用 default 关键字新增各种方法的，这些我们在后续内容都会提到。

[02 String、Long 源码解析和面试题](https://www.imooc.com/read/47/article/844)[04 Arrays、Collections、Objects 常用方法源码解析](https://www.imooc.com/read/47/article/846)

精选留言 29

欢迎在这里发表留言，作者筛选后可公开显示

- [019caoyu](https://www.imooc.com/u/8435762/articles)

  7.1 题目应该改为证明 static静态变量和类实例无关，更准确些吧

   1

  回复

  2天前

- [慕粉1142258395](https://www.imooc.com/u/4714955/articles)

  老师您好，这段话 “不过 catch 会吃掉 try 中抛出的异常，为了避免这种情况，在一些可以预见 catch 中会发生异常的地方，先把 try 抛出的异常打印出来，这样从日志中就可以看到完整的异常了。” 指的是有些catch中捕获的异常可能是try中抛出的异常的父类，导致最后输出的是catch的父类异常，而不是try中抛出的具体异常吗？

   0

  回复

  4天前

  - [4566413851](https://www.imooc.com/u/8198079/articles)

    回复[慕粉1142258395](https://www.imooc.com/u/4714955/articles)

    你知道 finally 会先执行， 为什么先输出 finally的代码吗？

    回复

    3天前

  - [4566413851](https://www.imooc.com/u/8198079/articles)

    回复[慕粉1142258395](https://www.imooc.com/u/4714955/articles)

    为了区分是 try 中的异常 还是 catch 中的异常吧，个人看法

    回复

    3天前

- [所相虚妄](https://www.imooc.com/u/7839242/articles)

  这个读取应该是在通知之后才能用有作用吧，读取值之后，然后完成了计算，那么就有再写会缓存中的话，那么这个通知机制就没用作用了吧。

   1

  回复

  2019-12-06

- [所相虚妄](https://www.imooc.com/u/7839242/articles)

  try 那个代码是不是少了吧System.out.println(e.getMessage());这种代码了

   0

  回复

  2019-12-06

- [所相虚妄](https://www.imooc.com/u/7839242/articles)

  我感觉文章中的表达应该是，静态方法和变量和对象没啥关系，就算没有初始化成对象，依然可以使用吧，

   0

  回复

  2019-12-06

- [wt4446](https://www.imooc.com/u/3616005/articles)

  volatile的底层原理是cas吗？

   0

  回复

  2019-11-29

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[wt4446](https://www.imooc.com/u/3616005/articles)

    和 CAS 有关，底层实现是计算机底层实现的。

    回复

    2019-11-30 13:04:22

- [风云独舞九天](https://www.imooc.com/u/5748466/articles)

  补充一波，有非静态代码块的情况： 父类静态变量 父类静态代码块 子类静态变量 子类静态代码块 父类非静态代码块 父类构造方法 子类非静态代码块 子类构造方法

   0

  回复

  2019-11-18

- [java_simon](https://www.imooc.com/u/6259472/articles)

  您好，问下在修改volatitle变量时，先修改CPU缓存中的值再修改内存中的值吗？顺序是怎么样的呢？

   0

  回复

  2019-10-30

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[java_simon](https://www.imooc.com/u/6259472/articles)

    同学你好，先修改当前机器(修改变量命令所有机器)的 CPU 缓存，再修改主存，在修改其他CPU 缓存。

    回复

    2019-10-31 10:45:55

- [qq_orientation_0](https://www.imooc.com/u/2738102/articles)

  不是说String中内存地址不可变吗， String str = "abc"; str = "hello"; 那我上面的代码是只改变了str的值吗， 但是我在idea编辑器查看地址的时候发现上面的str的地址和下面改变后的str地址也变了 如果说确实地址是没变的，那也就是说idea编辑器看到的不是内存地址，那上面显示的又是 什么呢? 麻烦老师解答一下

   1

  回复

  2019-09-30

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[qq_orientation_0](https://www.imooc.com/u/2738102/articles)

    String 比较特殊，你重新赋值时，会产生新的内存引用，新的hello 和原来的 abc 是两个字符串，在 idea 上能看到两个内存地址。

    回复

    2019-10-03 07:54:21

  - [Blue_Fish0323](https://www.imooc.com/u/1110029/articles)

    回复[qq_orientation_0](https://www.imooc.com/u/2738102/articles)

    可以这么理解，str指向的是字符串"abc"的地址，你重新赋值的时候指向的是"hello"的地址，但是"abc"这个字符串的地址时没有变化的

    回复

    2019-10-17 20:54:35

- [慕虎3144156](https://www.imooc.com/u/8015987/articles)

  testCatchFinally这个再次运行时和楼主发的是一样的顺序了。不知道为什么

   0

  回复

  2019-09-29

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[慕虎3144156](https://www.imooc.com/u/8015987/articles)

    同事自己在检查下运行环境哈，谢谢

    回复

    2019-09-30 14:06:17

- [慕虎3144156](https://www.imooc.com/u/8015987/articles)

  testCatchFinally，这个例子为什么在我电脑上和作者的不一样？ 我的结果是下面的 try is run Exception in thread "main" java.lang.RuntimeException: catch exception at testCatchFinally.testCatchFinally(testCatchFinally.java:21) catch is run at testCatchFinally.main(testCatchFinally.java:9) finally is run

   0

  回复

  2019-09-29

- [风舞炫动](https://www.imooc.com/u/6409329/articles)

  线程2在第10部如果是修改C的值为某一个值 这种情况是如何处理的呢？

   0

  回复

  2019-09-26

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[风舞炫动](https://www.imooc.com/u/6409329/articles)

    会拿到最新的值进行修改。

    回复

    2019-09-26 19:01:43

  - [风舞炫动](https://www.imooc.com/u/6409329/articles)

    回复

    [文贺](https://www.imooc.com/u/8062574/articles)

    明白啦 ， 谢谢老师 ！

    回复

    2019-10-08 11:39:22

- [tongguangyu](https://www.imooc.com/u/6185391/articles)

  被 final 修饰的变量，说明该变量在声明的时候，就必须初始化完成，而且以后也不能修改其内存地址。 可以举一个修改变量内存地址的例子吗

   0

  回复

  2019-09-23

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[tongguangyu](https://www.imooc.com/u/6185391/articles)

    final 修饰的是不能修改哈，你应该问的是如何证明不可修改是吧，这个在编译期间是强制的，final 变量如果初始化时不赋值，编译器就会报错：Variable might not have been initialized，如果再次给 final 变量赋值，编译器会报错：Cannot assign a value to final variable 。

    回复

    2019-09-23 10:41:26

  - [狗肉是只猫](https://www.imooc.com/u/259614/articles)

    回复[tongguangyu](https://www.imooc.com/u/6185391/articles)

    final Student stu = new Student("五五开"); Student stu2 = new Student("white"); stu = stu2 // 错误，final修饰的对象，不可重新指向另一个对象。 stu.setName("卢本伟")；// 正确，可以修改值。

    回复

    2019-09-23 20:27:23

  - [拾灬荒灬者](https://www.imooc.com/u/5658415/articles)

    回复[狗肉是只猫](https://www.imooc.com/u/259614/articles)

    卢老爷的例子可以说很生动了

    回复

    2019-09-24 11:52:14

  点击展开后面 1 条

- [开拓者OS](https://www.imooc.com/u/1104055/articles)

  1.静态变量和静态方法与对象无关是属于类的，所以和类是有关的。 2."无论new出多少个类"，这句说法不严谨应该是对象。

   13

  回复

  2019-09-19

  - [Eric_余浩](https://www.imooc.com/u/3002030/articles)

    回复[开拓者OS](https://www.imooc.com/u/1104055/articles)

    我也觉得 静态变量和静态方法是和类有关的。只是和具体的对象没有关系。

    回复

    2019-09-27 13:39:47

  - [魅影劲](https://www.imooc.com/u/4768694/articles)

    回复[Eric_余浩](https://www.imooc.com/u/3002030/articles)

    恩 我也觉得这样说好一点 看正文的时候我还楞了一下

    回复

    2019-10-16 12:17:54

- [wentian40](https://www.imooc.com/u/2282065/articles)

  和类怎么无关，和对象吧？

   5

  回复

  2019-09-18

- [slvayf](https://www.imooc.com/u/2077521/articles)

  老师好，请问学习专栏和网络上其他视频课程的时候，真正高效的学习方式是什么？记笔记的过程重要吗（感觉很少会回头再看，只有常用的东西会记住，那些已经理解并自己写了demo的，不常用就会慢慢忘掉，只能回想起自己学过）？

   0

  回复

  2019-09-17

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[slvayf](https://www.imooc.com/u/2077521/articles)

    你说的很对，不常用的，过段时间就会忘记，所以重复温习很重要哈，你做的笔记、学习的课程正好是你温习的最快简捷，重复温习很重要哈，帮你巩固记忆。

    回复

    2019-09-18 21:30:09

- [weixin_慕婉清1547377](https://www.imooc.com/u/8136744/articles)

  transient这个还真的没怎么用过

   0

  回复

  2019-09-12

- [power_cheng4342740](https://www.imooc.com/u/4342740/articles)

  看了下源码, Arrays Collections Objects中提供的工具方法几乎都没有使用final修饰. 即使子类中存在相同签名的静态方法,它实际上也并没有重写父类中的方法(因为使用@Override注解会报错). 而且在实际应用中几乎都是用类名来调用静态方法所以并不影响使用. 即使使用对象来调用静态方法, 也是根据引用类型来确定具体使用哪个方法, 而不是根据对象的实际类型

   0

  回复

  2019-09-11

- [power_cheng4342740](https://www.imooc.com/u/4342740/articles)

  final修饰的变量是可以先声明再初始化的. 修饰成员变量时可以在构造方法中初始化, 修饰局部变量时可以在具体的逻辑中初始化

   0

  回复

  2019-09-11

- [power_cheng4342740](https://www.imooc.com/u/4342740/articles)

  final修饰的变量是可以先声明再初始化的. 声明成员变量时可以在构造方法中初始化, 声明局部变量时可以在具体的逻辑中初始化

   0

  回复

  2019-09-11

- [慕神9346227](https://www.imooc.com/u/7808597/articles)

  这两天源码中经常看到transient关键字，使用这个关键字有什么好处呢

   0

  回复

  2019-09-09

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[慕神9346227](https://www.imooc.com/u/7808597/articles)

    序列化时无需序列化，文中有说哈。

    回复

    2019-09-10 14:35:20

- [源自我心](https://www.imooc.com/u/1073881/articles)

  “static修饰的方法内部只能调用同样被static修饰的方法”，我觉得这句话说得并不严谨，比如static修饰的方法中也可以通过对象调用普通方法。

   0

  回复

  2019-09-08

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[源自我心](https://www.imooc.com/u/1073881/articles)

    new 出来的对象，基本没啥限制哈，有丢丢钻牛角尖了哈，哈哈。

    回复

    2019-09-09 13:58:58

- [慕神9346227](https://www.imooc.com/u/7808597/articles)

  老师能顺便讲讲static class吗

   0

  回复

  2019-09-01

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[慕神9346227](https://www.imooc.com/u/7808597/articles)

    有具体的问题么，这一方面的内容很多哈。

    回复

    2019-09-09 13:59:25

  - [慕神9346227](https://www.imooc.com/u/7808597/articles)

    回复

    [文贺](https://www.imooc.com/u/8062574/articles)

    主要是“static 只能修饰类变量、方法和方法块。”这句话有点问题吧

    回复

    2019-12-06 16:33:29

- [慕神9346227](https://www.imooc.com/u/7808597/articles)

  老师为什么我在IDEA里打开源码log.info的log是标红的啊，不过不影响运行

   0

  回复

  2019-09-01

  - [慕神9346227](https://www.imooc.com/u/7808597/articles)

    回复[慕神9346227](https://www.imooc.com/u/7808597/articles)

    我知道了要安个插件...

    回复

    2019-09-02 12:33:56

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[慕神9346227](https://www.imooc.com/u/7808597/articles)

    棒，刚看到，需要安装 lombok 插件，我们都用哦。

    回复

    2019-09-02 13:04:17

  - [猿小默](https://www.imooc.com/u/5795134/articles)

    回复

    [文贺](https://www.imooc.com/u/8062574/articles)

    老师，企业中用lombok的多吗

    回复

    2天前

- [OO行胜于言](https://www.imooc.com/u/3004336/articles)

  大佬，(1)static可以修饰类吧。(2)讲volatile关键字的时候，您说失效之后会重新拉取，那按照这么说在执行i++操作的时候，只要加了volatile那么就可以是线程安全的吗？因为失效时候会重新获取。所以感觉这句话不太严谨，只是下一个线程获取到的是最新的值。(3)讲try catch的时候，finally应该是最后执行吧，catch块执行了才会执行finally块。有说的不对，希望大佬指正。

   1

  回复

  2019-08-31

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[OO行胜于言](https://www.imooc.com/u/3004336/articles)

    1：static 可以修饰类的。 2：volatile 可以保证可见性，但无法保证原子性，i++已经不是原子操作了，所以即使使用 volatile 修饰，也无法保证其线程安全，比较好的做法可以参考 AtomicInteger，值使用 volatile 修饰，保证多核下的可见性，数据修改使用 unsafe 方法，保证原子性。 3：这里说的是如果 catch 里面抛出了异常，但也要等到 finally 执行完成之后，异常才会抛出来哈。

    回复

    2019-09-02 13:14:07

  - [慕粉6227487](https://www.imooc.com/u/8016091/articles)

    回复[OO行胜于言](https://www.imooc.com/u/3004336/articles)

    如何判断原子操作呢？

    回复

    2019-09-16 10:26:11

- [Opener](https://www.imooc.com/u/2089758/articles)

  刚看到这里，我其实不太知道读源码应该是怎样的，但是老师您讲的这些不应该算是Java基础吗？不知道后面的内容会不会深一点，希望没有这种感觉吧，希望老师能提示一下读源码真正应该领悟到一些什么，我个人感觉应该不是简单读api，谢谢老师！

   2

  回复

  2019-08-31

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[Opener](https://www.imooc.com/u/2089758/articles)

    理解 JAVA 关键字是阅读源码的基础哈，我们后面解析源码的时候不再会说这些关键字的作用了。 阅读源码第一步就是读API，然后尝试理解为什么这么写，理解设计思想，才能在适当的工作场景中灵活运用，甚至把设计思想运用到工作中。第一步就是读，然后悟，最后用。

    回复

    2019-09-02 12:29:23

  - [Opener](https://www.imooc.com/u/2089758/articles)

    回复

    [文贺](https://www.imooc.com/u/8062574/articles)

    感觉要领悟到一些方法是如何设计的才行，源码作者的思考很重要，谢谢老师！

    回复

    2019-09-09 13:28:17

- [初一](https://www.imooc.com/u/7789740/articles)

  源码解析：https://github.com/luanqiu/java8 文章 demo：https://github.com/luanqiu/java8_demo 同学们有需要可以自取哈^^

   4

  回复

  2019-08-28

  - [慕神9346227](https://www.imooc.com/u/7808597/articles)

    回复[初一](https://www.imooc.com/u/7789740/articles)

    这个都不能复制，慕课是不是太过了

    回复

    2019-10-24 11:41:34

  - [calvinsheng](https://www.imooc.com/u/4470896/articles)

    回复[初一](https://www.imooc.com/u/7789740/articles)

    源码解析: https://github.com/luanqiu/java8 文章demo: https://github.com/luanqiu/java8_ demo

    回复

    5天前

- [Bennie_Lee](https://www.imooc.com/u/5323418/articles)

  关于static关键字，个人理解：凡被static关键字修饰的字段、方法、内部类和代码块均属于该类，而与该类的对象无关。

   12

  回复

  2019-08-28

  - [摘星zx](https://www.imooc.com/u/6947932/articles)

    回复[Bennie_Lee](https://www.imooc.com/u/5323418/articles)

    我也认为是这样的，是属于类的而不是属于对象的

    回复

    2019-08-28 18:21:05

  - [MFeng](https://www.imooc.com/u/5404186/articles)

    回复[Bennie_Lee](https://www.imooc.com/u/5323418/articles)

    这样讲比较清楚，也容易理解

    回复

    2019-08-28 20:05:24

  - [世界和平灬](https://www.imooc.com/u/7803755/articles)

    回复[Bennie_Lee](https://www.imooc.com/u/5323418/articles)

    赞同，类成员和实例成员。

    回复

    2019-08-29 10:00:02

- [weixin_bpvACL](https://www.imooc.com/u/6792134/articles)

  觉得底层讲的还是不太详细 比如这个volatile关键字 知道工作机制 但是如何源码实现还是不清楚

   0

  回复

  2019-08-28

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[weixin_bpvACL](https://www.imooc.com/u/6792134/articles)

    volatile 关键字 Java 底层并没有源码实现哦。

    回复

    2019-08-28 08:48:39

  - [mengyilangan](https://www.imooc.com/u/1890040/articles)

    回复[weixin_bpvACL](https://www.imooc.com/u/6792134/articles)

    看到很多地方写的主存，副本。主存副本是个比喻词汇吗？我怎么确认呢

    回复

    2019-08-28 23:04:13

  - [weixin_Fortune_0](https://www.imooc.com/u/5146405/articles)

    回复[weixin_bpvACL](https://www.imooc.com/u/6792134/articles)

    volatile的详细可以到并发这块知识了解，老师上面已经画出了jvm内存的内存模型了，这个也是很重要的基础知识哈

    回复

    2019-08-30 12:37:54

  - [慕神9346227](https://www.imooc.com/u/7808597/articles)

    回复[weixin_bpvACL](https://www.imooc.com/u/6792134/articles)

    这个应该不是java代码实现的吧

    回复

    2019-09-01 12:39:37

  - [slvayf](https://www.imooc.com/u/2077521/articles)

    回复[慕神9346227](https://www.imooc.com/u/7808597/articles)

    应该是Java底层JVM实现的

    回复

    2019-09-18 17:35:29

  - [风云独舞九天](https://www.imooc.com/u/5748466/articles)

    回复[weixin_bpvACL](https://www.imooc.com/u/6792134/articles)

    可以去看OPENJDK源码

    回复

    2019-11-18 14:38:00

 

千学不如一看，千看不如一练

 

# 04 Arrays、Collections、Objects 常用方法源码解析

04 Arrays、Collections、Objects 常用方法源码解析

更新时间：2019-11-25 18:04:50

![img](https://img2.mukewang.com/5d6355040001e91306400359.jpg)

![img](https://www.imooc.com/static/img/column/bg-l.png)![img](https://www.imooc.com/static/img/column/bg-r.png)

读一本好书，就是和许多高尚的人谈话。

——歌德

## 引导语

我们在工作中都会写工具类，但如何才能使写出来的工具类更好用，也是有一些技巧的。本章内容以三种平时工作中经常使用的工具类为例，从使用案例出发，再看看底层源码的实现，看看能否学习到一些工具类的技巧，以及三种工具类的实际使用场景。

> 下方是本专栏 GitHub 地址：
> 源码解析：https://github.com/luanqiu/java8
> 文章 demo：https://github.com/luanqiu/java8_demo
> 同学们有需要可以对照着来看 ：）

## 1 工具类通用的特征

再看细节之前，我们先总结一下好的工具类都有哪些通用的特征写法：

1. 构造器必须是私有的。这样的话，工具类就无法被 new 出来，因为工具类在使用的时候，无需初始化，直接使用即可，所以不会开放出构造器出来。
2. 工具类的工具方法必须被 static、final 关键字修饰。这样的话就可以保证方法不可变，并且可以直接使用，非常方便。

我们需要注意的是，尽量不在工具方法中，对共享变量有做修改的操作访问（如果必须要做的话，必须加锁），因为会有线程安全的问题。除此之外，工具类方法本身是没有线程安全问题的，可以放心使用。

## 2 Arrays

Arrays 主要对数组提供了一些高效的操作，比如说排序、查找、填充、拷贝、相等判断等等。我们选择其中两三看下，对其余操作感兴趣的同学可以到 GitHub 上查看源码解析。

### 2.1 排序

Arrays.sort 方法主要用于排序，入参支持 int、long、double 等各种基本类型的数组，也支持自定义类的数组，下面我们写个 demo 来演示一下自定义类数组的排序：

```java
@Data
// 自定义类
class SortDTO {
  private String sortTarget;

  public SortDTO(String sortTarget) {
    this.sortTarget = sortTarget;
  }
}

@Test
public void testSort(){
  List<SortDTO> list = ImmutableList.of(
      new SortDTO("300"),
      new SortDTO("50"),
      new SortDTO("200"),
      new SortDTO("220")
  );
  // 我们先把数组的大小初始化成 list 的大小，保证能够正确执行 toArray
  SortDTO[] array = new SortDTO[list.size()];
  list.toArray(array);

  log.info("排序之前：{}", JSON.toJSONString(array));
  Arrays.sort(array, Comparator.comparing(SortDTO::getSortTarget));
  log.info("排序之后：{}", JSON.toJSONString(array));
}
输出结果为：
排序之前：[{"sortTarget":"300"},{"sortTarget":"50"},{"sortTarget":"200"},{"sortTarget":"220"}]
排序之后：[{"sortTarget":"200"},{"sortTarget":"220"},{"sortTarget":"300"},{"sortTarget":"50"}]
```

从输出的结果中可以看到，排序之后的数组已经是有顺序的了，也可以看到 sort 方法支持两个入参：要排序的数组和外部排序器。

大家都说 sort 方法排序的性能较高，主要原因是 sort 使用了双轴快速排序算法，具体算法就不细说了。

### 2.1 二分查找法

Arrays.binarySearch 方法主要用于快速从数组中查找出对应的值。其支持的入参类型非常多，如 byte、int、long 各种类型的数组。返回参数是查找到的对应数组下标的值，如果查询不到，则返回负数。
![图片描述](https://img.mukewang.com/5d5fc4a400010d4106820685.png)我们写了一个 demo 如下：

```java
List<SortDTO> list = ImmutableList.of(
    new SortDTO("300"),
    new SortDTO("50"),
    new SortDTO("200"),
    new SortDTO("220")
);

SortDTO[] array = new SortDTO[list.size()];
list.toArray(array);

log.info("搜索之前：{}", JSON.toJSONString(array));
Arrays.sort(array, Comparator.comparing(SortDTO::getSortTarget));
log.info("先排序，结果为：{}", JSON.toJSONString(array));
int index = Arrays.binarySearch(array, new SortDTO("200"),
                    Comparator.comparing(SortDTO::getSortTarget));
if(index<0){
  throw new RuntimeException("没有找到 200");
}
log.info("搜索结果：{}", JSON.toJSONString(array[index]));

输出的结果为：
搜索之前：[{"sortTarget":"300"},{"sortTarget":"50"},{"sortTarget":"200"},{"sortTarget":"220"}]
先排序，结果为：[{"sortTarget":"200"},{"sortTarget":"220"},{"sortTarget":"300"},{"sortTarget":"50"}]
搜索结果：{"sortTarget":"200"}
```

从上述代码中我们需要注意两点：

1. 如果被搜索的数组是无序的，一定要先排序，否则二分搜索很有可能搜索不到，我们 demo 里面也先对数组进行了排序；
2. 搜索方法返回的是数组的下标值。如果搜索不到，返回的下标值就会是负数，这时我们需要判断一下正负。如果是负数，还从数组中获取数据的话，会报数组越界的错误。demo 中对这种情况进行了判断，如果是负数，会提前抛出明确的异常。

接下来，我们来看下二分法底层代码的实现：

```java
// a：我们要搜索的数组，fromIndex：从那里开始搜索，默认是0； toIndex：搜索到何时停止，默认是数组大小
// key：我们需要搜索的值 c：外部比较器
private static <T> int binarySearch0(T[] a, int fromIndex, int toIndex,
                                     T key, Comparator<? super T> c) {
    // 如果比较器 c 是空的，直接使用 key 的 Comparable.compareTo 方法进行排序
    // 假设 key 类型是 String 类型，String 默认实现了 Comparable 接口，就可以直接使用 compareTo 方法进行排序
    if (c == null) {
        // 这是另外一个方法，使用内部排序器进行比较的方法
        return binarySearch0(a, fromIndex, toIndex, key);
    }
    int low = fromIndex;
    int high = toIndex - 1;
    // 开始位置小于结束位置，就会一直循环搜索
    while (low <= high) {
        // 假设 low =0，high =10，那么 mid 就是 5，所以说二分的意思主要在这里，每次都是计算索引的中间值
        int mid = (low + high) >>> 1;
        T midVal = a[mid];
        // 比较数组中间值和给定的值的大小关系
        int cmp = c.compare(midVal, key);
        // 如果数组中间值小于给定的值，说明我们要找的值在中间值的右边
        if (cmp < 0)
            low = mid + 1;
        // 我们要找的值在中间值的左边
        else if (cmp > 0)
            high = mid - 1;
        else
        // 找到了
            return mid; // key found
    }
    // 返回的值是负数，表示没有找到
    return -(low + 1);  // key not found.
}
```

二分的主要意思是每次查找之前，都找到中间值，然后拿我们要比较的值和中间值比较，根据结果修改比较的上限或者下限，通过循环最终找到相等的位置索引，以上代码实现比较简洁，大家可以在自己理解的基础上，自己复写一遍。

### 2.2 拷贝

数组拷贝我们经常遇到，有时需要拷贝整个数组，有时需要拷贝部分，比如 ArrayList 在 add（扩容） 或 remove（删除元素不是最后一个） 操作时，会进行一些拷贝。拷贝整个数组我们可以使用 copyOf 方法，拷贝部分我们可以使用 copyOfRange 方法，以 copyOfRange 为例，看下底层源码的实现：

```java
// original 原始数组数据
// from 拷贝起点
// to 拷贝终点
public static char[] copyOfRange(char[] original, int from, int to) {
    // 需要拷贝的长度
    int newLength = to - from;
    if (newLength < 0)
        throw new IllegalArgumentException(from + " > " + to);
    // 初始化新数组
    char[] copy = new char[newLength];
    // 调用 native 方法进行拷贝，参数的意思分别是：
    // 被拷贝的数组、从数组那里开始、目标数组、从目的数组那里开始拷贝、拷贝的长度
    System.arraycopy(original, from, copy, 0,
                     Math.min(original.length - from, newLength));
    return copy;
}
```

从源码中，我们发现，Arrays 的拷贝方法，实际上底层调用的是 System.arraycopy 这个 native 方法，如果你自己对底层拷贝方法比较熟悉的话，也可以直接使用。

## 3 Collections

Collections 是为了方便使用集合而产生的工具类，Arrays 方便数组使用，Collections 是方便集合使用。

Collections 也提供了 sort 和 binarySearch 方法，sort 底层使用的就是 Arrays.sort 方法，binarySearch 底层是自己重写了二分查找算法，实现的逻辑和 Arrays 的二分查找算法完全一致，这两个方法上 Collections 和 Arrays 的内部实现很类似，接下来我们来看下 Collections 独有的特性。

### 3.1 求集合中最大、小值

提供了 max 方法来取得集合中的最大值，min 方法来取得集合中的最小值，max 和 min 方法很相似的，我们以 max 方法为例来说明一下，max 提供了两种类型的方法，一个需要传外部排序器，一个不需要传排序器，但需要集合中的元素强制实现 Comparable 接口，后者的泛型定义很有意思，我们来看下（从右往左看）：
![图片描述](https://img.mukewang.com/5d5fc50a0001220c19701126.png)从这段源码中，我们可以学习到两点：

1. max 方法泛型 T 定义得非常巧妙，意思是泛型必须继承 Object 并且实现 Comparable 的接口。一般让我们来定义的话，我们可以会在方法里面去判断有无实现 Comparable 的接口，这种是在运行时才能知道结果。而这里泛型直接定义了必须实现 Comparable 接口，在编译的时候就可告诉使用者，当前类没有实现 Comparable 接口，使用起来很友好；
2. 给我们提供了实现两种排序机制的好示例：自定义类实现 Comparable 接口和传入外部排序器。两种排序实现原理类似，但实现有所差别，我们在工作中如果需要些排序的工具类时，可以效仿。

### 3.2 多种类型的集合

Collections 对原始集合类进行了封装，提供了更好的集合类给我们，一种是线程安全的集合，一种是不可变的集合，针对 List、Map、Set 都有提供，我们先来看下线程安全的集合：

#### 3.2.1 线程安全的集合

线程安全的集合方法都是 synchronized 打头的，如下：
![图片描述](https://img.mukewang.com/5d5fc5230001a8ba11460942.png)从方法命名我们都可以看出来，底层是通过 synchronized 轻量锁来实现的，我们以 synchronizedList 为例来说明下底层的实现：
![图片描述](https://img.mukewang.com/5d5fc55a0001a96b14201306.png)可以看到 List 的所有操作方法都被加上了 synchronized 锁，所以多线程对集合同时进行操作，是线程安全的。

#### 3.2.1 不可变的集合

得到不可变集合的方法都是以 unmodifiable 开头的。这类方法的意思是，我们会从原集合中，得到一个不可变的新集合，新集合只能访问，无法修改；一旦修改，就会抛出异常。这主要是因为只开放了查询方法，其余任何修改操作都会抛出异常，我们以 unmodifiableList 为例来看下底层实现机制：
![图片描述](https://img.mukewang.com/5d5fc56c000106c613981318.png)

#### 3.2.2 小结

以上两种 List 其实解决了工作中的一些困惑，比如说 ArrayList 是线程不安全的，然后其内部数组很容易被修改，有的时候，我们希望 List 一旦生成后，就不能被修改，Collections 对 List 重新进行了封装，提供了两种类型的集合封装形式，从而解决了工作中的一些烦恼，如果你平时使用 List 时有一些烦恼，也可以学习此种方式，自己对原始集合进行封装，来解决 List 使用过程中的不方便。

## 4 Objects

对于 Objects，我们经常使用的就是两个场景，相等判断和判空。

### 4.1 相等判断

Objects 有提供 equals 和 deepEquals 两个方法来进行相等判断，前者是判断基本类型和自定义类的，后者是用来判断数组的，我们来看下底层的源码实现：
![图片描述](https://img.mukewang.com/5d5fc5830001b26a23601336.png)从源码中，可以看出 Objects 对基本类型和复杂类型的对象，都有着比较细粒度的判断，可以放心使用。

### 4.2 为空判断

![图片描述](https://img.mukewang.com/5d5fc59b00010ebc10820386.png)Objects 提供了各种关于空的一些判断，isNull 和 nonNull 对于对象是否为空返回 Boolean 值，requireNonNull 方法更加严格，如果一旦为空，会直接抛出异常，我们需要根据生活的场景选择使用。

## 5 面试题

### 5.1 工作中有没有遇到特别好用的工具类，如何写好一个工具类

答：有的，像 Arrays 的排序、二分查找、Collections 的不可变、线程安全集合类、Objects 的判空相等判断等等工具类，好的工具类肯定很好用，比如说使用 static final 关键字对方法进行修饰，工具类构造器必须是私有等等手段来写好工具类。

### 5.2 写一个二分查找算法的实现

答：可以参考 Arrays 的 binarySearch 方法的源码实现。

### 5.3 如果我希望 ArrayList 初始化之后，不能被修改，该怎么办

答：可以使用 Collections 的 unmodifiableList 的方法，该方法会返回一个不能被修改的内部类集合，这些集合类只开放查询的方法，对于调用修改集合的方法会直接抛出异常。

## 总结

从三大工具类中，我们不仅学习到了如何写好一个工具类，还熟悉了三大工具类的具体使用姿势，甚至了解了其底层的源码实现，有兴趣的话，可以自己也可以仿照写个好用的工具类加深学习。

[03 Java 常用关键字理解](https://www.imooc.com/read/47/article/845)[05 ArrayList 源码解析和设计思路](https://www.imooc.com/read/47/article/847)

精选留言 20

欢迎在这里发表留言，作者筛选后可公开显示

- [友_](https://www.imooc.com/u/6590979/articles)

  老师 Arrays.binarySearch这个方法我只看得懂 第一个参数是数组，第二个参数是要查找到数，第三个参数是干嘛的

   0

  回复

  3天前

- [幕布斯1005](https://www.imooc.com/u/6438578/articles)

  老师，您好！请问那个java8-master和java8_demo-master应该怎么查看使用呢？导入eclipse后一直报红叉。。

   0

  回复

  2019-12-31

  - [taian_work](https://www.imooc.com/u/2704775/articles)

    回复[幕布斯1005](https://www.imooc.com/u/6438578/articles)

    idea直接打开工程就自动下载依赖了，完全都不用配开发环境。

    回复

    3天前

- [夜很殇37](https://www.imooc.com/u/1233061/articles)

  binarySearch方法，为什么要先排序，如果不先排序，搜索不到数据？ List list = ImmutableList.of( new SortDTO("300"), new SortDTO("50"), new SortDTO("200"), new SortDTO("220") ); SortDTO[] array = new SortDTO[list.size()]; list.toArray(array); System.out.println(JSON.toJSONString(array)); int index = Arrays

   0

  回复

  2019-11-21

  - [qq_慕哥2339582](https://www.imooc.com/u/8238904/articles)

    回复[夜很殇37](https://www.imooc.com/u/1233061/articles)

    二分法的时间度为O（logn），也就是每次查找都能在数组中排除一半的数据（要么是比它大的，要么是比它小的），如果无序的话，就不能保证排除的数据一定是比它大的或比它小

    回复

    2019-11-22 12:50:44

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[夜很殇37](https://www.imooc.com/u/1233061/articles)

    是的，下面这个同学已经完美的回答你了哈，二分首选要排序，不然二分没有意义。

    回复

    2019-11-23 16:39:01

- [java_simon](https://www.imooc.com/u/6259472/articles)

  github的地址有谁知道

   0

  回复

  2019-10-29

  - [初一](https://www.imooc.com/u/7789740/articles)

    回复[java_simon](https://www.imooc.com/u/6259472/articles)

    源码解析：https://github.com/luanqiu/java8 文章 demo：https://github.com/luanqiu/java8_demo

    回复

    2019-10-29 14:06:51

- [慕运维9394156](https://www.imooc.com/u/7682139/articles)

  ImmutableList的作用是什么呢？

   0

  回复

  2019-10-24

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[慕运维9394156](https://www.imooc.com/u/7682139/articles)

    一个工具类，方便我们使用集合，源码中贴出了官网介绍地址：https://github.com/google/guava/wiki/ImmutableCollectionsExplained

    回复

    2019-10-28 12:49:03

- [代夫阿普曼](https://www.imooc.com/u/7651076/articles)

  老师，线程安全的类已经有了Vector类了，为什么还需要synchronizedList啊。

   0

  回复

  2019-10-24

  - [xiaobaicaisss](https://www.imooc.com/u/6700857/articles)

    回复[代夫阿普曼](https://www.imooc.com/u/7651076/articles)

    Vector都已经不用了，可以用Collections.synchronizedList(new ArrayList())或者用CopyOnWriteArrayList,都是线程安全的

    回复

    2019-11-21 09:27:46

  - [萌萌萌唬](https://www.imooc.com/u/6366873/articles)

    回复[xiaobaicaisss](https://www.imooc.com/u/6700857/articles)

    为啥不用vector啊？

    回复

    2019-11-22 18:03:18

  - [所相虚妄](https://www.imooc.com/u/7839242/articles)

    回复[萌萌萌唬](https://www.imooc.com/u/6366873/articles)

    效率不行，效率和那个synchronizedlist一样，

    回复

    2019-12-06 14:27:29

- [swim0](https://www.imooc.com/u/4708175/articles)

  你好老师，上面sort例子里面这个符号“ :: ”有什么用？

   0

  回复

  2019-10-22

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[swim0](https://www.imooc.com/u/4708175/articles)

    Lambda 表达式的一种写法，DTO::getA 的效果和 DTO.getA() 一样。

    回复

    2019-10-24 20:50:48

- [幕布斯0011243](https://www.imooc.com/u/5955019/articles)

  订阅了怎么只能看部分内容？

   0

  回复

  2019-10-09

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[幕布斯0011243](https://www.imooc.com/u/5955019/articles)

    同学你好，应该可以看到全部哈，你现在还只能看到部分么，如果还是的话，可以联系下慕课网的小姐姐问一问。

    回复

    2019-10-10 23:00:05

- [为了angular耻辱上线](https://www.imooc.com/u/6958824/articles)

  int mid = (low + high) >>> 1; 这一句不是很明白，为什么就可以确定中位数啊……这个位运算为什么就不需要判断数组的奇偶了？

   1

  回复

  2019-10-04

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[为了angular耻辱上线](https://www.imooc.com/u/6958824/articles)

    System.out.println("(0 + 10-1) &gt;&gt;&gt; 1:"+((0 + 10-1) &gt;&gt;&gt; 1)); System.out.println("(0 + 11-1) &gt;&gt;&gt; 1:"+((0 + 11-1) &gt;&gt;&gt; 1)); System.out.println("(1 + 11-1) &gt;&gt;&gt; 1:"+((1 + 11-1) &gt;&gt;&gt; 1)); System.out.println("(1 + 10-1) &gt;&gt;&gt; 1:"+((1 + 10-1) &gt;&gt;&gt; 1)); 二进制位移是不需要判断奇数偶数的哈，这个不是除法哈。

    回复

    2019-10-08 19:29:19

  - [qq__13270](https://www.imooc.com/u/6547001/articles)

    回复[为了angular耻辱上线](https://www.imooc.com/u/6958824/articles)

    右移一位不就是除于2吗

    回复

    2019-11-21 23:23:33

  - [慕才子](https://www.imooc.com/u/6946410/articles)

    回复[为了angular耻辱上线](https://www.imooc.com/u/6958824/articles)

    <不行该转换成实体吧，太难看了

    回复

    2天前

- [风舞炫动](https://www.imooc.com/u/6409329/articles)

  写泛型全参照源码，源码里泛型用的是真6

   0

  回复

  2019-09-26

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[风舞炫动](https://www.imooc.com/u/6409329/articles)

    同学你好，说的很有道理的。

    回复

    2019-09-27 13:05:23

- [慕斯卡6586063](https://www.imooc.com/u/7268198/articles)

  尽量不在工具方法中，对共享变量有做修改的操作访问（如果必须要做的话，必须加锁），因为会有线程安全的问题。除此之外，工具类方法本身是没有线程安全问题的，可以放心使用 这一段讲得有点模糊，请老师再说明一下

   0

  回复

  2019-09-20

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[慕斯卡6586063](https://www.imooc.com/u/7268198/articles)

    public static final String[] array = new String [3]; public static final void doSomeThing(String params1){ array[0] = params1; } 简单举个例子，在工具方法 doSomeThing 里面对共享变量 array 进行了操作，并发情况下会有问题。

    回复

    2019-09-20 14:01:56

- [qq_Ezio_1](https://www.imooc.com/u/4477929/articles)

  老师。目前大三要找工作，题型怎么刷才好，在哪里找题库比较好。希望老师能给予些建议

   0

  回复

  2019-09-18

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[qq_Ezio_1](https://www.imooc.com/u/4477929/articles)

    知乎上可以搜索到大厂面试题，比如搜索阿里面试题，就会出现最新的面试题，另外说一句，刷面试题全靠运气，大厂每年的面试题都和往年不一样，面试的几个关键要素： 1. 运气，问到的都是你会的；2. 有所准备，事先准备几个知识点，是自己深入研究过的，这样可以突出亮点；3. 注意知识点之间的关联，大多人学习的知识都是单点，想孤岛一样，如果你能把知识点关联起来，无疑比大多数人更深入了一步。 最后，相信自己，我也相信你可以的。

    回复

    2019-09-18 21:32:26

- [qq_Ezio_1](https://www.imooc.com/u/4477929/articles)

  老师。目前大三要找工作，题型怎么刷才好，在哪里找题库比较好。希望老师能给予些建议

   0

  回复

  2019-09-18

- [Super丶Lee](https://www.imooc.com/u/3739134/articles)

  二分搜索的那里 泛型 后面为什么还有个int 这是什么意思？

   0

  回复

  2019-09-11

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[Super丶Lee](https://www.imooc.com/u/3739134/articles)

    int 表示 key 在所搜索的数组下标位置，是方法的返回类型，泛型主要是为了表示数组元素的类型。

    回复

    2019-09-11 20:54:45

- [weixin_慕婉清1034667](https://www.imooc.com/u/8002968/articles)

  Arrays.sort排序50最大是什么情况？

   1

  回复

  2019-09-11

  - [power_cheng4342740](https://www.imooc.com/u/4342740/articles)

    回复[weixin_慕婉清1034667](https://www.imooc.com/u/8002968/articles)

    作者这个地方是根据字符串排序而不是根据数值大小排序, 如果根据数值大小排序可以改成Arrays.sort(array, Comparator.comparing(sortDTO -&gt; Integer.valueOf(sortDTO.getSortTarget())));

    回复

    2019-09-11 11:33:30

- [zzcy](https://www.imooc.com/u/6629019/articles)

  怎么我这边unmodifiableCollection 1.8jdk返回的集合没有get函数

   0

  回复

  2019-09-05

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[zzcy](https://www.imooc.com/u/6629019/articles)

    是 unmodifiableList 方法哦。

    回复

    2019-09-05 16:46:25

- [许龙](https://www.imooc.com/u/6119984/articles)

  ArrayList不是每次add和remove都会复制数组吧，应该是扩容的时候复制

   0

  回复

  2019-09-04

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[许龙](https://www.imooc.com/u/6119984/articles)

    是的，add 是在扩容时，remove 只要删除的元素不是最后一个元素，就会拷贝。

    回复

    2019-09-04 14:12:16

- [BenChen学JAVA](https://www.imooc.com/u/5185272/articles)

  SortDTO::getSortTarget，这个是什么意思啊，没看到，二分查找那里。?

   0

  回复

  2019-08-30

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[BenChen学JAVA](https://www.imooc.com/u/5185272/articles)

    取得 SortDTO 的 getSortTarget 属性，是 Java 8 的一种写法，在 Lambda 表达式中经常使用到。我们在 Lambda 章节会细说。

    回复

    2019-08-30 18:24:25

  - [itAltman](https://www.imooc.com/u/3800835/articles)

    回复[BenChen学JAVA](https://www.imooc.com/u/5185272/articles)

    相当于 SortDTO sortDto = new SortDTO("123"); sortDto.getSortTarget;

    回复

    2019-09-02 13:54:30

  - [向远之航](https://www.imooc.com/u/7779445/articles)

    回复[BenChen学JAVA](https://www.imooc.com/u/5185272/articles)

    同问，我了解一些lambda表达式的使用方法。关键是，getSortTarget这个方法在哪里定义了呢，我看了sortDTO类只有一个简单的构造函数，没有其他函数方法的定义啊。

    回复

    2019-12-04 10:27:47

- [edindzeko](https://www.imooc.com/u/280315/articles)

  为什么会有这种写法，java中不是所有的object都自动extend Object吗？

   1

  回复

  2019-08-29

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[edindzeko](https://www.imooc.com/u/280315/articles)

    没有看懂问题哈，什么写法？

    回复

    2019-08-30 20:31:36

  - [贰零一贰](https://www.imooc.com/u/2232970/articles)

    回复[edindzeko](https://www.imooc.com/u/280315/articles)

    他的意思是泛形<？extend object>

    回复

    2019-09-11 07:42:59

  - [贰零一贰](https://www.imooc.com/u/2232970/articles)

    回复[贰零一贰](https://www.imooc.com/u/2232970/articles)

    <? extend object>

    回复

    2019-09-11 07:43:49

  点击展开后面 1 条

- [世界和平灬](https://www.imooc.com/u/7803755/articles)

  惭愧，现在才知道有Objects这个工具类，感谢作者~

   2

  回复

  2019-08-29

  - [文贺](https://www.imooc.com/u/8062574/articles)

    回复[世界和平灬](https://www.imooc.com/u/7803755/articles)

    谢谢，get 用起来。

    回复

    2019-08-30 18:27:49

  - [最怕认真](https://www.imooc.com/u/1899708/articles)

    回复[世界和平灬](https://www.imooc.com/u/7803755/articles)

    objects好像只有jdk8才有的

    回复

    2019-09-07 23:37:42

 

千学不如一看，千看不如一练

 