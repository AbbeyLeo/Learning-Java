04.JPA的基本操作

 第1章   JPA的API介绍

  Persistence对象

Persistence对象主要作用是用于获取EntityManagerFactory对象的 。通过调用该类的createEntityManagerFactory静态方法，根据配置文件中持久化单元名称创建EntityManagerFactory。

```java
//1. 创建 EntitymanagerFactory
@Test
String unitName = "myJpa";
EntityManagerFactory factory= Persistence.createEntityManagerFactory(unitName);

```

EntityManagerFactory

EntityManagerFactory 接口主要用来创建 EntityManager 实例

```java
//创建实体管理类
EntityManager em = factory.createEntityManager();

```

由于EntityManagerFactory 是一个线程安全的对象（即多个线程访问同一个EntityManagerFactory 对象不会有线程安全问题），并且EntityManagerFactory 的创建极其浪费资源，所以在使用JPA编程时，我们可以对EntityManagerFactory 的创建进行优化，只需要做到一个工程只存在一个EntityManagerFactory 即可

5.3	EntityManager

```java
在 JPA 规范中, EntityManager是完成持久化操作的核心对象。实体类作为普通 java对象，只有在调用 EntityManager将其持久化后才会变成持久化对象。EntityManager对象在一组实体类与底层数据源之间进行 O/R 映射的管理。它可以用来管理和更新 Entity Bean, 根椐主键查找 Entity Bean, 还可以通过JPQL语句查询实体。

我们可以通过调用EntityManager的方法完成获取事务，以及持久化数据库的操作

方法说明：
getTransaction : 获取事务对象
	persist ： 保存操作
	merge ： 更新操作
	remove ： 删除操作
	find/getReference ： 根据id查询

```

  EntityTransaction

在 JPA 规范中, EntityTransaction是完成事务操作的核心对象，对于EntityTransaction在我们的java代码中承接的功能比较简单

```
begin：开启事务
commit：提交事务
rollback：回滚事务

```

第6章	抽取JPAUtil工具类

```java
package cn.itcast.dao;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Persistence;

public final class JPAUtil {
	// JPA的实体管理器工厂：相当于Hibernate的SessionFactory
	private static EntityManagerFactory em;
	// 使用静态代码块赋值
	static {
		// 注意：该方法参数必须和persistence.xml中persistence-unit标签name属性取值一致
		em = Persistence.createEntityManagerFactory("myPersistUnit");
	}

	/**
	 * 使用管理器工厂生产一个管理器对象
	 * 
	 * @return
	 */
	public static EntityManager getEntityManager() {
		return em.createEntityManager();
	}
}



```

 使用JPA完成增删改查操作

保存

```
/**
	 * 保存一个实体
	 */
	@Test
	public void testAdd() {
		// 定义对象
		Customer c = new Customer();
		c.setCustName("传智学院");
		c.setCustLevel("VIP客户");
		c.setCustSource("网络");
		c.setCustIndustry("IT教育");
		c.setCustAddress("昌平区北七家镇");
		c.setCustPhone("010-84389340");
		EntityManager em = null;
		EntityTransaction tx = null;
		try {
			// 获取实体管理对象
			em = JPAUtil.getEntityManager();
			// 获取事务对象
			tx = em.getTransaction();
			// 开启事务
			tx.begin();
			// 执行操作
			em.persist(c);
			// 提交事务
			tx.commit();
		} catch (Exception e) {
			// 回滚事务
			tx.rollback();
			e.printStackTrace();
		} finally {
			// 释放资源
			em.close();
		}
	}

```

7.2	修改

```java
@Test
    public void testMerge(){  
        //定义对象
        EntityManager em=null;  
        EntityTransaction tx=null;  
        try{  
          	//获取实体管理对象
          	em=JPAUtil.getEntityManager();
          	//获取事务对象
          	tx=em.getTransaction();
          	//开启事务
          	tx.begin();
          	//执行操作
          	Customer c1 = em.find(Customer.class, 6L);
          	c1.setCustName("江苏传智学院");
         	em.clear();//把c1对象从缓存中清除出去
          	em.merge(c1);
          	//提交事务
          	tx.commit(); 
        }catch(Exception e){
          	//回滚事务
          	tx.rollback();
          	e.printStackTrace();  
        }finally{  
        	//释放资源
        	em.close();  
        }    
    }

```

7.3	删除

```java
/**
	 * 删除
	 */
	@Test
	public void testRemove() {
// 定义对象
		EntityManager em = null;
		EntityTransaction tx = null;
		try {
			// 获取实体管理对象
			em = JPAUtil.getEntityManager();
			// 获取事务对象
			tx = em.getTransaction();
			// 开启事务
			tx.begin();
			// 执行操作
			Customer c1 = em.find(Customer.class, 6L);
			em.remove(c1);
			// 提交事务
			tx.commit();
		} catch (Exception e) {
			// 回滚事务
			tx.rollback();
			e.printStackTrace();
		} finally {
			// 释放资源
			em.close();
		}
	}

```

7.4	根据id查询

```java
/**
	 * 查询一个： 使用立即加载的策略
	 */
	@Test
	public void testGetOne() {
		// 定义对象
		EntityManager em = null;
		EntityTransaction tx = null;
		try {
			// 获取实体管理对象
			em = JPAUtil.getEntityManager();
			// 获取事务对象
			tx = em.getTransaction();
			// 开启事务
			tx.begin();
			// 执行操作
			Customer c1 = em.find(Customer.class, 1L);
			// 提交事务
			tx.commit();
			System.out.println(c1); // 输出查询对象
		} catch (Exception e) {
			// 回滚事务
			tx.rollback();
			e.printStackTrace();
		} finally {
			// 释放资源
			em.close();
		}
	}

	// 查询实体的缓存问题
	@Test
	public void testGetOne() {
		// 定义对象
		EntityManager em = null;
		EntityTransaction tx = null;
		try {
			// 获取实体管理对象
			em = JPAUtil.getEntityManager();
			// 获取事务对象
			tx = em.getTransaction();
			// 开启事务
			tx.begin();
			// 执行操作
			Customer c1 = em.find(Customer.class, 1L);
			Customer c2 = em.find(Customer.class, 1L);
			System.out.println(c1 == c2);// 输出结果是true，EntityManager也有缓存
			// 提交事务
			tx.commit();
			System.out.println(c1);
		} catch (Exception e) {
			// 回滚事务
			tx.rollback();
			e.printStackTrace();
		} finally {
			// 释放资源
			em.close();
		}
	}


```



```
jpa操作的操作步骤
	1.加载配置文件创建实体管理器工厂
		Persisitence：静态方法（根据持久化单元名称创建实体管理器工厂）
			createEntityMnagerFactory（持久化单元名称）
		作用：创建实体管理器工厂
		
	2.根据实体管理器工厂，创建实体管理器
		EntityManagerFactory ：获取EntityManager对象
		方法：createEntityManager
		* 内部维护的很多的内容
			内部维护了数据库信息，
			维护了缓存信息
			维护了所有的实体管理器对象
			再创建EntityManagerFactory的过程中会根据配置创建数据库表
		* EntityManagerFactory的创建过程比较浪费资源
		特点：线程安全的对象
			多个线程访问同一个EntityManagerFactory不会有线程安全问题
		* 如何解决EntityManagerFactory的创建过程浪费资源（耗时）的问题？
		思路：创建一个公共的EntityManagerFactory的对象
		* 静态代码块的形式创建EntityManagerFactory
		
	3.创建事务对象，开启事务
		EntityManager对象：实体类管理器
			beginTransaction : 创建事务对象
			presist ： 保存
			merge  ： 更新
			remove ： 删除
			find/getRefrence ： 根据id查询
			
		Transaction 对象 ： 事务
			begin：开启事务
			commit：提交事务
			rollback：回滚
	4.增删改查操作
	5.提交事务
	6.释放资源

i.搭建环境的过程
	1.创建maven工程导入坐标
	2.需要配置jpa的核心配置文件
		*位置：配置到类路径下的一个叫做 META-INF 的文件夹下
		*命名：persistence.xml
	3.编写客户的实体类
	4.配置实体类和表，类中属性和表中字段的映射关系
	5.保存客户到数据库中
ii.完成基本CRUD案例
	persist ： 保存
	merge ： 更新
	remove ： 删除
	find/getRefrence ： 根据id查询
	
iii.jpql查询
	sql：查询的是表和表中的字段
	jpql：查询的是实体类和类中的属性
	* jpql和sql语句的语法相似
	
	1.查询全部
	2.分页查询
	3.统计查询
	4.条件查询
	5.排序
```

